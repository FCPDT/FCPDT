diff --git a/node_modules/@tresjs/cientos/dist/.DS_Store b/node_modules/@tresjs/cientos/dist/.DS_Store
new file mode 100644
index 0000000..425cee8
Binary files /dev/null and b/node_modules/@tresjs/cientos/dist/.DS_Store differ
diff --git a/node_modules/@tresjs/cientos/dist/core/.DS_Store b/node_modules/@tresjs/cientos/dist/core/.DS_Store
new file mode 100644
index 0000000..217dc05
Binary files /dev/null and b/node_modules/@tresjs/cientos/dist/core/.DS_Store differ
diff --git a/node_modules/@tresjs/cientos/dist/core/abstractions/.DS_Store b/node_modules/@tresjs/cientos/dist/core/abstractions/.DS_Store
new file mode 100644
index 0000000..2293da8
Binary files /dev/null and b/node_modules/@tresjs/cientos/dist/core/abstractions/.DS_Store differ
diff --git a/node_modules/@tresjs/cientos/dist/core/controls/TransformControls.vue.d.ts b/node_modules/@tresjs/cientos/dist/core/controls/TransformControls.vue.d.ts
index 997a68f..7b0aa7b 100644
--- a/node_modules/@tresjs/cientos/dist/core/controls/TransformControls.vue.d.ts
+++ b/node_modules/@tresjs/cientos/dist/core/controls/TransformControls.vue.d.ts
@@ -1,6 +1,7 @@
-import type { Object3D } from 'three';
+import type { Object3D, Camera } from 'three';
 export interface TransformControlsProps {
     object: Object3D;
+    camera?: Camera;
     mode?: string;
     enabled?: boolean;
     axis?: 'X' | 'Y' | 'Z' | 'XY' | 'YZ' | 'XZ' | 'XYZ';
diff --git a/node_modules/@tresjs/cientos/dist/core/loaders/.DS_Store b/node_modules/@tresjs/cientos/dist/core/loaders/.DS_Store
new file mode 100644
index 0000000..dcad572
Binary files /dev/null and b/node_modules/@tresjs/cientos/dist/core/loaders/.DS_Store differ
diff --git a/node_modules/@tresjs/cientos/dist/core/materials/.DS_Store b/node_modules/@tresjs/cientos/dist/core/materials/.DS_Store
new file mode 100644
index 0000000..99cedf5
Binary files /dev/null and b/node_modules/@tresjs/cientos/dist/core/materials/.DS_Store differ
diff --git a/node_modules/@tresjs/cientos/dist/core/materials/holographicMaterial/index.vue.d.ts b/node_modules/@tresjs/cientos/dist/core/materials/holographicMaterial/index.vue.d.ts
new file mode 100644
index 0000000..41ae628
--- /dev/null
+++ b/node_modules/@tresjs/cientos/dist/core/materials/holographicMaterial/index.vue.d.ts
@@ -0,0 +1,85 @@
+import type { TresColor } from '@tresjs/core';
+import type { Side } from 'three';
+import HolographicMaterial from './material';
+declare const _default: import("vue").DefineComponent<__VLS_WithDefaults<__VLS_TypePropsToRuntimeProps<{
+    fresnelAmount?: number | undefined;
+    fresnelOpacity?: number | undefined;
+    blinkFresnelOnly?: boolean | undefined;
+    enableBlinking?: boolean | undefined;
+    enableAdditive?: boolean | undefined;
+    hologramBrightness?: number | undefined;
+    scanlineSize?: number | undefined;
+    signalSpeed?: number | undefined;
+    hologramOpacity?: number | undefined;
+    hologramColor?: import("three").ColorRepresentation | [r: number, g: number, b: number] | undefined;
+    side?: Side | undefined;
+}>, {
+    fresnelAmount: number;
+    fresnelOpacity: number;
+    blinkFresnelOnly: boolean;
+    enableBlinking: boolean;
+    enableAdditive: boolean;
+    hologramBrightness: number;
+    scanlineSize: number;
+    signalSpeed: number;
+    hologramOpacity: number;
+    hologramColor: string;
+    side: 0;
+}>, {
+    root: import("vue").ShallowRef<any>;
+    constructor: typeof HolographicMaterial;
+}, unknown, {}, {}, import("vue").ComponentOptionsMixin, import("vue").ComponentOptionsMixin, {}, string, import("vue").PublicProps, Readonly<import("vue").ExtractPropTypes<__VLS_WithDefaults<__VLS_TypePropsToRuntimeProps<{
+    fresnelAmount?: number | undefined;
+    fresnelOpacity?: number | undefined;
+    blinkFresnelOnly?: boolean | undefined;
+    enableBlinking?: boolean | undefined;
+    enableAdditive?: boolean | undefined;
+    hologramBrightness?: number | undefined;
+    scanlineSize?: number | undefined;
+    signalSpeed?: number | undefined;
+    hologramOpacity?: number | undefined;
+    hologramColor?: import("three").ColorRepresentation | [r: number, g: number, b: number] | undefined;
+    side?: Side | undefined;
+}>, {
+    fresnelAmount: number;
+    fresnelOpacity: number;
+    blinkFresnelOnly: boolean;
+    enableBlinking: boolean;
+    enableAdditive: boolean;
+    hologramBrightness: number;
+    scanlineSize: number;
+    signalSpeed: number;
+    hologramOpacity: number;
+    hologramColor: string;
+    side: 0;
+}>>>, {
+    side: Side;
+    fresnelOpacity: number;
+    fresnelAmount: number;
+    scanlineSize: number;
+    hologramBrightness: number;
+    signalSpeed: number;
+    hologramColor: TresColor;
+    enableBlinking: boolean;
+    blinkFresnelOnly: boolean;
+    hologramOpacity: number;
+    enableAdditive: boolean;
+}, {}>;
+export default _default;
+type __VLS_NonUndefinedable<T> = T extends undefined ? never : T;
+type __VLS_TypePropsToRuntimeProps<T> = {
+    [K in keyof T]-?: {} extends Pick<T, K> ? {
+        type: import('vue').PropType<__VLS_NonUndefinedable<T[K]>>;
+    } : {
+        type: import('vue').PropType<T[K]>;
+        required: true;
+    };
+};
+type __VLS_WithDefaults<P, D> = {
+    [K in keyof Pick<P, keyof P>]: K extends keyof D ? __VLS_Prettify<P[K] & {
+        default: D[K];
+    }> : P[K];
+};
+type __VLS_Prettify<T> = {
+    [K in keyof T]: T[K];
+} & {};
diff --git a/node_modules/@tresjs/cientos/dist/core/materials/holographicMaterial/material.d.ts b/node_modules/@tresjs/cientos/dist/core/materials/holographicMaterial/material.d.ts
new file mode 100644
index 0000000..05aafe9
--- /dev/null
+++ b/node_modules/@tresjs/cientos/dist/core/materials/holographicMaterial/material.d.ts
@@ -0,0 +1,67 @@
+/**
+ * Holographic material by Anderson Mancini - Dec 2023.
+ */
+/**
+MIT License
+
+Copyright (c) 2023 Anderson Mancini
+
+Permission is hereby granted, free of charge, to any person obtaining a copy
+of this software and associated documentation files (the "Software"), to deal
+in the Software without restriction, including without limitation the rights
+to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+copies of the Software, and to permit persons to whom the Software is
+furnished to do so, subject to the following conditions:
+
+The above copyright notice and this permission notice shall be included in all
+copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+SOFTWARE.
+ */
+import { ShaderMaterial, Color } from 'three';
+import type { Side, Blending } from 'three';
+interface HolographicMaterialParameters {
+    time?: number;
+    fresnelOpacity?: number;
+    fresnelAmount?: number;
+    scanlineSize?: number;
+    hologramBrightness?: number;
+    signalSpeed?: number;
+    hologramColor?: Color;
+    enableBlinking?: boolean;
+    blinkFresnelOnly?: boolean;
+    hologramOpacity?: number;
+    blendMode?: Blending;
+    side?: Side;
+    depthTest?: boolean;
+}
+declare class HolographicMaterial extends ShaderMaterial {
+    /**
+     * Create a HolographicMaterial.
+     *
+     * @param {Object} parameters - The parameters to configure the material.
+     * @param {number} [parameters.time=0.0] - The time uniform representing animation time.
+     * @param {number} [parameters.fresnelOpacity=1.0] - The opacity for the fresnel effect.
+     * @param {number} [parameters.fresnelAmount=1.0] - The strength of the fresnel effect.
+     * @param {number} [parameters.scanlineSize=15.0] - The size of the scanline effect.
+     * @param {number} [parameters.hologramBrightness=1.0] - The brightness of the hologram.
+     * @param {number} [parameters.signalSpeed=1.0] - The speed of the signal effect.
+     * @param {Color} [parameters.hologramColor=new Color('#00d5ff')] - The color of the hologram.
+     * @param {boolean} [parameters.enableBlinking=true] - Enable/disable blinking effect.
+     * @param {boolean} [parameters.blinkFresnelOnly=false] - Enable blinking only on the fresnel effect.
+     * @param {number} [parameters.hologramOpacity=1.0] - The opacity of the hologram.
+     * @param {number} [parameters.blendMode=NormalBlending] - The blending mode. Use `THREE.NormalBlending` or `THREE.AdditiveBlending`.
+     * @param {number} [parameters.side=FrontSide] - The rendering side. Use `THREE.FrontSide`,
+     *  `THREE.BackSide`, or `THREE.DoubleSide`.
+     * @param {Boolean} [parameters.depthTest=true] - Enable or disable depthTest.
+     */
+    constructor(parameters?: HolographicMaterialParameters);
+    update(): void;
+}
+export default HolographicMaterial;
diff --git a/node_modules/@tresjs/cientos/dist/core/materials/index.d.ts b/node_modules/@tresjs/cientos/dist/core/materials/index.d.ts
index 45f10d4..a866c07 100644
--- a/node_modules/@tresjs/cientos/dist/core/materials/index.d.ts
+++ b/node_modules/@tresjs/cientos/dist/core/materials/index.d.ts
@@ -2,4 +2,5 @@ import MeshWobbleMaterial from './meshWobbleMaterial/index.vue';
 import MeshGlassMaterial from './meshGlassMaterial/index.vue';
 import CustomShaderMaterial from './customShaderMaterial/index.vue';
 import MeshReflectionMaterial from './meshReflectionMaterial/index.vue';
-export { MeshWobbleMaterial, MeshGlassMaterial, CustomShaderMaterial, MeshReflectionMaterial };
+import HolographicMaterial from './holographicMaterial/index.vue';
+export { MeshWobbleMaterial, MeshGlassMaterial, CustomShaderMaterial, MeshReflectionMaterial, HolographicMaterial };
diff --git a/node_modules/@tresjs/cientos/dist/core/misc/.DS_Store b/node_modules/@tresjs/cientos/dist/core/misc/.DS_Store
new file mode 100644
index 0000000..97155dc
Binary files /dev/null and b/node_modules/@tresjs/cientos/dist/core/misc/.DS_Store differ
diff --git a/node_modules/@tresjs/cientos/dist/core/shapes/RoundedBox.vue.d.ts b/node_modules/@tresjs/cientos/dist/core/shapes/RoundedBox.vue.d.ts
new file mode 100644
index 0000000..2f2cbc7
--- /dev/null
+++ b/node_modules/@tresjs/cientos/dist/core/shapes/RoundedBox.vue.d.ts
@@ -0,0 +1,58 @@
+import type { TresColor } from '@tresjs/core';
+import type { BoxGeometry } from 'three';
+export interface BoxProps {
+    /**
+     * The width, height, depth, segments and radius.
+     * @default [1, 1, 1, 2, 0.1]
+     * @type {number[]}
+     * @memberof BoxProps
+     * @see https://github.com/mrdoob/three.js/blob/master/examples/jsm/geometries/RoundedBoxGeometry.js
+     *
+     */
+    args?: ConstructorParameters<typeof BoxGeometry>;
+    /**
+     * The color of the box.
+     * @default 0xffffff
+     * @type {TresColor}
+     * @memberof BoxProps
+     * @see https://threejs.org/docs/#api/en/materials/MeshBasicMaterial
+     */
+    color?: TresColor;
+}
+declare const _default: __VLS_WithTemplateSlots<import("vue").DefineComponent<__VLS_WithDefaults<__VLS_TypePropsToRuntimeProps<BoxProps>, {
+    args: () => number[];
+    color: string;
+}>, {
+    value: import("vue").ShallowRef<any>;
+}, unknown, {}, {}, import("vue").ComponentOptionsMixin, import("vue").ComponentOptionsMixin, {}, string, import("vue").PublicProps, Readonly<import("vue").ExtractPropTypes<__VLS_WithDefaults<__VLS_TypePropsToRuntimeProps<BoxProps>, {
+    args: () => number[];
+    color: string;
+}>>>, {
+    color: import("three").ColorRepresentation | [r: number, g: number, b: number];
+    args: [width?: number | undefined, height?: number | undefined, depth?: number | undefined, widthSegments?: number | undefined, heightSegments?: number | undefined, depthSegments?: number | undefined];
+}, {}>, {
+    default?(_: {}): any;
+}>;
+export default _default;
+type __VLS_NonUndefinedable<T> = T extends undefined ? never : T;
+type __VLS_TypePropsToRuntimeProps<T> = {
+    [K in keyof T]-?: {} extends Pick<T, K> ? {
+        type: import('vue').PropType<__VLS_NonUndefinedable<T[K]>>;
+    } : {
+        type: import('vue').PropType<T[K]>;
+        required: true;
+    };
+};
+type __VLS_WithDefaults<P, D> = {
+    [K in keyof Pick<P, keyof P>]: K extends keyof D ? __VLS_Prettify<P[K] & {
+        default: D[K];
+    }> : P[K];
+};
+type __VLS_Prettify<T> = {
+    [K in keyof T]: T[K];
+} & {};
+type __VLS_WithTemplateSlots<T, S> = T & {
+    new (): {
+        $slots: S;
+    };
+};
diff --git a/node_modules/@tresjs/cientos/dist/core/shapes/index.d.ts b/node_modules/@tresjs/cientos/dist/core/shapes/index.d.ts
index 7f227be..bf3730f 100644
--- a/node_modules/@tresjs/cientos/dist/core/shapes/index.d.ts
+++ b/node_modules/@tresjs/cientos/dist/core/shapes/index.d.ts
@@ -8,10 +8,11 @@ import Line2 from './Line2.vue';
 import Octahedron from './Octahedron.vue';
 import Plane from './Plane.vue';
 import Ring from './Ring.vue';
+import RoundedBox from './RoundedBox.vue';
 import Sphere from './Sphere.vue';
 import Superformula from './Superformula.vue';
 import Tetrahedron from './Tetrahedron.vue';
 import Torus from './Torus.vue';
 import TorusKnot from './TorusKnot.vue';
 import Tube from './Tube.vue';
-export { Box, CatmullRomCurve3, Circle, Cone, Dodecahedron, Icosahedron, Line2, Octahedron, Plane, Ring, Sphere, Superformula, Tetrahedron, Torus, TorusKnot, Tube, };
+export { Box, CatmullRomCurve3, Circle, Cone, Dodecahedron, Icosahedron, Line2, Octahedron, Plane, Ring, RoundedBox, Sphere, Superformula, Tetrahedron, Torus, TorusKnot, Tube, };
diff --git a/node_modules/@tresjs/cientos/dist/core/staging/.DS_Store b/node_modules/@tresjs/cientos/dist/core/staging/.DS_Store
new file mode 100644
index 0000000..81307ce
Binary files /dev/null and b/node_modules/@tresjs/cientos/dist/core/staging/.DS_Store differ
diff --git a/node_modules/@tresjs/cientos/dist/core/staging/Ocean.vue.d.ts b/node_modules/@tresjs/cientos/dist/core/staging/Ocean.vue.d.ts
new file mode 100644
index 0000000..32692a1
--- /dev/null
+++ b/node_modules/@tresjs/cientos/dist/core/staging/Ocean.vue.d.ts
@@ -0,0 +1,163 @@
+import type { TresColor, TresVector3 } from '@tresjs/core';
+import { Vector3 } from 'three';
+export interface OceanProps {
+    /**
+     * The textureWidth of the internal WebGLRenderTarget.
+     *
+     * @default 512
+     * @type {number}
+     * @memberof OceanProps
+     *
+     */
+    textureWidth?: number;
+    /**
+     * The textureHeight of the internal WebGLRenderTarget.
+     *
+     * @default 512
+     * @type {number}
+     * @memberof OceanProps
+     *
+     */
+    textureHeight?: number;
+    /**
+     * The normal texture of the ocean.
+     * @default 'https://raw.githubusercontent.com/mrdoob/three.js/master/examples/textures/water/Water_1_M_Normal.jpg'
+     * @type {string}
+     * @memberof OceanProps
+     * @see https://threejs.org/docs/#api/en/materials/MeshStandardMaterial
+     */
+    waterNormals?: string;
+    /**
+     * The sun direction
+     * @default '[0,0,0]'
+     * @type {TresVector3}
+     * @memberof OceanProps
+     */
+    sunDirection?: TresVector3;
+    /**
+     * The sun color.
+     *
+     * @default '#fff'
+     * @type {TresColor}
+     * @memberof OceanProps
+     *
+     */
+    sunColor?: TresColor;
+    /**
+     * The water color.
+     *
+     * @default '#001e0f'
+     * @type {TresColor}
+     * @memberof OceanProps
+     *
+     */
+    waterColor?: TresColor;
+    /**
+      * The distortion scale of the reflections.
+     * @default 3.7
+     * @type {number}
+     * @memberof OceanProps
+     *
+     */
+    distortionScale?: number;
+    /**
+     * The size of the normal texture.
+     *
+     * @default 1
+     * @type {number}
+     * @memberof OceanProps
+     *
+     */
+    size?: number;
+    /**
+     * The ClipBias.
+     *
+     * @default 0.0
+     * @type {number}
+     * @memberof OceanProps
+     *
+     */
+    clipBias?: number;
+    /**
+     * The alpha factor.
+     *
+     * @default 1.0
+     * @type {number}
+     * @memberof OceanProps
+     *
+     */
+    alpha?: number;
+    /**
+     * ThreeJs side material property.
+     *
+     * @default FrontSide
+     * @type {TresVector3}
+     * @memberof OceanProps
+     *
+     */
+    side?: TresVector3;
+}
+declare const _default: __VLS_WithTemplateSlots<import("vue").DefineComponent<__VLS_WithDefaults<__VLS_TypePropsToRuntimeProps<OceanProps>, {
+    textureWidth: number;
+    textureHeight: number;
+    waterNormals: string;
+    sunDirection: () => Vector3;
+    sunColor: number;
+    waterColor: number;
+    distortionScale: number;
+    size: number;
+    clipBias: number;
+    alpha: number;
+    side: 0;
+}>, {
+    root: import("vue").ShallowRef<any>;
+}, unknown, {}, {}, import("vue").ComponentOptionsMixin, import("vue").ComponentOptionsMixin, {}, string, import("vue").PublicProps, Readonly<import("vue").ExtractPropTypes<__VLS_WithDefaults<__VLS_TypePropsToRuntimeProps<OceanProps>, {
+    textureWidth: number;
+    textureHeight: number;
+    waterNormals: string;
+    sunDirection: () => Vector3;
+    sunColor: number;
+    waterColor: number;
+    distortionScale: number;
+    size: number;
+    clipBias: number;
+    alpha: number;
+    side: 0;
+}>>>, {
+    side: number | Vector3 | import("@tresjs/core").VectorCoordinates | [x: number, y: number, z: number];
+    textureWidth: number;
+    textureHeight: number;
+    clipBias: number;
+    size: number;
+    waterNormals: string;
+    sunDirection: number | Vector3 | import("@tresjs/core").VectorCoordinates | [x: number, y: number, z: number];
+    sunColor: import("three").ColorRepresentation | [r: number, g: number, b: number];
+    waterColor: import("three").ColorRepresentation | [r: number, g: number, b: number];
+    distortionScale: number;
+    alpha: number;
+}, {}>, {
+    default?(_: {}): any;
+}>;
+export default _default;
+type __VLS_NonUndefinedable<T> = T extends undefined ? never : T;
+type __VLS_TypePropsToRuntimeProps<T> = {
+    [K in keyof T]-?: {} extends Pick<T, K> ? {
+        type: import('vue').PropType<__VLS_NonUndefinedable<T[K]>>;
+    } : {
+        type: import('vue').PropType<T[K]>;
+        required: true;
+    };
+};
+type __VLS_WithDefaults<P, D> = {
+    [K in keyof Pick<P, keyof P>]: K extends keyof D ? __VLS_Prettify<P[K] & {
+        default: D[K];
+    }> : P[K];
+};
+type __VLS_Prettify<T> = {
+    [K in keyof T]: T[K];
+} & {};
+type __VLS_WithTemplateSlots<T, S> = T & {
+    new (): {
+        $slots: S;
+    };
+};
diff --git a/node_modules/@tresjs/cientos/dist/core/staging/Sky.vue.d.ts b/node_modules/@tresjs/cientos/dist/core/staging/Sky.vue.d.ts
index afa1881..06e037d 100644
--- a/node_modules/@tresjs/cientos/dist/core/staging/Sky.vue.d.ts
+++ b/node_modules/@tresjs/cientos/dist/core/staging/Sky.vue.d.ts
@@ -1,3 +1,5 @@
+import { Vector3 } from 'three';
+import { Sky as SkyImpl } from 'three/examples/jsm/objects/Sky';
 export interface SkyProps {
     /**
      * Haziness
@@ -37,7 +39,10 @@ declare const _default: import("vue").DefineComponent<__VLS_WithDefaults<__VLS_T
     elevation: number;
     azimuth: number;
     distance: number;
-}>, {}, unknown, {}, {}, import("vue").ComponentOptionsMixin, import("vue").ComponentOptionsMixin, {}, string, import("vue").PublicProps, Readonly<import("vue").ExtractPropTypes<__VLS_WithDefaults<__VLS_TypePropsToRuntimeProps<SkyProps>, {
+}>, {
+    root: import("vue").ShallowRef<SkyImpl | undefined>;
+    sunPosition: Vector3;
+}, unknown, {}, {}, import("vue").ComponentOptionsMixin, import("vue").ComponentOptionsMixin, {}, string, import("vue").PublicProps, Readonly<import("vue").ExtractPropTypes<__VLS_WithDefaults<__VLS_TypePropsToRuntimeProps<SkyProps>, {
     turbidity: number;
     rayleigh: number;
     mieCoefficient: number;
diff --git a/node_modules/@tresjs/cientos/dist/core/staging/Sparkles/component.vue.d.ts b/node_modules/@tresjs/cientos/dist/core/staging/Sparkles/component.vue.d.ts
index 37347a8..27d0dab 100644
--- a/node_modules/@tresjs/cientos/dist/core/staging/Sparkles/component.vue.d.ts
+++ b/node_modules/@tresjs/cientos/dist/core/staging/Sparkles/component.vue.d.ts
@@ -203,6 +203,7 @@ declare const _default: import("vue").DefineComponent<__VLS_WithDefaults<__VLS_T
     size: number;
     geometry: Object3D<import("three").Object3DEventMap> | BufferGeometry<import("three").NormalBufferAttributes>;
     offset: number;
+    alpha: number;
     lifetimeSec: number;
     cooldownSec: number;
     normalThreshold: number;
@@ -210,7 +211,6 @@ declare const _default: import("vue").DefineComponent<__VLS_WithDefaults<__VLS_T
     scaleNoise: number;
     offsetNoise: number;
     lifetimeNoise: number;
-    alpha: number;
     surfaceDistance: number;
     sequenceColor: Gradient<import("three").ColorRepresentation | [r: number, g: number, b: number]>;
     sequenceAlpha: Gradient<number>;
diff --git a/node_modules/@tresjs/cientos/dist/core/staging/index.d.ts b/node_modules/@tresjs/cientos/dist/core/staging/index.d.ts
index 405b629..146eced 100644
--- a/node_modules/@tresjs/cientos/dist/core/staging/index.d.ts
+++ b/node_modules/@tresjs/cientos/dist/core/staging/index.d.ts
@@ -1,4 +1,5 @@
 import Environment from './useEnvironment/component.vue';
+import Lightformer from './useEnvironment/lightformer/index.vue';
 import Backdrop from './Backdrop.vue';
 import ContactShadows from './ContactShadows.vue';
 import Precipitation from './Precipitation.vue';
@@ -6,4 +7,5 @@ import Sky from './Sky.vue';
 import Smoke from './Smoke.vue';
 import Sparkles from './Sparkles/component.vue';
 import Stars from './Stars.vue';
-export { Backdrop, ContactShadows, Environment, Precipitation, Sky, Smoke, Sparkles, Stars, };
+import Ocean from './Ocean.vue';
+export { Backdrop, ContactShadows, Environment, Precipitation, Sky, Smoke, Sparkles, Stars, Ocean, Lightformer, };
diff --git a/node_modules/@tresjs/cientos/dist/core/staging/useEnvironment/component.vue.d.ts b/node_modules/@tresjs/cientos/dist/core/staging/useEnvironment/component.vue.d.ts
new file mode 100644
index 0000000..b754588
--- /dev/null
+++ b/node_modules/@tresjs/cientos/dist/core/staging/useEnvironment/component.vue.d.ts
@@ -0,0 +1,61 @@
+import type { Ref } from 'vue';
+import type { CubeTexture, Texture } from 'three';
+import type { EnvironmentOptions } from './const';
+declare const _default: __VLS_WithTemplateSlots<import("vue").DefineComponent<__VLS_WithDefaults<__VLS_TypePropsToRuntimeProps<EnvironmentOptions>, {
+    background: boolean;
+    blur: number;
+    files: never[];
+    path: string;
+    preset: undefined;
+    resolution: number;
+    near: number;
+    far: number;
+    frames: number;
+}>, {
+    texture: Ref<Texture | CubeTexture | null>;
+}, unknown, {}, {}, import("vue").ComponentOptionsMixin, import("vue").ComponentOptionsMixin, {}, string, import("vue").PublicProps, Readonly<import("vue").ExtractPropTypes<__VLS_WithDefaults<__VLS_TypePropsToRuntimeProps<EnvironmentOptions>, {
+    background: boolean;
+    blur: number;
+    files: never[];
+    path: string;
+    preset: undefined;
+    resolution: number;
+    near: number;
+    far: number;
+    frames: number;
+}>>>, {
+    path: string;
+    blur: number;
+    resolution: number;
+    far: number;
+    frames: number;
+    near: number;
+    preset: "sunset" | "studio" | "city" | "umbrellas" | "night" | "forest" | "snow" | "dawn" | "hangar" | "urban" | "modern" | "shangai";
+    files: string | string[];
+    background: string | boolean;
+}, {}>, {
+    default?(_: {}): any;
+}>;
+export default _default;
+type __VLS_NonUndefinedable<T> = T extends undefined ? never : T;
+type __VLS_TypePropsToRuntimeProps<T> = {
+    [K in keyof T]-?: {} extends Pick<T, K> ? {
+        type: import('vue').PropType<__VLS_NonUndefinedable<T[K]>>;
+    } : {
+        type: import('vue').PropType<T[K]>;
+        required: true;
+    };
+};
+type __VLS_WithDefaults<P, D> = {
+    [K in keyof Pick<P, keyof P>]: K extends keyof D ? __VLS_Prettify<P[K] & {
+        default: D[K];
+    }> : P[K];
+};
+type __VLS_Prettify<T> = {
+    [K in keyof T]: T[K];
+} & {};
+type __VLS_WithTemplateSlots<T, S> = T & {
+    new (): {
+        $slots: S;
+    };
+};
diff --git a/node_modules/@tresjs/cientos/dist/core/staging/useEnvironment/const.d.ts b/node_modules/@tresjs/cientos/dist/core/staging/useEnvironment/const.d.ts
index 8f24dfe..c17f3e9 100644
--- a/node_modules/@tresjs/cientos/dist/core/staging/useEnvironment/const.d.ts
+++ b/node_modules/@tresjs/cientos/dist/core/staging/useEnvironment/const.d.ts
@@ -33,6 +33,34 @@ export interface EnvironmentOptions {
      * @type {EnvironmentPresetsType}
      */
     preset?: EnvironmentPresetsType;
+    /**
+    * The resolution of the WebGLCubeRenderTarget.
+    *
+    * @type {number}
+    * @default 256
+    */
+    resolution?: number;
+    /**
+    * The near of the CubeCamera.
+    *
+    * @type {number}
+    * @default 1
+    */
+    near?: number;
+    /**
+    * The far of the CubeCamera.
+    *
+    * @type {number}
+    * @default 1000
+    */
+    far?: number;
+    /**
+    * The frames of the cubeCamera.update.
+    *
+    * @type {number}
+    * @default Infinity
+    */
+    frames?: number;
 }
 export declare const environmentPresets: {
     sunset: string;
diff --git a/node_modules/@tresjs/cientos/dist/core/staging/useEnvironment/envSence.d.ts b/node_modules/@tresjs/cientos/dist/core/staging/useEnvironment/envSence.d.ts
new file mode 100644
index 0000000..db2aeaa
--- /dev/null
+++ b/node_modules/@tresjs/cientos/dist/core/staging/useEnvironment/envSence.d.ts
@@ -0,0 +1,8 @@
+import { Scene, Object3D } from 'three';
+declare class EnvSence extends Object3D {
+    virtualScene: Scene;
+    constructor();
+    add(...object: Object3D[]): this;
+    destructor(): void;
+}
+export default EnvSence;
diff --git a/node_modules/@tresjs/cientos/dist/core/staging/useEnvironment/index.d.ts b/node_modules/@tresjs/cientos/dist/core/staging/useEnvironment/index.d.ts
index 4b3d77b..1d91f1f 100644
--- a/node_modules/@tresjs/cientos/dist/core/staging/useEnvironment/index.d.ts
+++ b/node_modules/@tresjs/cientos/dist/core/staging/useEnvironment/index.d.ts
@@ -1,3 +1,4 @@
-import type { CubeTexture, Texture } from 'three';
+import type { CubeTexture, Texture, WebGLCubeRenderTarget } from 'three';
+import type { Ref } from 'vue';
 import type { EnvironmentOptions } from './const';
-export declare function useEnvironment(options: Partial<EnvironmentOptions>): Promise<Texture | CubeTexture>;
+export declare function useEnvironment(options: Partial<EnvironmentOptions>, fbo: Ref<WebGLCubeRenderTarget | undefined>): Promise<Texture | CubeTexture>;
diff --git a/node_modules/@tresjs/cientos/dist/core/staging/useEnvironment/lightformer/index.vue.d.ts b/node_modules/@tresjs/cientos/dist/core/staging/useEnvironment/lightformer/index.vue.d.ts
new file mode 100644
index 0000000..469dd17
--- /dev/null
+++ b/node_modules/@tresjs/cientos/dist/core/staging/useEnvironment/lightformer/index.vue.d.ts
@@ -0,0 +1,56 @@
+import type { Texture } from 'three';
+import { Color } from 'three';
+declare const _default: import("vue").DefineComponent<__VLS_WithDefaults<__VLS_TypePropsToRuntimeProps<{
+    args?: any[] | undefined;
+    from?: 'circle' | 'ring' | 'rect' | any;
+    toneMapped?: boolean | undefined;
+    map?: Texture | undefined;
+    intensity?: number | undefined;
+    color?: any;
+}>, {
+    args: any;
+    from: string;
+    toneMapped: boolean;
+    map: any;
+    intensity: number;
+    color: Color;
+}>, {}, unknown, {}, {}, import("vue").ComponentOptionsMixin, import("vue").ComponentOptionsMixin, {}, string, import("vue").PublicProps, Readonly<import("vue").ExtractPropTypes<__VLS_WithDefaults<__VLS_TypePropsToRuntimeProps<{
+    args?: any[] | undefined;
+    from?: 'circle' | 'ring' | 'rect' | any;
+    toneMapped?: boolean | undefined;
+    map?: Texture | undefined;
+    intensity?: number | undefined;
+    color?: any;
+}>, {
+    args: any;
+    from: string;
+    toneMapped: boolean;
+    map: any;
+    intensity: number;
+    color: Color;
+}>>>, {
+    map: Texture;
+    color: any;
+    args: any[];
+    toneMapped: boolean;
+    from: 'circle' | 'ring' | 'rect' | any;
+    intensity: number;
+}, {}>;
+export default _default;
+type __VLS_NonUndefinedable<T> = T extends undefined ? never : T;
+type __VLS_TypePropsToRuntimeProps<T> = {
+    [K in keyof T]-?: {} extends Pick<T, K> ? {
+        type: import('vue').PropType<__VLS_NonUndefinedable<T[K]>>;
+    } : {
+        type: import('vue').PropType<T[K]>;
+        required: true;
+    };
+};
+type __VLS_WithDefaults<P, D> = {
+    [K in keyof Pick<P, keyof P>]: K extends keyof D ? __VLS_Prettify<P[K] & {
+        default: D[K];
+    }> : P[K];
+};
+type __VLS_Prettify<T> = {
+    [K in keyof T]: T[K];
+} & {};
diff --git a/node_modules/@tresjs/cientos/dist/trescientos.js b/node_modules/@tresjs/cientos/dist/trescientos.js
index 8ffb702..5e225a6 100644
--- a/node_modules/@tresjs/cientos/dist/trescientos.js
+++ b/node_modules/@tresjs/cientos/dist/trescientos.js
@@ -5,18 +5,18 @@
  * description: Collection of useful helpers and fully functional, ready-made abstractions for Tres
  * author: Alvaro Saburido <hola@alvarosaburido.dev> (https://github.com/alvarosabu/)
  */
-var rl = Object.defineProperty;
-var ol = (o, e, t) => e in o ? rl(o, e, { enumerable: !0, configurable: !0, writable: !0, value: t }) : o[e] = t;
-var oe = (o, e, t) => (ol(o, typeof e != "symbol" ? e + "" : e, t), t);
-import * as Ar from "three";
-import { TrianglesDrawMode as al, TriangleFanDrawMode as Ni, TriangleStripDrawMode as ko, REVISION as rr, Color as Be, Vector3 as ee, CompressedTexture as ii, Texture as zn, MathUtils as We, RGBAFormat as Uo, DoubleSide as wn, BufferAttribute as pt, PropertyBinding as Yt, InterpolateDiscrete as Bo, Matrix4 as De, Scene as Xs, PlaneGeometry as Dt, ShaderMaterial as Xt, Uniform as Re, Mesh as ae, PerspectiveCamera as Mt, WebGLRenderer as ll, InterpolateLinear as or, NearestFilter as No, NearestMipmapNearestFilter as zo, NearestMipmapLinearFilter as Ho, LinearFilter as At, LinearMipmapNearestFilter as Go, LinearMipmapLinearFilter as ar, ClampToEdgeWrapping as Hn, RepeatWrapping as Gn, MirroredRepeatWrapping as jo, Triangle as cl, Object3D as St, Raycaster as Vo, Quaternion as He, Euler as _n, MeshBasicMaterial as Gt, LineBasicMaterial as qs, CylinderGeometry as xt, BoxGeometry as tn, BufferGeometry as rt, Float32BufferAttribute as it, Line as Ie, OctahedronGeometry as dn, TorusGeometry as xs, SphereGeometry as ul, EventDispatcher as Yo, Ray as hl, Plane as lr, MOUSE as on, TOUCH as Lt, OrthographicCamera as jt, Spherical as Ws, Vector2 as le, Loader as cs, LoaderUtils as Ft, FileLoader as Tn, SpotLight as Xo, PointLight as zi, DirectionalLight as Wo, MeshPhysicalMaterial as fn, InstancedMesh as fl, TextureLoader as cr, ImageBitmapLoader as dl, InterleavedBuffer as ur, InterleavedBufferAttribute as Vt, PointsMaterial as pl, Material as ri, MeshStandardMaterial as us, SkinnedMesh as $o, LineSegments as ml, LineLoop as gl, Points as Zo, Group as ns, Skeleton as Ko, AnimationClip as qo, Bone as Hi, FrontSide as yl, VectorKeyframeTrack as Qo, QuaternionKeyframeTrack as Gi, NumberKeyframeTrack as Jo, Box3 as hs, Sphere as Qs, Interpolant as vl, ExtrudeGeometry as _l, Vector4 as ht, Curve as xl, MeshPhongMaterial as oi, MeshLambertMaterial as wl, EquirectangularReflectionMapping as ji, AmbientLight as Tl, Uint16BufferAttribute as bl, Matrix3 as vn, ShapePath as nn, DataTextureLoader as El, HalfFloatType as un, FloatType as Gs, DataUtils as ws, ShapeUtils as Ml, Box2 as ea, Shape as Sl, Path as ai, BackSide as ta, AnimationMixer as Al, WebGLRenderTarget as bn, UniformsUtils as Js, AudioListener as Pl, Audio as Rl, AudioLoader as Cl, FramebufferTexture as Pr, RawShaderMaterial as li, AdditiveBlending as na, UnsignedByteType as Vi, DepthTexture as sa, CubeTextureLoader as Il, CubeReflectionMapping as Dl, ShapeGeometry as Ll, DefaultLoadingManager as Ts, VideoTexture as Ol, NoBlending as Fl, Camera as kl, DepthFormat as Ul, UnsignedShortType as Bl, InstancedBufferGeometry as Nl, InstancedInterleavedBuffer as Yi, WireframeGeometry as zl, UniformsLib as js, ShaderLib as Vs, Line3 as Hl, CatmullRomCurve3 as Gl, QuadraticBezierCurve3 as jl, MeshDepthMaterial as Vl, DataTexture as ia, UVMapping as Yl, IcosahedronGeometry as Xl, DirectionalLightHelper as Wl, PointLightHelper as $l, SpotLightHelper as Zl, HemisphereLightHelper as Kl, ArrowHelper as ql } from "three";
-import { defineComponent as pe, toRefs as Fe, useSlots as ra, computed as Ne, shallowRef as xe, withAsyncContext as fs, toValue as Kt, watchEffect as ft, unref as z, openBlock as fe, createElementBlock as de, createCommentVNode as Wt, renderSlot as $e, ref as ue, shallowReactive as Ql, mergeProps as Ye, createElementVNode as Te, getCurrentScope as Jl, onScopeDispose as ec, onMounted as ds, nextTick as tc, getCurrentInstance as oa, watch as we, reactive as Xi, onUnmounted as ot, isReactive as nc, onBeforeUnmount as aa, Fragment as la, renderList as ca, normalizeProps as ua, guardReactiveProps as ha, useAttrs as fa, createBlock as sc, triggerRef as ic, isRef as Wi, createVNode as bs, render as rc } from "vue";
-import { useTresContext as je, useRenderLoop as Ke, normalizeColor as ln, useLoader as rs, useLogger as ps, useTexture as $i, normalizeVectorFlexibleParam as oc } from "@tresjs/core";
-import { Pane as ac } from "tweakpane";
-function Rr(o, e) {
-  if (e === al)
+var fl = Object.defineProperty;
+var dl = (o, e, t) => e in o ? fl(o, e, { enumerable: !0, configurable: !0, writable: !0, value: t }) : o[e] = t;
+var oe = (o, e, t) => (dl(o, typeof e != "symbol" ? e + "" : e, t), t);
+import * as Or from "three";
+import { TrianglesDrawMode as pl, TriangleFanDrawMode as Yi, TriangleStripDrawMode as Go, REVISION as ur, Color as Re, Vector3 as q, CompressedTexture as ui, Texture as Vn, MathUtils as Ze, RGBAFormat as Vo, DoubleSide as dn, BufferAttribute as pt, PropertyBinding as Kt, InterpolateDiscrete as Wo, Matrix4 as Pe, Scene as fs, PlaneGeometry as Lt, ShaderMaterial as Pt, Uniform as we, Mesh as ae, PerspectiveCamera as wt, WebGLRenderer as ml, InterpolateLinear as hr, NearestFilter as Yo, NearestMipmapNearestFilter as Xo, NearestMipmapLinearFilter as $o, LinearFilter as Ct, LinearMipmapNearestFilter as Zo, LinearMipmapLinearFilter as fr, ClampToEdgeWrapping as Wn, RepeatWrapping as En, MirroredRepeatWrapping as Ko, Triangle as gl, Object3D as Tt, Raycaster as qo, Quaternion as He, Euler as Tn, MeshBasicMaterial as Yt, LineBasicMaterial as si, CylinderGeometry as bt, BoxGeometry as Wt, BufferGeometry as at, Float32BufferAttribute as it, Line as De, OctahedronGeometry as gn, TorusGeometry as As, SphereGeometry as vl, EventDispatcher as Qo, Ray as yl, Plane as ii, MOUSE as ln, TOUCH as Ft, OrthographicCamera as Xt, Spherical as qs, Vector2 as he, Loader as vs, LoaderUtils as Bt, FileLoader as Sn, SpotLight as Jo, PointLight as Xi, DirectionalLight as ea, MeshPhysicalMaterial as mn, InstancedMesh as _l, TextureLoader as dr, ImageBitmapLoader as xl, InterleavedBuffer as pr, InterleavedBufferAttribute as $t, PointsMaterial as wl, Material as hi, MeshStandardMaterial as ys, SkinnedMesh as ta, LineSegments as Tl, LineLoop as bl, Points as na, Group as cs, Skeleton as sa, AnimationClip as ia, Bone as $i, FrontSide as _s, VectorKeyframeTrack as ra, QuaternionKeyframeTrack as Zi, NumberKeyframeTrack as oa, Box3 as xs, Sphere as ri, Interpolant as El, ExtrudeGeometry as Sl, Vector4 as rt, Curve as Ml, MeshPhongMaterial as fi, MeshLambertMaterial as Al, EquirectangularReflectionMapping as Ki, AmbientLight as Pl, Uint16BufferAttribute as Cl, Matrix3 as wn, ShapePath as rn, DataTextureLoader as Rl, HalfFloatType as Zt, FloatType as Zs, DataUtils as Ps, ShapeUtils as Il, Box2 as aa, Shape as Dl, Path as di, BackSide as la, AnimationMixer as Ol, WebGLRenderTarget as pn, UniformsUtils as Yn, AudioListener as Ll, Audio as Fl, AudioLoader as kl, FramebufferTexture as Lr, RawShaderMaterial as pi, AdditiveBlending as mr, UnsignedByteType as qi, DepthTexture as ca, CubeTextureLoader as Bl, CubeReflectionMapping as Ul, ShapeGeometry as Nl, DefaultLoadingManager as Cs, VideoTexture as zl, NoBlending as Hl, Camera as jl, DepthFormat as Gl, UnsignedShortType as Vl, Clock as Wl, InstancedBufferGeometry as Yl, InstancedInterleavedBuffer as Qi, WireframeGeometry as Xl, UniformsLib as jn, ShaderLib as Ks, Line3 as $l, CatmullRomCurve3 as Zl, QuadraticBezierCurve3 as Kl, WebGLCubeRenderTarget as ql, CubeCamera as Ql, MeshDepthMaterial as Jl, DataTexture as ua, UVMapping as ec, IcosahedronGeometry as tc, DirectionalLightHelper as nc, PointLightHelper as sc, SpotLightHelper as ic, HemisphereLightHelper as rc, ArrowHelper as oc } from "three";
+import { defineComponent as pe, toRefs as Oe, useSlots as gr, computed as Ne, shallowRef as me, withAsyncContext as Xn, toValue as Jt, watchEffect as lt, unref as B, openBlock as le, createElementBlock as ce, createCommentVNode as Ut, renderSlot as Ve, ref as ue, shallowReactive as ac, mergeProps as Ye, createElementVNode as ye, getCurrentScope as lc, onScopeDispose as cc, onMounted as $n, nextTick as ha, isRef as Qs, getCurrentInstance as fa, watch as Te, reactive as Ji, onUnmounted as ot, isReactive as uc, onBeforeUnmount as da, Fragment as pa, renderList as ma, normalizeProps as ga, guardReactiveProps as va, useAttrs as ya, createBlock as _a, toRaw as hc, triggerRef as fc, createVNode as Rs, render as dc } from "vue";
+import { useTresContext as Ue, useRenderLoop as Xe, normalizeColor as un, useLoader as ds, useLogger as ws, useTexture as Js, normalizeVectorFlexibleParam as pc } from "@tresjs/core";
+import { Pane as mc } from "tweakpane";
+function Fr(o, e) {
+  if (e === pl)
     return console.warn("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Geometry already defined as triangles."), o;
-  if (e === Ni || e === ko) {
+  if (e === Yi || e === Go) {
     let t = o.getIndex();
     if (t === null) {
       const r = [], a = o.getAttribute("position");
@@ -31,7 +31,7 @@ function Rr(o, e) {
     }
     const n = t.count - 2, s = [];
     if (t)
-      if (e === Ni)
+      if (e === Yi)
         for (let r = 1; r <= n; r++)
           s.push(t.getX(0)), s.push(t.getX(r)), s.push(t.getX(r + 1));
       else
@@ -43,16 +43,16 @@ function Rr(o, e) {
   } else
     return console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unknown draw mode:", e), o;
 }
-const da = parseInt(rr.replace(/\D+/g, ""));
-var lc = Object.defineProperty, cc = (o, e, t) => e in o ? lc(o, e, { enumerable: !0, configurable: !0, writable: !0, value: t }) : o[e] = t, uc = (o, e, t) => (cc(o, typeof e != "symbol" ? e + "" : e, t), t);
-async function Cr(o) {
+const xa = parseInt(ur.replace(/\D+/g, ""));
+var gc = Object.defineProperty, vc = (o, e, t) => e in o ? gc(o, e, { enumerable: !0, configurable: !0, writable: !0, value: t }) : o[e] = t, yc = (o, e, t) => (vc(o, typeof e != "symbol" ? e + "" : e, t), t);
+async function kr(o) {
   const e = await o.arrayBuffer(), t = btoa(String.fromCharCode(...new Uint8Array(e)));
   return `data:${o.type || ""};base64,${t}`;
 }
-let Es, ci, Pn, Ms;
-function ui(o, e = 1 / 0, t = null) {
-  ci || (ci = new Dt(2, 2, 1, 1)), Pn || (Pn = new Xt({
-    uniforms: { blitTexture: new Re(o) },
+let Is, mi, Rn, Ds;
+function gi(o, e = 1 / 0, t = null) {
+  mi || (mi = new Lt(2, 2, 1, 1)), Rn || (Rn = new Pt({
+    uniforms: { blitTexture: new we(o) },
     vertexShader: (
       /* glsl */
       `
@@ -80,13 +80,13 @@ function ui(o, e = 1 / 0, t = null) {
           }
       `
     )
-  })), Pn.uniforms.blitTexture.value = o, Pn.defines.IS_SRGB = "colorSpace" in o ? o.colorSpace === "srgb" : o.encoding === 3001, Pn.needsUpdate = !0, Ms || (Ms = new ae(ci, Pn), Ms.frustrumCulled = !1);
-  const n = new Mt(), s = new Xs();
-  s.add(Ms), t || (t = Es = new ll({ antialias: !1 })), t.setSize(Math.min(o.image.width, e), Math.min(o.image.height, e)), t.clear(), t.render(s, n);
-  const i = new zn(t.domElement);
-  return i.minFilter = o.minFilter, i.magFilter = o.magFilter, i.wrapS = o.wrapS, i.wrapT = o.wrapT, i.name = o.name, Es && (Es.dispose(), Es = null), i;
+  })), Rn.uniforms.blitTexture.value = o, Rn.defines.IS_SRGB = "colorSpace" in o ? o.colorSpace === "srgb" : o.encoding === 3001, Rn.needsUpdate = !0, Ds || (Ds = new ae(mi, Rn), Ds.frustrumCulled = !1);
+  const n = new wt(), s = new fs();
+  s.add(Ds), t || (t = Is = new ml({ antialias: !1 })), t.setSize(Math.min(o.image.width, e), Math.min(o.image.height, e)), t.clear(), t.render(s, n);
+  const i = new Vn(t.domElement);
+  return i.minFilter = o.minFilter, i.magFilter = o.magFilter, i.wrapS = o.wrapS, i.wrapT = o.wrapT, i.name = o.name, Is && (Is.dispose(), Is = null), i;
 }
-const Ir = {
+const Br = {
   POSITION: [
     "byte",
     "byte normalized",
@@ -101,30 +101,30 @@ const Ir = {
   TANGENT: ["byte normalized", "short normalized"],
   TEXCOORD: ["byte", "byte normalized", "unsigned byte", "short", "short normalized", "unsigned short"]
 };
-class hr {
+class vr {
   constructor() {
     this.pluginCallbacks = [], this.register(function(e) {
-      return new xc(e);
+      return new Pc(e);
     }), this.register(function(e) {
-      return new wc(e);
+      return new Cc(e);
     }), this.register(function(e) {
-      return new Ec(e);
+      return new Dc(e);
     }), this.register(function(e) {
-      return new Mc(e);
+      return new Oc(e);
     }), this.register(function(e) {
-      return new Sc(e);
+      return new Lc(e);
     }), this.register(function(e) {
-      return new Ac(e);
+      return new Fc(e);
     }), this.register(function(e) {
-      return new Tc(e);
+      return new Rc(e);
     }), this.register(function(e) {
-      return new bc(e);
+      return new Ic(e);
     }), this.register(function(e) {
-      return new Pc(e);
+      return new kc(e);
     }), this.register(function(e) {
-      return new Rc(e);
+      return new Bc(e);
     }), this.register(function(e) {
-      return new Cc(e);
+      return new Uc(e);
     });
   }
   register(e) {
@@ -141,7 +141,7 @@ class hr {
    * @param  {Object} options options
    */
   parse(e, t, n, s) {
-    const i = new _c(), r = [];
+    const i = new Ac(), r = [];
     for (let a = 0, l = this.pluginCallbacks.length; a < l; a++)
       r.push(this.pluginCallbacks[a](i));
     i.setPlugins(r), i.write(e, t, s).catch(n);
@@ -153,7 +153,7 @@ class hr {
     });
   }
 }
-uc(hr, "Utils", {
+yc(vr, "Utils", {
   insertKeyframe: function(o, e) {
     const n = o.getValueSize(), s = new o.TimeBufferType(o.times.length + 1), i = new o.ValueBufferType(o.values.length + n), r = o.createInterpolant(new o.ValueBufferType(n));
     let a;
@@ -185,7 +185,7 @@ uc(hr, "Utils", {
     const t = [], n = {}, s = o.tracks;
     for (let i = 0; i < s.length; ++i) {
       let r = s[i];
-      const a = Yt.parseTrackName(r.name), l = Yt.findNode(e, a.nodeName);
+      const a = Kt.parseTrackName(r.name), l = Kt.findNode(e, a.nodeName);
       if (a.propertyName !== "morphTargetInfluences" || a.propertyIndex === void 0) {
         t.push(r);
         continue;
@@ -193,7 +193,7 @@ uc(hr, "Utils", {
       if (r.createInterpolant !== r.InterpolantFactoryMethodDiscrete && r.createInterpolant !== r.InterpolantFactoryMethodLinear) {
         if (r.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline)
           throw new Error("THREE.GLTFExporter: Cannot merge tracks with glTF CUBICSPLINE interpolation.");
-        console.warn("THREE.GLTFExporter: Morph target interpolation mode not yet supported. Using LINEAR instead."), r = r.clone(), r.setInterpolation(or);
+        console.warn("THREE.GLTFExporter: Morph target interpolation mode not yet supported. Using LINEAR instead."), r = r.clone(), r.setInterpolation(hr);
       }
       const c = l.morphTargetInfluences.length, u = l.morphTargetDictionary[a.propertyIndex];
       if (u === void 0)
@@ -201,25 +201,25 @@ uc(hr, "Utils", {
       let h;
       if (n[l.uuid] === void 0) {
         h = r.clone();
-        const p = new h.ValueBufferType(c * h.times.length);
-        for (let v = 0; v < h.times.length; v++)
-          p[v * c + u] = h.values[v];
-        h.name = (a.nodeName || "") + ".morphTargetInfluences", h.values = p, n[l.uuid] = h, t.push(h);
+        const d = new h.ValueBufferType(c * h.times.length);
+        for (let y = 0; y < h.times.length; y++)
+          d[y * c + u] = h.values[y];
+        h.name = (a.nodeName || "") + ".morphTargetInfluences", h.values = d, n[l.uuid] = h, t.push(h);
         continue;
       }
-      const m = r.createInterpolant(new r.ValueBufferType(1));
+      const f = r.createInterpolant(new r.ValueBufferType(1));
       h = n[l.uuid];
-      for (let p = 0; p < h.times.length; p++)
-        h.values[p * c + u] = m.evaluate(h.times[p]);
-      for (let p = 0; p < r.times.length; p++) {
-        const v = this.insertKeyframe(h, r.times[p]);
-        h.values[v * c + u] = r.values[p];
+      for (let d = 0; d < h.times.length; d++)
+        h.values[d * c + u] = f.evaluate(h.times[d]);
+      for (let d = 0; d < r.times.length; d++) {
+        const y = this.insertKeyframe(h, r.times[d]);
+        h.values[y * c + u] = r.values[d];
       }
     }
     return o.tracks = t, o;
   }
 });
-const Pe = {
+const Ce = {
   POINTS: 0,
   LINES: 1,
   LINE_LOOP: 2,
@@ -245,34 +245,34 @@ const Pe = {
   CLAMP_TO_EDGE: 33071,
   MIRRORED_REPEAT: 33648,
   REPEAT: 10497
-}, hi = "KHR_mesh_quantization", mt = {};
-mt[No] = Pe.NEAREST;
-mt[zo] = Pe.NEAREST_MIPMAP_NEAREST;
-mt[Ho] = Pe.NEAREST_MIPMAP_LINEAR;
-mt[At] = Pe.LINEAR;
-mt[Go] = Pe.LINEAR_MIPMAP_NEAREST;
-mt[ar] = Pe.LINEAR_MIPMAP_LINEAR;
-mt[Hn] = Pe.CLAMP_TO_EDGE;
-mt[Gn] = Pe.REPEAT;
-mt[jo] = Pe.MIRRORED_REPEAT;
-const Dr = {
+}, vi = "KHR_mesh_quantization", mt = {};
+mt[Yo] = Ce.NEAREST;
+mt[Xo] = Ce.NEAREST_MIPMAP_NEAREST;
+mt[$o] = Ce.NEAREST_MIPMAP_LINEAR;
+mt[Ct] = Ce.LINEAR;
+mt[Zo] = Ce.LINEAR_MIPMAP_NEAREST;
+mt[fr] = Ce.LINEAR_MIPMAP_LINEAR;
+mt[Wn] = Ce.CLAMP_TO_EDGE;
+mt[En] = Ce.REPEAT;
+mt[Ko] = Ce.MIRRORED_REPEAT;
+const Ur = {
   scale: "scale",
   position: "translation",
   quaternion: "rotation",
   morphTargetInfluences: "weights"
-}, hc = new Be(), Lr = 12, fc = 1179937895, dc = 2, Or = 8, pc = 1313821514, mc = 5130562;
-function ts(o, e) {
+}, _c = new Re(), Nr = 12, xc = 1179937895, wc = 2, zr = 8, Tc = 1313821514, bc = 5130562;
+function ls(o, e) {
   return o.length === e.length && o.every(function(t, n) {
     return t === e[n];
   });
 }
-function gc(o) {
+function Ec(o) {
   return new TextEncoder().encode(o).buffer;
 }
-function yc(o) {
-  return ts(o.elements, [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]);
+function Sc(o) {
+  return ls(o.elements, [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]);
 }
-function vc(o, e, t) {
+function Mc(o, e, t) {
   const n = {
     min: new Array(o.itemSize).fill(Number.POSITIVE_INFINITY),
     max: new Array(o.itemSize).fill(Number.NEGATIVE_INFINITY)
@@ -280,15 +280,15 @@ function vc(o, e, t) {
   for (let s = e; s < e + t; s++)
     for (let i = 0; i < o.itemSize; i++) {
       let r;
-      o.itemSize > 4 ? r = o.array[s * o.itemSize + i] : (i === 0 ? r = o.getX(s) : i === 1 ? r = o.getY(s) : i === 2 ? r = o.getZ(s) : i === 3 && (r = o.getW(s)), o.normalized === !0 && (r = We.normalize(r, o.array))), n.min[i] = Math.min(n.min[i], r), n.max[i] = Math.max(n.max[i], r);
+      o.itemSize > 4 ? r = o.array[s * o.itemSize + i] : (i === 0 ? r = o.getX(s) : i === 1 ? r = o.getY(s) : i === 2 ? r = o.getZ(s) : i === 3 && (r = o.getW(s)), o.normalized === !0 && (r = Ze.normalize(r, o.array))), n.min[i] = Math.min(n.min[i], r), n.max[i] = Math.max(n.max[i], r);
     }
   return n;
 }
-function pa(o) {
+function wa(o) {
   return Math.ceil(o / 4) * 4;
 }
-function fi(o, e = 0) {
-  const t = pa(o.byteLength);
+function yi(o, e = 0) {
+  const t = wa(o.byteLength);
   if (t !== o.byteLength) {
     const n = new Uint8Array(t);
     if (n.set(new Uint8Array(o)), e !== 0)
@@ -298,10 +298,10 @@ function fi(o, e = 0) {
   }
   return o;
 }
-function Fr() {
+function Hr() {
   return typeof document > "u" && typeof OffscreenCanvas < "u" ? new OffscreenCanvas(1, 1) : document.createElement("canvas");
 }
-function kr(o, e) {
+function jr(o, e) {
   if (o.toBlob !== void 0)
     return new Promise((n) => o.toBlob(n, e));
   let t;
@@ -310,7 +310,7 @@ function kr(o, e) {
     quality: t
   });
 }
-class _c {
+class Ac {
   constructor() {
     this.plugins = [], this.options = {}, this.pending = [], this.buffers = [], this.byteOffset = 0, this.buffers = [], this.nodeMap = /* @__PURE__ */ new Map(), this.skins = [], this.extensionsUsed = {}, this.extensionsRequired = {}, this.uids = /* @__PURE__ */ new Map(), this.uid = 0, this.json = {
       asset: {
@@ -351,19 +351,19 @@ class _c {
     const s = this, i = s.buffers, r = s.json;
     n = s.options;
     const a = s.extensionsUsed, l = s.extensionsRequired, c = new Blob(i, { type: "application/octet-stream" }), u = Object.keys(a), h = Object.keys(l);
-    u.length > 0 && (r.extensionsUsed = u), h.length > 0 && (r.extensionsRequired = h), r.buffers && r.buffers.length > 0 && (r.buffers[0].byteLength = c.size), n.binary === !0 ? c.arrayBuffer().then((m) => {
-      const p = fi(m), v = new DataView(new ArrayBuffer(Or));
-      v.setUint32(0, p.byteLength, !0), v.setUint32(4, mc, !0);
-      const _ = fi(gc(JSON.stringify(r)), 32), y = new DataView(new ArrayBuffer(Or));
-      y.setUint32(0, _.byteLength, !0), y.setUint32(4, pc, !0);
-      const E = new ArrayBuffer(Lr), R = new DataView(E);
-      R.setUint32(0, fc, !0), R.setUint32(4, dc, !0);
-      const T = Lr + y.byteLength + _.byteLength + v.byteLength + p.byteLength;
-      R.setUint32(8, T, !0), new Blob([E, y, _, v, p], {
+    u.length > 0 && (r.extensionsUsed = u), h.length > 0 && (r.extensionsRequired = h), r.buffers && r.buffers.length > 0 && (r.buffers[0].byteLength = c.size), n.binary === !0 ? c.arrayBuffer().then((f) => {
+      const d = yi(f), y = new DataView(new ArrayBuffer(zr));
+      y.setUint32(0, d.byteLength, !0), y.setUint32(4, bc, !0);
+      const x = yi(Ec(JSON.stringify(r)), 32), g = new DataView(new ArrayBuffer(zr));
+      g.setUint32(0, x.byteLength, !0), g.setUint32(4, Tc, !0);
+      const v = new ArrayBuffer(Nr), M = new DataView(v);
+      M.setUint32(0, xc, !0), M.setUint32(4, wc, !0);
+      const _ = Nr + g.byteLength + x.byteLength + y.byteLength + d.byteLength;
+      M.setUint32(8, _, !0), new Blob([v, g, x, y, d], {
         type: "application/octet-stream"
       }).arrayBuffer().then(t);
-    }) : r.buffers && r.buffers.length > 0 ? Cr(c).then((m) => {
-      r.buffers[0].uri = m, t(r);
+    }) : r.buffers && r.buffers.length > 0 ? kr(c).then((f) => {
+      r.buffers[0].uri = f, t(r);
     }) : t(r);
   }
   /**
@@ -412,7 +412,7 @@ class _c {
   isNormalizedNormalAttribute(e) {
     if (this.cache.attributesNormalized.has(e))
       return !1;
-    const n = new ee();
+    const n = new q();
     for (let s = 0, i = e.count; s < i; s++)
       if (Math.abs(n.fromBufferAttribute(e, s).length() - 1) > 5e-4)
         return !1;
@@ -429,7 +429,7 @@ class _c {
     const t = this.cache;
     if (t.attributesNormalized.has(e))
       return t.attributesNormalized.get(e);
-    const n = e.clone(), s = new ee();
+    const n = e.clone(), s = new q();
     for (let i = 0, r = n.count; i < r; i++)
       s.fromBufferAttribute(n, i), s.x === 0 && s.y === 0 && s.z === 0 ? s.setX(1) : s.normalize(), n.setXYZ(i, s.x, s.y, s.z);
     return t.attributesNormalized.set(e, n), n;
@@ -449,34 +449,34 @@ class _c {
   buildMetalRoughTexture(e, t) {
     if (e === t)
       return e;
-    function n(p) {
-      return ("colorSpace" in p ? p.colorSpace === "srgb" : p.encoding === 3001) ? function(_) {
-        return _ < 0.04045 ? _ * 0.0773993808 : Math.pow(_ * 0.9478672986 + 0.0521327014, 2.4);
-      } : function(_) {
-        return _;
+    function n(d) {
+      return ("colorSpace" in d ? d.colorSpace === "srgb" : d.encoding === 3001) ? function(x) {
+        return x < 0.04045 ? x * 0.0773993808 : Math.pow(x * 0.9478672986 + 0.0521327014, 2.4);
+      } : function(x) {
+        return x;
       };
     }
-    console.warn("THREE.GLTFExporter: Merged metalnessMap and roughnessMap textures."), e instanceof ii && (e = ui(e)), t instanceof ii && (t = ui(t));
-    const s = e ? e.image : null, i = t ? t.image : null, r = Math.max(s ? s.width : 0, i ? i.width : 0), a = Math.max(s ? s.height : 0, i ? i.height : 0), l = Fr();
+    console.warn("THREE.GLTFExporter: Merged metalnessMap and roughnessMap textures."), e instanceof ui && (e = gi(e)), t instanceof ui && (t = gi(t));
+    const s = e ? e.image : null, i = t ? t.image : null, r = Math.max(s ? s.width : 0, i ? i.width : 0), a = Math.max(s ? s.height : 0, i ? i.height : 0), l = Hr();
     l.width = r, l.height = a;
     const c = l.getContext("2d");
     c.fillStyle = "#00ffff", c.fillRect(0, 0, r, a);
     const u = c.getImageData(0, 0, r, a);
     if (s) {
       c.drawImage(s, 0, 0, r, a);
-      const p = n(e), v = c.getImageData(0, 0, r, a).data;
-      for (let _ = 2; _ < v.length; _ += 4)
-        u.data[_] = p(v[_] / 256) * 256;
+      const d = n(e), y = c.getImageData(0, 0, r, a).data;
+      for (let x = 2; x < y.length; x += 4)
+        u.data[x] = d(y[x] / 256) * 256;
     }
     if (i) {
       c.drawImage(i, 0, 0, r, a);
-      const p = n(t), v = c.getImageData(0, 0, r, a).data;
-      for (let _ = 1; _ < v.length; _ += 4)
-        u.data[_] = p(v[_] / 256) * 256;
+      const d = n(t), y = c.getImageData(0, 0, r, a).data;
+      for (let x = 1; x < y.length; x += 4)
+        u.data[x] = d(y[x] / 256) * 256;
     }
     c.putImageData(u, 0, 0);
-    const m = (e || t).clone();
-    return m.source = new zn(l).source, "colorSpace" in m ? m.colorSpace = "" : m.encoding = 3e3, m.channel = (e || t).channel, e && t && e.channel !== t.channel && console.warn("THREE.GLTFExporter: UV channels for metalnessMap and roughnessMap textures must match."), m;
+    const f = (e || t).clone();
+    return f.source = new Vn(l).source, "colorSpace" in f ? f.colorSpace = "" : f.encoding = 3e3, f.channel = (e || t).channel, e && t && e.channel !== t.channel && console.warn("THREE.GLTFExporter: UV channels for metalnessMap and roughnessMap textures must match."), f;
   }
   /**
    * Process a buffer to append to the default one.
@@ -501,30 +501,30 @@ class _c {
     r.bufferViews || (r.bufferViews = []);
     let a;
     switch (t) {
-      case Pe.BYTE:
-      case Pe.UNSIGNED_BYTE:
+      case Ce.BYTE:
+      case Ce.UNSIGNED_BYTE:
         a = 1;
         break;
-      case Pe.SHORT:
-      case Pe.UNSIGNED_SHORT:
+      case Ce.SHORT:
+      case Ce.UNSIGNED_SHORT:
         a = 2;
         break;
       default:
         a = 4;
     }
-    const l = pa(s * e.itemSize * a), c = new DataView(new ArrayBuffer(l));
+    const l = wa(s * e.itemSize * a), c = new DataView(new ArrayBuffer(l));
     let u = 0;
-    for (let p = n; p < n + s; p++)
-      for (let v = 0; v < e.itemSize; v++) {
-        let _;
-        e.itemSize > 4 ? _ = e.array[p * e.itemSize + v] : (v === 0 ? _ = e.getX(p) : v === 1 ? _ = e.getY(p) : v === 2 ? _ = e.getZ(p) : v === 3 && (_ = e.getW(p)), e.normalized === !0 && (_ = We.normalize(_, e.array))), t === Pe.FLOAT ? c.setFloat32(u, _, !0) : t === Pe.INT ? c.setInt32(u, _, !0) : t === Pe.UNSIGNED_INT ? c.setUint32(u, _, !0) : t === Pe.SHORT ? c.setInt16(u, _, !0) : t === Pe.UNSIGNED_SHORT ? c.setUint16(u, _, !0) : t === Pe.BYTE ? c.setInt8(u, _) : t === Pe.UNSIGNED_BYTE && c.setUint8(u, _), u += a;
+    for (let d = n; d < n + s; d++)
+      for (let y = 0; y < e.itemSize; y++) {
+        let x;
+        e.itemSize > 4 ? x = e.array[d * e.itemSize + y] : (y === 0 ? x = e.getX(d) : y === 1 ? x = e.getY(d) : y === 2 ? x = e.getZ(d) : y === 3 && (x = e.getW(d)), e.normalized === !0 && (x = Ze.normalize(x, e.array))), t === Ce.FLOAT ? c.setFloat32(u, x, !0) : t === Ce.INT ? c.setInt32(u, x, !0) : t === Ce.UNSIGNED_INT ? c.setUint32(u, x, !0) : t === Ce.SHORT ? c.setInt16(u, x, !0) : t === Ce.UNSIGNED_SHORT ? c.setUint16(u, x, !0) : t === Ce.BYTE ? c.setInt8(u, x) : t === Ce.UNSIGNED_BYTE && c.setUint8(u, x), u += a;
       }
     const h = {
       buffer: this.processBuffer(c.buffer),
       byteOffset: this.byteOffset,
       byteLength: l
     };
-    return i !== void 0 && (h.target = i), i === Pe.ARRAY_BUFFER && (h.byteStride = e.itemSize * a), this.byteOffset += l, r.bufferViews.push(h), {
+    return i !== void 0 && (h.target = i), i === Ce.ARRAY_BUFFER && (h.byteStride = e.itemSize * a), this.byteOffset += l, r.bufferViews.push(h), {
       id: r.bufferViews.length - 1,
       byteLength: 0
     };
@@ -537,7 +537,7 @@ class _c {
   processBufferViewImage(e) {
     const t = this, n = t.json;
     return n.bufferViews || (n.bufferViews = []), e.arrayBuffer().then((s) => {
-      const i = fi(s), r = {
+      const i = yi(s), r = {
         buffer: t.processBuffer(i),
         byteOffset: t.byteOffset,
         byteLength: i.byteLength
@@ -564,28 +564,28 @@ class _c {
     };
     let a;
     if (e.array.constructor === Float32Array)
-      a = Pe.FLOAT;
+      a = Ce.FLOAT;
     else if (e.array.constructor === Int32Array)
-      a = Pe.INT;
+      a = Ce.INT;
     else if (e.array.constructor === Uint32Array)
-      a = Pe.UNSIGNED_INT;
+      a = Ce.UNSIGNED_INT;
     else if (e.array.constructor === Int16Array)
-      a = Pe.SHORT;
+      a = Ce.SHORT;
     else if (e.array.constructor === Uint16Array)
-      a = Pe.UNSIGNED_SHORT;
+      a = Ce.UNSIGNED_SHORT;
     else if (e.array.constructor === Int8Array)
-      a = Pe.BYTE;
+      a = Ce.BYTE;
     else if (e.array.constructor === Uint8Array)
-      a = Pe.UNSIGNED_BYTE;
+      a = Ce.UNSIGNED_BYTE;
     else
       throw new Error(
         "THREE.GLTFExporter: Unsupported bufferAttribute component type: " + e.array.constructor.name
       );
     if (n === void 0 && (n = 0), s === void 0 && (s = e.count), s === 0)
       return null;
-    const l = vc(e, n, s);
+    const l = Mc(e, n, s);
     let c;
-    t !== void 0 && (c = e === t.index ? Pe.ELEMENT_ARRAY_BUFFER : Pe.ARRAY_BUFFER);
+    t !== void 0 && (c = e === t.index ? Ce.ELEMENT_ARRAY_BUFFER : Ce.ARRAY_BUFFER);
     const u = this.processBufferView(e, a, n, s, c), h = {
       bufferView: u.id,
       byteOffset: u.byteOffset,
@@ -613,28 +613,28 @@ class _c {
       if (u[h] !== void 0)
         return u[h];
       a.images || (a.images = []);
-      const m = { mimeType: s }, p = Fr();
-      p.width = Math.min(e.width, l.maxTextureSize), p.height = Math.min(e.height, l.maxTextureSize);
-      const v = p.getContext("2d");
-      if (n === !0 && (v.translate(0, p.height), v.scale(1, -1)), e.data !== void 0) {
-        t !== Uo && console.error("GLTFExporter: Only RGBAFormat is supported.", t), (e.width > l.maxTextureSize || e.height > l.maxTextureSize) && console.warn("GLTFExporter: Image size is bigger than maxTextureSize", e);
-        const y = new Uint8ClampedArray(e.height * e.width * 4);
-        for (let E = 0; E < y.length; E += 4)
-          y[E + 0] = e.data[E + 0], y[E + 1] = e.data[E + 1], y[E + 2] = e.data[E + 2], y[E + 3] = e.data[E + 3];
-        v.putImageData(new ImageData(y, e.width, e.height), 0, 0);
+      const f = { mimeType: s }, d = Hr();
+      d.width = Math.min(e.width, l.maxTextureSize), d.height = Math.min(e.height, l.maxTextureSize);
+      const y = d.getContext("2d");
+      if (n === !0 && (y.translate(0, d.height), y.scale(1, -1)), e.data !== void 0) {
+        t !== Vo && console.error("GLTFExporter: Only RGBAFormat is supported.", t), (e.width > l.maxTextureSize || e.height > l.maxTextureSize) && console.warn("GLTFExporter: Image size is bigger than maxTextureSize", e);
+        const g = new Uint8ClampedArray(e.height * e.width * 4);
+        for (let v = 0; v < g.length; v += 4)
+          g[v + 0] = e.data[v + 0], g[v + 1] = e.data[v + 1], g[v + 2] = e.data[v + 2], g[v + 3] = e.data[v + 3];
+        y.putImageData(new ImageData(g, e.width, e.height), 0, 0);
       } else
-        v.drawImage(e, 0, 0, p.width, p.height);
+        y.drawImage(e, 0, 0, d.width, d.height);
       l.binary === !0 ? c.push(
-        kr(p, s).then((y) => i.processBufferViewImage(y)).then((y) => {
-          m.bufferView = y;
+        jr(d, s).then((g) => i.processBufferViewImage(g)).then((g) => {
+          f.bufferView = g;
         })
-      ) : p.toDataURL !== void 0 ? m.uri = p.toDataURL(s) : c.push(
-        kr(p, s).then(Cr).then((y) => {
-          m.uri = y;
+      ) : d.toDataURL !== void 0 ? f.uri = d.toDataURL(s) : c.push(
+        jr(d, s).then(kr).then((g) => {
+          f.uri = g;
         })
       );
-      const _ = a.images.push(m) - 1;
-      return u[h] = _, _;
+      const x = a.images.push(f) - 1;
+      return u[h] = x, x;
     } else
       throw new Error("THREE.GLTFExporter: No valid image data found. Unable to process texture.");
   }
@@ -663,7 +663,7 @@ class _c {
     const n = this.options, s = this.cache, i = this.json;
     if (s.textures.has(e))
       return s.textures.get(e);
-    i.textures || (i.textures = []), e instanceof ii && (e = ui(e, n.maxTextureSize));
+    i.textures || (i.textures = []), e instanceof ui && (e = gi(e, n.maxTextureSize));
     let r = e.userData.mimeType;
     r === "image/webp" && (r = "image/png");
     const a = {
@@ -691,7 +691,7 @@ class _c {
     const s = { pbrMetallicRoughness: {} };
     e.isMeshStandardMaterial !== !0 && e.isMeshBasicMaterial !== !0 && console.warn("GLTFExporter: Use MeshStandardMaterial or MeshBasicMaterial for best results.");
     const i = e.color.toArray().concat([e.opacity]);
-    if (ts(i, [1, 1, 1, 1]) || (s.pbrMetallicRoughness.baseColorFactor = i), e.isMeshStandardMaterial ? (s.pbrMetallicRoughness.metallicFactor = e.metalness, s.pbrMetallicRoughness.roughnessFactor = e.roughness) : (s.pbrMetallicRoughness.metallicFactor = 0.5, s.pbrMetallicRoughness.roughnessFactor = 0.5), e.metalnessMap || e.roughnessMap) {
+    if (ls(i, [1, 1, 1, 1]) || (s.pbrMetallicRoughness.baseColorFactor = i), e.isMeshStandardMaterial ? (s.pbrMetallicRoughness.metallicFactor = e.metalness, s.pbrMetallicRoughness.roughnessFactor = e.roughness) : (s.pbrMetallicRoughness.metallicFactor = 0.5, s.pbrMetallicRoughness.roughnessFactor = 0.5), e.metalnessMap || e.roughnessMap) {
       const a = this.buildMetalRoughTexture(e.metalnessMap, e.roughnessMap), l = {
         index: this.processTexture(a),
         channel: a.channel
@@ -729,7 +729,7 @@ class _c {
       };
       e.aoMapIntensity !== 1 && (a.strength = e.aoMapIntensity), this.applyTextureTransform(a, e.aoMap), s.occlusionTexture = a;
     }
-    e.transparent ? s.alphaMode = "BLEND" : e.alphaTest > 0 && (s.alphaMode = "MASK", s.alphaCutoff = e.alphaTest), e.side === wn && (s.doubleSided = !0), e.name !== "" && (s.name = e.name), this.serializeUserData(e, s), this._invokeAll(function(a) {
+    e.transparent ? s.alphaMode = "BLEND" : e.alphaTest > 0 && (s.alphaMode = "MASK", s.alphaCutoff = e.alphaTest), e.side === dn && (s.doubleSided = !0), e.name !== "" && (s.name = e.name), this.serializeUserData(e, s), this._invokeAll(function(a) {
       a.writeMaterial && a.writeMaterial(e, s);
     });
     const r = n.materials.push(s) - 1;
@@ -743,8 +743,8 @@ class _c {
   processMesh(e) {
     const t = this.cache, n = this.json, s = [e.geometry.uuid];
     if (Array.isArray(e.material))
-      for (let T = 0, g = e.material.length; T < g; T++)
-        s.push(e.material[T].uuid);
+      for (let _ = 0, w = e.material.length; _ < w; _++)
+        s.push(e.material[_].uuid);
     else
       s.push(e.material.uuid);
     const i = s.join(":");
@@ -752,9 +752,9 @@ class _c {
       return t.meshes.get(i);
     const r = e.geometry;
     let a;
-    e.isLineSegments ? a = Pe.LINES : e.isLineLoop ? a = Pe.LINE_LOOP : e.isLine ? a = Pe.LINE_STRIP : e.isPoints ? a = Pe.POINTS : a = e.material.wireframe ? Pe.LINES : Pe.TRIANGLES;
-    const l = {}, c = {}, u = [], h = [], m = {
-      ...da >= 152 ? {
+    e.isLineSegments ? a = Ce.LINES : e.isLineLoop ? a = Ce.LINE_LOOP : e.isLine ? a = Ce.LINE_STRIP : e.isPoints ? a = Ce.POINTS : a = e.material.wireframe ? Ce.LINES : Ce.TRIANGLES;
+    const l = {}, c = {}, u = [], h = [], f = {
+      ...xa >= 152 ? {
         uv: "TEXCOORD_0",
         uv1: "TEXCOORD_1",
         uv2: "TEXCOORD_2",
@@ -766,75 +766,75 @@ class _c {
       color: "COLOR_0",
       skinWeight: "WEIGHTS_0",
       skinIndex: "JOINTS_0"
-    }, p = r.getAttribute("normal");
-    p !== void 0 && !this.isNormalizedNormalAttribute(p) && (console.warn("THREE.GLTFExporter: Creating normalized normal attribute from the non-normalized one."), r.setAttribute("normal", this.createNormalizedNormalAttribute(p)));
-    let v = null;
-    for (let T in r.attributes) {
-      if (T.slice(0, 5) === "morph")
+    }, d = r.getAttribute("normal");
+    d !== void 0 && !this.isNormalizedNormalAttribute(d) && (console.warn("THREE.GLTFExporter: Creating normalized normal attribute from the non-normalized one."), r.setAttribute("normal", this.createNormalizedNormalAttribute(d)));
+    let y = null;
+    for (let _ in r.attributes) {
+      if (_.slice(0, 5) === "morph")
         continue;
-      const g = r.attributes[T];
-      if (T = m[T] || T.toUpperCase(), /^(POSITION|NORMAL|TANGENT|TEXCOORD_\d+|COLOR_\d+|JOINTS_\d+|WEIGHTS_\d+)$/.test(T) || (T = "_" + T), t.attributes.has(this.getUID(g))) {
-        c[T] = t.attributes.get(this.getUID(g));
+      const w = r.attributes[_];
+      if (_ = f[_] || _.toUpperCase(), /^(POSITION|NORMAL|TANGENT|TEXCOORD_\d+|COLOR_\d+|JOINTS_\d+|WEIGHTS_\d+)$/.test(_) || (_ = "_" + _), t.attributes.has(this.getUID(w))) {
+        c[_] = t.attributes.get(this.getUID(w));
         continue;
       }
-      v = null;
-      const x = g.array;
-      T === "JOINTS_0" && !(x instanceof Uint16Array) && !(x instanceof Uint8Array) && (console.warn('GLTFExporter: Attribute "skinIndex" converted to type UNSIGNED_SHORT.'), v = new pt(new Uint16Array(x), g.itemSize, g.normalized));
-      const M = this.processAccessor(v || g, r);
-      M !== null && (T.startsWith("_") || this.detectMeshQuantization(T, g), c[T] = M, t.attributes.set(this.getUID(g), M));
+      y = null;
+      const T = w.array;
+      _ === "JOINTS_0" && !(T instanceof Uint16Array) && !(T instanceof Uint8Array) && (console.warn('GLTFExporter: Attribute "skinIndex" converted to type UNSIGNED_SHORT.'), y = new pt(new Uint16Array(T), w.itemSize, w.normalized));
+      const E = this.processAccessor(y || w, r);
+      E !== null && (_.startsWith("_") || this.detectMeshQuantization(_, w), c[_] = E, t.attributes.set(this.getUID(w), E));
     }
-    if (p !== void 0 && r.setAttribute("normal", p), Object.keys(c).length === 0)
+    if (d !== void 0 && r.setAttribute("normal", d), Object.keys(c).length === 0)
       return null;
     if (e.morphTargetInfluences !== void 0 && e.morphTargetInfluences.length > 0) {
-      const T = [], g = [], A = {};
+      const _ = [], w = [], P = {};
       if (e.morphTargetDictionary !== void 0)
-        for (const x in e.morphTargetDictionary)
-          A[e.morphTargetDictionary[x]] = x;
-      for (let x = 0; x < e.morphTargetInfluences.length; ++x) {
-        const M = {};
-        let d = !1;
-        for (const w in r.morphAttributes) {
-          if (w !== "position" && w !== "normal") {
-            d || (console.warn("GLTFExporter: Only POSITION and NORMAL morph are supported."), d = !0);
+        for (const T in e.morphTargetDictionary)
+          P[e.morphTargetDictionary[T]] = T;
+      for (let T = 0; T < e.morphTargetInfluences.length; ++T) {
+        const E = {};
+        let m = !1;
+        for (const b in r.morphAttributes) {
+          if (b !== "position" && b !== "normal") {
+            m || (console.warn("GLTFExporter: Only POSITION and NORMAL morph are supported."), m = !0);
             continue;
           }
-          const f = r.morphAttributes[w][x], P = w.toUpperCase(), I = r.attributes[w];
-          if (t.attributes.has(this.getUID(f, !0))) {
-            M[P] = t.attributes.get(this.getUID(f, !0));
+          const p = r.morphAttributes[b][T], C = b.toUpperCase(), I = r.attributes[b];
+          if (t.attributes.has(this.getUID(p, !0))) {
+            E[C] = t.attributes.get(this.getUID(p, !0));
             continue;
           }
-          const K = f.clone();
+          const K = p.clone();
           if (!r.morphTargetsRelative)
-            for (let N = 0, Z = f.count; N < Z; N++)
-              for (let W = 0; W < f.itemSize; W++)
-                W === 0 && K.setX(N, f.getX(N) - I.getX(N)), W === 1 && K.setY(N, f.getY(N) - I.getY(N)), W === 2 && K.setZ(N, f.getZ(N) - I.getZ(N)), W === 3 && K.setW(N, f.getW(N) - I.getW(N));
-          M[P] = this.processAccessor(K, r), t.attributes.set(this.getUID(I, !0), M[P]);
+            for (let z = 0, Y = p.count; z < Y; z++)
+              for (let W = 0; W < p.itemSize; W++)
+                W === 0 && K.setX(z, p.getX(z) - I.getX(z)), W === 1 && K.setY(z, p.getY(z) - I.getY(z)), W === 2 && K.setZ(z, p.getZ(z) - I.getZ(z)), W === 3 && K.setW(z, p.getW(z) - I.getW(z));
+          E[C] = this.processAccessor(K, r), t.attributes.set(this.getUID(I, !0), E[C]);
         }
-        h.push(M), T.push(e.morphTargetInfluences[x]), e.morphTargetDictionary !== void 0 && g.push(A[x]);
+        h.push(E), _.push(e.morphTargetInfluences[T]), e.morphTargetDictionary !== void 0 && w.push(P[T]);
       }
-      l.weights = T, g.length > 0 && (l.extras = {}, l.extras.targetNames = g);
+      l.weights = _, w.length > 0 && (l.extras = {}, l.extras.targetNames = w);
     }
-    const _ = Array.isArray(e.material);
-    if (_ && r.groups.length === 0)
+    const x = Array.isArray(e.material);
+    if (x && r.groups.length === 0)
       return null;
-    const y = _ ? e.material : [e.material], E = _ ? r.groups : [{ materialIndex: 0, start: void 0, count: void 0 }];
-    for (let T = 0, g = E.length; T < g; T++) {
-      const A = {
+    const g = x ? e.material : [e.material], v = x ? r.groups : [{ materialIndex: 0, start: void 0, count: void 0 }];
+    for (let _ = 0, w = v.length; _ < w; _++) {
+      const P = {
         mode: a,
         attributes: c
       };
-      if (this.serializeUserData(r, A), h.length > 0 && (A.targets = h), r.index !== null) {
-        let M = this.getUID(r.index);
-        (E[T].start !== void 0 || E[T].count !== void 0) && (M += ":" + E[T].start + ":" + E[T].count), t.attributes.has(M) ? A.indices = t.attributes.get(M) : (A.indices = this.processAccessor(r.index, r, E[T].start, E[T].count), t.attributes.set(M, A.indices)), A.indices === null && delete A.indices;
+      if (this.serializeUserData(r, P), h.length > 0 && (P.targets = h), r.index !== null) {
+        let E = this.getUID(r.index);
+        (v[_].start !== void 0 || v[_].count !== void 0) && (E += ":" + v[_].start + ":" + v[_].count), t.attributes.has(E) ? P.indices = t.attributes.get(E) : (P.indices = this.processAccessor(r.index, r, v[_].start, v[_].count), t.attributes.set(E, P.indices)), P.indices === null && delete P.indices;
       }
-      const x = this.processMaterial(y[E[T].materialIndex]);
-      x !== null && (A.material = x), u.push(A);
+      const T = this.processMaterial(g[v[_].materialIndex]);
+      T !== null && (P.material = T), u.push(P);
     }
-    l.primitives = u, n.meshes || (n.meshes = []), this._invokeAll(function(T) {
-      T.writeMesh && T.writeMesh(e, l);
+    l.primitives = u, n.meshes || (n.meshes = []), this._invokeAll(function(_) {
+      _.writeMesh && _.writeMesh(e, l);
     });
-    const R = n.meshes.push(l) - 1;
-    return t.meshes.set(i, R), R;
+    const M = n.meshes.push(l) - 1;
+    return t.meshes.set(i, M), M;
   }
   /**
    * If a vertex attribute with a
@@ -848,7 +848,7 @@ class _c {
    * @param {THREE.BufferAttribute} attribute
    */
   detectMeshQuantization(e, t) {
-    if (this.extensionsUsed[hi])
+    if (this.extensionsUsed[vi])
       return;
     let n;
     switch (t.array.constructor) {
@@ -869,7 +869,7 @@ class _c {
     }
     t.normalized && (n += " normalized");
     const s = e.split("_", 1)[0];
-    Ir[s] && Ir[s].includes(n) && (this.extensionsUsed[hi] = !0, this.extensionsRequired[hi] = !0);
+    Br[s] && Br[s].includes(n) && (this.extensionsUsed[vi] = !0, this.extensionsRequired[vi] = !0);
   }
   /**
    * Process camera
@@ -889,7 +889,7 @@ class _c {
       znear: e.near < 0 ? 0 : e.near
     } : s.perspective = {
       aspectRatio: e.aspect,
-      yfov: We.degToRad(e.fov),
+      yfov: Ze.degToRad(e.fov),
       zfar: e.far <= 0 ? 1e-3 : e.far,
       znear: e.near < 0 ? 0 : e.near
     }, e.name !== "" && (s.name = e.type), t.cameras.push(s) - 1;
@@ -906,27 +906,27 @@ class _c {
    */
   processAnimation(e, t) {
     const n = this.json, s = this.nodeMap;
-    n.animations || (n.animations = []), e = hr.Utils.mergeMorphTargetTracks(e.clone(), t);
+    n.animations || (n.animations = []), e = vr.Utils.mergeMorphTargetTracks(e.clone(), t);
     const i = e.tracks, r = [], a = [];
     for (let l = 0; l < i.length; ++l) {
-      const c = i[l], u = Yt.parseTrackName(c.name);
-      let h = Yt.findNode(t, u.nodeName);
-      const m = Dr[u.propertyName];
-      if (u.objectName === "bones" && (h.isSkinnedMesh === !0 ? h = h.skeleton.getBoneByName(u.objectIndex) : h = void 0), !h || !m)
+      const c = i[l], u = Kt.parseTrackName(c.name);
+      let h = Kt.findNode(t, u.nodeName);
+      const f = Ur[u.propertyName];
+      if (u.objectName === "bones" && (h.isSkinnedMesh === !0 ? h = h.skeleton.getBoneByName(u.objectIndex) : h = void 0), !h || !f)
         return console.warn('THREE.GLTFExporter: Could not export animation track "%s".', c.name), null;
-      const p = 1;
-      let v = c.values.length / c.times.length;
-      m === Dr.morphTargetInfluences && (v /= h.morphTargetInfluences.length);
-      let _;
-      c.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline === !0 ? (_ = "CUBICSPLINE", v /= 3) : c.getInterpolation() === Bo ? _ = "STEP" : _ = "LINEAR", a.push({
-        input: this.processAccessor(new pt(c.times, p)),
-        output: this.processAccessor(new pt(c.values, v)),
-        interpolation: _
+      const d = 1;
+      let y = c.values.length / c.times.length;
+      f === Ur.morphTargetInfluences && (y /= h.morphTargetInfluences.length);
+      let x;
+      c.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline === !0 ? (x = "CUBICSPLINE", y /= 3) : c.getInterpolation() === Wo ? x = "STEP" : x = "LINEAR", a.push({
+        input: this.processAccessor(new pt(c.times, d)),
+        output: this.processAccessor(new pt(c.values, y)),
+        interpolation: x
       }), r.push({
         sampler: a.length - 1,
         target: {
           node: s.get(h),
-          path: m
+          path: f
         }
       });
     }
@@ -947,7 +947,7 @@ class _c {
     const r = e.skeleton.bones[0];
     if (r === void 0)
       return null;
-    const a = [], l = new Float32Array(i.bones.length * 16), c = new De();
+    const a = [], l = new Float32Array(i.bones.length * 16), c = new Pe();
     for (let h = 0; h < i.bones.length; ++h)
       a.push(n.get(i.bones[h])), c.copy(i.boneInverses[h]), c.multiply(e.bindMatrix).toArray(l, h * 16);
     return t.skins === void 0 && (t.skins = []), t.skins.push({
@@ -967,9 +967,9 @@ class _c {
     const i = {};
     if (n.trs) {
       const a = e.quaternion.toArray(), l = e.position.toArray(), c = e.scale.toArray();
-      ts(a, [0, 0, 0, 1]) || (i.rotation = a), ts(l, [0, 0, 0]) || (i.translation = l), ts(c, [1, 1, 1]) || (i.scale = c);
+      ls(a, [0, 0, 0, 1]) || (i.rotation = a), ls(l, [0, 0, 0]) || (i.translation = l), ls(c, [1, 1, 1]) || (i.scale = c);
     } else
-      e.matrixAutoUpdate && e.updateMatrix(), yc(e.matrix) === !1 && (i.matrix = e.matrix.elements);
+      e.matrixAutoUpdate && e.updateMatrix(), Sc(e.matrix) === !1 && (i.matrix = e.matrix.elements);
     if (e.name !== "" && (i.name = String(e.name)), this.serializeUserData(e, i), e.isMesh || e.isLine || e.isPoints) {
       const a = this.processMesh(e);
       a !== null && (i.mesh = a);
@@ -1016,7 +1016,7 @@ class _c {
    * @param  {Array} objects List of objects to process
    */
   processObjects(e) {
-    const t = new Xs();
+    const t = new fs();
     t.name = "AuxScene";
     for (let n = 0; n < e.length; n++)
       t.children.push(e[n]);
@@ -1032,7 +1032,7 @@ class _c {
     });
     const n = [];
     for (let s = 0; s < e.length; s++)
-      e[s] instanceof Xs ? this.processScene(e[s]) : n.push(e[s]);
+      e[s] instanceof fs ? this.processScene(e[s]) : n.push(e[s]);
     n.length > 0 && this.processObjects(n);
     for (let s = 0; s < this.skins.length; ++s)
       this.processSkin(this.skins[s]);
@@ -1047,7 +1047,7 @@ class _c {
       e(this.plugins[t]);
   }
 }
-class xc {
+class Pc {
   constructor(e) {
     this.writer = e, this.name = "KHR_lights_punctual";
   }
@@ -1068,7 +1068,7 @@ class xc {
     a.push(r), t.extensions = t.extensions || {}, t.extensions[this.name] = { light: a.length - 1 };
   }
 }
-let wc = class {
+let Cc = class {
   constructor(e) {
     this.writer = e, this.name = "KHR_materials_unlit";
   }
@@ -1078,7 +1078,7 @@ let wc = class {
     const s = this.writer.extensionsUsed;
     t.extensions = t.extensions || {}, t.extensions[this.name] = {}, s[this.name] = !0, t.pbrMetallicRoughness.metallicFactor = 0, t.pbrMetallicRoughness.roughnessFactor = 0.9;
   }
-}, Tc = class {
+}, Rc = class {
   constructor(e) {
     this.writer = e, this.name = "KHR_materials_clearcoat";
   }
@@ -1109,7 +1109,7 @@ let wc = class {
     }
     t.extensions = t.extensions || {}, t.extensions[this.name] = i, s[this.name] = !0;
   }
-}, bc = class {
+}, Ic = class {
   constructor(e) {
     this.writer = e, this.name = "KHR_materials_iridescence";
   }
@@ -1133,7 +1133,7 @@ let wc = class {
     }
     t.extensions = t.extensions || {}, t.extensions[this.name] = i, s[this.name] = !0;
   }
-}, Ec = class {
+}, Dc = class {
   constructor(e) {
     this.writer = e, this.name = "KHR_materials_transmission";
   }
@@ -1150,7 +1150,7 @@ let wc = class {
     }
     t.extensions = t.extensions || {}, t.extensions[this.name] = i, s[this.name] = !0;
   }
-}, Mc = class {
+}, Oc = class {
   constructor(e) {
     this.writer = e, this.name = "KHR_materials_volume";
   }
@@ -1167,7 +1167,7 @@ let wc = class {
     }
     i.attenuationDistance = e.attenuationDistance, i.attenuationColor = e.attenuationColor.toArray(), t.extensions = t.extensions || {}, t.extensions[this.name] = i, s[this.name] = !0;
   }
-}, Sc = class {
+}, Lc = class {
   constructor(e) {
     this.writer = e, this.name = "KHR_materials_ior";
   }
@@ -1177,12 +1177,12 @@ let wc = class {
     const s = this.writer.extensionsUsed, i = {};
     i.ior = e.ior, t.extensions = t.extensions || {}, t.extensions[this.name] = i, s[this.name] = !0;
   }
-}, Ac = class {
+}, Fc = class {
   constructor(e) {
     this.writer = e, this.name = "KHR_materials_specular";
   }
   writeMaterial(e, t) {
-    if (!e.isMeshPhysicalMaterial || e.specularIntensity === 1 && e.specularColor.equals(hc) && !e.specularIntensityMap && !e.specularColorTexture)
+    if (!e.isMeshPhysicalMaterial || e.specularIntensity === 1 && e.specularColor.equals(_c) && !e.specularIntensityMap && !e.specularColorTexture)
       return;
     const n = this.writer, s = n.extensionsUsed, i = {};
     if (e.specularIntensityMap) {
@@ -1201,7 +1201,7 @@ let wc = class {
     }
     i.specularFactor = e.specularIntensity, i.specularColorFactor = e.specularColor.toArray(), t.extensions = t.extensions || {}, t.extensions[this.name] = i, s[this.name] = !0;
   }
-}, Pc = class {
+}, kc = class {
   constructor(e) {
     this.writer = e, this.name = "KHR_materials_sheen";
   }
@@ -1225,7 +1225,7 @@ let wc = class {
     }
     i.sheenRoughnessFactor = e.sheenRoughness, i.sheenColorFactor = e.sheenColor.toArray(), t.extensions = t.extensions || {}, t.extensions[this.name] = i, s[this.name] = !0;
   }
-}, Rc = class {
+}, Bc = class {
   constructor(e) {
     this.writer = e, this.name = "KHR_materials_anisotropy";
   }
@@ -1239,7 +1239,7 @@ let wc = class {
     }
     i.anisotropyStrength = e.anisotropy, i.anisotropyRotation = e.anisotropyRotation, t.extensions = t.extensions || {}, t.extensions[this.name] = i, s[this.name] = !0;
   }
-}, Cc = class {
+}, Uc = class {
   constructor(e) {
     this.writer = e, this.name = "KHR_materials_emissive_strength";
   }
@@ -1250,7 +1250,7 @@ let wc = class {
     i.emissiveStrength = e.emissiveIntensity, t.extensions = t.extensions || {}, t.extensions[this.name] = i, s[this.name] = !0;
   }
 };
-var _t = Uint8Array, hn = Uint16Array, Zi = Uint32Array, ma = new _t([
+var xt = Uint8Array, fn = Uint16Array, er = Uint32Array, Ta = new xt([
   0,
   0,
   0,
@@ -1285,7 +1285,7 @@ var _t = Uint8Array, hn = Uint16Array, Zi = Uint32Array, ma = new _t([
   0,
   /* impossible */
   0
-]), ga = new _t([
+]), ba = new xt([
   0,
   0,
   0,
@@ -1319,128 +1319,128 @@ var _t = Uint8Array, hn = Uint16Array, Zi = Uint32Array, ma = new _t([
   /* unused */
   0,
   0
-]), Ic = new _t([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]), ya = function(o, e) {
-  for (var t = new hn(31), n = 0; n < 31; ++n)
+]), Nc = new xt([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]), Ea = function(o, e) {
+  for (var t = new fn(31), n = 0; n < 31; ++n)
     t[n] = e += 1 << o[n - 1];
-  for (var s = new Zi(t[30]), n = 1; n < 30; ++n)
+  for (var s = new er(t[30]), n = 1; n < 30; ++n)
     for (var i = t[n]; i < t[n + 1]; ++i)
       s[i] = i - t[n] << 5 | n;
   return [t, s];
-}, va = ya(ma, 2), _a = va[0], Dc = va[1];
-_a[28] = 258, Dc[258] = 28;
-var Lc = ya(ga, 0), Oc = Lc[0], Ki = new hn(32768);
-for (var Ge = 0; Ge < 32768; ++Ge) {
-  var qt = (Ge & 43690) >>> 1 | (Ge & 21845) << 1;
-  qt = (qt & 52428) >>> 2 | (qt & 13107) << 2, qt = (qt & 61680) >>> 4 | (qt & 3855) << 4, Ki[Ge] = ((qt & 65280) >>> 8 | (qt & 255) << 8) >>> 1;
+}, Sa = Ea(Ta, 2), Ma = Sa[0], zc = Sa[1];
+Ma[28] = 258, zc[258] = 28;
+var Hc = Ea(ba, 0), jc = Hc[0], tr = new fn(32768);
+for (var je = 0; je < 32768; ++je) {
+  var en = (je & 43690) >>> 1 | (je & 21845) << 1;
+  en = (en & 52428) >>> 2 | (en & 13107) << 2, en = (en & 61680) >>> 4 | (en & 3855) << 4, tr[je] = ((en & 65280) >>> 8 | (en & 255) << 8) >>> 1;
 }
-var ss = function(o, e, t) {
-  for (var n = o.length, s = 0, i = new hn(e); s < n; ++s)
+var us = function(o, e, t) {
+  for (var n = o.length, s = 0, i = new fn(e); s < n; ++s)
     ++i[o[s] - 1];
-  var r = new hn(e);
+  var r = new fn(e);
   for (s = 0; s < e; ++s)
     r[s] = r[s - 1] + i[s - 1] << 1;
   var a;
   if (t) {
-    a = new hn(1 << e);
+    a = new fn(1 << e);
     var l = 15 - e;
     for (s = 0; s < n; ++s)
       if (o[s])
-        for (var c = s << 4 | o[s], u = e - o[s], h = r[o[s] - 1]++ << u, m = h | (1 << u) - 1; h <= m; ++h)
-          a[Ki[h] >>> l] = c;
+        for (var c = s << 4 | o[s], u = e - o[s], h = r[o[s] - 1]++ << u, f = h | (1 << u) - 1; h <= f; ++h)
+          a[tr[h] >>> l] = c;
   } else
-    for (a = new hn(n), s = 0; s < n; ++s)
-      o[s] && (a[s] = Ki[r[o[s] - 1]++] >>> 15 - o[s]);
+    for (a = new fn(n), s = 0; s < n; ++s)
+      o[s] && (a[s] = tr[r[o[s] - 1]++] >>> 15 - o[s]);
   return a;
-}, ms = new _t(288);
-for (var Ge = 0; Ge < 144; ++Ge)
-  ms[Ge] = 8;
-for (var Ge = 144; Ge < 256; ++Ge)
-  ms[Ge] = 9;
-for (var Ge = 256; Ge < 280; ++Ge)
-  ms[Ge] = 7;
-for (var Ge = 280; Ge < 288; ++Ge)
-  ms[Ge] = 8;
-var xa = new _t(32);
-for (var Ge = 0; Ge < 32; ++Ge)
-  xa[Ge] = 5;
-var Fc = /* @__PURE__ */ ss(ms, 9, 1), kc = /* @__PURE__ */ ss(xa, 5, 1), di = function(o) {
+}, Ts = new xt(288);
+for (var je = 0; je < 144; ++je)
+  Ts[je] = 8;
+for (var je = 144; je < 256; ++je)
+  Ts[je] = 9;
+for (var je = 256; je < 280; ++je)
+  Ts[je] = 7;
+for (var je = 280; je < 288; ++je)
+  Ts[je] = 8;
+var Aa = new xt(32);
+for (var je = 0; je < 32; ++je)
+  Aa[je] = 5;
+var Gc = /* @__PURE__ */ us(Ts, 9, 1), Vc = /* @__PURE__ */ us(Aa, 5, 1), _i = function(o) {
   for (var e = o[0], t = 1; t < o.length; ++t)
     o[t] > e && (e = o[t]);
   return e;
-}, wt = function(o, e, t) {
+}, Et = function(o, e, t) {
   var n = e / 8 | 0;
   return (o[n] | o[n + 1] << 8) >> (e & 7) & t;
-}, pi = function(o, e) {
+}, xi = function(o, e) {
   var t = e / 8 | 0;
   return (o[t] | o[t + 1] << 8 | o[t + 2] << 16) >> (e & 7);
-}, Uc = function(o) {
+}, Wc = function(o) {
   return (o / 8 | 0) + (o & 7 && 1);
-}, Bc = function(o, e, t) {
+}, Yc = function(o, e, t) {
   (e == null || e < 0) && (e = 0), (t == null || t > o.length) && (t = o.length);
-  var n = new (o instanceof hn ? hn : o instanceof Zi ? Zi : _t)(t - e);
+  var n = new (o instanceof fn ? fn : o instanceof er ? er : xt)(t - e);
   return n.set(o.subarray(e, t)), n;
-}, Nc = function(o, e, t) {
+}, Xc = function(o, e, t) {
   var n = o.length;
   if (!n || t && !t.l && n < 5)
-    return e || new _t(0);
+    return e || new xt(0);
   var s = !e || t, i = !t || t.i;
-  t || (t = {}), e || (e = new _t(n * 3));
-  var r = function(J) {
+  t || (t = {}), e || (e = new xt(n * 3));
+  var r = function(ee) {
     var F = e.length;
-    if (J > F) {
-      var B = new _t(Math.max(F * 2, J));
-      B.set(e), e = B;
+    if (ee > F) {
+      var N = new xt(Math.max(F * 2, ee));
+      N.set(e), e = N;
     }
-  }, a = t.f || 0, l = t.p || 0, c = t.b || 0, u = t.l, h = t.d, m = t.m, p = t.n, v = n * 8;
+  }, a = t.f || 0, l = t.p || 0, c = t.b || 0, u = t.l, h = t.d, f = t.m, d = t.n, y = n * 8;
   do {
     if (!u) {
-      t.f = a = wt(o, l, 1);
-      var _ = wt(o, l + 1, 3);
-      if (l += 3, _)
-        if (_ == 1)
-          u = Fc, h = kc, m = 9, p = 5;
-        else if (_ == 2) {
-          var T = wt(o, l, 31) + 257, g = wt(o, l + 10, 15) + 4, A = T + wt(o, l + 5, 31) + 1;
+      t.f = a = Et(o, l, 1);
+      var x = Et(o, l + 1, 3);
+      if (l += 3, x)
+        if (x == 1)
+          u = Gc, h = Vc, f = 9, d = 5;
+        else if (x == 2) {
+          var _ = Et(o, l, 31) + 257, w = Et(o, l + 10, 15) + 4, P = _ + Et(o, l + 5, 31) + 1;
           l += 14;
-          for (var x = new _t(A), M = new _t(19), d = 0; d < g; ++d)
-            M[Ic[d]] = wt(o, l + d * 3, 7);
-          l += g * 3;
-          for (var w = di(M), f = (1 << w) - 1, P = ss(M, w, 1), d = 0; d < A; ) {
-            var I = P[wt(o, l, f)];
+          for (var T = new xt(P), E = new xt(19), m = 0; m < w; ++m)
+            E[Nc[m]] = Et(o, l + m * 3, 7);
+          l += w * 3;
+          for (var b = _i(E), p = (1 << b) - 1, C = us(E, b, 1), m = 0; m < P; ) {
+            var I = C[Et(o, l, p)];
             l += I & 15;
-            var y = I >>> 4;
-            if (y < 16)
-              x[d++] = y;
+            var g = I >>> 4;
+            if (g < 16)
+              T[m++] = g;
             else {
-              var K = 0, N = 0;
-              for (y == 16 ? (N = 3 + wt(o, l, 3), l += 2, K = x[d - 1]) : y == 17 ? (N = 3 + wt(o, l, 7), l += 3) : y == 18 && (N = 11 + wt(o, l, 127), l += 7); N--; )
-                x[d++] = K;
+              var K = 0, z = 0;
+              for (g == 16 ? (z = 3 + Et(o, l, 3), l += 2, K = T[m - 1]) : g == 17 ? (z = 3 + Et(o, l, 7), l += 3) : g == 18 && (z = 11 + Et(o, l, 127), l += 7); z--; )
+                T[m++] = K;
             }
           }
-          var Z = x.subarray(0, T), W = x.subarray(T);
-          m = di(Z), p = di(W), u = ss(Z, m, 1), h = ss(W, p, 1);
+          var Y = T.subarray(0, _), W = T.subarray(_);
+          f = _i(Y), d = _i(W), u = us(Y, f, 1), h = us(W, d, 1);
         } else
           throw "invalid block type";
       else {
-        var y = Uc(l) + 4, E = o[y - 4] | o[y - 3] << 8, R = y + E;
-        if (R > n) {
+        var g = Wc(l) + 4, v = o[g - 4] | o[g - 3] << 8, M = g + v;
+        if (M > n) {
           if (i)
             throw "unexpected EOF";
           break;
         }
-        s && r(c + E), e.set(o.subarray(y, R), c), t.b = c += E, t.p = l = R * 8;
+        s && r(c + v), e.set(o.subarray(g, M), c), t.b = c += v, t.p = l = M * 8;
         continue;
       }
-      if (l > v) {
+      if (l > y) {
         if (i)
           throw "unexpected EOF";
         break;
       }
     }
     s && r(c + 131072);
-    for (var X = (1 << m) - 1, V = (1 << p) - 1, ne = l; ; ne = l) {
-      var K = u[pi(o, l) & X], se = K >>> 4;
-      if (l += K & 15, l > v) {
+    for (var X = (1 << f) - 1, V = (1 << d) - 1, te = l; ; te = l) {
+      var K = u[xi(o, l) & X], se = K >>> 4;
+      if (l += K & 15, l > y) {
         if (i)
           throw "unexpected EOF";
         break;
@@ -1450,53 +1450,53 @@ var Fc = /* @__PURE__ */ ss(ms, 9, 1), kc = /* @__PURE__ */ ss(xa, 5, 1), di = f
       if (se < 256)
         e[c++] = se;
       else if (se == 256) {
-        ne = l, u = null;
+        te = l, u = null;
         break;
       } else {
-        var he = se - 254;
+        var fe = se - 254;
         if (se > 264) {
-          var d = se - 257, H = ma[d];
-          he = wt(o, l, (1 << H) - 1) + _a[d], l += H;
+          var m = se - 257, H = Ta[m];
+          fe = Et(o, l, (1 << H) - 1) + Ma[m], l += H;
         }
-        var k = h[pi(o, l) & V], b = k >>> 4;
+        var k = h[xi(o, l) & V], S = k >>> 4;
         if (!k)
           throw "invalid distance";
         l += k & 15;
-        var W = Oc[b];
-        if (b > 3) {
-          var H = ga[b];
-          W += pi(o, l) & (1 << H) - 1, l += H;
+        var W = jc[S];
+        if (S > 3) {
+          var H = ba[S];
+          W += xi(o, l) & (1 << H) - 1, l += H;
         }
-        if (l > v) {
+        if (l > y) {
           if (i)
             throw "unexpected EOF";
           break;
         }
         s && r(c + 131072);
-        for (var U = c + he; c < U; c += 4)
+        for (var U = c + fe; c < U; c += 4)
           e[c] = e[c - W], e[c + 1] = e[c + 1 - W], e[c + 2] = e[c + 2 - W], e[c + 3] = e[c + 3 - W];
         c = U;
       }
     }
-    t.l = u, t.p = ne, t.b = c, u && (a = 1, t.m = m, t.d = h, t.n = p);
+    t.l = u, t.p = te, t.b = c, u && (a = 1, t.m = f, t.d = h, t.n = d);
   } while (!a);
-  return c == e.length ? e : Bc(e, 0, c);
-}, zc = /* @__PURE__ */ new _t(0), Hc = function(o) {
+  return c == e.length ? e : Yc(e, 0, c);
+}, $c = /* @__PURE__ */ new xt(0), Zc = function(o) {
   if ((o[0] & 15) != 8 || o[0] >>> 4 > 7 || (o[0] << 8 | o[1]) % 31)
     throw "invalid zlib data";
   if (o[1] & 32)
     throw "invalid zlib data: preset dictionaries not supported";
 };
-function Gc(o, e) {
-  return Nc((Hc(o), o.subarray(2, -4)), e);
+function Kc(o, e) {
+  return Xc((Zc(o), o.subarray(2, -4)), e);
 }
-var jc = typeof TextDecoder < "u" && /* @__PURE__ */ new TextDecoder(), Vc = 0;
+var qc = typeof TextDecoder < "u" && /* @__PURE__ */ new TextDecoder(), Qc = 0;
 try {
-  jc.decode(zc, { stream: !0 }), Vc = 1;
+  qc.decode($c, { stream: !0 }), Qc = 1;
 } catch {
 }
-const Je = new cl(), Ss = new ee();
-class Yc {
+const Je = new gl(), Os = new q();
+class Jc {
   constructor(e) {
     let t = e.geometry;
     t.index && (console.warn("THREE.MeshSurfaceSampler: Converting geometry to non-indexed BufferGeometry."), t = t.toNonIndexed()), this.geometry = t, this.randomFunction = Math.random, this.positionAttribute = this.geometry.getAttribute("position"), this.colorAttribute = this.geometry.getAttribute("color"), this.weightAttribute = null, this.distribution = null;
@@ -1542,31 +1542,31 @@ class Yc {
   }
   sampleFace(e, t, n, s) {
     let i = this.randomFunction(), r = this.randomFunction();
-    return i + r > 1 && (i = 1 - i, r = 1 - r), Je.a.fromBufferAttribute(this.positionAttribute, e * 3), Je.b.fromBufferAttribute(this.positionAttribute, e * 3 + 1), Je.c.fromBufferAttribute(this.positionAttribute, e * 3 + 2), t.set(0, 0, 0).addScaledVector(Je.a, i).addScaledVector(Je.b, r).addScaledVector(Je.c, 1 - (i + r)), n !== void 0 && Je.getNormal(n), s !== void 0 && this.colorAttribute !== void 0 && (Je.a.fromBufferAttribute(this.colorAttribute, e * 3), Je.b.fromBufferAttribute(this.colorAttribute, e * 3 + 1), Je.c.fromBufferAttribute(this.colorAttribute, e * 3 + 2), Ss.set(0, 0, 0).addScaledVector(Je.a, i).addScaledVector(Je.b, r).addScaledVector(Je.c, 1 - (i + r)), s.r = Ss.x, s.g = Ss.y, s.b = Ss.z), this;
+    return i + r > 1 && (i = 1 - i, r = 1 - r), Je.a.fromBufferAttribute(this.positionAttribute, e * 3), Je.b.fromBufferAttribute(this.positionAttribute, e * 3 + 1), Je.c.fromBufferAttribute(this.positionAttribute, e * 3 + 2), t.set(0, 0, 0).addScaledVector(Je.a, i).addScaledVector(Je.b, r).addScaledVector(Je.c, 1 - (i + r)), n !== void 0 && Je.getNormal(n), s !== void 0 && this.colorAttribute !== void 0 && (Je.a.fromBufferAttribute(this.colorAttribute, e * 3), Je.b.fromBufferAttribute(this.colorAttribute, e * 3 + 1), Je.c.fromBufferAttribute(this.colorAttribute, e * 3 + 2), Os.set(0, 0, 0).addScaledVector(Je.a, i).addScaledVector(Je.b, r).addScaledVector(Je.c, 1 - (i + r)), s.r = Os.x, s.g = Os.y, s.b = Os.z), this;
   }
 }
-var Xc = Object.defineProperty, Wc = (o, e, t) => e in o ? Xc(o, e, { enumerable: !0, configurable: !0, writable: !0, value: t }) : o[e] = t, q = (o, e, t) => (Wc(o, typeof e != "symbol" ? e + "" : e, t), t);
-class $c extends St {
+var eu = Object.defineProperty, tu = (o, e, t) => e in o ? eu(o, e, { enumerable: !0, configurable: !0, writable: !0, value: t }) : o[e] = t, Q = (o, e, t) => (tu(o, typeof e != "symbol" ? e + "" : e, t), t);
+class nu extends Tt {
   constructor(e, t) {
-    super(), q(this, "isTransformControls", !0), q(this, "visible", !1), q(this, "domElement"), q(this, "raycaster", new Vo()), q(this, "gizmo"), q(this, "plane"), q(this, "tempVector", new ee()), q(this, "tempVector2", new ee()), q(this, "tempQuaternion", new He()), q(this, "unit", {
-      X: new ee(1, 0, 0),
-      Y: new ee(0, 1, 0),
-      Z: new ee(0, 0, 1)
-    }), q(this, "pointStart", new ee()), q(this, "pointEnd", new ee()), q(this, "offset", new ee()), q(this, "rotationAxis", new ee()), q(this, "startNorm", new ee()), q(this, "endNorm", new ee()), q(this, "rotationAngle", 0), q(this, "cameraPosition", new ee()), q(this, "cameraQuaternion", new He()), q(this, "cameraScale", new ee()), q(this, "parentPosition", new ee()), q(this, "parentQuaternion", new He()), q(this, "parentQuaternionInv", new He()), q(this, "parentScale", new ee()), q(this, "worldPositionStart", new ee()), q(this, "worldQuaternionStart", new He()), q(this, "worldScaleStart", new ee()), q(this, "worldPosition", new ee()), q(this, "worldQuaternion", new He()), q(this, "worldQuaternionInv", new He()), q(this, "worldScale", new ee()), q(this, "eye", new ee()), q(this, "positionStart", new ee()), q(this, "quaternionStart", new He()), q(this, "scaleStart", new ee()), q(this, "camera"), q(this, "object"), q(this, "enabled", !0), q(this, "axis", null), q(this, "mode", "translate"), q(this, "translationSnap", null), q(this, "rotationSnap", null), q(this, "scaleSnap", null), q(this, "space", "world"), q(this, "size", 1), q(this, "dragging", !1), q(this, "showX", !0), q(this, "showY", !0), q(this, "showZ", !0), q(this, "changeEvent", { type: "change" }), q(this, "mouseDownEvent", { type: "mouseDown", mode: this.mode }), q(this, "mouseUpEvent", { type: "mouseUp", mode: this.mode }), q(this, "objectChangeEvent", { type: "objectChange" }), q(this, "intersectObjectWithRay", (s, i, r) => {
+    super(), Q(this, "isTransformControls", !0), Q(this, "visible", !1), Q(this, "domElement"), Q(this, "raycaster", new qo()), Q(this, "gizmo"), Q(this, "plane"), Q(this, "tempVector", new q()), Q(this, "tempVector2", new q()), Q(this, "tempQuaternion", new He()), Q(this, "unit", {
+      X: new q(1, 0, 0),
+      Y: new q(0, 1, 0),
+      Z: new q(0, 0, 1)
+    }), Q(this, "pointStart", new q()), Q(this, "pointEnd", new q()), Q(this, "offset", new q()), Q(this, "rotationAxis", new q()), Q(this, "startNorm", new q()), Q(this, "endNorm", new q()), Q(this, "rotationAngle", 0), Q(this, "cameraPosition", new q()), Q(this, "cameraQuaternion", new He()), Q(this, "cameraScale", new q()), Q(this, "parentPosition", new q()), Q(this, "parentQuaternion", new He()), Q(this, "parentQuaternionInv", new He()), Q(this, "parentScale", new q()), Q(this, "worldPositionStart", new q()), Q(this, "worldQuaternionStart", new He()), Q(this, "worldScaleStart", new q()), Q(this, "worldPosition", new q()), Q(this, "worldQuaternion", new He()), Q(this, "worldQuaternionInv", new He()), Q(this, "worldScale", new q()), Q(this, "eye", new q()), Q(this, "positionStart", new q()), Q(this, "quaternionStart", new He()), Q(this, "scaleStart", new q()), Q(this, "camera"), Q(this, "object"), Q(this, "enabled", !0), Q(this, "axis", null), Q(this, "mode", "translate"), Q(this, "translationSnap", null), Q(this, "rotationSnap", null), Q(this, "scaleSnap", null), Q(this, "space", "world"), Q(this, "size", 1), Q(this, "dragging", !1), Q(this, "showX", !0), Q(this, "showY", !0), Q(this, "showZ", !0), Q(this, "changeEvent", { type: "change" }), Q(this, "mouseDownEvent", { type: "mouseDown", mode: this.mode }), Q(this, "mouseUpEvent", { type: "mouseUp", mode: this.mode }), Q(this, "objectChangeEvent", { type: "objectChange" }), Q(this, "intersectObjectWithRay", (s, i, r) => {
       const a = i.intersectObject(s, !0);
       for (let l = 0; l < a.length; l++)
         if (a[l].object.visible || r)
           return a[l];
       return !1;
-    }), q(this, "attach", (s) => (this.object = s, this.visible = !0, this)), q(this, "detach", () => (this.object = void 0, this.visible = !1, this.axis = null, this)), q(this, "reset", () => this.enabled ? (this.dragging && this.object !== void 0 && (this.object.position.copy(this.positionStart), this.object.quaternion.copy(this.quaternionStart), this.object.scale.copy(this.scaleStart), this.dispatchEvent(this.changeEvent), this.dispatchEvent(this.objectChangeEvent), this.pointStart.copy(this.pointEnd)), this) : this), q(this, "updateMatrixWorld", () => {
+    }), Q(this, "attach", (s) => (this.object = s, this.visible = !0, this)), Q(this, "detach", () => (this.object = void 0, this.visible = !1, this.axis = null, this)), Q(this, "reset", () => this.enabled ? (this.dragging && this.object !== void 0 && (this.object.position.copy(this.positionStart), this.object.quaternion.copy(this.quaternionStart), this.object.scale.copy(this.scaleStart), this.dispatchEvent(this.changeEvent), this.dispatchEvent(this.objectChangeEvent), this.pointStart.copy(this.pointEnd)), this) : this), Q(this, "updateMatrixWorld", () => {
       this.object !== void 0 && (this.object.updateMatrixWorld(), this.object.parent === null ? console.error("TransformControls: The attached 3D object must be a part of the scene graph.") : this.object.parent.matrixWorld.decompose(this.parentPosition, this.parentQuaternion, this.parentScale), this.object.matrixWorld.decompose(this.worldPosition, this.worldQuaternion, this.worldScale), this.parentQuaternionInv.copy(this.parentQuaternion).invert(), this.worldQuaternionInv.copy(this.worldQuaternion).invert()), this.camera.updateMatrixWorld(), this.camera.matrixWorld.decompose(this.cameraPosition, this.cameraQuaternion, this.cameraScale), this.eye.copy(this.cameraPosition).sub(this.worldPosition).normalize(), super.updateMatrixWorld();
-    }), q(this, "pointerHover", (s) => {
+    }), Q(this, "pointerHover", (s) => {
       if (this.object === void 0 || this.dragging === !0)
         return;
       this.raycaster.setFromCamera(s, this.camera);
       const i = this.intersectObjectWithRay(this.gizmo.picker[this.mode], this.raycaster);
       i ? this.axis = i.object.name : this.axis = null;
-    }), q(this, "pointerDown", (s) => {
+    }), Q(this, "pointerDown", (s) => {
       if (!(this.object === void 0 || this.dragging === !0 || s.button !== 0) && this.axis !== null) {
         this.raycaster.setFromCamera(s, this.camera);
         const i = this.intersectObjectWithRay(this.plane, this.raycaster, !0);
@@ -1580,7 +1580,7 @@ class $c extends St {
         }
         this.dragging = !0, this.mouseDownEvent.mode = this.mode, this.dispatchEvent(this.mouseDownEvent);
       }
-    }), q(this, "pointerMove", (s) => {
+    }), Q(this, "pointerMove", (s) => {
       const i = this.axis, r = this.mode, a = this.object;
       let l = this.space;
       if (r === "scale" ? l = "local" : (i === "E" || i === "XYZE" || i === "XYZ") && (l = "world"), a === void 0 || i === null || this.dragging === !1 || s.button !== -1)
@@ -1604,9 +1604,9 @@ class $c extends St {
         }
         this.dispatchEvent(this.changeEvent), this.dispatchEvent(this.objectChangeEvent);
       }
-    }), q(this, "pointerUp", (s) => {
+    }), Q(this, "pointerUp", (s) => {
       s.button === 0 && (this.dragging && this.axis !== null && (this.mouseUpEvent.mode = this.mode, this.dispatchEvent(this.mouseUpEvent)), this.dragging = !1, this.axis = null);
-    }), q(this, "getPointer", (s) => {
+    }), Q(this, "getPointer", (s) => {
       var i;
       if (this.domElement && ((i = this.domElement.ownerDocument) != null && i.pointerLockElement))
         return {
@@ -1622,7 +1622,7 @@ class $c extends St {
           button: s.button
         };
       }
-    }), q(this, "onPointerHover", (s) => {
+    }), Q(this, "onPointerHover", (s) => {
       if (this.enabled)
         switch (s.pointerType) {
           case "mouse":
@@ -1630,39 +1630,39 @@ class $c extends St {
             this.pointerHover(this.getPointer(s));
             break;
         }
-    }), q(this, "onPointerDown", (s) => {
+    }), Q(this, "onPointerDown", (s) => {
       !this.enabled || !this.domElement || (this.domElement.style.touchAction = "none", this.domElement.ownerDocument.addEventListener("pointermove", this.onPointerMove), this.pointerHover(this.getPointer(s)), this.pointerDown(this.getPointer(s)));
-    }), q(this, "onPointerMove", (s) => {
+    }), Q(this, "onPointerMove", (s) => {
       this.enabled && this.pointerMove(this.getPointer(s));
-    }), q(this, "onPointerUp", (s) => {
+    }), Q(this, "onPointerUp", (s) => {
       !this.enabled || !this.domElement || (this.domElement.style.touchAction = "", this.domElement.ownerDocument.removeEventListener("pointermove", this.onPointerMove), this.pointerUp(this.getPointer(s)));
-    }), q(this, "getMode", () => this.mode), q(this, "setMode", (s) => {
+    }), Q(this, "getMode", () => this.mode), Q(this, "setMode", (s) => {
       this.mode = s;
-    }), q(this, "setTranslationSnap", (s) => {
+    }), Q(this, "setTranslationSnap", (s) => {
       this.translationSnap = s;
-    }), q(this, "setRotationSnap", (s) => {
+    }), Q(this, "setRotationSnap", (s) => {
       this.rotationSnap = s;
-    }), q(this, "setScaleSnap", (s) => {
+    }), Q(this, "setScaleSnap", (s) => {
       this.scaleSnap = s;
-    }), q(this, "setSize", (s) => {
+    }), Q(this, "setSize", (s) => {
       this.size = s;
-    }), q(this, "setSpace", (s) => {
+    }), Q(this, "setSpace", (s) => {
       this.space = s;
-    }), q(this, "update", () => {
+    }), Q(this, "update", () => {
       console.warn(
         "THREE.TransformControls: update function has no more functionality and therefore has been deprecated."
       );
-    }), q(this, "connect", (s) => {
+    }), Q(this, "connect", (s) => {
       s === document && console.error(
         'THREE.OrbitControls: "document" should not be used as the target "domElement". Please use "renderer.domElement" instead.'
       ), this.domElement = s, this.domElement.addEventListener("pointerdown", this.onPointerDown), this.domElement.addEventListener("pointermove", this.onPointerHover), this.domElement.ownerDocument.addEventListener("pointerup", this.onPointerUp);
-    }), q(this, "dispose", () => {
+    }), Q(this, "dispose", () => {
       var s, i, r, a, l, c;
       (s = this.domElement) == null || s.removeEventListener("pointerdown", this.onPointerDown), (i = this.domElement) == null || i.removeEventListener("pointermove", this.onPointerHover), (a = (r = this.domElement) == null ? void 0 : r.ownerDocument) == null || a.removeEventListener("pointermove", this.onPointerMove), (c = (l = this.domElement) == null ? void 0 : l.ownerDocument) == null || c.removeEventListener("pointerup", this.onPointerUp), this.traverse((u) => {
         const h = u;
         h.geometry && h.geometry.dispose(), h.material && h.material.dispose();
       });
-    }), this.domElement = t, this.camera = e, this.gizmo = new Zc(), this.add(this.gizmo), this.plane = new Kc(), this.add(this.plane);
+    }), this.domElement = t, this.camera = e, this.gizmo = new su(), this.add(this.gizmo), this.plane = new iu(), this.add(this.plane);
     const n = (s, i) => {
       let r = i;
       Object.defineProperty(this, s, {
@@ -1677,39 +1677,39 @@ class $c extends St {
     n("camera", this.camera), n("object", this.object), n("enabled", this.enabled), n("axis", this.axis), n("mode", this.mode), n("translationSnap", this.translationSnap), n("rotationSnap", this.rotationSnap), n("scaleSnap", this.scaleSnap), n("space", this.space), n("size", this.size), n("dragging", this.dragging), n("showX", this.showX), n("showY", this.showY), n("showZ", this.showZ), n("worldPosition", this.worldPosition), n("worldPositionStart", this.worldPositionStart), n("worldQuaternion", this.worldQuaternion), n("worldQuaternionStart", this.worldQuaternionStart), n("cameraPosition", this.cameraPosition), n("cameraQuaternion", this.cameraQuaternion), n("pointStart", this.pointStart), n("pointEnd", this.pointEnd), n("rotationAxis", this.rotationAxis), n("rotationAngle", this.rotationAngle), n("eye", this.eye), t !== void 0 && this.connect(t);
   }
 }
-class Zc extends St {
+class su extends Tt {
   constructor() {
-    super(), q(this, "isTransformControlsGizmo", !0), q(this, "type", "TransformControlsGizmo"), q(this, "tempVector", new ee(0, 0, 0)), q(this, "tempEuler", new _n()), q(this, "alignVector", new ee(0, 1, 0)), q(this, "zeroVector", new ee(0, 0, 0)), q(this, "lookAtMatrix", new De()), q(this, "tempQuaternion", new He()), q(this, "tempQuaternion2", new He()), q(this, "identityQuaternion", new He()), q(this, "unitX", new ee(1, 0, 0)), q(this, "unitY", new ee(0, 1, 0)), q(this, "unitZ", new ee(0, 0, 1)), q(this, "gizmo"), q(this, "picker"), q(this, "helper"), q(this, "rotationAxis", new ee()), q(this, "cameraPosition", new ee()), q(this, "worldPositionStart", new ee()), q(this, "worldQuaternionStart", new He()), q(this, "worldPosition", new ee()), q(this, "worldQuaternion", new He()), q(this, "eye", new ee()), q(this, "camera", null), q(this, "enabled", !0), q(this, "axis", null), q(this, "mode", "translate"), q(this, "space", "world"), q(this, "size", 1), q(this, "dragging", !1), q(this, "showX", !0), q(this, "showY", !0), q(this, "showZ", !0), q(this, "updateMatrixWorld", () => {
+    super(), Q(this, "isTransformControlsGizmo", !0), Q(this, "type", "TransformControlsGizmo"), Q(this, "tempVector", new q(0, 0, 0)), Q(this, "tempEuler", new Tn()), Q(this, "alignVector", new q(0, 1, 0)), Q(this, "zeroVector", new q(0, 0, 0)), Q(this, "lookAtMatrix", new Pe()), Q(this, "tempQuaternion", new He()), Q(this, "tempQuaternion2", new He()), Q(this, "identityQuaternion", new He()), Q(this, "unitX", new q(1, 0, 0)), Q(this, "unitY", new q(0, 1, 0)), Q(this, "unitZ", new q(0, 0, 1)), Q(this, "gizmo"), Q(this, "picker"), Q(this, "helper"), Q(this, "rotationAxis", new q()), Q(this, "cameraPosition", new q()), Q(this, "worldPositionStart", new q()), Q(this, "worldQuaternionStart", new He()), Q(this, "worldPosition", new q()), Q(this, "worldQuaternion", new He()), Q(this, "eye", new q()), Q(this, "camera", null), Q(this, "enabled", !0), Q(this, "axis", null), Q(this, "mode", "translate"), Q(this, "space", "world"), Q(this, "size", 1), Q(this, "dragging", !1), Q(this, "showX", !0), Q(this, "showY", !0), Q(this, "showZ", !0), Q(this, "updateMatrixWorld", () => {
       let se = this.space;
       this.mode === "scale" && (se = "local");
-      const he = se === "local" ? this.worldQuaternion : this.identityQuaternion;
+      const fe = se === "local" ? this.worldQuaternion : this.identityQuaternion;
       this.gizmo.translate.visible = this.mode === "translate", this.gizmo.rotate.visible = this.mode === "rotate", this.gizmo.scale.visible = this.mode === "scale", this.helper.translate.visible = this.mode === "translate", this.helper.rotate.visible = this.mode === "rotate", this.helper.scale.visible = this.mode === "scale";
       let H = [];
       H = H.concat(this.picker[this.mode].children), H = H.concat(this.gizmo[this.mode].children), H = H.concat(this.helper[this.mode].children);
       for (let k = 0; k < H.length; k++) {
-        const b = H[k];
-        b.visible = !0, b.rotation.set(0, 0, 0), b.position.copy(this.worldPosition);
+        const S = H[k];
+        S.visible = !0, S.rotation.set(0, 0, 0), S.position.copy(this.worldPosition);
         let U;
-        if (this.camera.isOrthographicCamera ? U = (this.camera.top - this.camera.bottom) / this.camera.zoom : U = this.worldPosition.distanceTo(this.cameraPosition) * Math.min(1.9 * Math.tan(Math.PI * this.camera.fov / 360) / this.camera.zoom, 7), b.scale.set(1, 1, 1).multiplyScalar(U * this.size / 7), b.tag === "helper") {
-          b.visible = !1, b.name === "AXIS" ? (b.position.copy(this.worldPositionStart), b.visible = !!this.axis, this.axis === "X" && (this.tempQuaternion.setFromEuler(this.tempEuler.set(0, 0, 0)), b.quaternion.copy(he).multiply(this.tempQuaternion), Math.abs(this.alignVector.copy(this.unitX).applyQuaternion(he).dot(this.eye)) > 0.9 && (b.visible = !1)), this.axis === "Y" && (this.tempQuaternion.setFromEuler(this.tempEuler.set(0, 0, Math.PI / 2)), b.quaternion.copy(he).multiply(this.tempQuaternion), Math.abs(this.alignVector.copy(this.unitY).applyQuaternion(he).dot(this.eye)) > 0.9 && (b.visible = !1)), this.axis === "Z" && (this.tempQuaternion.setFromEuler(this.tempEuler.set(0, Math.PI / 2, 0)), b.quaternion.copy(he).multiply(this.tempQuaternion), Math.abs(this.alignVector.copy(this.unitZ).applyQuaternion(he).dot(this.eye)) > 0.9 && (b.visible = !1)), this.axis === "XYZE" && (this.tempQuaternion.setFromEuler(this.tempEuler.set(0, Math.PI / 2, 0)), this.alignVector.copy(this.rotationAxis), b.quaternion.setFromRotationMatrix(
+        if (this.camera.isOrthographicCamera ? U = (this.camera.top - this.camera.bottom) / this.camera.zoom : U = this.worldPosition.distanceTo(this.cameraPosition) * Math.min(1.9 * Math.tan(Math.PI * this.camera.fov / 360) / this.camera.zoom, 7), S.scale.set(1, 1, 1).multiplyScalar(U * this.size / 7), S.tag === "helper") {
+          S.visible = !1, S.name === "AXIS" ? (S.position.copy(this.worldPositionStart), S.visible = !!this.axis, this.axis === "X" && (this.tempQuaternion.setFromEuler(this.tempEuler.set(0, 0, 0)), S.quaternion.copy(fe).multiply(this.tempQuaternion), Math.abs(this.alignVector.copy(this.unitX).applyQuaternion(fe).dot(this.eye)) > 0.9 && (S.visible = !1)), this.axis === "Y" && (this.tempQuaternion.setFromEuler(this.tempEuler.set(0, 0, Math.PI / 2)), S.quaternion.copy(fe).multiply(this.tempQuaternion), Math.abs(this.alignVector.copy(this.unitY).applyQuaternion(fe).dot(this.eye)) > 0.9 && (S.visible = !1)), this.axis === "Z" && (this.tempQuaternion.setFromEuler(this.tempEuler.set(0, Math.PI / 2, 0)), S.quaternion.copy(fe).multiply(this.tempQuaternion), Math.abs(this.alignVector.copy(this.unitZ).applyQuaternion(fe).dot(this.eye)) > 0.9 && (S.visible = !1)), this.axis === "XYZE" && (this.tempQuaternion.setFromEuler(this.tempEuler.set(0, Math.PI / 2, 0)), this.alignVector.copy(this.rotationAxis), S.quaternion.setFromRotationMatrix(
             this.lookAtMatrix.lookAt(this.zeroVector, this.alignVector, this.unitY)
-          ), b.quaternion.multiply(this.tempQuaternion), b.visible = this.dragging), this.axis === "E" && (b.visible = !1)) : b.name === "START" ? (b.position.copy(this.worldPositionStart), b.visible = this.dragging) : b.name === "END" ? (b.position.copy(this.worldPosition), b.visible = this.dragging) : b.name === "DELTA" ? (b.position.copy(this.worldPositionStart), b.quaternion.copy(this.worldQuaternionStart), this.tempVector.set(1e-10, 1e-10, 1e-10).add(this.worldPositionStart).sub(this.worldPosition).multiplyScalar(-1), this.tempVector.applyQuaternion(this.worldQuaternionStart.clone().invert()), b.scale.copy(this.tempVector), b.visible = this.dragging) : (b.quaternion.copy(he), this.dragging ? b.position.copy(this.worldPositionStart) : b.position.copy(this.worldPosition), this.axis && (b.visible = this.axis.search(b.name) !== -1));
+          ), S.quaternion.multiply(this.tempQuaternion), S.visible = this.dragging), this.axis === "E" && (S.visible = !1)) : S.name === "START" ? (S.position.copy(this.worldPositionStart), S.visible = this.dragging) : S.name === "END" ? (S.position.copy(this.worldPosition), S.visible = this.dragging) : S.name === "DELTA" ? (S.position.copy(this.worldPositionStart), S.quaternion.copy(this.worldQuaternionStart), this.tempVector.set(1e-10, 1e-10, 1e-10).add(this.worldPositionStart).sub(this.worldPosition).multiplyScalar(-1), this.tempVector.applyQuaternion(this.worldQuaternionStart.clone().invert()), S.scale.copy(this.tempVector), S.visible = this.dragging) : (S.quaternion.copy(fe), this.dragging ? S.position.copy(this.worldPositionStart) : S.position.copy(this.worldPosition), this.axis && (S.visible = this.axis.search(S.name) !== -1));
           continue;
         }
-        b.quaternion.copy(he), this.mode === "translate" || this.mode === "scale" ? ((b.name === "X" || b.name === "XYZX") && Math.abs(this.alignVector.copy(this.unitX).applyQuaternion(he).dot(this.eye)) > 0.99 && (b.scale.set(1e-10, 1e-10, 1e-10), b.visible = !1), (b.name === "Y" || b.name === "XYZY") && Math.abs(this.alignVector.copy(this.unitY).applyQuaternion(he).dot(this.eye)) > 0.99 && (b.scale.set(1e-10, 1e-10, 1e-10), b.visible = !1), (b.name === "Z" || b.name === "XYZZ") && Math.abs(this.alignVector.copy(this.unitZ).applyQuaternion(he).dot(this.eye)) > 0.99 && (b.scale.set(1e-10, 1e-10, 1e-10), b.visible = !1), b.name === "XY" && Math.abs(this.alignVector.copy(this.unitZ).applyQuaternion(he).dot(this.eye)) < 0.2 && (b.scale.set(1e-10, 1e-10, 1e-10), b.visible = !1), b.name === "YZ" && Math.abs(this.alignVector.copy(this.unitX).applyQuaternion(he).dot(this.eye)) < 0.2 && (b.scale.set(1e-10, 1e-10, 1e-10), b.visible = !1), b.name === "XZ" && Math.abs(this.alignVector.copy(this.unitY).applyQuaternion(he).dot(this.eye)) < 0.2 && (b.scale.set(1e-10, 1e-10, 1e-10), b.visible = !1), b.name.search("X") !== -1 && (this.alignVector.copy(this.unitX).applyQuaternion(he).dot(this.eye) < 0 ? b.tag === "fwd" ? b.visible = !1 : b.scale.x *= -1 : b.tag === "bwd" && (b.visible = !1)), b.name.search("Y") !== -1 && (this.alignVector.copy(this.unitY).applyQuaternion(he).dot(this.eye) < 0 ? b.tag === "fwd" ? b.visible = !1 : b.scale.y *= -1 : b.tag === "bwd" && (b.visible = !1)), b.name.search("Z") !== -1 && (this.alignVector.copy(this.unitZ).applyQuaternion(he).dot(this.eye) < 0 ? b.tag === "fwd" ? b.visible = !1 : b.scale.z *= -1 : b.tag === "bwd" && (b.visible = !1))) : this.mode === "rotate" && (this.tempQuaternion2.copy(he), this.alignVector.copy(this.eye).applyQuaternion(this.tempQuaternion.copy(he).invert()), b.name.search("E") !== -1 && b.quaternion.setFromRotationMatrix(this.lookAtMatrix.lookAt(this.eye, this.zeroVector, this.unitY)), b.name === "X" && (this.tempQuaternion.setFromAxisAngle(this.unitX, Math.atan2(-this.alignVector.y, this.alignVector.z)), this.tempQuaternion.multiplyQuaternions(this.tempQuaternion2, this.tempQuaternion), b.quaternion.copy(this.tempQuaternion)), b.name === "Y" && (this.tempQuaternion.setFromAxisAngle(this.unitY, Math.atan2(this.alignVector.x, this.alignVector.z)), this.tempQuaternion.multiplyQuaternions(this.tempQuaternion2, this.tempQuaternion), b.quaternion.copy(this.tempQuaternion)), b.name === "Z" && (this.tempQuaternion.setFromAxisAngle(this.unitZ, Math.atan2(this.alignVector.y, this.alignVector.x)), this.tempQuaternion.multiplyQuaternions(this.tempQuaternion2, this.tempQuaternion), b.quaternion.copy(this.tempQuaternion))), b.visible = b.visible && (b.name.indexOf("X") === -1 || this.showX), b.visible = b.visible && (b.name.indexOf("Y") === -1 || this.showY), b.visible = b.visible && (b.name.indexOf("Z") === -1 || this.showZ), b.visible = b.visible && (b.name.indexOf("E") === -1 || this.showX && this.showY && this.showZ), b.material.tempOpacity = b.material.tempOpacity || b.material.opacity, b.material.tempColor = b.material.tempColor || b.material.color.clone(), b.material.color.copy(b.material.tempColor), b.material.opacity = b.material.tempOpacity, this.enabled ? this.axis && (b.name === this.axis ? (b.material.opacity = 1, b.material.color.lerp(new Be(1, 1, 1), 0.5)) : this.axis.split("").some(function(J) {
-          return b.name === J;
-        }) ? (b.material.opacity = 1, b.material.color.lerp(new Be(1, 1, 1), 0.5)) : (b.material.opacity *= 0.25, b.material.color.lerp(new Be(1, 1, 1), 0.5))) : (b.material.opacity *= 0.5, b.material.color.lerp(new Be(1, 1, 1), 0.5));
+        S.quaternion.copy(fe), this.mode === "translate" || this.mode === "scale" ? ((S.name === "X" || S.name === "XYZX") && Math.abs(this.alignVector.copy(this.unitX).applyQuaternion(fe).dot(this.eye)) > 0.99 && (S.scale.set(1e-10, 1e-10, 1e-10), S.visible = !1), (S.name === "Y" || S.name === "XYZY") && Math.abs(this.alignVector.copy(this.unitY).applyQuaternion(fe).dot(this.eye)) > 0.99 && (S.scale.set(1e-10, 1e-10, 1e-10), S.visible = !1), (S.name === "Z" || S.name === "XYZZ") && Math.abs(this.alignVector.copy(this.unitZ).applyQuaternion(fe).dot(this.eye)) > 0.99 && (S.scale.set(1e-10, 1e-10, 1e-10), S.visible = !1), S.name === "XY" && Math.abs(this.alignVector.copy(this.unitZ).applyQuaternion(fe).dot(this.eye)) < 0.2 && (S.scale.set(1e-10, 1e-10, 1e-10), S.visible = !1), S.name === "YZ" && Math.abs(this.alignVector.copy(this.unitX).applyQuaternion(fe).dot(this.eye)) < 0.2 && (S.scale.set(1e-10, 1e-10, 1e-10), S.visible = !1), S.name === "XZ" && Math.abs(this.alignVector.copy(this.unitY).applyQuaternion(fe).dot(this.eye)) < 0.2 && (S.scale.set(1e-10, 1e-10, 1e-10), S.visible = !1), S.name.search("X") !== -1 && (this.alignVector.copy(this.unitX).applyQuaternion(fe).dot(this.eye) < 0 ? S.tag === "fwd" ? S.visible = !1 : S.scale.x *= -1 : S.tag === "bwd" && (S.visible = !1)), S.name.search("Y") !== -1 && (this.alignVector.copy(this.unitY).applyQuaternion(fe).dot(this.eye) < 0 ? S.tag === "fwd" ? S.visible = !1 : S.scale.y *= -1 : S.tag === "bwd" && (S.visible = !1)), S.name.search("Z") !== -1 && (this.alignVector.copy(this.unitZ).applyQuaternion(fe).dot(this.eye) < 0 ? S.tag === "fwd" ? S.visible = !1 : S.scale.z *= -1 : S.tag === "bwd" && (S.visible = !1))) : this.mode === "rotate" && (this.tempQuaternion2.copy(fe), this.alignVector.copy(this.eye).applyQuaternion(this.tempQuaternion.copy(fe).invert()), S.name.search("E") !== -1 && S.quaternion.setFromRotationMatrix(this.lookAtMatrix.lookAt(this.eye, this.zeroVector, this.unitY)), S.name === "X" && (this.tempQuaternion.setFromAxisAngle(this.unitX, Math.atan2(-this.alignVector.y, this.alignVector.z)), this.tempQuaternion.multiplyQuaternions(this.tempQuaternion2, this.tempQuaternion), S.quaternion.copy(this.tempQuaternion)), S.name === "Y" && (this.tempQuaternion.setFromAxisAngle(this.unitY, Math.atan2(this.alignVector.x, this.alignVector.z)), this.tempQuaternion.multiplyQuaternions(this.tempQuaternion2, this.tempQuaternion), S.quaternion.copy(this.tempQuaternion)), S.name === "Z" && (this.tempQuaternion.setFromAxisAngle(this.unitZ, Math.atan2(this.alignVector.y, this.alignVector.x)), this.tempQuaternion.multiplyQuaternions(this.tempQuaternion2, this.tempQuaternion), S.quaternion.copy(this.tempQuaternion))), S.visible = S.visible && (S.name.indexOf("X") === -1 || this.showX), S.visible = S.visible && (S.name.indexOf("Y") === -1 || this.showY), S.visible = S.visible && (S.name.indexOf("Z") === -1 || this.showZ), S.visible = S.visible && (S.name.indexOf("E") === -1 || this.showX && this.showY && this.showZ), S.material.tempOpacity = S.material.tempOpacity || S.material.opacity, S.material.tempColor = S.material.tempColor || S.material.color.clone(), S.material.color.copy(S.material.tempColor), S.material.opacity = S.material.tempOpacity, this.enabled ? this.axis && (S.name === this.axis ? (S.material.opacity = 1, S.material.color.lerp(new Re(1, 1, 1), 0.5)) : this.axis.split("").some(function(ee) {
+          return S.name === ee;
+        }) ? (S.material.opacity = 1, S.material.color.lerp(new Re(1, 1, 1), 0.5)) : (S.material.opacity *= 0.25, S.material.color.lerp(new Re(1, 1, 1), 0.5))) : (S.material.opacity *= 0.5, S.material.color.lerp(new Re(1, 1, 1), 0.5));
       }
       super.updateMatrixWorld();
     });
-    const e = new Gt({
+    const e = new Yt({
       depthTest: !1,
       depthWrite: !1,
       transparent: !0,
-      side: wn,
+      side: dn,
       fog: !1,
       toneMapped: !1
-    }), t = new qs({
+    }), t = new si({
       depthTest: !1,
       depthWrite: !1,
       transparent: !0,
@@ -1734,204 +1734,204 @@ class Zc extends St {
     u.color.set(65535);
     const h = l.clone();
     h.color.set(16711935), e.clone().color.set(16776960);
-    const p = t.clone();
-    p.color.set(16711680);
+    const d = t.clone();
+    d.color.set(16711680);
+    const y = t.clone();
+    y.color.set(65280);
+    const x = t.clone();
+    x.color.set(255);
+    const g = t.clone();
+    g.color.set(65535);
     const v = t.clone();
-    v.color.set(65280);
+    v.color.set(16711935);
+    const M = t.clone();
+    M.color.set(16776960);
     const _ = t.clone();
-    _.color.set(255);
-    const y = t.clone();
-    y.color.set(65535);
-    const E = t.clone();
-    E.color.set(16711935);
-    const R = t.clone();
-    R.color.set(16776960);
-    const T = t.clone();
-    T.color.set(7895160);
-    const g = R.clone();
-    g.opacity = 0.25;
-    const A = new xt(0, 0.05, 0.2, 12, 1, !1), x = new tn(0.125, 0.125, 0.125), M = new rt();
-    M.setAttribute("position", new it([0, 0, 0, 1, 0, 0], 3));
-    const d = (se, he) => {
-      const H = new rt(), k = [];
-      for (let b = 0; b <= 64 * he; ++b)
-        k.push(0, Math.cos(b / 32 * Math.PI) * se, Math.sin(b / 32 * Math.PI) * se);
+    _.color.set(7895160);
+    const w = M.clone();
+    w.opacity = 0.25;
+    const P = new bt(0, 0.05, 0.2, 12, 1, !1), T = new Wt(0.125, 0.125, 0.125), E = new at();
+    E.setAttribute("position", new it([0, 0, 0, 1, 0, 0], 3));
+    const m = (se, fe) => {
+      const H = new at(), k = [];
+      for (let S = 0; S <= 64 * fe; ++S)
+        k.push(0, Math.cos(S / 32 * Math.PI) * se, Math.sin(S / 32 * Math.PI) * se);
       return H.setAttribute("position", new it(k, 3)), H;
-    }, w = () => {
-      const se = new rt();
+    }, b = () => {
+      const se = new at();
       return se.setAttribute("position", new it([0, 0, 0, 1, 1, 1], 3)), se;
-    }, f = {
+    }, p = {
       X: [
-        [new ae(A, i), [1, 0, 0], [0, 0, -Math.PI / 2], null, "fwd"],
-        [new ae(A, i), [1, 0, 0], [0, 0, Math.PI / 2], null, "bwd"],
-        [new Ie(M, p)]
+        [new ae(P, i), [1, 0, 0], [0, 0, -Math.PI / 2], null, "fwd"],
+        [new ae(P, i), [1, 0, 0], [0, 0, Math.PI / 2], null, "bwd"],
+        [new De(E, d)]
       ],
       Y: [
-        [new ae(A, r), [0, 1, 0], null, null, "fwd"],
-        [new ae(A, r), [0, 1, 0], [Math.PI, 0, 0], null, "bwd"],
-        [new Ie(M, v), null, [0, 0, Math.PI / 2]]
+        [new ae(P, r), [0, 1, 0], null, null, "fwd"],
+        [new ae(P, r), [0, 1, 0], [Math.PI, 0, 0], null, "bwd"],
+        [new De(E, y), null, [0, 0, Math.PI / 2]]
       ],
       Z: [
-        [new ae(A, a), [0, 0, 1], [Math.PI / 2, 0, 0], null, "fwd"],
-        [new ae(A, a), [0, 0, 1], [-Math.PI / 2, 0, 0], null, "bwd"],
-        [new Ie(M, _), null, [0, -Math.PI / 2, 0]]
+        [new ae(P, a), [0, 0, 1], [Math.PI / 2, 0, 0], null, "fwd"],
+        [new ae(P, a), [0, 0, 1], [-Math.PI / 2, 0, 0], null, "bwd"],
+        [new De(E, x), null, [0, -Math.PI / 2, 0]]
       ],
-      XYZ: [[new ae(new dn(0.1, 0), l.clone()), [0, 0, 0], [0, 0, 0]]],
+      XYZ: [[new ae(new gn(0.1, 0), l.clone()), [0, 0, 0], [0, 0, 0]]],
       XY: [
-        [new ae(new Dt(0.295, 0.295), c.clone()), [0.15, 0.15, 0]],
-        [new Ie(M, R), [0.18, 0.3, 0], null, [0.125, 1, 1]],
-        [new Ie(M, R), [0.3, 0.18, 0], [0, 0, Math.PI / 2], [0.125, 1, 1]]
+        [new ae(new Lt(0.295, 0.295), c.clone()), [0.15, 0.15, 0]],
+        [new De(E, M), [0.18, 0.3, 0], null, [0.125, 1, 1]],
+        [new De(E, M), [0.3, 0.18, 0], [0, 0, Math.PI / 2], [0.125, 1, 1]]
       ],
       YZ: [
-        [new ae(new Dt(0.295, 0.295), u.clone()), [0, 0.15, 0.15], [0, Math.PI / 2, 0]],
-        [new Ie(M, y), [0, 0.18, 0.3], [0, 0, Math.PI / 2], [0.125, 1, 1]],
-        [new Ie(M, y), [0, 0.3, 0.18], [0, -Math.PI / 2, 0], [0.125, 1, 1]]
+        [new ae(new Lt(0.295, 0.295), u.clone()), [0, 0.15, 0.15], [0, Math.PI / 2, 0]],
+        [new De(E, g), [0, 0.18, 0.3], [0, 0, Math.PI / 2], [0.125, 1, 1]],
+        [new De(E, g), [0, 0.3, 0.18], [0, -Math.PI / 2, 0], [0.125, 1, 1]]
       ],
       XZ: [
         [
-          new ae(new Dt(0.295, 0.295), h.clone()),
+          new ae(new Lt(0.295, 0.295), h.clone()),
           [0.15, 0, 0.15],
           [-Math.PI / 2, 0, 0]
         ],
-        [new Ie(M, E), [0.18, 0, 0.3], null, [0.125, 1, 1]],
-        [new Ie(M, E), [0.3, 0, 0.18], [0, -Math.PI / 2, 0], [0.125, 1, 1]]
+        [new De(E, v), [0.18, 0, 0.3], null, [0.125, 1, 1]],
+        [new De(E, v), [0.3, 0, 0.18], [0, -Math.PI / 2, 0], [0.125, 1, 1]]
       ]
-    }, P = {
-      X: [[new ae(new xt(0.2, 0, 1, 4, 1, !1), n), [0.6, 0, 0], [0, 0, -Math.PI / 2]]],
-      Y: [[new ae(new xt(0.2, 0, 1, 4, 1, !1), n), [0, 0.6, 0]]],
-      Z: [[new ae(new xt(0.2, 0, 1, 4, 1, !1), n), [0, 0, 0.6], [Math.PI / 2, 0, 0]]],
-      XYZ: [[new ae(new dn(0.2, 0), n)]],
-      XY: [[new ae(new Dt(0.4, 0.4), n), [0.2, 0.2, 0]]],
-      YZ: [[new ae(new Dt(0.4, 0.4), n), [0, 0.2, 0.2], [0, Math.PI / 2, 0]]],
-      XZ: [[new ae(new Dt(0.4, 0.4), n), [0.2, 0, 0.2], [-Math.PI / 2, 0, 0]]]
+    }, C = {
+      X: [[new ae(new bt(0.2, 0, 1, 4, 1, !1), n), [0.6, 0, 0], [0, 0, -Math.PI / 2]]],
+      Y: [[new ae(new bt(0.2, 0, 1, 4, 1, !1), n), [0, 0.6, 0]]],
+      Z: [[new ae(new bt(0.2, 0, 1, 4, 1, !1), n), [0, 0, 0.6], [Math.PI / 2, 0, 0]]],
+      XYZ: [[new ae(new gn(0.2, 0), n)]],
+      XY: [[new ae(new Lt(0.4, 0.4), n), [0.2, 0.2, 0]]],
+      YZ: [[new ae(new Lt(0.4, 0.4), n), [0, 0.2, 0.2], [0, Math.PI / 2, 0]]],
+      XZ: [[new ae(new Lt(0.4, 0.4), n), [0.2, 0, 0.2], [-Math.PI / 2, 0, 0]]]
     }, I = {
-      START: [[new ae(new dn(0.01, 2), s), null, null, null, "helper"]],
-      END: [[new ae(new dn(0.01, 2), s), null, null, null, "helper"]],
-      DELTA: [[new Ie(w(), s), null, null, null, "helper"]],
-      X: [[new Ie(M, s.clone()), [-1e3, 0, 0], null, [1e6, 1, 1], "helper"]],
-      Y: [[new Ie(M, s.clone()), [0, -1e3, 0], [0, 0, Math.PI / 2], [1e6, 1, 1], "helper"]],
-      Z: [[new Ie(M, s.clone()), [0, 0, -1e3], [0, -Math.PI / 2, 0], [1e6, 1, 1], "helper"]]
+      START: [[new ae(new gn(0.01, 2), s), null, null, null, "helper"]],
+      END: [[new ae(new gn(0.01, 2), s), null, null, null, "helper"]],
+      DELTA: [[new De(b(), s), null, null, null, "helper"]],
+      X: [[new De(E, s.clone()), [-1e3, 0, 0], null, [1e6, 1, 1], "helper"]],
+      Y: [[new De(E, s.clone()), [0, -1e3, 0], [0, 0, Math.PI / 2], [1e6, 1, 1], "helper"]],
+      Z: [[new De(E, s.clone()), [0, 0, -1e3], [0, -Math.PI / 2, 0], [1e6, 1, 1], "helper"]]
     }, K = {
       X: [
-        [new Ie(d(1, 0.5), p)],
-        [new ae(new dn(0.04, 0), i), [0, 0, 0.99], null, [1, 3, 1]]
+        [new De(m(1, 0.5), d)],
+        [new ae(new gn(0.04, 0), i), [0, 0, 0.99], null, [1, 3, 1]]
       ],
       Y: [
-        [new Ie(d(1, 0.5), v), null, [0, 0, -Math.PI / 2]],
-        [new ae(new dn(0.04, 0), r), [0, 0, 0.99], null, [3, 1, 1]]
+        [new De(m(1, 0.5), y), null, [0, 0, -Math.PI / 2]],
+        [new ae(new gn(0.04, 0), r), [0, 0, 0.99], null, [3, 1, 1]]
       ],
       Z: [
-        [new Ie(d(1, 0.5), _), null, [0, Math.PI / 2, 0]],
-        [new ae(new dn(0.04, 0), a), [0.99, 0, 0], null, [1, 3, 1]]
+        [new De(m(1, 0.5), x), null, [0, Math.PI / 2, 0]],
+        [new ae(new gn(0.04, 0), a), [0.99, 0, 0], null, [1, 3, 1]]
       ],
       E: [
-        [new Ie(d(1.25, 1), g), null, [0, Math.PI / 2, 0]],
+        [new De(m(1.25, 1), w), null, [0, Math.PI / 2, 0]],
         [
-          new ae(new xt(0.03, 0, 0.15, 4, 1, !1), g),
+          new ae(new bt(0.03, 0, 0.15, 4, 1, !1), w),
           [1.17, 0, 0],
           [0, 0, -Math.PI / 2],
           [1, 1, 1e-3]
         ],
         [
-          new ae(new xt(0.03, 0, 0.15, 4, 1, !1), g),
+          new ae(new bt(0.03, 0, 0.15, 4, 1, !1), w),
           [-1.17, 0, 0],
           [0, 0, Math.PI / 2],
           [1, 1, 1e-3]
         ],
         [
-          new ae(new xt(0.03, 0, 0.15, 4, 1, !1), g),
+          new ae(new bt(0.03, 0, 0.15, 4, 1, !1), w),
           [0, -1.17, 0],
           [Math.PI, 0, 0],
           [1, 1, 1e-3]
         ],
         [
-          new ae(new xt(0.03, 0, 0.15, 4, 1, !1), g),
+          new ae(new bt(0.03, 0, 0.15, 4, 1, !1), w),
           [0, 1.17, 0],
           [0, 0, 0],
           [1, 1, 1e-3]
         ]
       ],
-      XYZE: [[new Ie(d(1, 1), T), null, [0, Math.PI / 2, 0]]]
-    }, N = {
-      AXIS: [[new Ie(M, s.clone()), [-1e3, 0, 0], null, [1e6, 1, 1], "helper"]]
-    }, Z = {
-      X: [[new ae(new xs(1, 0.1, 4, 24), n), [0, 0, 0], [0, -Math.PI / 2, -Math.PI / 2]]],
-      Y: [[new ae(new xs(1, 0.1, 4, 24), n), [0, 0, 0], [Math.PI / 2, 0, 0]]],
-      Z: [[new ae(new xs(1, 0.1, 4, 24), n), [0, 0, 0], [0, 0, -Math.PI / 2]]],
-      E: [[new ae(new xs(1.25, 0.1, 2, 24), n)]],
-      XYZE: [[new ae(new ul(0.7, 10, 8), n)]]
+      XYZE: [[new De(m(1, 1), _), null, [0, Math.PI / 2, 0]]]
+    }, z = {
+      AXIS: [[new De(E, s.clone()), [-1e3, 0, 0], null, [1e6, 1, 1], "helper"]]
+    }, Y = {
+      X: [[new ae(new As(1, 0.1, 4, 24), n), [0, 0, 0], [0, -Math.PI / 2, -Math.PI / 2]]],
+      Y: [[new ae(new As(1, 0.1, 4, 24), n), [0, 0, 0], [Math.PI / 2, 0, 0]]],
+      Z: [[new ae(new As(1, 0.1, 4, 24), n), [0, 0, 0], [0, 0, -Math.PI / 2]]],
+      E: [[new ae(new As(1.25, 0.1, 2, 24), n)]],
+      XYZE: [[new ae(new vl(0.7, 10, 8), n)]]
     }, W = {
       X: [
-        [new ae(x, i), [0.8, 0, 0], [0, 0, -Math.PI / 2]],
-        [new Ie(M, p), null, null, [0.8, 1, 1]]
+        [new ae(T, i), [0.8, 0, 0], [0, 0, -Math.PI / 2]],
+        [new De(E, d), null, null, [0.8, 1, 1]]
       ],
       Y: [
-        [new ae(x, r), [0, 0.8, 0]],
-        [new Ie(M, v), null, [0, 0, Math.PI / 2], [0.8, 1, 1]]
+        [new ae(T, r), [0, 0.8, 0]],
+        [new De(E, y), null, [0, 0, Math.PI / 2], [0.8, 1, 1]]
       ],
       Z: [
-        [new ae(x, a), [0, 0, 0.8], [Math.PI / 2, 0, 0]],
-        [new Ie(M, _), null, [0, -Math.PI / 2, 0], [0.8, 1, 1]]
+        [new ae(T, a), [0, 0, 0.8], [Math.PI / 2, 0, 0]],
+        [new De(E, x), null, [0, -Math.PI / 2, 0], [0.8, 1, 1]]
       ],
       XY: [
-        [new ae(x, c), [0.85, 0.85, 0], null, [2, 2, 0.2]],
-        [new Ie(M, R), [0.855, 0.98, 0], null, [0.125, 1, 1]],
-        [new Ie(M, R), [0.98, 0.855, 0], [0, 0, Math.PI / 2], [0.125, 1, 1]]
+        [new ae(T, c), [0.85, 0.85, 0], null, [2, 2, 0.2]],
+        [new De(E, M), [0.855, 0.98, 0], null, [0.125, 1, 1]],
+        [new De(E, M), [0.98, 0.855, 0], [0, 0, Math.PI / 2], [0.125, 1, 1]]
       ],
       YZ: [
-        [new ae(x, u), [0, 0.85, 0.85], null, [0.2, 2, 2]],
-        [new Ie(M, y), [0, 0.855, 0.98], [0, 0, Math.PI / 2], [0.125, 1, 1]],
-        [new Ie(M, y), [0, 0.98, 0.855], [0, -Math.PI / 2, 0], [0.125, 1, 1]]
+        [new ae(T, u), [0, 0.85, 0.85], null, [0.2, 2, 2]],
+        [new De(E, g), [0, 0.855, 0.98], [0, 0, Math.PI / 2], [0.125, 1, 1]],
+        [new De(E, g), [0, 0.98, 0.855], [0, -Math.PI / 2, 0], [0.125, 1, 1]]
       ],
       XZ: [
-        [new ae(x, h), [0.85, 0, 0.85], null, [2, 0.2, 2]],
-        [new Ie(M, E), [0.855, 0, 0.98], null, [0.125, 1, 1]],
-        [new Ie(M, E), [0.98, 0, 0.855], [0, -Math.PI / 2, 0], [0.125, 1, 1]]
+        [new ae(T, h), [0.85, 0, 0.85], null, [2, 0.2, 2]],
+        [new De(E, v), [0.855, 0, 0.98], null, [0.125, 1, 1]],
+        [new De(E, v), [0.98, 0, 0.855], [0, -Math.PI / 2, 0], [0.125, 1, 1]]
       ],
-      XYZX: [[new ae(new tn(0.125, 0.125, 0.125), l.clone()), [1.1, 0, 0]]],
-      XYZY: [[new ae(new tn(0.125, 0.125, 0.125), l.clone()), [0, 1.1, 0]]],
-      XYZZ: [[new ae(new tn(0.125, 0.125, 0.125), l.clone()), [0, 0, 1.1]]]
+      XYZX: [[new ae(new Wt(0.125, 0.125, 0.125), l.clone()), [1.1, 0, 0]]],
+      XYZY: [[new ae(new Wt(0.125, 0.125, 0.125), l.clone()), [0, 1.1, 0]]],
+      XYZZ: [[new ae(new Wt(0.125, 0.125, 0.125), l.clone()), [0, 0, 1.1]]]
     }, X = {
-      X: [[new ae(new xt(0.2, 0, 0.8, 4, 1, !1), n), [0.5, 0, 0], [0, 0, -Math.PI / 2]]],
-      Y: [[new ae(new xt(0.2, 0, 0.8, 4, 1, !1), n), [0, 0.5, 0]]],
-      Z: [[new ae(new xt(0.2, 0, 0.8, 4, 1, !1), n), [0, 0, 0.5], [Math.PI / 2, 0, 0]]],
-      XY: [[new ae(x, n), [0.85, 0.85, 0], null, [3, 3, 0.2]]],
-      YZ: [[new ae(x, n), [0, 0.85, 0.85], null, [0.2, 3, 3]]],
-      XZ: [[new ae(x, n), [0.85, 0, 0.85], null, [3, 0.2, 3]]],
-      XYZX: [[new ae(new tn(0.2, 0.2, 0.2), n), [1.1, 0, 0]]],
-      XYZY: [[new ae(new tn(0.2, 0.2, 0.2), n), [0, 1.1, 0]]],
-      XYZZ: [[new ae(new tn(0.2, 0.2, 0.2), n), [0, 0, 1.1]]]
+      X: [[new ae(new bt(0.2, 0, 0.8, 4, 1, !1), n), [0.5, 0, 0], [0, 0, -Math.PI / 2]]],
+      Y: [[new ae(new bt(0.2, 0, 0.8, 4, 1, !1), n), [0, 0.5, 0]]],
+      Z: [[new ae(new bt(0.2, 0, 0.8, 4, 1, !1), n), [0, 0, 0.5], [Math.PI / 2, 0, 0]]],
+      XY: [[new ae(T, n), [0.85, 0.85, 0], null, [3, 3, 0.2]]],
+      YZ: [[new ae(T, n), [0, 0.85, 0.85], null, [0.2, 3, 3]]],
+      XZ: [[new ae(T, n), [0.85, 0, 0.85], null, [3, 0.2, 3]]],
+      XYZX: [[new ae(new Wt(0.2, 0.2, 0.2), n), [1.1, 0, 0]]],
+      XYZY: [[new ae(new Wt(0.2, 0.2, 0.2), n), [0, 1.1, 0]]],
+      XYZZ: [[new ae(new Wt(0.2, 0.2, 0.2), n), [0, 0, 1.1]]]
     }, V = {
-      X: [[new Ie(M, s.clone()), [-1e3, 0, 0], null, [1e6, 1, 1], "helper"]],
-      Y: [[new Ie(M, s.clone()), [0, -1e3, 0], [0, 0, Math.PI / 2], [1e6, 1, 1], "helper"]],
-      Z: [[new Ie(M, s.clone()), [0, 0, -1e3], [0, -Math.PI / 2, 0], [1e6, 1, 1], "helper"]]
-    }, ne = (se) => {
-      const he = new St();
+      X: [[new De(E, s.clone()), [-1e3, 0, 0], null, [1e6, 1, 1], "helper"]],
+      Y: [[new De(E, s.clone()), [0, -1e3, 0], [0, 0, Math.PI / 2], [1e6, 1, 1], "helper"]],
+      Z: [[new De(E, s.clone()), [0, 0, -1e3], [0, -Math.PI / 2, 0], [1e6, 1, 1], "helper"]]
+    }, te = (se) => {
+      const fe = new Tt();
       for (let H in se)
         for (let k = se[H].length; k--; ) {
-          const b = se[H][k][0].clone(), U = se[H][k][1], J = se[H][k][2], F = se[H][k][3], B = se[H][k][4];
-          b.name = H, b.tag = B, U && b.position.set(U[0], U[1], U[2]), J && b.rotation.set(J[0], J[1], J[2]), F && b.scale.set(F[0], F[1], F[2]), b.updateMatrix();
-          const S = b.geometry.clone();
-          S.applyMatrix4(b.matrix), b.geometry = S, b.renderOrder = 1 / 0, b.position.set(0, 0, 0), b.rotation.set(0, 0, 0), b.scale.set(1, 1, 1), he.add(b);
+          const S = se[H][k][0].clone(), U = se[H][k][1], ee = se[H][k][2], F = se[H][k][3], N = se[H][k][4];
+          S.name = H, S.tag = N, U && S.position.set(U[0], U[1], U[2]), ee && S.rotation.set(ee[0], ee[1], ee[2]), F && S.scale.set(F[0], F[1], F[2]), S.updateMatrix();
+          const A = S.geometry.clone();
+          A.applyMatrix4(S.matrix), S.geometry = A, S.renderOrder = 1 / 0, S.position.set(0, 0, 0), S.rotation.set(0, 0, 0), S.scale.set(1, 1, 1), fe.add(S);
         }
-      return he;
+      return fe;
     };
-    this.gizmo = {}, this.picker = {}, this.helper = {}, this.add(this.gizmo.translate = ne(f)), this.add(this.gizmo.rotate = ne(K)), this.add(this.gizmo.scale = ne(W)), this.add(this.picker.translate = ne(P)), this.add(this.picker.rotate = ne(Z)), this.add(this.picker.scale = ne(X)), this.add(this.helper.translate = ne(I)), this.add(this.helper.rotate = ne(N)), this.add(this.helper.scale = ne(V)), this.picker.translate.visible = !1, this.picker.rotate.visible = !1, this.picker.scale.visible = !1;
+    this.gizmo = {}, this.picker = {}, this.helper = {}, this.add(this.gizmo.translate = te(p)), this.add(this.gizmo.rotate = te(K)), this.add(this.gizmo.scale = te(W)), this.add(this.picker.translate = te(C)), this.add(this.picker.rotate = te(Y)), this.add(this.picker.scale = te(X)), this.add(this.helper.translate = te(I)), this.add(this.helper.rotate = te(z)), this.add(this.helper.scale = te(V)), this.picker.translate.visible = !1, this.picker.rotate.visible = !1, this.picker.scale.visible = !1;
   }
 }
-class Kc extends ae {
+class iu extends ae {
   constructor() {
     super(
-      new Dt(1e5, 1e5, 2, 2),
-      new Gt({
+      new Lt(1e5, 1e5, 2, 2),
+      new Yt({
         visible: !1,
         wireframe: !0,
-        side: wn,
+        side: dn,
         transparent: !0,
         opacity: 0.1,
         toneMapped: !1
       })
-    ), q(this, "isTransformControlsPlane", !0), q(this, "type", "TransformControlsPlane"), q(this, "unitX", new ee(1, 0, 0)), q(this, "unitY", new ee(0, 1, 0)), q(this, "unitZ", new ee(0, 0, 1)), q(this, "tempVector", new ee()), q(this, "dirVector", new ee()), q(this, "alignVector", new ee()), q(this, "tempMatrix", new De()), q(this, "identityQuaternion", new He()), q(this, "cameraQuaternion", new He()), q(this, "worldPosition", new ee()), q(this, "worldQuaternion", new He()), q(this, "eye", new ee()), q(this, "axis", null), q(this, "mode", "translate"), q(this, "space", "world"), q(this, "updateMatrixWorld", () => {
+    ), Q(this, "isTransformControlsPlane", !0), Q(this, "type", "TransformControlsPlane"), Q(this, "unitX", new q(1, 0, 0)), Q(this, "unitY", new q(0, 1, 0)), Q(this, "unitZ", new q(0, 0, 1)), Q(this, "tempVector", new q()), Q(this, "dirVector", new q()), Q(this, "alignVector", new q()), Q(this, "tempMatrix", new Pe()), Q(this, "identityQuaternion", new He()), Q(this, "cameraQuaternion", new He()), Q(this, "worldPosition", new q()), Q(this, "worldQuaternion", new He()), Q(this, "eye", new q()), Q(this, "axis", null), Q(this, "mode", "translate"), Q(this, "space", "world"), Q(this, "updateMatrixWorld", () => {
       let e = this.space;
       switch (this.position.copy(this.worldPosition), this.mode === "scale" && (e = "local"), this.unitX.set(1, 0, 0).applyQuaternion(e === "local" ? this.worldQuaternion : this.identityQuaternion), this.unitY.set(0, 1, 0).applyQuaternion(e === "local" ? this.worldQuaternion : this.identityQuaternion), this.unitZ.set(0, 0, 1).applyQuaternion(e === "local" ? this.worldQuaternion : this.identityQuaternion), this.alignVector.copy(this.unitY), this.mode) {
         case "translate":
@@ -1969,96 +1969,96 @@ class Kc extends ae {
     });
   }
 }
-var qc = Object.defineProperty, Qc = (o, e, t) => e in o ? qc(o, e, { enumerable: !0, configurable: !0, writable: !0, value: t }) : o[e] = t, Ze = (o, e, t) => (Qc(o, typeof e != "symbol" ? e + "" : e, t), t);
-const Rn = new _n(0, 0, 0, "YXZ"), Cn = new ee(), Jc = { type: "change" }, eu = { type: "lock" }, tu = { type: "unlock" }, Ur = Math.PI / 2;
-class qi extends Yo {
+var ru = Object.defineProperty, ou = (o, e, t) => e in o ? ru(o, e, { enumerable: !0, configurable: !0, writable: !0, value: t }) : o[e] = t, Ke = (o, e, t) => (ou(o, typeof e != "symbol" ? e + "" : e, t), t);
+const In = new Tn(0, 0, 0, "YXZ"), Dn = new q(), au = { type: "change" }, lu = { type: "lock" }, cu = { type: "unlock" }, Gr = Math.PI / 2;
+class nr extends Qo {
   constructor(e, t) {
-    super(), Ze(this, "camera"), Ze(this, "domElement"), Ze(this, "isLocked"), Ze(this, "minPolarAngle"), Ze(this, "maxPolarAngle"), Ze(this, "pointerSpeed"), Ze(this, "onMouseMove", (n) => {
+    super(), Ke(this, "camera"), Ke(this, "domElement"), Ke(this, "isLocked"), Ke(this, "minPolarAngle"), Ke(this, "maxPolarAngle"), Ke(this, "pointerSpeed"), Ke(this, "onMouseMove", (n) => {
       if (!this.domElement || this.isLocked === !1)
         return;
       const s = n.movementX || n.mozMovementX || n.webkitMovementX || 0, i = n.movementY || n.mozMovementY || n.webkitMovementY || 0;
-      Rn.setFromQuaternion(this.camera.quaternion), Rn.y -= s * 2e-3 * this.pointerSpeed, Rn.x -= i * 2e-3 * this.pointerSpeed, Rn.x = Math.max(Ur - this.maxPolarAngle, Math.min(Ur - this.minPolarAngle, Rn.x)), this.camera.quaternion.setFromEuler(Rn), this.dispatchEvent(Jc);
-    }), Ze(this, "onPointerlockChange", () => {
-      this.domElement && (this.domElement.ownerDocument.pointerLockElement === this.domElement ? (this.dispatchEvent(eu), this.isLocked = !0) : (this.dispatchEvent(tu), this.isLocked = !1));
-    }), Ze(this, "onPointerlockError", () => {
+      In.setFromQuaternion(this.camera.quaternion), In.y -= s * 2e-3 * this.pointerSpeed, In.x -= i * 2e-3 * this.pointerSpeed, In.x = Math.max(Gr - this.maxPolarAngle, Math.min(Gr - this.minPolarAngle, In.x)), this.camera.quaternion.setFromEuler(In), this.dispatchEvent(au);
+    }), Ke(this, "onPointerlockChange", () => {
+      this.domElement && (this.domElement.ownerDocument.pointerLockElement === this.domElement ? (this.dispatchEvent(lu), this.isLocked = !0) : (this.dispatchEvent(cu), this.isLocked = !1));
+    }), Ke(this, "onPointerlockError", () => {
       console.error("THREE.PointerLockControls: Unable to use Pointer Lock API");
-    }), Ze(this, "connect", (n) => {
+    }), Ke(this, "connect", (n) => {
       this.domElement = n || this.domElement, this.domElement && (this.domElement.ownerDocument.addEventListener("mousemove", this.onMouseMove), this.domElement.ownerDocument.addEventListener("pointerlockchange", this.onPointerlockChange), this.domElement.ownerDocument.addEventListener("pointerlockerror", this.onPointerlockError));
-    }), Ze(this, "disconnect", () => {
+    }), Ke(this, "disconnect", () => {
       this.domElement && (this.domElement.ownerDocument.removeEventListener("mousemove", this.onMouseMove), this.domElement.ownerDocument.removeEventListener("pointerlockchange", this.onPointerlockChange), this.domElement.ownerDocument.removeEventListener("pointerlockerror", this.onPointerlockError));
-    }), Ze(this, "dispose", () => {
+    }), Ke(this, "dispose", () => {
       this.disconnect();
-    }), Ze(this, "getObject", () => this.camera), Ze(this, "direction", new ee(0, 0, -1)), Ze(this, "getDirection", (n) => n.copy(this.direction).applyQuaternion(this.camera.quaternion)), Ze(this, "moveForward", (n) => {
-      Cn.setFromMatrixColumn(this.camera.matrix, 0), Cn.crossVectors(this.camera.up, Cn), this.camera.position.addScaledVector(Cn, n);
-    }), Ze(this, "moveRight", (n) => {
-      Cn.setFromMatrixColumn(this.camera.matrix, 0), this.camera.position.addScaledVector(Cn, n);
-    }), Ze(this, "lock", () => {
+    }), Ke(this, "getObject", () => this.camera), Ke(this, "direction", new q(0, 0, -1)), Ke(this, "getDirection", (n) => n.copy(this.direction).applyQuaternion(this.camera.quaternion)), Ke(this, "moveForward", (n) => {
+      Dn.setFromMatrixColumn(this.camera.matrix, 0), Dn.crossVectors(this.camera.up, Dn), this.camera.position.addScaledVector(Dn, n);
+    }), Ke(this, "moveRight", (n) => {
+      Dn.setFromMatrixColumn(this.camera.matrix, 0), this.camera.position.addScaledVector(Dn, n);
+    }), Ke(this, "lock", () => {
       this.domElement && this.domElement.requestPointerLock();
-    }), Ze(this, "unlock", () => {
+    }), Ke(this, "unlock", () => {
       this.domElement && this.domElement.ownerDocument.exitPointerLock();
     }), this.camera = e, this.domElement = t, this.isLocked = !1, this.minPolarAngle = 0, this.maxPolarAngle = Math.PI, this.pointerSpeed = 1, t && this.connect(t);
   }
 }
-var nu = Object.defineProperty, su = (o, e, t) => e in o ? nu(o, e, { enumerable: !0, configurable: !0, writable: !0, value: t }) : o[e] = t, ge = (o, e, t) => (su(o, typeof e != "symbol" ? e + "" : e, t), t);
-const As = new hl(), Br = new lr(), iu = Math.cos(70 * (Math.PI / 180)), Nr = (o, e) => (o % e + e) % e;
-class wa extends Yo {
+var uu = Object.defineProperty, hu = (o, e, t) => e in o ? uu(o, e, { enumerable: !0, configurable: !0, writable: !0, value: t }) : o[e] = t, ve = (o, e, t) => (hu(o, typeof e != "symbol" ? e + "" : e, t), t);
+const Ls = new yl(), Vr = new ii(), fu = Math.cos(70 * (Math.PI / 180)), Wr = (o, e) => (o % e + e) % e;
+class Pa extends Qo {
   constructor(e, t) {
-    super(), ge(this, "object"), ge(this, "domElement"), ge(this, "enabled", !0), ge(this, "target", new ee()), ge(this, "minDistance", 0), ge(this, "maxDistance", 1 / 0), ge(this, "minZoom", 0), ge(this, "maxZoom", 1 / 0), ge(this, "minPolarAngle", 0), ge(this, "maxPolarAngle", Math.PI), ge(this, "minAzimuthAngle", -1 / 0), ge(this, "maxAzimuthAngle", 1 / 0), ge(this, "enableDamping", !1), ge(this, "dampingFactor", 0.05), ge(this, "enableZoom", !0), ge(this, "zoomSpeed", 1), ge(this, "enableRotate", !0), ge(this, "rotateSpeed", 1), ge(this, "enablePan", !0), ge(this, "panSpeed", 1), ge(this, "screenSpacePanning", !0), ge(this, "keyPanSpeed", 7), ge(this, "zoomToCursor", !1), ge(this, "autoRotate", !1), ge(this, "autoRotateSpeed", 2), ge(this, "reverseOrbit", !1), ge(this, "reverseHorizontalOrbit", !1), ge(this, "reverseVerticalOrbit", !1), ge(this, "keys", { LEFT: "ArrowLeft", UP: "ArrowUp", RIGHT: "ArrowRight", BOTTOM: "ArrowDown" }), ge(this, "mouseButtons", {
-      LEFT: on.ROTATE,
-      MIDDLE: on.DOLLY,
-      RIGHT: on.PAN
-    }), ge(this, "touches", { ONE: Lt.ROTATE, TWO: Lt.DOLLY_PAN }), ge(this, "target0"), ge(this, "position0"), ge(this, "zoom0"), ge(this, "_domElementKeyEvents", null), ge(this, "getPolarAngle"), ge(this, "getAzimuthalAngle"), ge(this, "setPolarAngle"), ge(this, "setAzimuthalAngle"), ge(this, "getDistance"), ge(this, "listenToKeyEvents"), ge(this, "stopListenToKeyEvents"), ge(this, "saveState"), ge(this, "reset"), ge(this, "update"), ge(this, "connect"), ge(this, "dispose"), this.object = e, this.domElement = t, this.target0 = this.target.clone(), this.position0 = this.object.position.clone(), this.zoom0 = this.object.zoom, this.getPolarAngle = () => u.phi, this.getAzimuthalAngle = () => u.theta, this.setPolarAngle = (j) => {
-      let ie = Nr(j, 2 * Math.PI), ve = u.phi;
-      ve < 0 && (ve += 2 * Math.PI), ie < 0 && (ie += 2 * Math.PI);
-      let Oe = Math.abs(ie - ve);
-      2 * Math.PI - Oe < Oe && (ie < ve ? ie += 2 * Math.PI : ve += 2 * Math.PI), h.phi = ie - ve, n.update();
-    }, this.setAzimuthalAngle = (j) => {
-      let ie = Nr(j, 2 * Math.PI), ve = u.theta;
-      ve < 0 && (ve += 2 * Math.PI), ie < 0 && (ie += 2 * Math.PI);
-      let Oe = Math.abs(ie - ve);
-      2 * Math.PI - Oe < Oe && (ie < ve ? ie += 2 * Math.PI : ve += 2 * Math.PI), h.theta = ie - ve, n.update();
-    }, this.getDistance = () => n.object.position.distanceTo(n.target), this.listenToKeyEvents = (j) => {
-      j.addEventListener("keydown", An), this._domElementKeyEvents = j;
+    super(), ve(this, "object"), ve(this, "domElement"), ve(this, "enabled", !0), ve(this, "target", new q()), ve(this, "minDistance", 0), ve(this, "maxDistance", 1 / 0), ve(this, "minZoom", 0), ve(this, "maxZoom", 1 / 0), ve(this, "minPolarAngle", 0), ve(this, "maxPolarAngle", Math.PI), ve(this, "minAzimuthAngle", -1 / 0), ve(this, "maxAzimuthAngle", 1 / 0), ve(this, "enableDamping", !1), ve(this, "dampingFactor", 0.05), ve(this, "enableZoom", !0), ve(this, "zoomSpeed", 1), ve(this, "enableRotate", !0), ve(this, "rotateSpeed", 1), ve(this, "enablePan", !0), ve(this, "panSpeed", 1), ve(this, "screenSpacePanning", !0), ve(this, "keyPanSpeed", 7), ve(this, "zoomToCursor", !1), ve(this, "autoRotate", !1), ve(this, "autoRotateSpeed", 2), ve(this, "reverseOrbit", !1), ve(this, "reverseHorizontalOrbit", !1), ve(this, "reverseVerticalOrbit", !1), ve(this, "keys", { LEFT: "ArrowLeft", UP: "ArrowUp", RIGHT: "ArrowRight", BOTTOM: "ArrowDown" }), ve(this, "mouseButtons", {
+      LEFT: ln.ROTATE,
+      MIDDLE: ln.DOLLY,
+      RIGHT: ln.PAN
+    }), ve(this, "touches", { ONE: Ft.ROTATE, TWO: Ft.DOLLY_PAN }), ve(this, "target0"), ve(this, "position0"), ve(this, "zoom0"), ve(this, "_domElementKeyEvents", null), ve(this, "getPolarAngle"), ve(this, "getAzimuthalAngle"), ve(this, "setPolarAngle"), ve(this, "setAzimuthalAngle"), ve(this, "getDistance"), ve(this, "listenToKeyEvents"), ve(this, "stopListenToKeyEvents"), ve(this, "saveState"), ve(this, "reset"), ve(this, "update"), ve(this, "connect"), ve(this, "dispose"), this.object = e, this.domElement = t, this.target0 = this.target.clone(), this.position0 = this.object.position.clone(), this.zoom0 = this.object.zoom, this.getPolarAngle = () => u.phi, this.getAzimuthalAngle = () => u.theta, this.setPolarAngle = (G) => {
+      let ie = Wr(G, 2 * Math.PI), _e = u.phi;
+      _e < 0 && (_e += 2 * Math.PI), ie < 0 && (ie += 2 * Math.PI);
+      let Fe = Math.abs(ie - _e);
+      2 * Math.PI - Fe < Fe && (ie < _e ? ie += 2 * Math.PI : _e += 2 * Math.PI), h.phi = ie - _e, n.update();
+    }, this.setAzimuthalAngle = (G) => {
+      let ie = Wr(G, 2 * Math.PI), _e = u.theta;
+      _e < 0 && (_e += 2 * Math.PI), ie < 0 && (ie += 2 * Math.PI);
+      let Fe = Math.abs(ie - _e);
+      2 * Math.PI - Fe < Fe && (ie < _e ? ie += 2 * Math.PI : _e += 2 * Math.PI), h.theta = ie - _e, n.update();
+    }, this.getDistance = () => n.object.position.distanceTo(n.target), this.listenToKeyEvents = (G) => {
+      G.addEventListener("keydown", Cn), this._domElementKeyEvents = G;
     }, this.stopListenToKeyEvents = () => {
-      this._domElementKeyEvents.removeEventListener("keydown", An), this._domElementKeyEvents = null;
+      this._domElementKeyEvents.removeEventListener("keydown", Cn), this._domElementKeyEvents = null;
     }, this.saveState = () => {
       n.target0.copy(n.target), n.position0.copy(n.object.position), n.zoom0 = n.object.zoom;
     }, this.reset = () => {
       n.target.copy(n.target0), n.object.position.copy(n.position0), n.object.zoom = n.zoom0, n.object.updateProjectionMatrix(), n.dispatchEvent(s), n.update(), l = a.NONE;
     }, this.update = (() => {
-      const j = new ee(), ie = new ee(0, 1, 0), ve = new He().setFromUnitVectors(e.up, ie), Oe = ve.clone().invert(), Qe = new ee(), Ut = new He(), Zt = 2 * Math.PI;
+      const G = new q(), ie = new q(0, 1, 0), _e = new He().setFromUnitVectors(e.up, ie), Fe = _e.clone().invert(), Qe = new q(), zt = new He(), Qt = 2 * Math.PI;
       return function() {
-        const Sr = n.object.position;
-        ve.setFromUnitVectors(e.up, ie), Oe.copy(ve).invert(), j.copy(Sr).sub(n.target), j.applyQuaternion(ve), u.setFromVector3(j), n.autoRotate && l === a.NONE && N(I()), n.enableDamping ? (u.theta += h.theta * n.dampingFactor, u.phi += h.phi * n.dampingFactor) : (u.theta += h.theta, u.phi += h.phi);
-        let Bt = n.minAzimuthAngle, Nt = n.maxAzimuthAngle;
-        isFinite(Bt) && isFinite(Nt) && (Bt < -Math.PI ? Bt += Zt : Bt > Math.PI && (Bt -= Zt), Nt < -Math.PI ? Nt += Zt : Nt > Math.PI && (Nt -= Zt), Bt <= Nt ? u.theta = Math.max(Bt, Math.min(Nt, u.theta)) : u.theta = u.theta > (Bt + Nt) / 2 ? Math.max(Bt, u.theta) : Math.min(Nt, u.theta)), u.phi = Math.max(n.minPolarAngle, Math.min(n.maxPolarAngle, u.phi)), u.makeSafe(), n.enableDamping === !0 ? n.target.addScaledVector(p, n.dampingFactor) : n.target.add(p), n.zoomToCursor && w || n.object.isOrthographicCamera ? u.radius = H(u.radius) : u.radius = H(u.radius * m), j.setFromSpherical(u), j.applyQuaternion(Oe), Sr.copy(n.target).add(j), n.object.matrixAutoUpdate || n.object.updateMatrix(), n.object.lookAt(n.target), n.enableDamping === !0 ? (h.theta *= 1 - n.dampingFactor, h.phi *= 1 - n.dampingFactor, p.multiplyScalar(1 - n.dampingFactor)) : (h.set(0, 0, 0), p.set(0, 0, 0));
-        let Vn = !1;
-        if (n.zoomToCursor && w) {
-          let Yn = null;
-          if (n.object instanceof Mt && n.object.isPerspectiveCamera) {
-            const Xn = j.length();
-            Yn = H(Xn * m);
-            const _s = Xn - Yn;
-            n.object.position.addScaledVector(M, _s), n.object.updateMatrixWorld();
+        const Dr = n.object.position;
+        _e.setFromUnitVectors(e.up, ie), Fe.copy(_e).invert(), G.copy(Dr).sub(n.target), G.applyQuaternion(_e), u.setFromVector3(G), n.autoRotate && l === a.NONE && z(I()), n.enableDamping ? (u.theta += h.theta * n.dampingFactor, u.phi += h.phi * n.dampingFactor) : (u.theta += h.theta, u.phi += h.phi);
+        let Ht = n.minAzimuthAngle, jt = n.maxAzimuthAngle;
+        isFinite(Ht) && isFinite(jt) && (Ht < -Math.PI ? Ht += Qt : Ht > Math.PI && (Ht -= Qt), jt < -Math.PI ? jt += Qt : jt > Math.PI && (jt -= Qt), Ht <= jt ? u.theta = Math.max(Ht, Math.min(jt, u.theta)) : u.theta = u.theta > (Ht + jt) / 2 ? Math.max(Ht, u.theta) : Math.min(jt, u.theta)), u.phi = Math.max(n.minPolarAngle, Math.min(n.maxPolarAngle, u.phi)), u.makeSafe(), n.enableDamping === !0 ? n.target.addScaledVector(d, n.dampingFactor) : n.target.add(d), n.zoomToCursor && b || n.object.isOrthographicCamera ? u.radius = H(u.radius) : u.radius = H(u.radius * f), G.setFromSpherical(u), G.applyQuaternion(Fe), Dr.copy(n.target).add(G), n.object.matrixAutoUpdate || n.object.updateMatrix(), n.object.lookAt(n.target), n.enableDamping === !0 ? (h.theta *= 1 - n.dampingFactor, h.phi *= 1 - n.dampingFactor, d.multiplyScalar(1 - n.dampingFactor)) : (h.set(0, 0, 0), d.set(0, 0, 0));
+        let Kn = !1;
+        if (n.zoomToCursor && b) {
+          let qn = null;
+          if (n.object instanceof wt && n.object.isPerspectiveCamera) {
+            const Qn = G.length();
+            qn = H(Qn * f);
+            const Ms = Qn - qn;
+            n.object.position.addScaledVector(E, Ms), n.object.updateMatrixWorld();
           } else if (n.object.isOrthographicCamera) {
-            const Xn = new ee(d.x, d.y, 0);
-            Xn.unproject(n.object), n.object.zoom = Math.max(n.minZoom, Math.min(n.maxZoom, n.object.zoom / m)), n.object.updateProjectionMatrix(), Vn = !0;
-            const _s = new ee(d.x, d.y, 0);
-            _s.unproject(n.object), n.object.position.sub(_s).add(Xn), n.object.updateMatrixWorld(), Yn = j.length();
+            const Qn = new q(m.x, m.y, 0);
+            Qn.unproject(n.object), n.object.zoom = Math.max(n.minZoom, Math.min(n.maxZoom, n.object.zoom / f)), n.object.updateProjectionMatrix(), Kn = !0;
+            const Ms = new q(m.x, m.y, 0);
+            Ms.unproject(n.object), n.object.position.sub(Ms).add(Qn), n.object.updateMatrixWorld(), qn = G.length();
           } else
             console.warn("WARNING: OrbitControls.js encountered an unknown camera type - zoom to cursor disabled."), n.zoomToCursor = !1;
-          Yn !== null && (n.screenSpacePanning ? n.target.set(0, 0, -1).transformDirection(n.object.matrix).multiplyScalar(Yn).add(n.object.position) : (As.origin.copy(n.object.position), As.direction.set(0, 0, -1).transformDirection(n.object.matrix), Math.abs(n.object.up.dot(As.direction)) < iu ? e.lookAt(n.target) : (Br.setFromNormalAndCoplanarPoint(n.object.up, n.target), As.intersectPlane(Br, n.target))));
+          qn !== null && (n.screenSpacePanning ? n.target.set(0, 0, -1).transformDirection(n.object.matrix).multiplyScalar(qn).add(n.object.position) : (Ls.origin.copy(n.object.position), Ls.direction.set(0, 0, -1).transformDirection(n.object.matrix), Math.abs(n.object.up.dot(Ls.direction)) < fu ? e.lookAt(n.target) : (Vr.setFromNormalAndCoplanarPoint(n.object.up, n.target), Ls.intersectPlane(Vr, n.target))));
         } else
-          n.object instanceof jt && n.object.isOrthographicCamera && (Vn = m !== 1, Vn && (n.object.zoom = Math.max(n.minZoom, Math.min(n.maxZoom, n.object.zoom / m)), n.object.updateProjectionMatrix()));
-        return m = 1, w = !1, Vn || Qe.distanceToSquared(n.object.position) > c || 8 * (1 - Ut.dot(n.object.quaternion)) > c ? (n.dispatchEvent(s), Qe.copy(n.object.position), Ut.copy(n.object.quaternion), Vn = !1, !0) : !1;
+          n.object instanceof Xt && n.object.isOrthographicCamera && (Kn = f !== 1, Kn && (n.object.zoom = Math.max(n.minZoom, Math.min(n.maxZoom, n.object.zoom / f)), n.object.updateProjectionMatrix()));
+        return f = 1, b = !1, Kn || Qe.distanceToSquared(n.object.position) > c || 8 * (1 - zt.dot(n.object.quaternion)) > c ? (n.dispatchEvent(s), Qe.copy(n.object.position), zt.copy(n.object.quaternion), Kn = !1, !0) : !1;
       };
-    })(), this.connect = (j) => {
-      j === document && console.error(
+    })(), this.connect = (G) => {
+      G === document && console.error(
         'THREE.OrbitControls: "document" should not be used as the target "domElement". Please use "renderer.domElement" instead.'
-      ), n.domElement = j, n.domElement.style.touchAction = "none", n.domElement.addEventListener("contextmenu", br), n.domElement.addEventListener("pointerdown", Me), n.domElement.addEventListener("pointercancel", kt), n.domElement.addEventListener("wheel", gt);
+      ), n.domElement = G, n.domElement.style.touchAction = "none", n.domElement.addEventListener("contextmenu", Cr), n.domElement.addEventListener("pointerdown", Se), n.domElement.addEventListener("pointercancel", Nt), n.domElement.addEventListener("wheel", gt);
     }, this.dispose = () => {
-      var j, ie, ve, Oe, Qe, Ut;
-      (j = n.domElement) == null || j.removeEventListener("contextmenu", br), (ie = n.domElement) == null || ie.removeEventListener("pointerdown", Me), (ve = n.domElement) == null || ve.removeEventListener("pointercancel", kt), (Oe = n.domElement) == null || Oe.removeEventListener("wheel", gt), (Qe = n.domElement) == null || Qe.ownerDocument.removeEventListener("pointermove", Se), (Ut = n.domElement) == null || Ut.ownerDocument.removeEventListener("pointerup", qe), n._domElementKeyEvents !== null && n._domElementKeyEvents.removeEventListener("keydown", An);
+      var G, ie, _e, Fe, Qe, zt;
+      (G = n.domElement) == null || G.removeEventListener("contextmenu", Cr), (ie = n.domElement) == null || ie.removeEventListener("pointerdown", Se), (_e = n.domElement) == null || _e.removeEventListener("pointercancel", Nt), (Fe = n.domElement) == null || Fe.removeEventListener("wheel", gt), (Qe = n.domElement) == null || Qe.ownerDocument.removeEventListener("pointermove", Me), (zt = n.domElement) == null || zt.ownerDocument.removeEventListener("pointerup", qe), n._domElementKeyEvents !== null && n._domElementKeyEvents.removeEventListener("keydown", Cn);
     };
     const n = this, s = { type: "change" }, i = { type: "start" }, r = { type: "end" }, a = {
       NONE: -1,
@@ -2071,94 +2071,94 @@ class wa extends Yo {
       TOUCH_DOLLY_ROTATE: 6
     };
     let l = a.NONE;
-    const c = 1e-6, u = new Ws(), h = new Ws();
-    let m = 1;
-    const p = new ee(), v = new le(), _ = new le(), y = new le(), E = new le(), R = new le(), T = new le(), g = new le(), A = new le(), x = new le(), M = new ee(), d = new le();
-    let w = !1;
-    const f = [], P = {};
+    const c = 1e-6, u = new qs(), h = new qs();
+    let f = 1;
+    const d = new q(), y = new he(), x = new he(), g = new he(), v = new he(), M = new he(), _ = new he(), w = new he(), P = new he(), T = new he(), E = new q(), m = new he();
+    let b = !1;
+    const p = [], C = {};
     function I() {
       return 2 * Math.PI / 60 / 60 * n.autoRotateSpeed;
     }
     function K() {
       return Math.pow(0.95, n.zoomSpeed);
     }
-    function N(j) {
-      n.reverseOrbit || n.reverseHorizontalOrbit ? h.theta += j : h.theta -= j;
+    function z(G) {
+      n.reverseOrbit || n.reverseHorizontalOrbit ? h.theta += G : h.theta -= G;
     }
-    function Z(j) {
-      n.reverseOrbit || n.reverseVerticalOrbit ? h.phi += j : h.phi -= j;
+    function Y(G) {
+      n.reverseOrbit || n.reverseVerticalOrbit ? h.phi += G : h.phi -= G;
     }
     const W = (() => {
-      const j = new ee();
-      return function(ve, Oe) {
-        j.setFromMatrixColumn(Oe, 0), j.multiplyScalar(-ve), p.add(j);
+      const G = new q();
+      return function(_e, Fe) {
+        G.setFromMatrixColumn(Fe, 0), G.multiplyScalar(-_e), d.add(G);
       };
     })(), X = (() => {
-      const j = new ee();
-      return function(ve, Oe) {
-        n.screenSpacePanning === !0 ? j.setFromMatrixColumn(Oe, 1) : (j.setFromMatrixColumn(Oe, 0), j.crossVectors(n.object.up, j)), j.multiplyScalar(ve), p.add(j);
+      const G = new q();
+      return function(_e, Fe) {
+        n.screenSpacePanning === !0 ? G.setFromMatrixColumn(Fe, 1) : (G.setFromMatrixColumn(Fe, 0), G.crossVectors(n.object.up, G)), G.multiplyScalar(_e), d.add(G);
       };
     })(), V = (() => {
-      const j = new ee();
-      return function(ve, Oe) {
+      const G = new q();
+      return function(_e, Fe) {
         const Qe = n.domElement;
-        if (Qe && n.object instanceof Mt && n.object.isPerspectiveCamera) {
-          const Ut = n.object.position;
-          j.copy(Ut).sub(n.target);
-          let Zt = j.length();
-          Zt *= Math.tan(n.object.fov / 2 * Math.PI / 180), W(2 * ve * Zt / Qe.clientHeight, n.object.matrix), X(2 * Oe * Zt / Qe.clientHeight, n.object.matrix);
+        if (Qe && n.object instanceof wt && n.object.isPerspectiveCamera) {
+          const zt = n.object.position;
+          G.copy(zt).sub(n.target);
+          let Qt = G.length();
+          Qt *= Math.tan(n.object.fov / 2 * Math.PI / 180), W(2 * _e * Qt / Qe.clientHeight, n.object.matrix), X(2 * Fe * Qt / Qe.clientHeight, n.object.matrix);
         } else
-          Qe && n.object instanceof jt && n.object.isOrthographicCamera ? (W(
-            ve * (n.object.right - n.object.left) / n.object.zoom / Qe.clientWidth,
+          Qe && n.object instanceof Xt && n.object.isOrthographicCamera ? (W(
+            _e * (n.object.right - n.object.left) / n.object.zoom / Qe.clientWidth,
             n.object.matrix
           ), X(
-            Oe * (n.object.top - n.object.bottom) / n.object.zoom / Qe.clientHeight,
+            Fe * (n.object.top - n.object.bottom) / n.object.zoom / Qe.clientHeight,
             n.object.matrix
           )) : (console.warn("WARNING: OrbitControls.js encountered an unknown camera type - pan disabled."), n.enablePan = !1);
       };
     })();
-    function ne(j) {
-      n.object instanceof Mt && n.object.isPerspectiveCamera || n.object instanceof jt && n.object.isOrthographicCamera ? m /= j : (console.warn("WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."), n.enableZoom = !1);
+    function te(G) {
+      n.object instanceof wt && n.object.isPerspectiveCamera || n.object instanceof Xt && n.object.isOrthographicCamera ? f /= G : (console.warn("WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."), n.enableZoom = !1);
     }
-    function se(j) {
-      n.object instanceof Mt && n.object.isPerspectiveCamera || n.object instanceof jt && n.object.isOrthographicCamera ? m *= j : (console.warn("WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."), n.enableZoom = !1);
+    function se(G) {
+      n.object instanceof wt && n.object.isPerspectiveCamera || n.object instanceof Xt && n.object.isOrthographicCamera ? f *= G : (console.warn("WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."), n.enableZoom = !1);
     }
-    function he(j) {
+    function fe(G) {
       if (!n.zoomToCursor || !n.domElement)
         return;
-      w = !0;
-      const ie = n.domElement.getBoundingClientRect(), ve = j.clientX - ie.left, Oe = j.clientY - ie.top, Qe = ie.width, Ut = ie.height;
-      d.x = ve / Qe * 2 - 1, d.y = -(Oe / Ut) * 2 + 1, M.set(d.x, d.y, 1).unproject(n.object).sub(n.object.position).normalize();
+      b = !0;
+      const ie = n.domElement.getBoundingClientRect(), _e = G.clientX - ie.left, Fe = G.clientY - ie.top, Qe = ie.width, zt = ie.height;
+      m.x = _e / Qe * 2 - 1, m.y = -(Fe / zt) * 2 + 1, E.set(m.x, m.y, 1).unproject(n.object).sub(n.object.position).normalize();
     }
-    function H(j) {
-      return Math.max(n.minDistance, Math.min(n.maxDistance, j));
+    function H(G) {
+      return Math.max(n.minDistance, Math.min(n.maxDistance, G));
     }
-    function k(j) {
-      v.set(j.clientX, j.clientY);
+    function k(G) {
+      y.set(G.clientX, G.clientY);
     }
-    function b(j) {
-      he(j), g.set(j.clientX, j.clientY);
+    function S(G) {
+      fe(G), w.set(G.clientX, G.clientY);
     }
-    function U(j) {
-      E.set(j.clientX, j.clientY);
+    function U(G) {
+      v.set(G.clientX, G.clientY);
     }
-    function J(j) {
-      _.set(j.clientX, j.clientY), y.subVectors(_, v).multiplyScalar(n.rotateSpeed);
+    function ee(G) {
+      x.set(G.clientX, G.clientY), g.subVectors(x, y).multiplyScalar(n.rotateSpeed);
       const ie = n.domElement;
-      ie && (N(2 * Math.PI * y.x / ie.clientHeight), Z(2 * Math.PI * y.y / ie.clientHeight)), v.copy(_), n.update();
+      ie && (z(2 * Math.PI * g.x / ie.clientHeight), Y(2 * Math.PI * g.y / ie.clientHeight)), y.copy(x), n.update();
     }
-    function F(j) {
-      A.set(j.clientX, j.clientY), x.subVectors(A, g), x.y > 0 ? ne(K()) : x.y < 0 && se(K()), g.copy(A), n.update();
+    function F(G) {
+      P.set(G.clientX, G.clientY), T.subVectors(P, w), T.y > 0 ? te(K()) : T.y < 0 && se(K()), w.copy(P), n.update();
     }
-    function B(j) {
-      R.set(j.clientX, j.clientY), T.subVectors(R, E).multiplyScalar(n.panSpeed), V(T.x, T.y), E.copy(R), n.update();
+    function N(G) {
+      M.set(G.clientX, G.clientY), _.subVectors(M, v).multiplyScalar(n.panSpeed), V(_.x, _.y), v.copy(M), n.update();
     }
-    function S(j) {
-      he(j), j.deltaY < 0 ? se(K()) : j.deltaY > 0 && ne(K()), n.update();
+    function A(G) {
+      fe(G), G.deltaY < 0 ? se(K()) : G.deltaY > 0 && te(K()), n.update();
     }
-    function C(j) {
+    function R(G) {
       let ie = !1;
-      switch (j.code) {
+      switch (G.code) {
         case n.keys.UP:
           V(0, n.keyPanSpeed), ie = !0;
           break;
@@ -2172,81 +2172,81 @@ class wa extends Yo {
           V(-n.keyPanSpeed, 0), ie = !0;
           break;
       }
-      ie && (j.preventDefault(), n.update());
+      ie && (G.preventDefault(), n.update());
     }
     function D() {
-      if (f.length == 1)
-        v.set(f[0].pageX, f[0].pageY);
+      if (p.length == 1)
+        y.set(p[0].pageX, p[0].pageY);
       else {
-        const j = 0.5 * (f[0].pageX + f[1].pageX), ie = 0.5 * (f[0].pageY + f[1].pageY);
-        v.set(j, ie);
+        const G = 0.5 * (p[0].pageX + p[1].pageX), ie = 0.5 * (p[0].pageY + p[1].pageY);
+        y.set(G, ie);
       }
     }
-    function G() {
-      if (f.length == 1)
-        E.set(f[0].pageX, f[0].pageY);
+    function j() {
+      if (p.length == 1)
+        v.set(p[0].pageX, p[0].pageY);
       else {
-        const j = 0.5 * (f[0].pageX + f[1].pageX), ie = 0.5 * (f[0].pageY + f[1].pageY);
-        E.set(j, ie);
+        const G = 0.5 * (p[0].pageX + p[1].pageX), ie = 0.5 * (p[0].pageY + p[1].pageY);
+        v.set(G, ie);
       }
     }
-    function $() {
-      const j = f[0].pageX - f[1].pageX, ie = f[0].pageY - f[1].pageY, ve = Math.sqrt(j * j + ie * ie);
-      g.set(0, ve);
+    function Z() {
+      const G = p[0].pageX - p[1].pageX, ie = p[0].pageY - p[1].pageY, _e = Math.sqrt(G * G + ie * ie);
+      w.set(0, _e);
     }
-    function Y() {
-      n.enableZoom && $(), n.enablePan && G();
+    function $() {
+      n.enableZoom && Z(), n.enablePan && j();
     }
-    function te() {
-      n.enableZoom && $(), n.enableRotate && D();
+    function ne() {
+      n.enableZoom && Z(), n.enableRotate && D();
     }
-    function O(j) {
-      if (f.length == 1)
-        _.set(j.pageX, j.pageY);
+    function L(G) {
+      if (p.length == 1)
+        x.set(G.pageX, G.pageY);
       else {
-        const ve = si(j), Oe = 0.5 * (j.pageX + ve.x), Qe = 0.5 * (j.pageY + ve.y);
-        _.set(Oe, Qe);
+        const _e = ci(G), Fe = 0.5 * (G.pageX + _e.x), Qe = 0.5 * (G.pageY + _e.y);
+        x.set(Fe, Qe);
       }
-      y.subVectors(_, v).multiplyScalar(n.rotateSpeed);
+      g.subVectors(x, y).multiplyScalar(n.rotateSpeed);
       const ie = n.domElement;
-      ie && (N(2 * Math.PI * y.x / ie.clientHeight), Z(2 * Math.PI * y.y / ie.clientHeight)), v.copy(_);
+      ie && (z(2 * Math.PI * g.x / ie.clientHeight), Y(2 * Math.PI * g.y / ie.clientHeight)), y.copy(x);
     }
-    function L(j) {
-      if (f.length == 1)
-        R.set(j.pageX, j.pageY);
+    function O(G) {
+      if (p.length == 1)
+        M.set(G.pageX, G.pageY);
       else {
-        const ie = si(j), ve = 0.5 * (j.pageX + ie.x), Oe = 0.5 * (j.pageY + ie.y);
-        R.set(ve, Oe);
+        const ie = ci(G), _e = 0.5 * (G.pageX + ie.x), Fe = 0.5 * (G.pageY + ie.y);
+        M.set(_e, Fe);
       }
-      T.subVectors(R, E).multiplyScalar(n.panSpeed), V(T.x, T.y), E.copy(R);
+      _.subVectors(M, v).multiplyScalar(n.panSpeed), V(_.x, _.y), v.copy(M);
     }
-    function re(j) {
-      const ie = si(j), ve = j.pageX - ie.x, Oe = j.pageY - ie.y, Qe = Math.sqrt(ve * ve + Oe * Oe);
-      A.set(0, Qe), x.set(0, Math.pow(A.y / g.y, n.zoomSpeed)), ne(x.y), g.copy(A);
+    function re(G) {
+      const ie = ci(G), _e = G.pageX - ie.x, Fe = G.pageY - ie.y, Qe = Math.sqrt(_e * _e + Fe * Fe);
+      P.set(0, Qe), T.set(0, Math.pow(P.y / w.y, n.zoomSpeed)), te(T.y), w.copy(P);
     }
-    function ce(j) {
-      n.enableZoom && re(j), n.enablePan && L(j);
+    function de(G) {
+      n.enableZoom && re(G), n.enablePan && O(G);
     }
-    function be(j) {
-      n.enableZoom && re(j), n.enableRotate && O(j);
+    function be(G) {
+      n.enableZoom && re(G), n.enableRotate && L(G);
     }
-    function Me(j) {
-      var ie, ve;
-      n.enabled !== !1 && (f.length === 0 && ((ie = n.domElement) == null || ie.ownerDocument.addEventListener("pointermove", Se), (ve = n.domElement) == null || ve.ownerDocument.addEventListener("pointerup", qe)), il(j), j.pointerType === "touch" ? nl(j) : jn(j));
+    function Se(G) {
+      var ie, _e;
+      n.enabled !== !1 && (p.length === 0 && ((ie = n.domElement) == null || ie.ownerDocument.addEventListener("pointermove", Me), (_e = n.domElement) == null || _e.ownerDocument.addEventListener("pointerup", qe)), hl(G), G.pointerType === "touch" ? cl(G) : Zn(G));
     }
-    function Se(j) {
-      n.enabled !== !1 && (j.pointerType === "touch" ? sl(j) : Sn(j));
+    function Me(G) {
+      n.enabled !== !1 && (G.pointerType === "touch" ? ul(G) : Pn(G));
     }
-    function qe(j) {
-      var ie, ve, Oe;
-      Er(j), f.length === 0 && ((ie = n.domElement) == null || ie.releasePointerCapture(j.pointerId), (ve = n.domElement) == null || ve.ownerDocument.removeEventListener("pointermove", Se), (Oe = n.domElement) == null || Oe.ownerDocument.removeEventListener("pointerup", qe)), n.dispatchEvent(r), l = a.NONE;
+    function qe(G) {
+      var ie, _e, Fe;
+      Rr(G), p.length === 0 && ((ie = n.domElement) == null || ie.releasePointerCapture(G.pointerId), (_e = n.domElement) == null || _e.ownerDocument.removeEventListener("pointermove", Me), (Fe = n.domElement) == null || Fe.ownerDocument.removeEventListener("pointerup", qe)), n.dispatchEvent(r), l = a.NONE;
     }
-    function kt(j) {
-      Er(j);
+    function Nt(G) {
+      Rr(G);
     }
-    function jn(j) {
+    function Zn(G) {
       let ie;
-      switch (j.button) {
+      switch (G.button) {
         case 0:
           ie = n.mouseButtons.LEFT;
           break;
@@ -2260,31 +2260,31 @@ class wa extends Yo {
           ie = -1;
       }
       switch (ie) {
-        case on.DOLLY:
+        case ln.DOLLY:
           if (n.enableZoom === !1)
             return;
-          b(j), l = a.DOLLY;
+          S(G), l = a.DOLLY;
           break;
-        case on.ROTATE:
-          if (j.ctrlKey || j.metaKey || j.shiftKey) {
+        case ln.ROTATE:
+          if (G.ctrlKey || G.metaKey || G.shiftKey) {
             if (n.enablePan === !1)
               return;
-            U(j), l = a.PAN;
+            U(G), l = a.PAN;
           } else {
             if (n.enableRotate === !1)
               return;
-            k(j), l = a.ROTATE;
+            k(G), l = a.ROTATE;
           }
           break;
-        case on.PAN:
-          if (j.ctrlKey || j.metaKey || j.shiftKey) {
+        case ln.PAN:
+          if (G.ctrlKey || G.metaKey || G.shiftKey) {
             if (n.enableRotate === !1)
               return;
-            k(j), l = a.ROTATE;
+            k(G), l = a.ROTATE;
           } else {
             if (n.enablePan === !1)
               return;
-            U(j), l = a.PAN;
+            U(G), l = a.PAN;
           }
           break;
         default:
@@ -2292,45 +2292,45 @@ class wa extends Yo {
       }
       l !== a.NONE && n.dispatchEvent(i);
     }
-    function Sn(j) {
+    function Pn(G) {
       if (n.enabled !== !1)
         switch (l) {
           case a.ROTATE:
             if (n.enableRotate === !1)
               return;
-            J(j);
+            ee(G);
             break;
           case a.DOLLY:
             if (n.enableZoom === !1)
               return;
-            F(j);
+            F(G);
             break;
           case a.PAN:
             if (n.enablePan === !1)
               return;
-            B(j);
+            N(G);
             break;
         }
     }
-    function gt(j) {
-      n.enabled === !1 || n.enableZoom === !1 || l !== a.NONE && l !== a.ROTATE || (j.preventDefault(), n.dispatchEvent(i), S(j), n.dispatchEvent(r));
+    function gt(G) {
+      n.enabled === !1 || n.enableZoom === !1 || l !== a.NONE && l !== a.ROTATE || (G.preventDefault(), n.dispatchEvent(i), A(G), n.dispatchEvent(r));
     }
-    function An(j) {
-      n.enabled === !1 || n.enablePan === !1 || C(j);
+    function Cn(G) {
+      n.enabled === !1 || n.enablePan === !1 || R(G);
     }
-    function nl(j) {
-      switch (Mr(j), f.length) {
+    function cl(G) {
+      switch (Ir(G), p.length) {
         case 1:
           switch (n.touches.ONE) {
-            case Lt.ROTATE:
+            case Ft.ROTATE:
               if (n.enableRotate === !1)
                 return;
               D(), l = a.TOUCH_ROTATE;
               break;
-            case Lt.PAN:
+            case Ft.PAN:
               if (n.enablePan === !1)
                 return;
-              G(), l = a.TOUCH_PAN;
+              j(), l = a.TOUCH_PAN;
               break;
             default:
               l = a.NONE;
@@ -2338,15 +2338,15 @@ class wa extends Yo {
           break;
         case 2:
           switch (n.touches.TWO) {
-            case Lt.DOLLY_PAN:
+            case Ft.DOLLY_PAN:
               if (n.enableZoom === !1 && n.enablePan === !1)
                 return;
-              Y(), l = a.TOUCH_DOLLY_PAN;
+              $(), l = a.TOUCH_DOLLY_PAN;
               break;
-            case Lt.DOLLY_ROTATE:
+            case Ft.DOLLY_ROTATE:
               if (n.enableZoom === !1 && n.enableRotate === !1)
                 return;
-              te(), l = a.TOUCH_DOLLY_ROTATE;
+              ne(), l = a.TOUCH_DOLLY_ROTATE;
               break;
             default:
               l = a.NONE;
@@ -2357,103 +2357,103 @@ class wa extends Yo {
       }
       l !== a.NONE && n.dispatchEvent(i);
     }
-    function sl(j) {
-      switch (Mr(j), l) {
+    function ul(G) {
+      switch (Ir(G), l) {
         case a.TOUCH_ROTATE:
           if (n.enableRotate === !1)
             return;
-          O(j), n.update();
+          L(G), n.update();
           break;
         case a.TOUCH_PAN:
           if (n.enablePan === !1)
             return;
-          L(j), n.update();
+          O(G), n.update();
           break;
         case a.TOUCH_DOLLY_PAN:
           if (n.enableZoom === !1 && n.enablePan === !1)
             return;
-          ce(j), n.update();
+          de(G), n.update();
           break;
         case a.TOUCH_DOLLY_ROTATE:
           if (n.enableZoom === !1 && n.enableRotate === !1)
             return;
-          be(j), n.update();
+          be(G), n.update();
           break;
         default:
           l = a.NONE;
       }
     }
-    function br(j) {
-      n.enabled !== !1 && j.preventDefault();
+    function Cr(G) {
+      n.enabled !== !1 && G.preventDefault();
     }
-    function il(j) {
-      f.push(j);
+    function hl(G) {
+      p.push(G);
     }
-    function Er(j) {
-      delete P[j.pointerId];
-      for (let ie = 0; ie < f.length; ie++)
-        if (f[ie].pointerId == j.pointerId) {
-          f.splice(ie, 1);
+    function Rr(G) {
+      delete C[G.pointerId];
+      for (let ie = 0; ie < p.length; ie++)
+        if (p[ie].pointerId == G.pointerId) {
+          p.splice(ie, 1);
           return;
         }
     }
-    function Mr(j) {
-      let ie = P[j.pointerId];
-      ie === void 0 && (ie = new le(), P[j.pointerId] = ie), ie.set(j.pageX, j.pageY);
+    function Ir(G) {
+      let ie = C[G.pointerId];
+      ie === void 0 && (ie = new he(), C[G.pointerId] = ie), ie.set(G.pageX, G.pageY);
     }
-    function si(j) {
-      const ie = j.pointerId === f[0].pointerId ? f[1] : f[0];
-      return P[ie.pointerId];
+    function ci(G) {
+      const ie = G.pointerId === p[0].pointerId ? p[1] : p[0];
+      return C[ie.pointerId];
     }
     t !== void 0 && this.connect(t), this.update();
   }
 }
-class ru extends wa {
+class du extends Pa {
   constructor(e, t) {
-    super(e, t), this.screenSpacePanning = !1, this.mouseButtons.LEFT = on.PAN, this.mouseButtons.RIGHT = on.ROTATE, this.touches.ONE = Lt.PAN, this.touches.TWO = Lt.DOLLY_ROTATE;
+    super(e, t), this.screenSpacePanning = !1, this.mouseButtons.LEFT = ln.PAN, this.mouseButtons.RIGHT = ln.ROTATE, this.touches.ONE = Ft.PAN, this.touches.TWO = Ft.DOLLY_ROTATE;
   }
 }
-class ou extends cs {
+class pu extends vs {
   constructor(e) {
     super(e), this.dracoLoader = null, this.ktx2Loader = null, this.meshoptDecoder = null, this.pluginCallbacks = [], this.register(function(t) {
-      return new hu(t);
-    }), this.register(function(t) {
       return new _u(t);
     }), this.register(function(t) {
-      return new xu(t);
+      return new Au(t);
     }), this.register(function(t) {
-      return new wu(t);
+      return new Pu(t);
     }), this.register(function(t) {
-      return new du(t);
+      return new Cu(t);
     }), this.register(function(t) {
-      return new pu(t);
+      return new wu(t);
     }), this.register(function(t) {
-      return new mu(t);
+      return new Tu(t);
     }), this.register(function(t) {
-      return new gu(t);
+      return new bu(t);
     }), this.register(function(t) {
-      return new uu(t);
+      return new Eu(t);
     }), this.register(function(t) {
       return new yu(t);
     }), this.register(function(t) {
-      return new fu(t);
+      return new Su(t);
     }), this.register(function(t) {
-      return new vu(t);
+      return new xu(t);
     }), this.register(function(t) {
-      return new lu(t);
+      return new Mu(t);
     }), this.register(function(t) {
-      return new Tu(t);
+      return new gu(t);
     }), this.register(function(t) {
-      return new bu(t);
+      return new Ru(t);
+    }), this.register(function(t) {
+      return new Iu(t);
     });
   }
   load(e, t, n, s) {
     const i = this;
     let r;
-    this.resourcePath !== "" ? r = this.resourcePath : this.path !== "" ? r = this.path : r = Ft.extractUrlBase(e), this.manager.itemStart(e);
+    this.resourcePath !== "" ? r = this.resourcePath : this.path !== "" ? r = this.path : r = Bt.extractUrlBase(e), this.manager.itemStart(e);
     const a = function(c) {
       s ? s(c) : console.error(c), i.manager.itemError(e), i.manager.itemEnd(e);
-    }, l = new Tn(this.manager);
+    }, l = new Sn(this.manager);
     l.setPath(this.path), l.setResponseType("arraybuffer"), l.setRequestHeader(this.requestHeader), l.setWithCredentials(this.withCredentials), l.load(
       e,
       function(c) {
@@ -2498,23 +2498,23 @@ class ou extends cs {
     if (typeof e == "string")
       i = JSON.parse(e);
     else if (e instanceof ArrayBuffer)
-      if (Ft.decodeText(new Uint8Array(e.slice(0, 4))) === Ta) {
+      if (Bt.decodeText(new Uint8Array(e.slice(0, 4))) === Ca) {
         try {
-          r[Ce.KHR_BINARY_GLTF] = new Eu(e);
+          r[Ie.KHR_BINARY_GLTF] = new Du(e);
         } catch (u) {
           s && s(u);
           return;
         }
-        i = JSON.parse(r[Ce.KHR_BINARY_GLTF].content);
+        i = JSON.parse(r[Ie.KHR_BINARY_GLTF].content);
       } else
-        i = JSON.parse(Ft.decodeText(new Uint8Array(e)));
+        i = JSON.parse(Bt.decodeText(new Uint8Array(e)));
     else
       i = e;
     if (i.asset === void 0 || i.asset.version[0] < 2) {
       s && s(new Error("THREE.GLTFLoader: Unsupported asset. glTF versions >=2.0 are supported."));
       return;
     }
-    const l = new Uu(i, {
+    const l = new Wu(i, {
       path: t || this.resourcePath || "",
       crossOrigin: this.crossOrigin,
       requestHeader: this.requestHeader,
@@ -2531,17 +2531,17 @@ class ou extends cs {
       for (let c = 0; c < i.extensionsUsed.length; ++c) {
         const u = i.extensionsUsed[c], h = i.extensionsRequired || [];
         switch (u) {
-          case Ce.KHR_MATERIALS_UNLIT:
-            r[u] = new cu();
+          case Ie.KHR_MATERIALS_UNLIT:
+            r[u] = new vu();
             break;
-          case Ce.KHR_DRACO_MESH_COMPRESSION:
-            r[u] = new Mu(i, this.dracoLoader);
+          case Ie.KHR_DRACO_MESH_COMPRESSION:
+            r[u] = new Ou(i, this.dracoLoader);
             break;
-          case Ce.KHR_TEXTURE_TRANSFORM:
-            r[u] = new Su();
+          case Ie.KHR_TEXTURE_TRANSFORM:
+            r[u] = new Lu();
             break;
-          case Ce.KHR_MESH_QUANTIZATION:
-            r[u] = new Au();
+          case Ie.KHR_MESH_QUANTIZATION:
+            r[u] = new Fu();
             break;
           default:
             h.indexOf(u) >= 0 && a[u] === void 0 && console.warn('THREE.GLTFLoader: Unknown extension "' + u + '".');
@@ -2556,7 +2556,7 @@ class ou extends cs {
     });
   }
 }
-function au() {
+function mu() {
   let o = {};
   return {
     get: function(e) {
@@ -2573,7 +2573,7 @@ function au() {
     }
   };
 }
-const Ce = {
+const Ie = {
   KHR_BINARY_GLTF: "KHR_binary_glTF",
   KHR_DRACO_MESH_COMPRESSION: "KHR_draco_mesh_compression",
   KHR_LIGHTS_PUNCTUAL: "KHR_lights_punctual",
@@ -2595,9 +2595,9 @@ const Ce = {
   EXT_MESHOPT_COMPRESSION: "EXT_meshopt_compression",
   EXT_MESH_GPU_INSTANCING: "EXT_mesh_gpu_instancing"
 };
-class lu {
+class gu {
   constructor(e) {
-    this.parser = e, this.name = Ce.KHR_LIGHTS_PUNCTUAL, this.cache = { refs: {}, uses: {} };
+    this.parser = e, this.name = Ie.KHR_LIGHTS_PUNCTUAL, this.cache = { refs: {}, uses: {} };
   }
   _markDefs() {
     const e = this.parser, t = this.parser.json.nodes || [];
@@ -2613,23 +2613,23 @@ class lu {
       return s;
     const i = t.json, l = ((i.extensions && i.extensions[this.name] || {}).lights || [])[e];
     let c;
-    const u = new Be(16777215);
+    const u = new Re(16777215);
     l.color !== void 0 && u.fromArray(l.color);
     const h = l.range !== void 0 ? l.range : 0;
     switch (l.type) {
       case "directional":
-        c = new Wo(u), c.target.position.set(0, 0, -1), c.add(c.target);
+        c = new ea(u), c.target.position.set(0, 0, -1), c.add(c.target);
         break;
       case "point":
-        c = new zi(u), c.distance = h;
+        c = new Xi(u), c.distance = h;
         break;
       case "spot":
-        c = new Xo(u), c.distance = h, l.spot = l.spot || {}, l.spot.innerConeAngle = l.spot.innerConeAngle !== void 0 ? l.spot.innerConeAngle : 0, l.spot.outerConeAngle = l.spot.outerConeAngle !== void 0 ? l.spot.outerConeAngle : Math.PI / 4, c.angle = l.spot.outerConeAngle, c.penumbra = 1 - l.spot.innerConeAngle / l.spot.outerConeAngle, c.target.position.set(0, 0, -1), c.add(c.target);
+        c = new Jo(u), c.distance = h, l.spot = l.spot || {}, l.spot.innerConeAngle = l.spot.innerConeAngle !== void 0 ? l.spot.innerConeAngle : 0, l.spot.outerConeAngle = l.spot.outerConeAngle !== void 0 ? l.spot.outerConeAngle : Math.PI / 4, c.angle = l.spot.outerConeAngle, c.penumbra = 1 - l.spot.innerConeAngle / l.spot.outerConeAngle, c.target.position.set(0, 0, -1), c.add(c.target);
         break;
       default:
         throw new Error("THREE.GLTFLoader: Unexpected light type: " + l.type);
     }
-    return c.position.set(0, 0, 0), c.decay = 2, an(c, l), l.intensity !== void 0 && (c.intensity = l.intensity), c.name = t.createUniqueName(l.name || "light_" + e), s = Promise.resolve(c), t.cache.add(n, s), s;
+    return c.position.set(0, 0, 0), c.decay = 2, cn(c, l), l.intensity !== void 0 && (c.intensity = l.intensity), c.name = t.createUniqueName(l.name || "light_" + e), s = Promise.resolve(c), t.cache.add(n, s), s;
   }
   getDependency(e, t) {
     if (e === "light")
@@ -2642,16 +2642,16 @@ class lu {
     });
   }
 }
-class cu {
+class vu {
   constructor() {
-    this.name = Ce.KHR_MATERIALS_UNLIT;
+    this.name = Ie.KHR_MATERIALS_UNLIT;
   }
   getMaterialType() {
-    return Gt;
+    return Yt;
   }
   extendParams(e, t, n) {
     const s = [];
-    e.color = new Be(1, 1, 1), e.opacity = 1;
+    e.color = new Re(1, 1, 1), e.opacity = 1;
     const i = t.pbrMetallicRoughness;
     if (i) {
       if (Array.isArray(i.baseColorFactor)) {
@@ -2663,9 +2663,9 @@ class cu {
     return Promise.all(s);
   }
 }
-class uu {
+class yu {
   constructor(e) {
-    this.parser = e, this.name = Ce.KHR_MATERIALS_EMISSIVE_STRENGTH;
+    this.parser = e, this.name = Ie.KHR_MATERIALS_EMISSIVE_STRENGTH;
   }
   extendMaterialParams(e, t) {
     const s = this.parser.json.materials[e];
@@ -2675,13 +2675,13 @@ class uu {
     return i !== void 0 && (t.emissiveIntensity = i), Promise.resolve();
   }
 }
-class hu {
+class _u {
   constructor(e) {
-    this.parser = e, this.name = Ce.KHR_MATERIALS_CLEARCOAT;
+    this.parser = e, this.name = Ie.KHR_MATERIALS_CLEARCOAT;
   }
   getMaterialType(e) {
     const n = this.parser.json.materials[e];
-    return !n.extensions || !n.extensions[this.name] ? null : fn;
+    return !n.extensions || !n.extensions[this.name] ? null : mn;
   }
   extendMaterialParams(e, t) {
     const n = this.parser, s = n.json.materials[e];
@@ -2690,18 +2690,18 @@ class hu {
     const i = [], r = s.extensions[this.name];
     if (r.clearcoatFactor !== void 0 && (t.clearcoat = r.clearcoatFactor), r.clearcoatTexture !== void 0 && i.push(n.assignTexture(t, "clearcoatMap", r.clearcoatTexture)), r.clearcoatRoughnessFactor !== void 0 && (t.clearcoatRoughness = r.clearcoatRoughnessFactor), r.clearcoatRoughnessTexture !== void 0 && i.push(n.assignTexture(t, "clearcoatRoughnessMap", r.clearcoatRoughnessTexture)), r.clearcoatNormalTexture !== void 0 && (i.push(n.assignTexture(t, "clearcoatNormalMap", r.clearcoatNormalTexture)), r.clearcoatNormalTexture.scale !== void 0)) {
       const a = r.clearcoatNormalTexture.scale;
-      t.clearcoatNormalScale = new le(a, a);
+      t.clearcoatNormalScale = new he(a, a);
     }
     return Promise.all(i);
   }
 }
-class fu {
+class xu {
   constructor(e) {
-    this.parser = e, this.name = Ce.KHR_MATERIALS_IRIDESCENCE;
+    this.parser = e, this.name = Ie.KHR_MATERIALS_IRIDESCENCE;
   }
   getMaterialType(e) {
     const n = this.parser.json.materials[e];
-    return !n.extensions || !n.extensions[this.name] ? null : fn;
+    return !n.extensions || !n.extensions[this.name] ? null : mn;
   }
   extendMaterialParams(e, t) {
     const n = this.parser, s = n.json.materials[e];
@@ -2713,31 +2713,31 @@ class fu {
     ), Promise.all(i);
   }
 }
-class du {
+class wu {
   constructor(e) {
-    this.parser = e, this.name = Ce.KHR_MATERIALS_SHEEN;
+    this.parser = e, this.name = Ie.KHR_MATERIALS_SHEEN;
   }
   getMaterialType(e) {
     const n = this.parser.json.materials[e];
-    return !n.extensions || !n.extensions[this.name] ? null : fn;
+    return !n.extensions || !n.extensions[this.name] ? null : mn;
   }
   extendMaterialParams(e, t) {
     const n = this.parser, s = n.json.materials[e];
     if (!s.extensions || !s.extensions[this.name])
       return Promise.resolve();
     const i = [];
-    t.sheenColor = new Be(0, 0, 0), t.sheenRoughness = 0, t.sheen = 1;
+    t.sheenColor = new Re(0, 0, 0), t.sheenRoughness = 0, t.sheen = 1;
     const r = s.extensions[this.name];
     return r.sheenColorFactor !== void 0 && t.sheenColor.fromArray(r.sheenColorFactor), r.sheenRoughnessFactor !== void 0 && (t.sheenRoughness = r.sheenRoughnessFactor), r.sheenColorTexture !== void 0 && i.push(n.assignTexture(t, "sheenColorMap", r.sheenColorTexture, 3001)), r.sheenRoughnessTexture !== void 0 && i.push(n.assignTexture(t, "sheenRoughnessMap", r.sheenRoughnessTexture)), Promise.all(i);
   }
 }
-class pu {
+class Tu {
   constructor(e) {
-    this.parser = e, this.name = Ce.KHR_MATERIALS_TRANSMISSION;
+    this.parser = e, this.name = Ie.KHR_MATERIALS_TRANSMISSION;
   }
   getMaterialType(e) {
     const n = this.parser.json.materials[e];
-    return !n.extensions || !n.extensions[this.name] ? null : fn;
+    return !n.extensions || !n.extensions[this.name] ? null : mn;
   }
   extendMaterialParams(e, t) {
     const n = this.parser, s = n.json.materials[e];
@@ -2747,13 +2747,13 @@ class pu {
     return r.transmissionFactor !== void 0 && (t.transmission = r.transmissionFactor), r.transmissionTexture !== void 0 && i.push(n.assignTexture(t, "transmissionMap", r.transmissionTexture)), Promise.all(i);
   }
 }
-class mu {
+class bu {
   constructor(e) {
-    this.parser = e, this.name = Ce.KHR_MATERIALS_VOLUME;
+    this.parser = e, this.name = Ie.KHR_MATERIALS_VOLUME;
   }
   getMaterialType(e) {
     const n = this.parser.json.materials[e];
-    return !n.extensions || !n.extensions[this.name] ? null : fn;
+    return !n.extensions || !n.extensions[this.name] ? null : mn;
   }
   extendMaterialParams(e, t) {
     const n = this.parser, s = n.json.materials[e];
@@ -2762,16 +2762,16 @@ class mu {
     const i = [], r = s.extensions[this.name];
     t.thickness = r.thicknessFactor !== void 0 ? r.thicknessFactor : 0, r.thicknessTexture !== void 0 && i.push(n.assignTexture(t, "thicknessMap", r.thicknessTexture)), t.attenuationDistance = r.attenuationDistance || 1 / 0;
     const a = r.attenuationColor || [1, 1, 1];
-    return t.attenuationColor = new Be(a[0], a[1], a[2]), Promise.all(i);
+    return t.attenuationColor = new Re(a[0], a[1], a[2]), Promise.all(i);
   }
 }
-class gu {
+class Eu {
   constructor(e) {
-    this.parser = e, this.name = Ce.KHR_MATERIALS_IOR;
+    this.parser = e, this.name = Ie.KHR_MATERIALS_IOR;
   }
   getMaterialType(e) {
     const n = this.parser.json.materials[e];
-    return !n.extensions || !n.extensions[this.name] ? null : fn;
+    return !n.extensions || !n.extensions[this.name] ? null : mn;
   }
   extendMaterialParams(e, t) {
     const s = this.parser.json.materials[e];
@@ -2781,13 +2781,13 @@ class gu {
     return t.ior = i.ior !== void 0 ? i.ior : 1.5, Promise.resolve();
   }
 }
-class yu {
+class Su {
   constructor(e) {
-    this.parser = e, this.name = Ce.KHR_MATERIALS_SPECULAR;
+    this.parser = e, this.name = Ie.KHR_MATERIALS_SPECULAR;
   }
   getMaterialType(e) {
     const n = this.parser.json.materials[e];
-    return !n.extensions || !n.extensions[this.name] ? null : fn;
+    return !n.extensions || !n.extensions[this.name] ? null : mn;
   }
   extendMaterialParams(e, t) {
     const n = this.parser, s = n.json.materials[e];
@@ -2796,19 +2796,19 @@ class yu {
     const i = [], r = s.extensions[this.name];
     t.specularIntensity = r.specularFactor !== void 0 ? r.specularFactor : 1, r.specularTexture !== void 0 && i.push(n.assignTexture(t, "specularIntensityMap", r.specularTexture));
     const a = r.specularColorFactor || [1, 1, 1];
-    return t.specularColor = new Be(a[0], a[1], a[2]), r.specularColorTexture !== void 0 && i.push(
+    return t.specularColor = new Re(a[0], a[1], a[2]), r.specularColorTexture !== void 0 && i.push(
       n.assignTexture(t, "specularColorMap", r.specularColorTexture, 3001)
       // sRGBEncoding
     ), Promise.all(i);
   }
 }
-class vu {
+class Mu {
   constructor(e) {
-    this.parser = e, this.name = Ce.KHR_MATERIALS_ANISOTROPY;
+    this.parser = e, this.name = Ie.KHR_MATERIALS_ANISOTROPY;
   }
   getMaterialType(e) {
     const n = this.parser.json.materials[e];
-    return !n.extensions || !n.extensions[this.name] ? null : fn;
+    return !n.extensions || !n.extensions[this.name] ? null : mn;
   }
   extendMaterialParams(e, t) {
     const n = this.parser, s = n.json.materials[e];
@@ -2818,9 +2818,9 @@ class vu {
     return r.anisotropyStrength !== void 0 && (t.anisotropy = r.anisotropyStrength), r.anisotropyRotation !== void 0 && (t.anisotropyRotation = r.anisotropyRotation), r.anisotropyTexture !== void 0 && i.push(n.assignTexture(t, "anisotropyMap", r.anisotropyTexture)), Promise.all(i);
   }
 }
-class _u {
+class Au {
   constructor(e) {
-    this.parser = e, this.name = Ce.KHR_TEXTURE_BASISU;
+    this.parser = e, this.name = Ie.KHR_TEXTURE_BASISU;
   }
   loadTexture(e) {
     const t = this.parser, n = t.json, s = n.textures[e];
@@ -2835,9 +2835,9 @@ class _u {
     return t.loadTextureImage(e, i.source, r);
   }
 }
-class xu {
+class Pu {
   constructor(e) {
-    this.parser = e, this.name = Ce.EXT_TEXTURE_WEBP, this.isSupported = null;
+    this.parser = e, this.name = Ie.EXT_TEXTURE_WEBP, this.isSupported = null;
   }
   loadTexture(e) {
     const t = this.name, n = this.parser, s = n.json, i = s.textures[e];
@@ -2866,9 +2866,9 @@ class xu {
     })), this.isSupported;
   }
 }
-class wu {
+class Cu {
   constructor(e) {
-    this.parser = e, this.name = Ce.EXT_TEXTURE_AVIF, this.isSupported = null;
+    this.parser = e, this.name = Ie.EXT_TEXTURE_AVIF, this.isSupported = null;
   }
   loadTexture(e) {
     const t = this.name, n = this.parser, s = n.json, i = s.textures[e];
@@ -2897,9 +2897,9 @@ class wu {
     })), this.isSupported;
   }
 }
-class Tu {
+class Ru {
   constructor(e) {
-    this.name = Ce.EXT_MESHOPT_COMPRESSION, this.parser = e;
+    this.name = Ie.EXT_MESHOPT_COMPRESSION, this.parser = e;
   }
   loadBufferView(e) {
     const t = this.parser.json, n = t.bufferViews[e];
@@ -2911,28 +2911,28 @@ class Tu {
         return null;
       }
       return i.then(function(a) {
-        const l = s.byteOffset || 0, c = s.byteLength || 0, u = s.count, h = s.byteStride, m = new Uint8Array(a, l, c);
-        return r.decodeGltfBufferAsync ? r.decodeGltfBufferAsync(u, h, m, s.mode, s.filter).then(function(p) {
-          return p.buffer;
+        const l = s.byteOffset || 0, c = s.byteLength || 0, u = s.count, h = s.byteStride, f = new Uint8Array(a, l, c);
+        return r.decodeGltfBufferAsync ? r.decodeGltfBufferAsync(u, h, f, s.mode, s.filter).then(function(d) {
+          return d.buffer;
         }) : r.ready.then(function() {
-          const p = new ArrayBuffer(u * h);
+          const d = new ArrayBuffer(u * h);
           return r.decodeGltfBuffer(
-            new Uint8Array(p),
+            new Uint8Array(d),
             u,
             h,
-            m,
+            f,
             s.mode,
             s.filter
-          ), p;
+          ), d;
         });
       });
     } else
       return null;
   }
 }
-class bu {
+class Iu {
   constructor(e) {
-    this.name = Ce.EXT_MESH_GPU_INSTANCING, this.parser = e;
+    this.name = Ie.EXT_MESH_GPU_INSTANCING, this.parser = e;
   }
   createNodeMesh(e) {
     const t = this.parser.json, n = t.nodes[e];
@@ -2940,7 +2940,7 @@ class bu {
       return null;
     const s = t.meshes[n.mesh];
     for (const c of s.primitives)
-      if (c.mode !== vt.TRIANGLES && c.mode !== vt.TRIANGLE_STRIP && c.mode !== vt.TRIANGLE_FAN && c.mode !== void 0)
+      if (c.mode !== _t.TRIANGLES && c.mode !== _t.TRIANGLE_STRIP && c.mode !== _t.TRIANGLE_FAN && c.mode !== void 0)
         return null;
     const r = n.extensions[this.name].attributes, a = [], l = {};
     for (const c in r)
@@ -2948,43 +2948,43 @@ class bu {
         this.parser.getDependency("accessor", r[c]).then((u) => (l[c] = u, l[c]))
       );
     return a.length < 1 ? null : (a.push(this.parser.createNodeMesh(e)), Promise.all(a).then((c) => {
-      const u = c.pop(), h = u.isGroup ? u.children : [u], m = c[0].count, p = [];
-      for (const v of h) {
-        const _ = new De(), y = new ee(), E = new He(), R = new ee(1, 1, 1), T = new fl(v.geometry, v.material, m);
-        for (let g = 0; g < m; g++)
-          l.TRANSLATION && y.fromBufferAttribute(l.TRANSLATION, g), l.ROTATION && E.fromBufferAttribute(l.ROTATION, g), l.SCALE && R.fromBufferAttribute(l.SCALE, g), T.setMatrixAt(g, _.compose(y, E, R));
-        for (const g in l)
-          g !== "TRANSLATION" && g !== "ROTATION" && g !== "SCALE" && v.geometry.setAttribute(g, l[g]);
-        St.prototype.copy.call(T, v), this.parser.assignFinalMaterial(T), p.push(T);
+      const u = c.pop(), h = u.isGroup ? u.children : [u], f = c[0].count, d = [];
+      for (const y of h) {
+        const x = new Pe(), g = new q(), v = new He(), M = new q(1, 1, 1), _ = new _l(y.geometry, y.material, f);
+        for (let w = 0; w < f; w++)
+          l.TRANSLATION && g.fromBufferAttribute(l.TRANSLATION, w), l.ROTATION && v.fromBufferAttribute(l.ROTATION, w), l.SCALE && M.fromBufferAttribute(l.SCALE, w), _.setMatrixAt(w, x.compose(g, v, M));
+        for (const w in l)
+          w !== "TRANSLATION" && w !== "ROTATION" && w !== "SCALE" && y.geometry.setAttribute(w, l[w]);
+        Tt.prototype.copy.call(_, y), this.parser.assignFinalMaterial(_), d.push(_);
       }
-      return u.isGroup ? (u.clear(), u.add(...p), u) : p[0];
+      return u.isGroup ? (u.clear(), u.add(...d), u) : d[0];
     }));
   }
 }
-const Ta = "glTF", Wn = 12, zr = { JSON: 1313821514, BIN: 5130562 };
-class Eu {
+const Ca = "glTF", Jn = 12, Yr = { JSON: 1313821514, BIN: 5130562 };
+class Du {
   constructor(e) {
-    this.name = Ce.KHR_BINARY_GLTF, this.content = null, this.body = null;
-    const t = new DataView(e, 0, Wn);
+    this.name = Ie.KHR_BINARY_GLTF, this.content = null, this.body = null;
+    const t = new DataView(e, 0, Jn);
     if (this.header = {
-      magic: Ft.decodeText(new Uint8Array(e.slice(0, 4))),
+      magic: Bt.decodeText(new Uint8Array(e.slice(0, 4))),
       version: t.getUint32(4, !0),
       length: t.getUint32(8, !0)
-    }, this.header.magic !== Ta)
+    }, this.header.magic !== Ca)
       throw new Error("THREE.GLTFLoader: Unsupported glTF-Binary header.");
     if (this.header.version < 2)
       throw new Error("THREE.GLTFLoader: Legacy binary file detected.");
-    const n = this.header.length - Wn, s = new DataView(e, Wn);
+    const n = this.header.length - Jn, s = new DataView(e, Jn);
     let i = 0;
     for (; i < n; ) {
       const r = s.getUint32(i, !0);
       i += 4;
       const a = s.getUint32(i, !0);
-      if (i += 4, a === zr.JSON) {
-        const l = new Uint8Array(e, Wn + i, r);
-        this.content = Ft.decodeText(l);
-      } else if (a === zr.BIN) {
-        const l = Wn + i;
+      if (i += 4, a === Yr.JSON) {
+        const l = new Uint8Array(e, Jn + i, r);
+        this.content = Bt.decodeText(l);
+      } else if (a === Yr.BIN) {
+        const l = Jn + i;
         this.body = e.slice(l, l + r);
       }
       i += r;
@@ -2993,35 +2993,35 @@ class Eu {
       throw new Error("THREE.GLTFLoader: JSON content not found.");
   }
 }
-class Mu {
+class Ou {
   constructor(e, t) {
     if (!t)
       throw new Error("THREE.GLTFLoader: No DRACOLoader instance provided.");
-    this.name = Ce.KHR_DRACO_MESH_COMPRESSION, this.json = e, this.dracoLoader = t, this.dracoLoader.preload();
+    this.name = Ie.KHR_DRACO_MESH_COMPRESSION, this.json = e, this.dracoLoader = t, this.dracoLoader.preload();
   }
   decodePrimitive(e, t) {
     const n = this.json, s = this.dracoLoader, i = e.extensions[this.name].bufferView, r = e.extensions[this.name].attributes, a = {}, l = {}, c = {};
     for (const u in r) {
-      const h = Qi[u] || u.toLowerCase();
+      const h = sr[u] || u.toLowerCase();
       a[h] = r[u];
     }
     for (const u in e.attributes) {
-      const h = Qi[u] || u.toLowerCase();
+      const h = sr[u] || u.toLowerCase();
       if (r[u] !== void 0) {
-        const m = n.accessors[e.attributes[u]], p = Nn[m.componentType];
-        c[h] = p.name, l[h] = m.normalized === !0;
+        const f = n.accessors[e.attributes[u]], d = Gn[f.componentType];
+        c[h] = d.name, l[h] = f.normalized === !0;
       }
     }
     return t.getDependency("bufferView", i).then(function(u) {
       return new Promise(function(h) {
         s.decodeDracoFile(
           u,
-          function(m) {
-            for (const p in m.attributes) {
-              const v = m.attributes[p], _ = l[p];
-              _ !== void 0 && (v.normalized = _);
+          function(f) {
+            for (const d in f.attributes) {
+              const y = f.attributes[d], x = l[d];
+              x !== void 0 && (y.normalized = x);
             }
-            h(m);
+            h(f);
           },
           a,
           c
@@ -3030,20 +3030,20 @@ class Mu {
     });
   }
 }
-class Su {
+class Lu {
   constructor() {
-    this.name = Ce.KHR_TEXTURE_TRANSFORM;
+    this.name = Ie.KHR_TEXTURE_TRANSFORM;
   }
   extendTexture(e, t) {
     return (t.texCoord === void 0 || t.texCoord === e.channel) && t.offset === void 0 && t.rotation === void 0 && t.scale === void 0 || (e = e.clone(), t.texCoord !== void 0 && (e.channel = t.texCoord), t.offset !== void 0 && e.offset.fromArray(t.offset), t.rotation !== void 0 && (e.rotation = t.rotation), t.scale !== void 0 && e.repeat.fromArray(t.scale), e.needsUpdate = !0), e;
   }
 }
-class Au {
+class Fu {
   constructor() {
-    this.name = Ce.KHR_MESH_QUANTIZATION;
+    this.name = Ie.KHR_MESH_QUANTIZATION;
   }
 }
-class ba extends vl {
+class Ra extends El {
   constructor(e, t, n, s) {
     super(e, t, n, s);
   }
@@ -3054,22 +3054,22 @@ class ba extends vl {
     return t;
   }
   interpolate_(e, t, n, s) {
-    const i = this.resultBuffer, r = this.sampleValues, a = this.valueSize, l = a * 2, c = a * 3, u = s - t, h = (n - t) / u, m = h * h, p = m * h, v = e * c, _ = v - c, y = -2 * p + 3 * m, E = p - m, R = 1 - y, T = E - m + h;
-    for (let g = 0; g !== a; g++) {
-      const A = r[_ + g + a], x = r[_ + g + l] * u, M = r[v + g + a], d = r[v + g] * u;
-      i[g] = R * A + T * x + y * M + E * d;
+    const i = this.resultBuffer, r = this.sampleValues, a = this.valueSize, l = a * 2, c = a * 3, u = s - t, h = (n - t) / u, f = h * h, d = f * h, y = e * c, x = y - c, g = -2 * d + 3 * f, v = d - f, M = 1 - g, _ = v - f + h;
+    for (let w = 0; w !== a; w++) {
+      const P = r[x + w + a], T = r[x + w + l] * u, E = r[y + w + a], m = r[y + w] * u;
+      i[w] = M * P + _ * T + g * E + v * m;
     }
     return i;
   }
 }
-const Pu = new He();
-class Ru extends ba {
+const ku = new He();
+class Bu extends Ra {
   interpolate_(e, t, n, s) {
     const i = super.interpolate_(e, t, n, s);
-    return Pu.fromArray(i).normalize().toArray(i), i;
+    return ku.fromArray(i).normalize().toArray(i), i;
   }
 }
-const vt = {
+const _t = {
   FLOAT: 5126,
   //FLOAT_MAT2: 35674,
   FLOAT_MAT3: 35675,
@@ -3089,25 +3089,25 @@ const vt = {
   TRIANGLE_FAN: 6,
   UNSIGNED_BYTE: 5121,
   UNSIGNED_SHORT: 5123
-}, Nn = {
+}, Gn = {
   5120: Int8Array,
   5121: Uint8Array,
   5122: Int16Array,
   5123: Uint16Array,
   5125: Uint32Array,
   5126: Float32Array
-}, Hr = {
-  9728: No,
-  9729: At,
-  9984: zo,
-  9985: Go,
-  9986: Ho,
-  9987: ar
-}, Gr = {
-  33071: Hn,
-  33648: jo,
-  10497: Gn
-}, mi = {
+}, Xr = {
+  9728: Yo,
+  9729: Ct,
+  9984: Xo,
+  9985: Zo,
+  9986: $o,
+  9987: fr
+}, $r = {
+  33071: Wn,
+  33648: Ko,
+  10497: En
+}, wi = {
   SCALAR: 1,
   VEC2: 2,
   VEC3: 3,
@@ -3115,14 +3115,14 @@ const vt = {
   MAT2: 4,
   MAT3: 9,
   MAT4: 16
-}, Qi = {
+}, sr = {
   POSITION: "position",
   NORMAL: "normal",
   TANGENT: "tangent",
   // uv => uv1, 4 uv channels
   // https://github.com/mrdoob/three.js/pull/25943
   // https://github.com/mrdoob/three.js/pull/25788
-  ...da >= 152 ? {
+  ...xa >= 152 ? {
     TEXCOORD_0: "uv",
     TEXCOORD_1: "uv1",
     TEXCOORD_2: "uv2",
@@ -3134,41 +3134,41 @@ const vt = {
   COLOR_0: "color",
   WEIGHTS_0: "skinWeight",
   JOINTS_0: "skinIndex"
-}, Qt = {
+}, tn = {
   scale: "scale",
   translation: "position",
   rotation: "quaternion",
   weights: "morphTargetInfluences"
-}, Cu = {
+}, Uu = {
   CUBICSPLINE: void 0,
   // We use a custom interpolant (GLTFCubicSplineInterpolation) for CUBICSPLINE tracks. Each
   // keyframe track will be initialized with a default interpolation type, then modified.
-  LINEAR: or,
-  STEP: Bo
-}, gi = {
+  LINEAR: hr,
+  STEP: Wo
+}, Ti = {
   OPAQUE: "OPAQUE",
   MASK: "MASK",
   BLEND: "BLEND"
 };
-function Iu(o) {
-  return o.DefaultMaterial === void 0 && (o.DefaultMaterial = new us({
+function Nu(o) {
+  return o.DefaultMaterial === void 0 && (o.DefaultMaterial = new ys({
     color: 16777215,
     emissive: 0,
     metalness: 1,
     roughness: 1,
     transparent: !1,
     depthTest: !0,
-    side: yl
+    side: _s
   })), o.DefaultMaterial;
 }
-function pn(o, e, t) {
+function vn(o, e, t) {
   for (const n in t.extensions)
     o[n] === void 0 && (e.userData.gltfExtensions = e.userData.gltfExtensions || {}, e.userData.gltfExtensions[n] = t.extensions[n]);
 }
-function an(o, e) {
+function cn(o, e) {
   e.extras !== void 0 && (typeof e.extras == "object" ? Object.assign(o.userData, e.extras) : console.warn("THREE.GLTFLoader: Ignoring primitive type .extras, " + e.extras));
 }
-function Du(o, e, t) {
+function zu(o, e, t) {
   let n = !1, s = !1, i = !1;
   for (let c = 0, u = e.length; c < u; c++) {
     const h = e[c];
@@ -3181,16 +3181,16 @@ function Du(o, e, t) {
   for (let c = 0, u = e.length; c < u; c++) {
     const h = e[c];
     if (n) {
-      const m = h.POSITION !== void 0 ? t.getDependency("accessor", h.POSITION) : o.attributes.position;
-      r.push(m);
+      const f = h.POSITION !== void 0 ? t.getDependency("accessor", h.POSITION) : o.attributes.position;
+      r.push(f);
     }
     if (s) {
-      const m = h.NORMAL !== void 0 ? t.getDependency("accessor", h.NORMAL) : o.attributes.normal;
-      a.push(m);
+      const f = h.NORMAL !== void 0 ? t.getDependency("accessor", h.NORMAL) : o.attributes.normal;
+      a.push(f);
     }
     if (i) {
-      const m = h.COLOR_0 !== void 0 ? t.getDependency("accessor", h.COLOR_0) : o.attributes.color;
-      l.push(m);
+      const f = h.COLOR_0 !== void 0 ? t.getDependency("accessor", h.COLOR_0) : o.attributes.color;
+      l.push(f);
     }
   }
   return Promise.all([
@@ -3198,11 +3198,11 @@ function Du(o, e, t) {
     Promise.all(a),
     Promise.all(l)
   ]).then(function(c) {
-    const u = c[0], h = c[1], m = c[2];
-    return n && (o.morphAttributes.position = u), s && (o.morphAttributes.normal = h), i && (o.morphAttributes.color = m), o.morphTargetsRelative = !0, o;
+    const u = c[0], h = c[1], f = c[2];
+    return n && (o.morphAttributes.position = u), s && (o.morphAttributes.normal = h), i && (o.morphAttributes.color = f), o.morphTargetsRelative = !0, o;
   });
 }
-function Lu(o, e) {
+function Hu(o, e) {
   if (o.updateMorphTargets(), e.weights !== void 0)
     for (let t = 0, n = e.weights.length; t < n; t++)
       o.morphTargetInfluences[t] = e.weights[t];
@@ -3216,22 +3216,22 @@ function Lu(o, e) {
       console.warn("THREE.GLTFLoader: Invalid extras.targetNames length. Ignoring names.");
   }
 }
-function Ou(o) {
+function ju(o) {
   let e;
-  const t = o.extensions && o.extensions[Ce.KHR_DRACO_MESH_COMPRESSION];
-  if (t ? e = "draco:" + t.bufferView + ":" + t.indices + ":" + yi(t.attributes) : e = o.indices + ":" + yi(o.attributes) + ":" + o.mode, o.targets !== void 0)
+  const t = o.extensions && o.extensions[Ie.KHR_DRACO_MESH_COMPRESSION];
+  if (t ? e = "draco:" + t.bufferView + ":" + t.indices + ":" + bi(t.attributes) : e = o.indices + ":" + bi(o.attributes) + ":" + o.mode, o.targets !== void 0)
     for (let n = 0, s = o.targets.length; n < s; n++)
-      e += ":" + yi(o.targets[n]);
+      e += ":" + bi(o.targets[n]);
   return e;
 }
-function yi(o) {
+function bi(o) {
   let e = "";
   const t = Object.keys(o).sort();
   for (let n = 0, s = t.length; n < s; n++)
     e += t[n] + ":" + o[t[n]] + ";";
   return e;
 }
-function Ji(o) {
+function ir(o) {
   switch (o) {
     case Int8Array:
       return 1 / 127;
@@ -3245,15 +3245,15 @@ function Ji(o) {
       throw new Error("THREE.GLTFLoader: Unsupported normalized accessor component type.");
   }
 }
-function Fu(o) {
+function Gu(o) {
   return o.search(/\.jpe?g($|\?)/i) > 0 || o.search(/^data\:image\/jpeg/) === 0 ? "image/jpeg" : o.search(/\.webp($|\?)/i) > 0 || o.search(/^data\:image\/webp/) === 0 ? "image/webp" : "image/png";
 }
-const ku = new De();
-class Uu {
+const Vu = new Pe();
+class Wu {
   constructor(e = {}, t = {}) {
-    this.json = e, this.extensions = {}, this.plugins = {}, this.options = t, this.cache = new au(), this.associations = /* @__PURE__ */ new Map(), this.primitiveCache = {}, this.nodeCache = {}, this.meshCache = { refs: {}, uses: {} }, this.cameraCache = { refs: {}, uses: {} }, this.lightCache = { refs: {}, uses: {} }, this.sourceCache = {}, this.textureCache = {}, this.nodeNamesUsed = {};
+    this.json = e, this.extensions = {}, this.plugins = {}, this.options = t, this.cache = new mu(), this.associations = /* @__PURE__ */ new Map(), this.primitiveCache = {}, this.nodeCache = {}, this.meshCache = { refs: {}, uses: {} }, this.cameraCache = { refs: {}, uses: {} }, this.lightCache = { refs: {}, uses: {} }, this.sourceCache = {}, this.textureCache = {}, this.nodeNamesUsed = {};
     let n = !1, s = !1, i = -1;
-    typeof navigator < "u" && typeof navigator.userAgent < "u" && (n = /^((?!chrome|android).)*safari/i.test(navigator.userAgent) === !0, s = navigator.userAgent.indexOf("Firefox") > -1, i = s ? navigator.userAgent.match(/Firefox\/([0-9]+)\./)[1] : -1), typeof createImageBitmap > "u" || n || s && i < 98 ? this.textureLoader = new cr(this.options.manager) : this.textureLoader = new dl(this.options.manager), this.textureLoader.setCrossOrigin(this.options.crossOrigin), this.textureLoader.setRequestHeader(this.options.requestHeader), this.fileLoader = new Tn(this.options.manager), this.fileLoader.setResponseType("arraybuffer"), this.options.crossOrigin === "use-credentials" && this.fileLoader.setWithCredentials(!0);
+    typeof navigator < "u" && typeof navigator.userAgent < "u" && (n = /^((?!chrome|android).)*safari/i.test(navigator.userAgent) === !0, s = navigator.userAgent.indexOf("Firefox") > -1, i = s ? navigator.userAgent.match(/Firefox\/([0-9]+)\./)[1] : -1), typeof createImageBitmap > "u" || n || s && i < 98 ? this.textureLoader = new dr(this.options.manager) : this.textureLoader = new xl(this.options.manager), this.textureLoader.setCrossOrigin(this.options.crossOrigin), this.textureLoader.setRequestHeader(this.options.requestHeader), this.fileLoader = new Sn(this.options.manager), this.fileLoader.setResponseType("arraybuffer"), this.options.crossOrigin === "use-credentials" && this.fileLoader.setWithCredentials(!0);
   }
   setExtensions(e) {
     this.extensions = e;
@@ -3285,7 +3285,7 @@ class Uu {
         parser: n,
         userData: {}
       };
-      pn(i, a, s), an(a, s), Promise.all(
+      vn(i, a, s), cn(a, s), Promise.all(
         n._invokeAll(function(l) {
           return l.afterRoot && l.afterRoot(a);
         })
@@ -3447,10 +3447,10 @@ class Uu {
     if (t.type && t.type !== "arraybuffer")
       throw new Error("THREE.GLTFLoader: " + t.type + " buffer type is not supported.");
     if (t.uri === void 0 && e === 0)
-      return Promise.resolve(this.extensions[Ce.KHR_BINARY_GLTF].body);
+      return Promise.resolve(this.extensions[Ie.KHR_BINARY_GLTF].body);
     const s = this.options;
     return new Promise(function(i, r) {
-      n.load(Ft.resolveURL(t.uri, s.path), i, void 0, function() {
+      n.load(Bt.resolveURL(t.uri, s.path), i, void 0, function() {
         r(new Error('THREE.GLTFLoader: Failed to load buffer "' + t.uri + '".'));
       });
     });
@@ -3475,42 +3475,42 @@ class Uu {
   loadAccessor(e) {
     const t = this, n = this.json, s = this.json.accessors[e];
     if (s.bufferView === void 0 && s.sparse === void 0) {
-      const r = mi[s.type], a = Nn[s.componentType], l = s.normalized === !0, c = new a(s.count * r);
+      const r = wi[s.type], a = Gn[s.componentType], l = s.normalized === !0, c = new a(s.count * r);
       return Promise.resolve(new pt(c, r, l));
     }
     const i = [];
     return s.bufferView !== void 0 ? i.push(this.getDependency("bufferView", s.bufferView)) : i.push(null), s.sparse !== void 0 && (i.push(this.getDependency("bufferView", s.sparse.indices.bufferView)), i.push(this.getDependency("bufferView", s.sparse.values.bufferView))), Promise.all(i).then(function(r) {
-      const a = r[0], l = mi[s.type], c = Nn[s.componentType], u = c.BYTES_PER_ELEMENT, h = u * l, m = s.byteOffset || 0, p = s.bufferView !== void 0 ? n.bufferViews[s.bufferView].byteStride : void 0, v = s.normalized === !0;
-      let _, y;
-      if (p && p !== h) {
-        const E = Math.floor(m / p), R = "InterleavedBuffer:" + s.bufferView + ":" + s.componentType + ":" + E + ":" + s.count;
-        let T = t.cache.get(R);
-        T || (_ = new c(a, E * p, s.count * p / u), T = new ur(_, p / u), t.cache.add(R, T)), y = new Vt(
-          T,
+      const a = r[0], l = wi[s.type], c = Gn[s.componentType], u = c.BYTES_PER_ELEMENT, h = u * l, f = s.byteOffset || 0, d = s.bufferView !== void 0 ? n.bufferViews[s.bufferView].byteStride : void 0, y = s.normalized === !0;
+      let x, g;
+      if (d && d !== h) {
+        const v = Math.floor(f / d), M = "InterleavedBuffer:" + s.bufferView + ":" + s.componentType + ":" + v + ":" + s.count;
+        let _ = t.cache.get(M);
+        _ || (x = new c(a, v * d, s.count * d / u), _ = new pr(x, d / u), t.cache.add(M, _)), g = new $t(
+          _,
           l,
-          m % p / u,
-          v
+          f % d / u,
+          y
         );
       } else
-        a === null ? _ = new c(s.count * l) : _ = new c(a, m, s.count * l), y = new pt(_, l, v);
+        a === null ? x = new c(s.count * l) : x = new c(a, f, s.count * l), g = new pt(x, l, y);
       if (s.sparse !== void 0) {
-        const E = mi.SCALAR, R = Nn[s.sparse.indices.componentType], T = s.sparse.indices.byteOffset || 0, g = s.sparse.values.byteOffset || 0, A = new R(
+        const v = wi.SCALAR, M = Gn[s.sparse.indices.componentType], _ = s.sparse.indices.byteOffset || 0, w = s.sparse.values.byteOffset || 0, P = new M(
           r[1],
-          T,
-          s.sparse.count * E
-        ), x = new c(r[2], g, s.sparse.count * l);
-        a !== null && (y = new pt(
-          y.array.slice(),
-          y.itemSize,
-          y.normalized
+          _,
+          s.sparse.count * v
+        ), T = new c(r[2], w, s.sparse.count * l);
+        a !== null && (g = new pt(
+          g.array.slice(),
+          g.itemSize,
+          g.normalized
         ));
-        for (let M = 0, d = A.length; M < d; M++) {
-          const w = A[M];
-          if (y.setX(w, x[M * l]), l >= 2 && y.setY(w, x[M * l + 1]), l >= 3 && y.setZ(w, x[M * l + 2]), l >= 4 && y.setW(w, x[M * l + 3]), l >= 5)
+        for (let E = 0, m = P.length; E < m; E++) {
+          const b = P[E];
+          if (g.setX(b, T[E * l]), l >= 2 && g.setY(b, T[E * l + 1]), l >= 3 && g.setZ(b, T[E * l + 2]), l >= 4 && g.setW(b, T[E * l + 3]), l >= 5)
             throw new Error("THREE.GLTFLoader: Unsupported itemSize in sparse BufferAttribute.");
         }
       }
-      return y;
+      return g;
     });
   }
   /**
@@ -3533,8 +3533,8 @@ class Uu {
       return this.textureCache[l];
     const c = this.loadImageSource(t, n).then(function(u) {
       u.flipY = !1, u.name = r.name || a.name || "", u.name === "" && typeof a.uri == "string" && a.uri.startsWith("data:image/") === !1 && (u.name = a.uri);
-      const m = (i.samplers || {})[r.sampler] || {};
-      return u.magFilter = Hr[m.magFilter] || At, u.minFilter = Hr[m.minFilter] || ar, u.wrapS = Gr[m.wrapS] || Gn, u.wrapT = Gr[m.wrapT] || Gn, s.associations.set(u, { textures: e }), u;
+      const f = (i.samplers || {})[r.sampler] || {};
+      return u.magFilter = Xr[f.magFilter] || Ct, u.minFilter = Xr[f.minFilter] || fr, u.wrapS = $r[f.wrapS] || En, u.wrapT = $r[f.wrapT] || En, s.associations.set(u, { textures: e }), u;
     }).catch(function() {
       return null;
     });
@@ -3549,21 +3549,21 @@ class Uu {
     if (r.bufferView !== void 0)
       l = n.getDependency("bufferView", r.bufferView).then(function(h) {
         c = !0;
-        const m = new Blob([h], { type: r.mimeType });
-        return l = a.createObjectURL(m), l;
+        const f = new Blob([h], { type: r.mimeType });
+        return l = a.createObjectURL(f), l;
       });
     else if (r.uri === void 0)
       throw new Error("THREE.GLTFLoader: Image " + e + " is missing URI and bufferView");
     const u = Promise.resolve(l).then(function(h) {
-      return new Promise(function(m, p) {
-        let v = m;
-        t.isImageBitmapLoader === !0 && (v = function(_) {
-          const y = new zn(_);
-          y.needsUpdate = !0, m(y);
-        }), t.load(Ft.resolveURL(h, i.path), v, void 0, p);
+      return new Promise(function(f, d) {
+        let y = f;
+        t.isImageBitmapLoader === !0 && (y = function(x) {
+          const g = new Vn(x);
+          g.needsUpdate = !0, f(g);
+        }), t.load(Bt.resolveURL(h, i.path), y, void 0, d);
       });
     }).then(function(h) {
-      return c === !0 && a.revokeObjectURL(l), h.userData.mimeType = r.mimeType || Fu(r.uri), h;
+      return c === !0 && a.revokeObjectURL(l), h.userData.mimeType = r.mimeType || Gu(r.uri), h;
     }).catch(function(h) {
       throw console.error("THREE.GLTFLoader: Couldn't load texture", l), h;
     });
@@ -3581,11 +3581,11 @@ class Uu {
     return this.getDependency("texture", n.index).then(function(r) {
       if (!r)
         return null;
-      if (n.texCoord !== void 0 && n.texCoord > 0 && (r = r.clone(), r.channel = n.texCoord), i.extensions[Ce.KHR_TEXTURE_TRANSFORM]) {
-        const a = n.extensions !== void 0 ? n.extensions[Ce.KHR_TEXTURE_TRANSFORM] : void 0;
+      if (n.texCoord !== void 0 && n.texCoord > 0 && (r = r.clone(), r.channel = n.texCoord), i.extensions[Ie.KHR_TEXTURE_TRANSFORM]) {
+        const a = n.extensions !== void 0 ? n.extensions[Ie.KHR_TEXTURE_TRANSFORM] : void 0;
         if (a) {
           const l = i.associations.get(r);
-          r = i.extensions[Ce.KHR_TEXTURE_TRANSFORM].extendTexture(r, a), i.associations.set(r, l);
+          r = i.extensions[Ie.KHR_TEXTURE_TRANSFORM].extendTexture(r, a), i.associations.set(r, l);
         }
       }
       return s !== void 0 && ("colorSpace" in r ? r.colorSpace = s === 3001 ? "srgb" : "srgb-linear" : r.encoding = s), e[t] = r, r;
@@ -3606,11 +3606,11 @@ class Uu {
     if (e.isPoints) {
       const a = "PointsMaterial:" + n.uuid;
       let l = this.cache.get(a);
-      l || (l = new pl(), ri.prototype.copy.call(l, n), l.color.copy(n.color), l.map = n.map, l.sizeAttenuation = !1, this.cache.add(a, l)), n = l;
+      l || (l = new wl(), hi.prototype.copy.call(l, n), l.color.copy(n.color), l.map = n.map, l.sizeAttenuation = !1, this.cache.add(a, l)), n = l;
     } else if (e.isLine) {
       const a = "LineBasicMaterial:" + n.uuid;
       let l = this.cache.get(a);
-      l || (l = new qs(), ri.prototype.copy.call(l, n), l.color.copy(n.color), l.map = n.map, this.cache.add(a, l)), n = l;
+      l || (l = new si(), hi.prototype.copy.call(l, n), l.color.copy(n.color), l.map = n.map, this.cache.add(a, l)), n = l;
     }
     if (s || i || r) {
       let a = "ClonedMaterial:" + n.uuid + ":";
@@ -3621,7 +3621,7 @@ class Uu {
     e.material = n;
   }
   getMaterialType() {
-    return us;
+    return ys;
   }
   /**
    * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#materials
@@ -3632,39 +3632,39 @@ class Uu {
     const t = this, n = this.json, s = this.extensions, i = n.materials[e];
     let r;
     const a = {}, l = i.extensions || {}, c = [];
-    if (l[Ce.KHR_MATERIALS_UNLIT]) {
-      const h = s[Ce.KHR_MATERIALS_UNLIT];
+    if (l[Ie.KHR_MATERIALS_UNLIT]) {
+      const h = s[Ie.KHR_MATERIALS_UNLIT];
       r = h.getMaterialType(), c.push(h.extendParams(a, i, t));
     } else {
       const h = i.pbrMetallicRoughness || {};
-      if (a.color = new Be(1, 1, 1), a.opacity = 1, Array.isArray(h.baseColorFactor)) {
-        const m = h.baseColorFactor;
-        a.color.fromArray(m), a.opacity = m[3];
+      if (a.color = new Re(1, 1, 1), a.opacity = 1, Array.isArray(h.baseColorFactor)) {
+        const f = h.baseColorFactor;
+        a.color.fromArray(f), a.opacity = f[3];
       }
-      h.baseColorTexture !== void 0 && c.push(t.assignTexture(a, "map", h.baseColorTexture, 3001)), a.metalness = h.metallicFactor !== void 0 ? h.metallicFactor : 1, a.roughness = h.roughnessFactor !== void 0 ? h.roughnessFactor : 1, h.metallicRoughnessTexture !== void 0 && (c.push(t.assignTexture(a, "metalnessMap", h.metallicRoughnessTexture)), c.push(t.assignTexture(a, "roughnessMap", h.metallicRoughnessTexture))), r = this._invokeOne(function(m) {
-        return m.getMaterialType && m.getMaterialType(e);
+      h.baseColorTexture !== void 0 && c.push(t.assignTexture(a, "map", h.baseColorTexture, 3001)), a.metalness = h.metallicFactor !== void 0 ? h.metallicFactor : 1, a.roughness = h.roughnessFactor !== void 0 ? h.roughnessFactor : 1, h.metallicRoughnessTexture !== void 0 && (c.push(t.assignTexture(a, "metalnessMap", h.metallicRoughnessTexture)), c.push(t.assignTexture(a, "roughnessMap", h.metallicRoughnessTexture))), r = this._invokeOne(function(f) {
+        return f.getMaterialType && f.getMaterialType(e);
       }), c.push(
         Promise.all(
-          this._invokeAll(function(m) {
-            return m.extendMaterialParams && m.extendMaterialParams(e, a);
+          this._invokeAll(function(f) {
+            return f.extendMaterialParams && f.extendMaterialParams(e, a);
           })
         )
       );
     }
-    i.doubleSided === !0 && (a.side = wn);
-    const u = i.alphaMode || gi.OPAQUE;
-    if (u === gi.BLEND ? (a.transparent = !0, a.depthWrite = !1) : (a.transparent = !1, u === gi.MASK && (a.alphaTest = i.alphaCutoff !== void 0 ? i.alphaCutoff : 0.5)), i.normalTexture !== void 0 && r !== Gt && (c.push(t.assignTexture(a, "normalMap", i.normalTexture)), a.normalScale = new le(1, 1), i.normalTexture.scale !== void 0)) {
+    i.doubleSided === !0 && (a.side = dn);
+    const u = i.alphaMode || Ti.OPAQUE;
+    if (u === Ti.BLEND ? (a.transparent = !0, a.depthWrite = !1) : (a.transparent = !1, u === Ti.MASK && (a.alphaTest = i.alphaCutoff !== void 0 ? i.alphaCutoff : 0.5)), i.normalTexture !== void 0 && r !== Yt && (c.push(t.assignTexture(a, "normalMap", i.normalTexture)), a.normalScale = new he(1, 1), i.normalTexture.scale !== void 0)) {
       const h = i.normalTexture.scale;
       a.normalScale.set(h, h);
     }
-    return i.occlusionTexture !== void 0 && r !== Gt && (c.push(t.assignTexture(a, "aoMap", i.occlusionTexture)), i.occlusionTexture.strength !== void 0 && (a.aoMapIntensity = i.occlusionTexture.strength)), i.emissiveFactor !== void 0 && r !== Gt && (a.emissive = new Be().fromArray(i.emissiveFactor)), i.emissiveTexture !== void 0 && r !== Gt && c.push(t.assignTexture(a, "emissiveMap", i.emissiveTexture, 3001)), Promise.all(c).then(function() {
+    return i.occlusionTexture !== void 0 && r !== Yt && (c.push(t.assignTexture(a, "aoMap", i.occlusionTexture)), i.occlusionTexture.strength !== void 0 && (a.aoMapIntensity = i.occlusionTexture.strength)), i.emissiveFactor !== void 0 && r !== Yt && (a.emissive = new Re().fromArray(i.emissiveFactor)), i.emissiveTexture !== void 0 && r !== Yt && c.push(t.assignTexture(a, "emissiveMap", i.emissiveTexture, 3001)), Promise.all(c).then(function() {
       const h = new r(a);
-      return i.name && (h.name = i.name), an(h, i), t.associations.set(h, { materials: e }), i.extensions && pn(s, h, i), h;
+      return i.name && (h.name = i.name), cn(h, i), t.associations.set(h, { materials: e }), i.extensions && vn(s, h, i), h;
     });
   }
   /** When Object3D instances are targeted by animation, they need unique names. */
   createUniqueName(e) {
-    const t = Yt.sanitizeNodeName(e || "");
+    const t = Kt.sanitizeNodeName(e || "");
     return t in this.nodeNamesUsed ? t + "_" + ++this.nodeNamesUsed[t] : (this.nodeNamesUsed[t] = 0, t);
   }
   /**
@@ -3678,18 +3678,18 @@ class Uu {
   loadGeometries(e) {
     const t = this, n = this.extensions, s = this.primitiveCache;
     function i(a) {
-      return n[Ce.KHR_DRACO_MESH_COMPRESSION].decodePrimitive(a, t).then(function(l) {
-        return jr(l, a, t);
+      return n[Ie.KHR_DRACO_MESH_COMPRESSION].decodePrimitive(a, t).then(function(l) {
+        return Zr(l, a, t);
       });
     }
     const r = [];
     for (let a = 0, l = e.length; a < l; a++) {
-      const c = e[a], u = Ou(c), h = s[u];
+      const c = e[a], u = ju(c), h = s[u];
       if (h)
         r.push(h.promise);
       else {
-        let m;
-        c.extensions && c.extensions[Ce.KHR_DRACO_MESH_COMPRESSION] ? m = i(c) : m = jr(new rt(), c, t), s[u] = { primitive: c, promise: m }, r.push(m);
+        let f;
+        c.extensions && c.extensions[Ie.KHR_DRACO_MESH_COMPRESSION] ? f = i(c) : f = Zr(new at(), c, t), s[u] = { primitive: c, promise: f }, r.push(f);
       }
     }
     return Promise.all(r);
@@ -3702,41 +3702,41 @@ class Uu {
   loadMesh(e) {
     const t = this, n = this.json, s = this.extensions, i = n.meshes[e], r = i.primitives, a = [];
     for (let l = 0, c = r.length; l < c; l++) {
-      const u = r[l].material === void 0 ? Iu(this.cache) : this.getDependency("material", r[l].material);
+      const u = r[l].material === void 0 ? Nu(this.cache) : this.getDependency("material", r[l].material);
       a.push(u);
     }
     return a.push(t.loadGeometries(r)), Promise.all(a).then(function(l) {
       const c = l.slice(0, l.length - 1), u = l[l.length - 1], h = [];
-      for (let p = 0, v = u.length; p < v; p++) {
-        const _ = u[p], y = r[p];
-        let E;
-        const R = c[p];
-        if (y.mode === vt.TRIANGLES || y.mode === vt.TRIANGLE_STRIP || y.mode === vt.TRIANGLE_FAN || y.mode === void 0)
-          E = i.isSkinnedMesh === !0 ? new $o(_, R) : new ae(_, R), E.isSkinnedMesh === !0 && E.normalizeSkinWeights(), y.mode === vt.TRIANGLE_STRIP ? E.geometry = Rr(E.geometry, ko) : y.mode === vt.TRIANGLE_FAN && (E.geometry = Rr(E.geometry, Ni));
-        else if (y.mode === vt.LINES)
-          E = new ml(_, R);
-        else if (y.mode === vt.LINE_STRIP)
-          E = new Ie(_, R);
-        else if (y.mode === vt.LINE_LOOP)
-          E = new gl(_, R);
-        else if (y.mode === vt.POINTS)
-          E = new Zo(_, R);
+      for (let d = 0, y = u.length; d < y; d++) {
+        const x = u[d], g = r[d];
+        let v;
+        const M = c[d];
+        if (g.mode === _t.TRIANGLES || g.mode === _t.TRIANGLE_STRIP || g.mode === _t.TRIANGLE_FAN || g.mode === void 0)
+          v = i.isSkinnedMesh === !0 ? new ta(x, M) : new ae(x, M), v.isSkinnedMesh === !0 && v.normalizeSkinWeights(), g.mode === _t.TRIANGLE_STRIP ? v.geometry = Fr(v.geometry, Go) : g.mode === _t.TRIANGLE_FAN && (v.geometry = Fr(v.geometry, Yi));
+        else if (g.mode === _t.LINES)
+          v = new Tl(x, M);
+        else if (g.mode === _t.LINE_STRIP)
+          v = new De(x, M);
+        else if (g.mode === _t.LINE_LOOP)
+          v = new bl(x, M);
+        else if (g.mode === _t.POINTS)
+          v = new na(x, M);
         else
-          throw new Error("THREE.GLTFLoader: Primitive mode unsupported: " + y.mode);
-        Object.keys(E.geometry.morphAttributes).length > 0 && Lu(E, i), E.name = t.createUniqueName(i.name || "mesh_" + e), an(E, i), y.extensions && pn(s, E, y), t.assignFinalMaterial(E), h.push(E);
+          throw new Error("THREE.GLTFLoader: Primitive mode unsupported: " + g.mode);
+        Object.keys(v.geometry.morphAttributes).length > 0 && Hu(v, i), v.name = t.createUniqueName(i.name || "mesh_" + e), cn(v, i), g.extensions && vn(s, v, g), t.assignFinalMaterial(v), h.push(v);
       }
-      for (let p = 0, v = h.length; p < v; p++)
-        t.associations.set(h[p], {
+      for (let d = 0, y = h.length; d < y; d++)
+        t.associations.set(h[d], {
           meshes: e,
-          primitives: p
+          primitives: d
         });
       if (h.length === 1)
-        return i.extensions && pn(s, h[0], i), h[0];
-      const m = new ns();
-      i.extensions && pn(s, m, i), t.associations.set(m, { meshes: e });
-      for (let p = 0, v = h.length; p < v; p++)
-        m.add(h[p]);
-      return m;
+        return i.extensions && vn(s, h[0], i), h[0];
+      const f = new cs();
+      i.extensions && vn(s, f, i), t.associations.set(f, { meshes: e });
+      for (let d = 0, y = h.length; d < y; d++)
+        f.add(h[d]);
+      return f;
     });
   }
   /**
@@ -3751,12 +3751,12 @@ class Uu {
       console.warn("THREE.GLTFLoader: Missing camera parameters.");
       return;
     }
-    return n.type === "perspective" ? t = new Mt(
-      We.radToDeg(s.yfov),
+    return n.type === "perspective" ? t = new wt(
+      Ze.radToDeg(s.yfov),
       s.aspectRatio || 1,
       s.znear || 1,
       s.zfar || 2e6
-    ) : n.type === "orthographic" && (t = new jt(-s.xmag, s.xmag, s.ymag, -s.ymag, s.znear, s.zfar)), n.name && (t.name = this.createUniqueName(n.name)), an(t, n), Promise.resolve(t);
+    ) : n.type === "orthographic" && (t = new Xt(-s.xmag, s.xmag, s.ymag, -s.ymag, s.znear, s.zfar)), n.name && (t.name = this.createUniqueName(n.name)), cn(t, n), Promise.resolve(t);
   }
   /**
    * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#skins
@@ -3773,12 +3773,12 @@ class Uu {
         const h = r[c];
         if (h) {
           a.push(h);
-          const m = new De();
-          i !== null && m.fromArray(i.array, c * 16), l.push(m);
+          const f = new Pe();
+          i !== null && f.fromArray(i.array, c * 16), l.push(f);
         } else
           console.warn('THREE.GLTFLoader: Joint "%s" could not be found.', t.joints[c]);
       }
-      return new Ko(a, l);
+      return new sa(a, l);
     });
   }
   /**
@@ -3789,8 +3789,8 @@ class Uu {
   loadAnimation(e) {
     const n = this.json.animations[e], s = n.name ? n.name : "animation_" + e, i = [], r = [], a = [], l = [], c = [];
     for (let u = 0, h = n.channels.length; u < h; u++) {
-      const m = n.channels[u], p = n.samplers[m.sampler], v = m.target, _ = v.node, y = n.parameters !== void 0 ? n.parameters[p.input] : p.input, E = n.parameters !== void 0 ? n.parameters[p.output] : p.output;
-      v.node !== void 0 && (i.push(this.getDependency("node", _)), r.push(this.getDependency("accessor", y)), a.push(this.getDependency("accessor", E)), l.push(p), c.push(v));
+      const f = n.channels[u], d = n.samplers[f.sampler], y = f.target, x = y.node, g = n.parameters !== void 0 ? n.parameters[d.input] : d.input, v = n.parameters !== void 0 ? n.parameters[d.output] : d.output;
+      y.node !== void 0 && (i.push(this.getDependency("node", x)), r.push(this.getDependency("accessor", g)), a.push(this.getDependency("accessor", v)), l.push(d), c.push(y));
     }
     return Promise.all([
       Promise.all(i),
@@ -3799,51 +3799,51 @@ class Uu {
       Promise.all(l),
       Promise.all(c)
     ]).then(function(u) {
-      const h = u[0], m = u[1], p = u[2], v = u[3], _ = u[4], y = [];
-      for (let E = 0, R = h.length; E < R; E++) {
-        const T = h[E], g = m[E], A = p[E], x = v[E], M = _[E];
-        if (T === void 0)
+      const h = u[0], f = u[1], d = u[2], y = u[3], x = u[4], g = [];
+      for (let v = 0, M = h.length; v < M; v++) {
+        const _ = h[v], w = f[v], P = d[v], T = y[v], E = x[v];
+        if (_ === void 0)
           continue;
-        T.updateMatrix();
-        let d;
-        switch (Qt[M.path]) {
-          case Qt.weights:
-            d = Jo;
+        _.updateMatrix();
+        let m;
+        switch (tn[E.path]) {
+          case tn.weights:
+            m = oa;
             break;
-          case Qt.rotation:
-            d = Gi;
+          case tn.rotation:
+            m = Zi;
             break;
-          case Qt.position:
-          case Qt.scale:
+          case tn.position:
+          case tn.scale:
           default:
-            d = Qo;
+            m = ra;
             break;
         }
-        const w = T.name ? T.name : T.uuid, f = x.interpolation !== void 0 ? Cu[x.interpolation] : or, P = [];
-        Qt[M.path] === Qt.weights ? T.traverse(function(K) {
-          K.morphTargetInfluences && P.push(K.name ? K.name : K.uuid);
-        }) : P.push(w);
-        let I = A.array;
-        if (A.normalized) {
-          const K = Ji(I.constructor), N = new Float32Array(I.length);
-          for (let Z = 0, W = I.length; Z < W; Z++)
-            N[Z] = I[Z] * K;
-          I = N;
+        const b = _.name ? _.name : _.uuid, p = T.interpolation !== void 0 ? Uu[T.interpolation] : hr, C = [];
+        tn[E.path] === tn.weights ? _.traverse(function(K) {
+          K.morphTargetInfluences && C.push(K.name ? K.name : K.uuid);
+        }) : C.push(b);
+        let I = P.array;
+        if (P.normalized) {
+          const K = ir(I.constructor), z = new Float32Array(I.length);
+          for (let Y = 0, W = I.length; Y < W; Y++)
+            z[Y] = I[Y] * K;
+          I = z;
         }
-        for (let K = 0, N = P.length; K < N; K++) {
-          const Z = new d(
-            P[K] + "." + Qt[M.path],
-            g.array,
+        for (let K = 0, z = C.length; K < z; K++) {
+          const Y = new m(
+            C[K] + "." + tn[E.path],
+            w.array,
             I,
-            f
+            p
           );
-          x.interpolation === "CUBICSPLINE" && (Z.createInterpolant = function(X) {
-            const V = this instanceof Gi ? Ru : ba;
+          T.interpolation === "CUBICSPLINE" && (Y.createInterpolant = function(X) {
+            const V = this instanceof Zi ? Bu : Ra;
             return new V(this.times, this.values, this.getValueSize() / 3, X);
-          }, Z.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline = !0), y.push(Z);
+          }, Y.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline = !0), g.push(Y);
         }
       }
-      return new qo(s, void 0, y);
+      return new ia(s, void 0, g);
     });
   }
   createNodeMesh(e) {
@@ -3868,12 +3868,12 @@ class Uu {
       r.push(n.getDependency("node", a[c]));
     const l = s.skin === void 0 ? Promise.resolve(null) : n.getDependency("skin", s.skin);
     return Promise.all([i, Promise.all(r), l]).then(function(c) {
-      const u = c[0], h = c[1], m = c[2];
-      m !== null && u.traverse(function(p) {
-        p.isSkinnedMesh && p.bind(m, ku);
+      const u = c[0], h = c[1], f = c[2];
+      f !== null && u.traverse(function(d) {
+        d.isSkinnedMesh && d.bind(f, Vu);
       });
-      for (let p = 0, v = h.length; p < v; p++)
-        u.add(h[p]);
+      for (let d = 0, y = h.length; d < y; d++)
+        u.add(h[d]);
       return u;
     });
   }
@@ -3896,11 +3896,11 @@ class Uu {
       a.push(c);
     }), this.nodeCache[e] = Promise.all(a).then(function(c) {
       let u;
-      if (i.isBone === !0 ? u = new Hi() : c.length > 1 ? u = new ns() : c.length === 1 ? u = c[0] : u = new St(), u !== c[0])
-        for (let h = 0, m = c.length; h < m; h++)
+      if (i.isBone === !0 ? u = new $i() : c.length > 1 ? u = new cs() : c.length === 1 ? u = c[0] : u = new Tt(), u !== c[0])
+        for (let h = 0, f = c.length; h < f; h++)
           u.add(c[h]);
-      if (i.name && (u.userData.name = i.name, u.name = r), an(u, i), i.extensions && pn(n, u, i), i.matrix !== void 0) {
-        const h = new De();
+      if (i.name && (u.userData.name = i.name, u.name = r), cn(u, i), i.extensions && vn(n, u, i), i.matrix !== void 0) {
+        const h = new Pe();
         h.fromArray(i.matrix), u.applyMatrix4(h);
       } else
         i.translation !== void 0 && u.position.fromArray(i.translation), i.rotation !== void 0 && u.quaternion.fromArray(i.rotation), i.scale !== void 0 && u.scale.fromArray(i.scale);
@@ -3913,8 +3913,8 @@ class Uu {
    * @return {Promise<Group>}
    */
   loadScene(e) {
-    const t = this.extensions, n = this.json.scenes[e], s = this, i = new ns();
-    n.name && (i.name = s.createUniqueName(n.name)), an(i, n), n.extensions && pn(t, i, n);
+    const t = this.extensions, n = this.json.scenes[e], s = this, i = new cs();
+    n.name && (i.name = s.createUniqueName(n.name)), cn(i, n), n.extensions && vn(t, i, n);
     const r = n.nodes || [], a = [];
     for (let l = 0, c = r.length; l < c; l++)
       a.push(s.getDependency("node", r[l]));
@@ -3923,24 +3923,24 @@ class Uu {
         i.add(l[u]);
       const c = (u) => {
         const h = /* @__PURE__ */ new Map();
-        for (const [m, p] of s.associations)
-          (m instanceof ri || m instanceof zn) && h.set(m, p);
-        return u.traverse((m) => {
-          const p = s.associations.get(m);
-          p != null && h.set(m, p);
+        for (const [f, d] of s.associations)
+          (f instanceof hi || f instanceof Vn) && h.set(f, d);
+        return u.traverse((f) => {
+          const d = s.associations.get(f);
+          d != null && h.set(f, d);
         }), h;
       };
       return s.associations = c(i), i;
     });
   }
 }
-function Bu(o, e, t) {
-  const n = e.attributes, s = new hs();
+function Yu(o, e, t) {
+  const n = e.attributes, s = new xs();
   if (n.POSITION !== void 0) {
     const a = t.json.accessors[n.POSITION], l = a.min, c = a.max;
     if (l !== void 0 && c !== void 0) {
-      if (s.set(new ee(l[0], l[1], l[2]), new ee(c[0], c[1], c[2])), a.normalized) {
-        const u = Ji(Nn[a.componentType]);
+      if (s.set(new q(l[0], l[1], l[2]), new q(c[0], c[1], c[2])), a.normalized) {
+        const u = ir(Gn[a.componentType]);
         s.min.multiplyScalar(u), s.max.multiplyScalar(u);
       }
     } else {
@@ -3951,15 +3951,15 @@ function Bu(o, e, t) {
     return;
   const i = e.targets;
   if (i !== void 0) {
-    const a = new ee(), l = new ee();
+    const a = new q(), l = new q();
     for (let c = 0, u = i.length; c < u; c++) {
       const h = i[c];
       if (h.POSITION !== void 0) {
-        const m = t.json.accessors[h.POSITION], p = m.min, v = m.max;
-        if (p !== void 0 && v !== void 0) {
-          if (l.setX(Math.max(Math.abs(p[0]), Math.abs(v[0]))), l.setY(Math.max(Math.abs(p[1]), Math.abs(v[1]))), l.setZ(Math.max(Math.abs(p[2]), Math.abs(v[2]))), m.normalized) {
-            const _ = Ji(Nn[m.componentType]);
-            l.multiplyScalar(_);
+        const f = t.json.accessors[h.POSITION], d = f.min, y = f.max;
+        if (d !== void 0 && y !== void 0) {
+          if (l.setX(Math.max(Math.abs(d[0]), Math.abs(y[0]))), l.setY(Math.max(Math.abs(d[1]), Math.abs(y[1]))), l.setZ(Math.max(Math.abs(d[2]), Math.abs(y[2]))), f.normalized) {
+            const x = ir(Gn[f.componentType]);
+            l.multiplyScalar(x);
           }
           a.max(l);
         } else
@@ -3969,10 +3969,10 @@ function Bu(o, e, t) {
     s.expandByVector(a);
   }
   o.boundingBox = s;
-  const r = new Qs();
+  const r = new ri();
   s.getCenter(r.center), r.radius = s.min.distanceTo(s.max) / 2, o.boundingSphere = r;
 }
-function jr(o, e, t) {
+function Zr(o, e, t) {
   const n = e.attributes, s = [];
   function i(r, a) {
     return t.getDependency("accessor", r).then(function(l) {
@@ -3980,7 +3980,7 @@ function jr(o, e, t) {
     });
   }
   for (const r in n) {
-    const a = Qi[r] || r.toLowerCase();
+    const a = sr[r] || r.toLowerCase();
     a in o.attributes || s.push(i(n[r], a));
   }
   if (e.indices !== void 0 && !o.index) {
@@ -3989,11 +3989,48 @@ function jr(o, e, t) {
     });
     s.push(r);
   }
-  return an(o, e), Bu(o, e, t), Promise.all(s).then(function() {
-    return e.targets !== void 0 ? Du(o, e.targets, t) : o;
+  return cn(o, e), Yu(o, e, t), Promise.all(s).then(function() {
+    return e.targets !== void 0 ? zu(o, e.targets, t) : o;
   });
 }
-class Vr extends _l {
+const es = new q();
+function vt(o, e, t, n, s, i) {
+  const r = 2 * Math.PI * s / 4, a = Math.max(i - 2 * s, 0), l = Math.PI / 4;
+  es.copy(e), es[n] = 0, es.normalize();
+  const c = 0.5 * r / (r + a), u = 1 - es.angleTo(o) / l;
+  return Math.sign(es[t]) === 1 ? u * c : a / (r + a) + c + c * (1 - u);
+}
+class Xu extends Wt {
+  constructor(e = 1, t = 1, n = 1, s = 2, i = 0.1) {
+    if (s = s * 2 + 1, i = Math.min(e / 2, t / 2, n / 2, i), super(1, 1, 1, s, s, s), s === 1)
+      return;
+    const r = this.toNonIndexed();
+    this.index = null, this.attributes.position = r.attributes.position, this.attributes.normal = r.attributes.normal, this.attributes.uv = r.attributes.uv;
+    const a = new q(), l = new q(), c = new q(e, t, n).divideScalar(2).subScalar(i), u = this.attributes.position.array, h = this.attributes.normal.array, f = this.attributes.uv.array, d = u.length / 6, y = new q(), x = 0.5 / s;
+    for (let g = 0, v = 0; g < u.length; g += 3, v += 2)
+      switch (a.fromArray(u, g), l.copy(a), l.x -= Math.sign(l.x) * x, l.y -= Math.sign(l.y) * x, l.z -= Math.sign(l.z) * x, l.normalize(), u[g + 0] = c.x * Math.sign(a.x) + l.x * i, u[g + 1] = c.y * Math.sign(a.y) + l.y * i, u[g + 2] = c.z * Math.sign(a.z) + l.z * i, h[g + 0] = l.x, h[g + 1] = l.y, h[g + 2] = l.z, Math.floor(g / d)) {
+        case 0:
+          y.set(1, 0, 0), f[v + 0] = vt(y, l, "z", "y", i, n), f[v + 1] = 1 - vt(y, l, "y", "z", i, t);
+          break;
+        case 1:
+          y.set(-1, 0, 0), f[v + 0] = 1 - vt(y, l, "z", "y", i, n), f[v + 1] = 1 - vt(y, l, "y", "z", i, t);
+          break;
+        case 2:
+          y.set(0, 1, 0), f[v + 0] = 1 - vt(y, l, "x", "z", i, e), f[v + 1] = vt(y, l, "z", "x", i, n);
+          break;
+        case 3:
+          y.set(0, -1, 0), f[v + 0] = 1 - vt(y, l, "x", "z", i, e), f[v + 1] = 1 - vt(y, l, "z", "x", i, n);
+          break;
+        case 4:
+          y.set(0, 0, 1), f[v + 0] = 1 - vt(y, l, "x", "y", i, e), f[v + 1] = 1 - vt(y, l, "y", "x", i, t);
+          break;
+        case 5:
+          y.set(0, 0, -1), f[v + 0] = vt(y, l, "x", "y", i, e), f[v + 1] = 1 - vt(y, l, "y", "x", i, t);
+          break;
+      }
+  }
+}
+class Kr extends Sl {
   constructor(e, t = {}) {
     const {
       bevelEnabled: n = !1,
@@ -4009,13 +4046,13 @@ class Vr extends _l {
     if (r === void 0)
       super();
     else {
-      const m = r.generateShapes(e, l, { lineHeight: c, letterSpacing: u });
-      super(m, { ...h, bevelEnabled: n, bevelSize: s, bevelThickness: i, depth: a });
+      const f = r.generateShapes(e, l, { lineHeight: c, letterSpacing: u });
+      super(f, { ...h, bevelEnabled: n, bevelSize: s, bevelThickness: i, depth: a });
     }
     this.type = "TextGeometry";
   }
 }
-const Nu = {
+const $u = {
   uniforms: {
     tDiffuse: { value: null },
     h: { value: 1 / 512 }
@@ -4060,7 +4097,7 @@ const Nu = {
     }
   `
   )
-}, zu = {
+}, Zu = {
   uniforms: {
     tDiffuse: { value: null },
     v: { value: 1 / 512 }
@@ -4107,7 +4144,7 @@ const Nu = {
   `
   )
 };
-function Ea(o, e, t) {
+function Ia(o, e, t) {
   const n = t.length - o - 1;
   if (e >= t[n])
     return n - 1;
@@ -4118,29 +4155,29 @@ function Ea(o, e, t) {
     e < t[r] ? i = r : s = r, r = Math.floor((s + i) / 2);
   return r;
 }
-function Hu(o, e, t, n) {
+function Ku(o, e, t, n) {
   const s = [], i = [], r = [];
   s[0] = 1;
   for (let a = 1; a <= t; ++a) {
     i[a] = e - n[o + 1 - a], r[a] = n[o + a] - e;
     let l = 0;
     for (let c = 0; c < a; ++c) {
-      const u = r[c + 1], h = i[a - c], m = s[c] / (u + h);
-      s[c] = l + u * m, l = h * m;
+      const u = r[c + 1], h = i[a - c], f = s[c] / (u + h);
+      s[c] = l + u * f, l = h * f;
     }
     s[a] = l;
   }
   return s;
 }
-function Gu(o, e, t, n) {
-  const s = Ea(o, n, e), i = Hu(s, n, o, e), r = new ht(0, 0, 0, 0);
+function qu(o, e, t, n) {
+  const s = Ia(o, n, e), i = Ku(s, n, o, e), r = new rt(0, 0, 0, 0);
   for (let a = 0; a <= o; ++a) {
     const l = t[s - o + a], c = i[a], u = l.w * c;
     r.x += l.x * u, r.y += l.y * u, r.z += l.z * u, r.w += l.w * c;
   }
   return r;
 }
-function ju(o, e, t, n, s) {
+function Qu(o, e, t, n, s) {
   const i = [];
   for (let h = 0; h <= t; ++h)
     i[h] = 0;
@@ -4154,60 +4191,60 @@ function ju(o, e, t, n, s) {
   const l = i.slice(0), c = i.slice(0);
   for (let h = 1; h <= t; ++h) {
     l[h] = e - s[o + 1 - h], c[h] = s[o + h] - e;
-    let m = 0;
-    for (let p = 0; p < h; ++p) {
-      const v = c[p + 1], _ = l[h - p];
-      a[h][p] = v + _;
-      const y = a[p][h - 1] / a[h][p];
-      a[p][h] = m + v * y, m = _ * y;
+    let f = 0;
+    for (let d = 0; d < h; ++d) {
+      const y = c[d + 1], x = l[h - d];
+      a[h][d] = y + x;
+      const g = a[d][h - 1] / a[h][d];
+      a[d][h] = f + y * g, f = x * g;
     }
-    a[h][h] = m;
+    a[h][h] = f;
   }
   for (let h = 0; h <= t; ++h)
     r[0][h] = a[h][t];
   for (let h = 0; h <= t; ++h) {
-    let m = 0, p = 1;
-    const v = [];
-    for (let _ = 0; _ <= t; ++_)
-      v[_] = i.slice(0);
-    v[0][0] = 1;
-    for (let _ = 1; _ <= n; ++_) {
-      let y = 0;
-      const E = h - _, R = t - _;
-      h >= _ && (v[p][0] = v[m][0] / a[R + 1][E], y = v[p][0] * a[E][R]);
-      const T = E >= -1 ? 1 : -E, g = h - 1 <= R ? _ - 1 : t - h;
-      for (let x = T; x <= g; ++x)
-        v[p][x] = (v[m][x] - v[m][x - 1]) / a[R + 1][E + x], y += v[p][x] * a[E + x][R];
-      h <= R && (v[p][_] = -v[m][_ - 1] / a[R + 1][h], y += v[p][_] * a[h][R]), r[_][h] = y;
-      const A = m;
-      m = p, p = A;
+    let f = 0, d = 1;
+    const y = [];
+    for (let x = 0; x <= t; ++x)
+      y[x] = i.slice(0);
+    y[0][0] = 1;
+    for (let x = 1; x <= n; ++x) {
+      let g = 0;
+      const v = h - x, M = t - x;
+      h >= x && (y[d][0] = y[f][0] / a[M + 1][v], g = y[d][0] * a[v][M]);
+      const _ = v >= -1 ? 1 : -v, w = h - 1 <= M ? x - 1 : t - h;
+      for (let T = _; T <= w; ++T)
+        y[d][T] = (y[f][T] - y[f][T - 1]) / a[M + 1][v + T], g += y[d][T] * a[v + T][M];
+      h <= M && (y[d][x] = -y[f][x - 1] / a[M + 1][h], g += y[d][x] * a[h][M]), r[x][h] = g;
+      const P = f;
+      f = d, d = P;
     }
   }
   let u = t;
   for (let h = 1; h <= n; ++h) {
-    for (let m = 0; m <= t; ++m)
-      r[h][m] *= u;
+    for (let f = 0; f <= t; ++f)
+      r[h][f] *= u;
     u *= t - h;
   }
   return r;
 }
-function Vu(o, e, t, n, s) {
-  const i = s < o ? s : o, r = [], a = Ea(o, n, e), l = ju(a, n, o, i, e), c = [];
+function Ju(o, e, t, n, s) {
+  const i = s < o ? s : o, r = [], a = Ia(o, n, e), l = Qu(a, n, o, i, e), c = [];
   for (let u = 0; u < t.length; ++u) {
-    const h = t[u].clone(), m = h.w;
-    h.x *= m, h.y *= m, h.z *= m, c[u] = h;
+    const h = t[u].clone(), f = h.w;
+    h.x *= f, h.y *= f, h.z *= f, c[u] = h;
   }
   for (let u = 0; u <= i; ++u) {
     const h = c[a - o].clone().multiplyScalar(l[u][0]);
-    for (let m = 1; m <= o; ++m)
-      h.add(c[a - o + m].clone().multiplyScalar(l[u][m]));
+    for (let f = 1; f <= o; ++f)
+      h.add(c[a - o + f].clone().multiplyScalar(l[u][f]));
     r[u] = h;
   }
   for (let u = i + 1; u <= s + 1; ++u)
-    r[u] = new ht(0, 0, 0);
+    r[u] = new rt(0, 0, 0);
   return r;
 }
-function Yu(o, e) {
+function eh(o, e) {
   let t = 1;
   for (let s = 2; s <= o; ++s)
     t *= s;
@@ -4218,49 +4255,49 @@ function Yu(o, e) {
     n *= s;
   return t / n;
 }
-function Xu(o) {
+function th(o) {
   const e = o.length, t = [], n = [];
   for (let i = 0; i < e; ++i) {
     const r = o[i];
-    t[i] = new ee(r.x, r.y, r.z), n[i] = r.w;
+    t[i] = new q(r.x, r.y, r.z), n[i] = r.w;
   }
   const s = [];
   for (let i = 0; i < e; ++i) {
     const r = t[i].clone();
     for (let a = 1; a <= i; ++a)
-      r.sub(s[i - a].clone().multiplyScalar(Yu(i, a) * n[a]));
+      r.sub(s[i - a].clone().multiplyScalar(eh(i, a) * n[a]));
     s[i] = r.divideScalar(n[0]);
   }
   return s;
 }
-function Wu(o, e, t, n, s) {
-  const i = Vu(o, e, t, n, s);
-  return Xu(i);
+function nh(o, e, t, n, s) {
+  const i = Ju(o, e, t, n, s);
+  return th(i);
 }
-class Yr extends xl {
+class qr extends Ml {
   constructor(e, t, n, s, i) {
     super(), this.degree = e, this.knots = t, this.controlPoints = [], this.startKnot = s || 0, this.endKnot = i || this.knots.length - 1;
     for (let r = 0; r < n.length; ++r) {
       const a = n[r];
-      this.controlPoints[r] = new ht(a.x, a.y, a.z, a.w);
+      this.controlPoints[r] = new rt(a.x, a.y, a.z, a.w);
     }
   }
   getPoint(e, t) {
-    const n = t || new ee(), s = this.knots[this.startKnot] + e * (this.knots[this.endKnot] - this.knots[this.startKnot]), i = Gu(this.degree, this.knots, this.controlPoints, s);
+    const n = t || new q(), s = this.knots[this.startKnot] + e * (this.knots[this.endKnot] - this.knots[this.startKnot]), i = qu(this.degree, this.knots, this.controlPoints, s);
     return i.w != 1 && i.divideScalar(i.w), n.set(i.x, i.y, i.z);
   }
   getTangent(e, t) {
-    const n = t || new ee(), s = this.knots[0] + e * (this.knots[this.knots.length - 1] - this.knots[0]), i = Wu(this.degree, this.knots, this.controlPoints, s, 1);
+    const n = t || new q(), s = this.knots[0] + e * (this.knots[this.knots.length - 1] - this.knots[0]), i = nh(this.degree, this.knots, this.controlPoints, s, 1);
     return n.copy(i[1]).normalize(), n;
   }
 }
-let Ae, Xe, ut;
-class $u extends cs {
+let Ae, $e, ft;
+class sh extends vs {
   constructor(e) {
     super(e);
   }
   load(e, t, n, s) {
-    const i = this, r = i.path === "" ? Ft.extractUrlBase(e) : i.path, a = new Tn(this.manager);
+    const i = this, r = i.path === "" ? Bt.extractUrlBase(e) : i.path, a = new Sn(this.manager);
     a.setPath(i.path), a.setResponseType("arraybuffer"), a.setRequestHeader(i.requestHeader), a.setWithCredentials(i.withCredentials), a.load(
       e,
       function(l) {
@@ -4275,28 +4312,28 @@ class $u extends cs {
     );
   }
   parse(e, t) {
-    if (eh(e))
-      Ae = new Ju().parse(e);
+    if (ch(e))
+      Ae = new lh().parse(e);
     else {
-      const s = Pa(e);
-      if (!th(s))
+      const s = Fa(e);
+      if (!uh(s))
         throw new Error("THREE.FBXLoader: Unknown format.");
-      if (Wr(s) < 7e3)
-        throw new Error("THREE.FBXLoader: FBX version not supported, FileVersion: " + Wr(s));
-      Ae = new Qu().parse(s);
+      if (Jr(s) < 7e3)
+        throw new Error("THREE.FBXLoader: FBX version not supported, FileVersion: " + Jr(s));
+      Ae = new ah().parse(s);
     }
-    const n = new cr(this.manager).setPath(this.resourcePath || t).setCrossOrigin(this.crossOrigin);
-    return new Zu(n, this.manager).parse(Ae);
+    const n = new dr(this.manager).setPath(this.resourcePath || t).setCrossOrigin(this.crossOrigin);
+    return new ih(n, this.manager).parse(Ae);
   }
 }
-class Zu {
+class ih {
   constructor(e, t) {
     this.textureLoader = e, this.manager = t;
   }
   parse() {
-    Xe = this.parseConnections();
-    const e = this.parseImages(), t = this.parseTextures(e), n = this.parseMaterials(t), s = this.parseDeformers(), i = new Ku().parse(s);
-    return this.parseScene(s, i, n), ut;
+    $e = this.parseConnections();
+    const e = this.parseImages(), t = this.parseTextures(e), n = this.parseMaterials(t), s = this.parseDeformers(), i = new rh().parse(s);
+    return this.parseScene(s, i, n), ft;
   }
   // Parses FBXTree.Connections which holds parent-child connections between objects (e.g. material -> texture, model->geometry )
   // and details the connection type
@@ -4392,7 +4429,7 @@ class Zu {
     const n = this.loadTexture(e, t);
     n.ID = e.id, n.name = e.attrName;
     const s = e.WrapModeU, i = e.WrapModeV, r = s !== void 0 ? s.value : 0, a = i !== void 0 ? i.value : 0;
-    if (n.wrapS = r === 0 ? Gn : Hn, n.wrapT = a === 0 ? Gn : Hn, "Scaling" in e) {
+    if (n.wrapS = r === 0 ? En : Wn, n.wrapT = a === 0 ? En : Wn, "Scaling" in e) {
       const l = e.Scaling.value;
       n.repeat.x = l[0], n.repeat.y = l[1];
     }
@@ -4401,18 +4438,18 @@ class Zu {
   // load a texture specified as a blob or data URI, or via an external URL using TextureLoader
   loadTexture(e, t) {
     let n;
-    const s = this.textureLoader.path, i = Xe.get(e.id).children;
+    const s = this.textureLoader.path, i = $e.get(e.id).children;
     i !== void 0 && i.length > 0 && t[i[0].ID] !== void 0 && (n = t[i[0].ID], (n.indexOf("blob:") === 0 || n.indexOf("data:") === 0) && this.textureLoader.setPath(void 0));
     let r;
     const a = e.FileName.slice(-3).toLowerCase();
     if (a === "tga") {
       const l = this.manager.getHandler(".tga");
-      l === null ? (console.warn("FBXLoader: TGA loader not found, creating placeholder texture for", e.RelativeFilename), r = new zn()) : (l.setPath(this.textureLoader.path), r = l.load(n));
+      l === null ? (console.warn("FBXLoader: TGA loader not found, creating placeholder texture for", e.RelativeFilename), r = new Vn()) : (l.setPath(this.textureLoader.path), r = l.load(n));
     } else
       a === "psd" ? (console.warn(
         "FBXLoader: PSD textures are not supported, creating placeholder texture for",
         e.RelativeFilename
-      ), r = new zn()) : r = this.textureLoader.load(n);
+      ), r = new Vn()) : r = this.textureLoader.load(n);
     return this.textureLoader.setPath(s), r;
   }
   // Parse nodes in FBXTree.Objects.Material
@@ -4433,19 +4470,19 @@ class Zu {
   parseMaterial(e, t) {
     const n = e.id, s = e.attrName;
     let i = e.ShadingModel;
-    if (typeof i == "object" && (i = i.value), !Xe.has(n))
+    if (typeof i == "object" && (i = i.value), !$e.has(n))
       return null;
     const r = this.parseParameters(e, t, n);
     let a;
     switch (i.toLowerCase()) {
       case "phong":
-        a = new oi();
+        a = new fi();
         break;
       case "lambert":
-        a = new wl();
+        a = new Al();
         break;
       default:
-        console.warn('THREE.FBXLoader: unknown material type "%s". Defaulting to MeshPhongMaterial.', i), a = new oi();
+        console.warn('THREE.FBXLoader: unknown material type "%s". Defaulting to MeshPhongMaterial.', i), a = new fi();
         break;
     }
     return a.setValues(r), a.name = s, a;
@@ -4454,9 +4491,9 @@ class Zu {
   // Also parse the texture map and return any textures associated with the material
   parseParameters(e, t, n) {
     const s = {};
-    e.BumpFactor && (s.bumpScale = e.BumpFactor.value), e.Diffuse ? s.color = new Be().fromArray(e.Diffuse.value) : e.DiffuseColor && (e.DiffuseColor.type === "Color" || e.DiffuseColor.type === "ColorRGB") && (s.color = new Be().fromArray(e.DiffuseColor.value)), e.DisplacementFactor && (s.displacementScale = e.DisplacementFactor.value), e.Emissive ? s.emissive = new Be().fromArray(e.Emissive.value) : e.EmissiveColor && (e.EmissiveColor.type === "Color" || e.EmissiveColor.type === "ColorRGB") && (s.emissive = new Be().fromArray(e.EmissiveColor.value)), e.EmissiveFactor && (s.emissiveIntensity = parseFloat(e.EmissiveFactor.value)), e.Opacity && (s.opacity = parseFloat(e.Opacity.value)), s.opacity < 1 && (s.transparent = !0), e.ReflectionFactor && (s.reflectivity = e.ReflectionFactor.value), e.Shininess && (s.shininess = e.Shininess.value), e.Specular ? s.specular = new Be().fromArray(e.Specular.value) : e.SpecularColor && e.SpecularColor.type === "Color" && (s.specular = new Be().fromArray(e.SpecularColor.value));
+    e.BumpFactor && (s.bumpScale = e.BumpFactor.value), e.Diffuse ? s.color = new Re().fromArray(e.Diffuse.value) : e.DiffuseColor && (e.DiffuseColor.type === "Color" || e.DiffuseColor.type === "ColorRGB") && (s.color = new Re().fromArray(e.DiffuseColor.value)), e.DisplacementFactor && (s.displacementScale = e.DisplacementFactor.value), e.Emissive ? s.emissive = new Re().fromArray(e.Emissive.value) : e.EmissiveColor && (e.EmissiveColor.type === "Color" || e.EmissiveColor.type === "ColorRGB") && (s.emissive = new Re().fromArray(e.EmissiveColor.value)), e.EmissiveFactor && (s.emissiveIntensity = parseFloat(e.EmissiveFactor.value)), e.Opacity && (s.opacity = parseFloat(e.Opacity.value)), s.opacity < 1 && (s.transparent = !0), e.ReflectionFactor && (s.reflectivity = e.ReflectionFactor.value), e.Shininess && (s.shininess = e.Shininess.value), e.Specular ? s.specular = new Re().fromArray(e.Specular.value) : e.SpecularColor && e.SpecularColor.type === "Color" && (s.specular = new Re().fromArray(e.SpecularColor.value));
     const i = this;
-    return Xe.get(n).children.forEach(function(r) {
+    return $e.get(n).children.forEach(function(r) {
       const a = r.relationship;
       switch (a) {
         case "Bump":
@@ -4480,7 +4517,7 @@ class Zu {
           s.normalMap = i.getTexture(t, r.ID);
           break;
         case "ReflectionColor":
-          s.envMap = i.getTexture(t, r.ID), s.envMap !== void 0 && (s.envMap.mapping = ji, "colorSpace" in s.envMap ? s.envMap.colorSpace = "srgb" : s.envMap.encoding = 3001);
+          s.envMap = i.getTexture(t, r.ID), s.envMap !== void 0 && (s.envMap.mapping = Ki, "colorSpace" in s.envMap ? s.envMap.colorSpace = "srgb" : s.envMap.encoding = 3001);
           break;
         case "SpecularColor":
           s.specularMap = i.getTexture(t, r.ID), s.specularMap !== void 0 && ("colorSpace" in s.specularMap ? s.specularMap.colorSpace = "srgb" : s.specularMap.encoding = 3001);
@@ -4501,7 +4538,7 @@ class Zu {
   }
   // get a texture from the textureMap for use by a material.
   getTexture(e, t) {
-    return "LayeredTexture" in Ae.Objects && t in Ae.Objects.LayeredTexture && (console.warn("THREE.FBXLoader: layered textures are not supported in three.js. Discarding all but first layer."), t = Xe.get(t).children[0].ID), e.get(t);
+    return "LayeredTexture" in Ae.Objects && t in Ae.Objects.LayeredTexture && (console.warn("THREE.FBXLoader: layered textures are not supported in three.js. Discarding all but first layer."), t = $e.get(t).children[0].ID), e.get(t);
   }
   // Parse nodes in FBXTree.Objects.Deformer
   // Deformer node can contain skinning or Vertex Cache animation data, however only skinning is supported here
@@ -4511,7 +4548,7 @@ class Zu {
     if ("Deformer" in Ae.Objects) {
       const n = Ae.Objects.Deformer;
       for (const s in n) {
-        const i = n[s], r = Xe.get(parseInt(s));
+        const i = n[s], r = $e.get(parseInt(s));
         if (i.attrType === "Skin") {
           const a = this.parseSkeleton(r, n);
           a.ID = s, r.parents.length > 1 && console.warn("THREE.FBXLoader: skeleton attached to more than one geometry is not supported."), a.geometryID = r.parents[0].ID, e[s] = a;
@@ -4541,7 +4578,7 @@ class Zu {
         ID: s.ID,
         indices: [],
         weights: [],
-        transformLink: new De().fromArray(i.TransformLink.a)
+        transformLink: new Pe().fromArray(i.TransformLink.a)
         // transform: new Matrix4().fromArray( boneNode.Transform.a ),
         // linkMode: boneNode.Mode,
       };
@@ -4563,7 +4600,7 @@ class Zu {
       };
       if (r.attrType !== "BlendShapeChannel")
         return;
-      a.geoID = Xe.get(parseInt(i.ID)).children.filter(function(l) {
+      a.geoID = $e.get(parseInt(i.ID)).children.filter(function(l) {
         return l.relationship === void 0;
       })[0].ID, n.push(a);
     }
@@ -4571,29 +4608,29 @@ class Zu {
   }
   // create the main Group() to be returned by the loader
   parseScene(e, t, n) {
-    ut = new ns();
+    ft = new cs();
     const s = this.parseModels(e.skeletons, t, n), i = Ae.Objects.Model, r = this;
     s.forEach(function(l) {
       const c = i[l.ID];
-      r.setLookAtProperties(l, c), Xe.get(l.ID).parents.forEach(function(h) {
-        const m = s.get(h.ID);
-        m !== void 0 && m.add(l);
-      }), l.parent === null && ut.add(l);
-    }), this.bindSkeleton(e.skeletons, t, s), this.createAmbientLight(), ut.traverse(function(l) {
+      r.setLookAtProperties(l, c), $e.get(l.ID).parents.forEach(function(h) {
+        const f = s.get(h.ID);
+        f !== void 0 && f.add(l);
+      }), l.parent === null && ft.add(l);
+    }), this.bindSkeleton(e.skeletons, t, s), this.createAmbientLight(), ft.traverse(function(l) {
       if (l.userData.transformData) {
         l.parent && (l.userData.transformData.parentMatrix = l.parent.matrix, l.userData.transformData.parentMatrixWorld = l.parent.matrixWorld);
-        const c = Sa(l.userData.transformData);
+        const c = Oa(l.userData.transformData);
         l.applyMatrix4(c), l.updateWorldMatrix();
       }
     });
-    const a = new qu().parse();
-    ut.children.length === 1 && ut.children[0].isGroup && (ut.children[0].animations = a, ut = ut.children[0]), ut.animations = a;
+    const a = new oh().parse();
+    ft.children.length === 1 && ft.children[0].isGroup && (ft.children[0].animations = a, ft = ft.children[0]), ft.animations = a;
   }
   // parse nodes in FBXTree.Objects.Model
   parseModels(e, t, n) {
     const s = /* @__PURE__ */ new Map(), i = Ae.Objects.Model;
     for (const r in i) {
-      const a = parseInt(r), l = i[r], c = Xe.get(a);
+      const a = parseInt(r), l = i[r], c = $e.get(a);
       let u = this.buildSkeleton(c, e, a, l.attrName);
       if (!u) {
         switch (l.attrType) {
@@ -4611,14 +4648,14 @@ class Zu {
             break;
           case "LimbNode":
           case "Root":
-            u = new Hi();
+            u = new $i();
             break;
           case "Null":
           default:
-            u = new ns();
+            u = new cs();
             break;
         }
-        u.name = l.attrName ? Yt.sanitizeNodeName(l.attrName) : "", u.ID = a;
+        u.name = l.attrName ? Kt.sanitizeNodeName(l.attrName) : "", u.ID = a;
       }
       this.getTransformData(u, l), s.set(a, u);
     }
@@ -4632,7 +4669,7 @@ class Zu {
         l.rawBones.forEach(function(c, u) {
           if (c.ID === r.ID) {
             const h = i;
-            i = new Hi(), i.matrixWorld.copy(c.transformLink), i.name = s ? Yt.sanitizeNodeName(s) : "", i.ID = n, l.bones[u] = i, h !== null && i.add(h);
+            i = new $i(), i.matrixWorld.copy(c.transformLink), i.name = s ? Kt.sanitizeNodeName(s) : "", i.ID = n, l.bones[u] = i, h !== null && i.add(h);
           }
         });
       }
@@ -4645,7 +4682,7 @@ class Zu {
       const i = Ae.Objects.NodeAttribute[s.ID];
       i !== void 0 && (n = i);
     }), n === void 0)
-      t = new St();
+      t = new Tt();
     else {
       let s = 0;
       n.CameraProjectionType !== void 0 && n.CameraProjectionType.value === 1 && (s = 1);
@@ -4661,10 +4698,10 @@ class Zu {
       const h = n.FocalLength ? n.FocalLength.value : null;
       switch (s) {
         case 0:
-          t = new Mt(u, c, i, r), h !== null && t.setFocalLength(h);
+          t = new wt(u, c, i, r), h !== null && t.setFocalLength(h);
           break;
         case 1:
-          t = new jt(
+          t = new Xt(
             -a / 2,
             a / 2,
             l / 2,
@@ -4674,7 +4711,7 @@ class Zu {
           );
           break;
         default:
-          console.warn("THREE.FBXLoader: Unknown camera type " + s + "."), t = new St();
+          console.warn("THREE.FBXLoader: Unknown camera type " + s + "."), t = new Tt();
           break;
       }
     }
@@ -4687,12 +4724,12 @@ class Zu {
       const i = Ae.Objects.NodeAttribute[s.ID];
       i !== void 0 && (n = i);
     }), n === void 0)
-      t = new St();
+      t = new Tt();
     else {
       let s;
       n.LightType === void 0 ? s = 0 : s = n.LightType.value;
       let i = 16777215;
-      n.Color !== void 0 && (i = new Be().fromArray(n.Color.value));
+      n.Color !== void 0 && (i = new Re().fromArray(n.Color.value));
       let r = n.Intensity === void 0 ? 1 : n.Intensity.value / 100;
       n.CastLightOnObject !== void 0 && n.CastLightOnObject.value === 0 && (r = 0);
       let a = 0;
@@ -4700,21 +4737,21 @@ class Zu {
       const l = 1;
       switch (s) {
         case 0:
-          t = new zi(i, r, a, l);
+          t = new Xi(i, r, a, l);
           break;
         case 1:
-          t = new Wo(i, r);
+          t = new ea(i, r);
           break;
         case 2:
           let c = Math.PI / 3;
-          n.InnerAngle !== void 0 && (c = We.degToRad(n.InnerAngle.value));
+          n.InnerAngle !== void 0 && (c = Ze.degToRad(n.InnerAngle.value));
           let u = 0;
-          n.OuterAngle !== void 0 && (u = We.degToRad(n.OuterAngle.value), u = Math.max(u, 1)), t = new Xo(i, r, a, c, u, l);
+          n.OuterAngle !== void 0 && (u = Ze.degToRad(n.OuterAngle.value), u = Math.max(u, 1)), t = new Jo(i, r, a, c, u, l);
           break;
         default:
           console.warn(
             "THREE.FBXLoader: Unknown light type " + n.LightType.value + ", defaulting to a PointLight."
-          ), t = new zi(i, r);
+          ), t = new Xi(i, r);
           break;
       }
       n.CastShadows !== void 0 && n.CastShadows.value === 1 && (t.castShadow = !0);
@@ -4726,28 +4763,28 @@ class Zu {
     const a = [];
     return e.children.forEach(function(l) {
       t.has(l.ID) && (i = t.get(l.ID)), n.has(l.ID) && a.push(n.get(l.ID));
-    }), a.length > 1 ? r = a : a.length > 0 ? r = a[0] : (r = new oi({ color: 13421772 }), a.push(r)), "color" in i.attributes && a.forEach(function(l) {
+    }), a.length > 1 ? r = a : a.length > 0 ? r = a[0] : (r = new fi({ color: 13421772 }), a.push(r)), "color" in i.attributes && a.forEach(function(l) {
       l.vertexColors = !0;
-    }), i.FBX_Deformer ? (s = new $o(i, r), s.normalizeSkinWeights()) : s = new ae(i, r), s;
+    }), i.FBX_Deformer ? (s = new ta(i, r), s.normalizeSkinWeights()) : s = new ae(i, r), s;
   }
   createCurve(e, t) {
     const n = e.children.reduce(function(i, r) {
       return t.has(r.ID) && (i = t.get(r.ID)), i;
-    }, null), s = new qs({ color: 3342591, linewidth: 1 });
-    return new Ie(n, s);
+    }, null), s = new si({ color: 3342591, linewidth: 1 });
+    return new De(n, s);
   }
   // parse the model node for transform data
   getTransformData(e, t) {
     const n = {};
-    "InheritType" in t && (n.inheritType = parseInt(t.InheritType.value)), "RotationOrder" in t ? n.eulerOrder = Aa(t.RotationOrder.value) : n.eulerOrder = "ZYX", "Lcl_Translation" in t && (n.translation = t.Lcl_Translation.value), "PreRotation" in t && (n.preRotation = t.PreRotation.value), "Lcl_Rotation" in t && (n.rotation = t.Lcl_Rotation.value), "PostRotation" in t && (n.postRotation = t.PostRotation.value), "Lcl_Scaling" in t && (n.scale = t.Lcl_Scaling.value), "ScalingOffset" in t && (n.scalingOffset = t.ScalingOffset.value), "ScalingPivot" in t && (n.scalingPivot = t.ScalingPivot.value), "RotationOffset" in t && (n.rotationOffset = t.RotationOffset.value), "RotationPivot" in t && (n.rotationPivot = t.RotationPivot.value), e.userData.transformData = n;
+    "InheritType" in t && (n.inheritType = parseInt(t.InheritType.value)), "RotationOrder" in t ? n.eulerOrder = La(t.RotationOrder.value) : n.eulerOrder = "ZYX", "Lcl_Translation" in t && (n.translation = t.Lcl_Translation.value), "PreRotation" in t && (n.preRotation = t.PreRotation.value), "Lcl_Rotation" in t && (n.rotation = t.Lcl_Rotation.value), "PostRotation" in t && (n.postRotation = t.PostRotation.value), "Lcl_Scaling" in t && (n.scale = t.Lcl_Scaling.value), "ScalingOffset" in t && (n.scalingOffset = t.ScalingOffset.value), "ScalingPivot" in t && (n.scalingPivot = t.ScalingPivot.value), "RotationOffset" in t && (n.rotationOffset = t.RotationOffset.value), "RotationPivot" in t && (n.rotationPivot = t.RotationPivot.value), e.userData.transformData = n;
   }
   setLookAtProperties(e, t) {
-    "LookAtProperty" in t && Xe.get(e.ID).children.forEach(function(s) {
+    "LookAtProperty" in t && $e.get(e.ID).children.forEach(function(s) {
       if (s.relationship === "LookAtProperty") {
         const i = Ae.Objects.Model[s.ID];
         if ("Lcl_Translation" in i) {
           const r = i.Lcl_Translation.value;
-          e.target !== void 0 ? (e.target.position.fromArray(r), ut.add(e.target)) : e.lookAt(new ee().fromArray(r));
+          e.target !== void 0 ? (e.target.position.fromArray(r), ft.add(e.target)) : e.lookAt(new q().fromArray(r));
         }
       }
     });
@@ -4756,11 +4793,11 @@ class Zu {
     const s = this.parsePoseNodes();
     for (const i in e) {
       const r = e[i];
-      Xe.get(parseInt(r.ID)).parents.forEach(function(l) {
+      $e.get(parseInt(r.ID)).parents.forEach(function(l) {
         if (t.has(l.ID)) {
           const c = l.ID;
-          Xe.get(c).parents.forEach(function(h) {
-            n.has(h.ID) && n.get(h.ID).bind(new Ko(r.bones), s[h.ID]);
+          $e.get(c).parents.forEach(function(h) {
+            n.has(h.ID) && n.get(h.ID).bind(new sa(r.bones), s[h.ID]);
           });
         }
       });
@@ -4774,8 +4811,8 @@ class Zu {
         if (t[n].attrType === "BindPose" && t[n].NbPoseNodes > 0) {
           const s = t[n].PoseNode;
           Array.isArray(s) ? s.forEach(function(i) {
-            e[i.Node] = new De().fromArray(i.Matrix.a);
-          }) : e[s.Node] = new De().fromArray(s.Matrix.a);
+            e[i.Node] = new Pe().fromArray(i.Matrix.a);
+          }) : e[s.Node] = new Pe().fromArray(s.Matrix.a);
         }
     }
     return e;
@@ -4785,20 +4822,20 @@ class Zu {
     if ("GlobalSettings" in Ae && "AmbientColor" in Ae.GlobalSettings) {
       const e = Ae.GlobalSettings.AmbientColor.value, t = e[0], n = e[1], s = e[2];
       if (t !== 0 || n !== 0 || s !== 0) {
-        const i = new Be(t, n, s);
-        ut.add(new Tl(i, 1));
+        const i = new Re(t, n, s);
+        ft.add(new Pl(i, 1));
       }
     }
   }
 }
-class Ku {
+class rh {
   // Parse nodes in FBXTree.Objects.Geometry
   parse(e) {
     const t = /* @__PURE__ */ new Map();
     if ("Geometry" in Ae.Objects) {
       const n = Ae.Objects.Geometry;
       for (const s in n) {
-        const i = Xe.get(parseInt(s)), r = this.parseGeometry(i, n[s], e);
+        const i = $e.get(parseInt(s)), r = this.parseGeometry(i, n[s], e);
         t.set(parseInt(s), r);
       }
     }
@@ -4820,24 +4857,24 @@ class Ku {
     });
     if (r.length === 0)
       return;
-    const a = e.children.reduce(function(h, m) {
-      return s[m.ID] !== void 0 && (h = s[m.ID]), h;
+    const a = e.children.reduce(function(h, f) {
+      return s[f.ID] !== void 0 && (h = s[f.ID]), h;
     }, null);
     e.children.forEach(function(h) {
       n.morphTargets[h.ID] !== void 0 && i.push(n.morphTargets[h.ID]);
     });
     const l = r[0], c = {};
-    "RotationOrder" in l && (c.eulerOrder = Aa(l.RotationOrder.value)), "InheritType" in l && (c.inheritType = parseInt(l.InheritType.value)), "GeometricTranslation" in l && (c.translation = l.GeometricTranslation.value), "GeometricRotation" in l && (c.rotation = l.GeometricRotation.value), "GeometricScaling" in l && (c.scale = l.GeometricScaling.value);
-    const u = Sa(c);
+    "RotationOrder" in l && (c.eulerOrder = La(l.RotationOrder.value)), "InheritType" in l && (c.inheritType = parseInt(l.InheritType.value)), "GeometricTranslation" in l && (c.translation = l.GeometricTranslation.value), "GeometricRotation" in l && (c.rotation = l.GeometricRotation.value), "GeometricScaling" in l && (c.scale = l.GeometricScaling.value);
+    const u = Oa(c);
     return this.genGeometry(t, a, i, u);
   }
   // Generate a BufferGeometry from a node in FBXTree.Objects.Geometry
   genGeometry(e, t, n, s) {
-    const i = new rt();
+    const i = new at();
     e.attrName && (i.name = e.attrName);
     const r = this.parseGeoNode(e, t), a = this.genBuffers(r), l = new it(a.vertex, 3);
-    if (l.applyMatrix4(s), i.setAttribute("position", l), a.colors.length > 0 && i.setAttribute("color", new it(a.colors, 3)), t && (i.setAttribute("skinIndex", new bl(a.weightsIndices, 4)), i.setAttribute("skinWeight", new it(a.vertexWeights, 4)), i.FBX_Deformer = t), a.normal.length > 0) {
-      const c = new vn().getNormalMatrix(s), u = new it(a.normal, 3);
+    if (l.applyMatrix4(s), i.setAttribute("position", l), a.colors.length > 0 && i.setAttribute("color", new it(a.colors, 3)), t && (i.setAttribute("skinIndex", new Cl(a.weightsIndices, 4)), i.setAttribute("skinWeight", new it(a.vertexWeights, 4)), i.FBX_Deformer = t), a.normal.length > 0) {
+      const c = new wn().getNormalMatrix(s), u = new it(a.normal, 3);
       u.applyNormalMatrix(c), i.setAttribute("normal", u);
     }
     if (a.uvs.forEach(function(c, u) {
@@ -4845,11 +4882,11 @@ class Ku {
       u === 0 && (h = "uv"), i.setAttribute(h, new it(a.uvs[u], 2));
     }), r.material && r.material.mappingType !== "AllSame") {
       let c = a.materialIndex[0], u = 0;
-      if (a.materialIndex.forEach(function(h, m) {
-        h !== c && (i.addGroup(u, m - u, c), c = h, u = m);
+      if (a.materialIndex.forEach(function(h, f) {
+        h !== c && (i.addGroup(u, f - u, c), c = h, u = f);
       }), i.groups.length > 0) {
-        const h = i.groups[i.groups.length - 1], m = h.start + h.count;
-        m !== a.materialIndex.length && i.addGroup(m, a.materialIndex.length - m, c);
+        const h = i.groups[i.groups.length - 1], f = h.start + h.count;
+        f !== a.materialIndex.length && i.addGroup(f, a.materialIndex.length - f, c);
       }
       i.groups.length === 0 && i.addGroup(0, a.materialIndex.length, a.materialIndex[0]);
     }
@@ -4883,51 +4920,51 @@ class Ku {
       weightsIndices: []
     };
     let n = 0, s = 0, i = !1, r = [], a = [], l = [], c = [], u = [], h = [];
-    const m = this;
-    return e.vertexIndices.forEach(function(p, v) {
-      let _, y = !1;
-      p < 0 && (p = p ^ -1, y = !0);
-      let E = [], R = [];
-      if (r.push(p * 3, p * 3 + 1, p * 3 + 2), e.color) {
-        const T = Ps(v, n, p, e.color);
-        l.push(T[0], T[1], T[2]);
+    const f = this;
+    return e.vertexIndices.forEach(function(d, y) {
+      let x, g = !1;
+      d < 0 && (d = d ^ -1, g = !0);
+      let v = [], M = [];
+      if (r.push(d * 3, d * 3 + 1, d * 3 + 2), e.color) {
+        const _ = Fs(y, n, d, e.color);
+        l.push(_[0], _[1], _[2]);
       }
       if (e.skeleton) {
-        if (e.weightTable[p] !== void 0 && e.weightTable[p].forEach(function(T) {
-          R.push(T.weight), E.push(T.id);
-        }), R.length > 4) {
+        if (e.weightTable[d] !== void 0 && e.weightTable[d].forEach(function(_) {
+          M.push(_.weight), v.push(_.id);
+        }), M.length > 4) {
           i || (console.warn(
             "THREE.FBXLoader: Vertex has more than 4 skinning weights assigned to vertex. Deleting additional weights."
           ), i = !0);
-          const T = [0, 0, 0, 0], g = [0, 0, 0, 0];
-          R.forEach(function(A, x) {
-            let M = A, d = E[x];
-            g.forEach(function(w, f, P) {
-              if (M > w) {
-                P[f] = M, M = w;
-                const I = T[f];
-                T[f] = d, d = I;
+          const _ = [0, 0, 0, 0], w = [0, 0, 0, 0];
+          M.forEach(function(P, T) {
+            let E = P, m = v[T];
+            w.forEach(function(b, p, C) {
+              if (E > b) {
+                C[p] = E, E = b;
+                const I = _[p];
+                _[p] = m, m = I;
               }
             });
-          }), E = T, R = g;
+          }), v = _, M = w;
         }
-        for (; R.length < 4; )
-          R.push(0), E.push(0);
-        for (let T = 0; T < 4; ++T)
-          u.push(R[T]), h.push(E[T]);
+        for (; M.length < 4; )
+          M.push(0), v.push(0);
+        for (let _ = 0; _ < 4; ++_)
+          u.push(M[_]), h.push(v[_]);
       }
       if (e.normal) {
-        const T = Ps(v, n, p, e.normal);
-        a.push(T[0], T[1], T[2]);
+        const _ = Fs(y, n, d, e.normal);
+        a.push(_[0], _[1], _[2]);
       }
-      e.material && e.material.mappingType !== "AllSame" && (_ = Ps(v, n, p, e.material)[0]), e.uv && e.uv.forEach(function(T, g) {
-        const A = Ps(v, n, p, T);
-        c[g] === void 0 && (c[g] = []), c[g].push(A[0]), c[g].push(A[1]);
-      }), s++, y && (m.genFace(
+      e.material && e.material.mappingType !== "AllSame" && (x = Fs(y, n, d, e.material)[0]), e.uv && e.uv.forEach(function(_, w) {
+        const P = Fs(y, n, d, _);
+        c[w] === void 0 && (c[w] = []), c[w].push(P[0]), c[w].push(P[1]);
+      }), s++, g && (f.genFace(
         t,
         e,
         r,
-        _,
+        x,
         a,
         l,
         c,
@@ -4940,8 +4977,8 @@ class Ku {
   // Generate data for a single face in a geometry. If the face is a quad then split it into 2 tris
   genFace(e, t, n, s, i, r, a, l, c, u) {
     for (let h = 2; h < u; h++)
-      e.vertex.push(t.vertexPositions[n[0]]), e.vertex.push(t.vertexPositions[n[1]]), e.vertex.push(t.vertexPositions[n[2]]), e.vertex.push(t.vertexPositions[n[(h - 1) * 3]]), e.vertex.push(t.vertexPositions[n[(h - 1) * 3 + 1]]), e.vertex.push(t.vertexPositions[n[(h - 1) * 3 + 2]]), e.vertex.push(t.vertexPositions[n[h * 3]]), e.vertex.push(t.vertexPositions[n[h * 3 + 1]]), e.vertex.push(t.vertexPositions[n[h * 3 + 2]]), t.skeleton && (e.vertexWeights.push(l[0]), e.vertexWeights.push(l[1]), e.vertexWeights.push(l[2]), e.vertexWeights.push(l[3]), e.vertexWeights.push(l[(h - 1) * 4]), e.vertexWeights.push(l[(h - 1) * 4 + 1]), e.vertexWeights.push(l[(h - 1) * 4 + 2]), e.vertexWeights.push(l[(h - 1) * 4 + 3]), e.vertexWeights.push(l[h * 4]), e.vertexWeights.push(l[h * 4 + 1]), e.vertexWeights.push(l[h * 4 + 2]), e.vertexWeights.push(l[h * 4 + 3]), e.weightsIndices.push(c[0]), e.weightsIndices.push(c[1]), e.weightsIndices.push(c[2]), e.weightsIndices.push(c[3]), e.weightsIndices.push(c[(h - 1) * 4]), e.weightsIndices.push(c[(h - 1) * 4 + 1]), e.weightsIndices.push(c[(h - 1) * 4 + 2]), e.weightsIndices.push(c[(h - 1) * 4 + 3]), e.weightsIndices.push(c[h * 4]), e.weightsIndices.push(c[h * 4 + 1]), e.weightsIndices.push(c[h * 4 + 2]), e.weightsIndices.push(c[h * 4 + 3])), t.color && (e.colors.push(r[0]), e.colors.push(r[1]), e.colors.push(r[2]), e.colors.push(r[(h - 1) * 3]), e.colors.push(r[(h - 1) * 3 + 1]), e.colors.push(r[(h - 1) * 3 + 2]), e.colors.push(r[h * 3]), e.colors.push(r[h * 3 + 1]), e.colors.push(r[h * 3 + 2])), t.material && t.material.mappingType !== "AllSame" && (e.materialIndex.push(s), e.materialIndex.push(s), e.materialIndex.push(s)), t.normal && (e.normal.push(i[0]), e.normal.push(i[1]), e.normal.push(i[2]), e.normal.push(i[(h - 1) * 3]), e.normal.push(i[(h - 1) * 3 + 1]), e.normal.push(i[(h - 1) * 3 + 2]), e.normal.push(i[h * 3]), e.normal.push(i[h * 3 + 1]), e.normal.push(i[h * 3 + 2])), t.uv && t.uv.forEach(function(m, p) {
-        e.uvs[p] === void 0 && (e.uvs[p] = []), e.uvs[p].push(a[p][0]), e.uvs[p].push(a[p][1]), e.uvs[p].push(a[p][(h - 1) * 2]), e.uvs[p].push(a[p][(h - 1) * 2 + 1]), e.uvs[p].push(a[p][h * 2]), e.uvs[p].push(a[p][h * 2 + 1]);
+      e.vertex.push(t.vertexPositions[n[0]]), e.vertex.push(t.vertexPositions[n[1]]), e.vertex.push(t.vertexPositions[n[2]]), e.vertex.push(t.vertexPositions[n[(h - 1) * 3]]), e.vertex.push(t.vertexPositions[n[(h - 1) * 3 + 1]]), e.vertex.push(t.vertexPositions[n[(h - 1) * 3 + 2]]), e.vertex.push(t.vertexPositions[n[h * 3]]), e.vertex.push(t.vertexPositions[n[h * 3 + 1]]), e.vertex.push(t.vertexPositions[n[h * 3 + 2]]), t.skeleton && (e.vertexWeights.push(l[0]), e.vertexWeights.push(l[1]), e.vertexWeights.push(l[2]), e.vertexWeights.push(l[3]), e.vertexWeights.push(l[(h - 1) * 4]), e.vertexWeights.push(l[(h - 1) * 4 + 1]), e.vertexWeights.push(l[(h - 1) * 4 + 2]), e.vertexWeights.push(l[(h - 1) * 4 + 3]), e.vertexWeights.push(l[h * 4]), e.vertexWeights.push(l[h * 4 + 1]), e.vertexWeights.push(l[h * 4 + 2]), e.vertexWeights.push(l[h * 4 + 3]), e.weightsIndices.push(c[0]), e.weightsIndices.push(c[1]), e.weightsIndices.push(c[2]), e.weightsIndices.push(c[3]), e.weightsIndices.push(c[(h - 1) * 4]), e.weightsIndices.push(c[(h - 1) * 4 + 1]), e.weightsIndices.push(c[(h - 1) * 4 + 2]), e.weightsIndices.push(c[(h - 1) * 4 + 3]), e.weightsIndices.push(c[h * 4]), e.weightsIndices.push(c[h * 4 + 1]), e.weightsIndices.push(c[h * 4 + 2]), e.weightsIndices.push(c[h * 4 + 3])), t.color && (e.colors.push(r[0]), e.colors.push(r[1]), e.colors.push(r[2]), e.colors.push(r[(h - 1) * 3]), e.colors.push(r[(h - 1) * 3 + 1]), e.colors.push(r[(h - 1) * 3 + 2]), e.colors.push(r[h * 3]), e.colors.push(r[h * 3 + 1]), e.colors.push(r[h * 3 + 2])), t.material && t.material.mappingType !== "AllSame" && (e.materialIndex.push(s), e.materialIndex.push(s), e.materialIndex.push(s)), t.normal && (e.normal.push(i[0]), e.normal.push(i[1]), e.normal.push(i[2]), e.normal.push(i[(h - 1) * 3]), e.normal.push(i[(h - 1) * 3 + 1]), e.normal.push(i[(h - 1) * 3 + 2]), e.normal.push(i[h * 3]), e.normal.push(i[h * 3 + 1]), e.normal.push(i[h * 3 + 2])), t.uv && t.uv.forEach(function(f, d) {
+        e.uvs[d] === void 0 && (e.uvs[d] = []), e.uvs[d].push(a[d][0]), e.uvs[d].push(a[d][1]), e.uvs[d].push(a[d][(h - 1) * 2]), e.uvs[d].push(a[d][(h - 1) * 2 + 1]), e.uvs[d].push(a[d][h * 2]), e.uvs[d].push(a[d][h * 2 + 1]);
       });
   }
   addMorphTargets(e, t, n, s) {
@@ -4962,15 +4999,15 @@ class Ku {
   // Normal and position attributes only have data for the vertices that are affected by the morph
   genMorphGeometry(e, t, n, s, i) {
     const r = t.PolygonVertexIndex !== void 0 ? t.PolygonVertexIndex.a : [], a = n.Vertices !== void 0 ? n.Vertices.a : [], l = n.Indexes !== void 0 ? n.Indexes.a : [], c = e.attributes.position.count * 3, u = new Float32Array(c);
-    for (let v = 0; v < l.length; v++) {
-      const _ = l[v] * 3;
-      u[_] = a[v * 3], u[_ + 1] = a[v * 3 + 1], u[_ + 2] = a[v * 3 + 2];
+    for (let y = 0; y < l.length; y++) {
+      const x = l[y] * 3;
+      u[x] = a[y * 3], u[x + 1] = a[y * 3 + 1], u[x + 2] = a[y * 3 + 2];
     }
     const h = {
       vertexIndices: r,
       vertexPositions: u
-    }, m = this.genBuffers(h), p = new it(m.vertex, 3);
-    p.name = i || n.attrName, p.applyMatrix4(s), e.morphAttributes.position.push(p);
+    }, f = this.genBuffers(h), d = new it(f.vertex, 3);
+    d.name = i || n.attrName, d.applyMatrix4(s), e.morphAttributes.position.push(d);
   }
   // Parse normal from FBXTree.Objects.Geometry.LayerElementNormal if it exists
   parseNormals(e) {
@@ -5032,16 +5069,16 @@ class Ku {
   }
   // Generate a NurbGeometry from a node in FBXTree.Objects.Geometry
   parseNurbsGeometry(e) {
-    if (Yr === void 0)
+    if (qr === void 0)
       return console.error(
         "THREE.FBXLoader: The loader relies on NURBSCurve for any nurbs present in the model. Nurbs will show up as empty geometry."
-      ), new rt();
+      ), new at();
     const t = parseInt(e.Order);
     if (isNaN(t))
-      return console.error("THREE.FBXLoader: Invalid Order %s given for geometry ID: %s", e.Order, e.id), new rt();
+      return console.error("THREE.FBXLoader: Invalid Order %s given for geometry ID: %s", e.Order, e.id), new at();
     const n = t - 1, s = e.KnotVector.a, i = [], r = e.Points.a;
-    for (let h = 0, m = r.length; h < m; h += 4)
-      i.push(new ht().fromArray(r, h));
+    for (let h = 0, f = r.length; h < f; h += 4)
+      i.push(new rt().fromArray(r, h));
     let a, l;
     if (e.Form === "Closed")
       i.push(i[0]);
@@ -5050,11 +5087,11 @@ class Ku {
       for (let h = 0; h < n; ++h)
         i.push(i[h]);
     }
-    const u = new Yr(n, s, i, a, l).getPoints(i.length * 12);
-    return new rt().setFromPoints(u);
+    const u = new qr(n, s, i, a, l).getPoints(i.length * 12);
+    return new at().setFromPoints(u);
   }
 }
-class qu {
+class oh {
   // take raw animation clips and turn them into three.js animation clips
   parse() {
     const e = [], t = this.parseClips();
@@ -5099,9 +5136,9 @@ class qu {
     for (const n in t) {
       const s = {
         id: t[n].id,
-        times: t[n].KeyTime.a.map(nh),
+        times: t[n].KeyTime.a.map(hh),
         values: t[n].KeyValueFloat.a
-      }, i = Xe.get(s.id);
+      }, i = $e.get(s.id);
       if (i !== void 0) {
         const r = i.parents[0].ID, a = i.parents[0].relationship;
         a.match(/X/) ? e.get(r).curves.x = s : a.match(/Y/) ? e.get(r).curves.y = s : a.match(/Z/) ? e.get(r).curves.z = s : a.match(/d|DeformPercent/) && e.has(r) && (e.get(r).curves.morph = s);
@@ -5114,43 +5151,43 @@ class qu {
   parseAnimationLayers(e) {
     const t = Ae.Objects.AnimationLayer, n = /* @__PURE__ */ new Map();
     for (const s in t) {
-      const i = [], r = Xe.get(parseInt(s));
+      const i = [], r = $e.get(parseInt(s));
       r !== void 0 && (r.children.forEach(function(l, c) {
         if (e.has(l.ID)) {
           const u = e.get(l.ID);
           if (u.curves.x !== void 0 || u.curves.y !== void 0 || u.curves.z !== void 0) {
             if (i[c] === void 0) {
-              const h = Xe.get(l.ID).parents.filter(function(m) {
-                return m.relationship !== void 0;
+              const h = $e.get(l.ID).parents.filter(function(f) {
+                return f.relationship !== void 0;
               })[0].ID;
               if (h !== void 0) {
-                const m = Ae.Objects.Model[h.toString()];
-                if (m === void 0) {
+                const f = Ae.Objects.Model[h.toString()];
+                if (f === void 0) {
                   console.warn("THREE.FBXLoader: Encountered a unused curve.", l);
                   return;
                 }
-                const p = {
-                  modelName: m.attrName ? Yt.sanitizeNodeName(m.attrName) : "",
-                  ID: m.id,
+                const d = {
+                  modelName: f.attrName ? Kt.sanitizeNodeName(f.attrName) : "",
+                  ID: f.id,
                   initialPosition: [0, 0, 0],
                   initialRotation: [0, 0, 0],
                   initialScale: [1, 1, 1]
                 };
-                ut.traverse(function(v) {
-                  v.ID === m.id && (p.transform = v.matrix, v.userData.transformData && (p.eulerOrder = v.userData.transformData.eulerOrder));
-                }), p.transform || (p.transform = new De()), "PreRotation" in m && (p.preRotation = m.PreRotation.value), "PostRotation" in m && (p.postRotation = m.PostRotation.value), i[c] = p;
+                ft.traverse(function(y) {
+                  y.ID === f.id && (d.transform = y.matrix, y.userData.transformData && (d.eulerOrder = y.userData.transformData.eulerOrder));
+                }), d.transform || (d.transform = new Pe()), "PreRotation" in f && (d.preRotation = f.PreRotation.value), "PostRotation" in f && (d.postRotation = f.PostRotation.value), i[c] = d;
               }
             }
             i[c] && (i[c][u.attr] = u);
           } else if (u.curves.morph !== void 0) {
             if (i[c] === void 0) {
-              const h = Xe.get(l.ID).parents.filter(function(E) {
-                return E.relationship !== void 0;
-              })[0].ID, m = Xe.get(h).parents[0].ID, p = Xe.get(m).parents[0].ID, v = Xe.get(p).parents[0].ID, _ = Ae.Objects.Model[v], y = {
-                modelName: _.attrName ? Yt.sanitizeNodeName(_.attrName) : "",
+              const h = $e.get(l.ID).parents.filter(function(v) {
+                return v.relationship !== void 0;
+              })[0].ID, f = $e.get(h).parents[0].ID, d = $e.get(f).parents[0].ID, y = $e.get(d).parents[0].ID, x = Ae.Objects.Model[y], g = {
+                modelName: x.attrName ? Kt.sanitizeNodeName(x.attrName) : "",
                 morphName: Ae.Objects.Deformer[h].attrName
               };
-              i[c] = y;
+              i[c] = g;
             }
             i[c][u.attr] = u;
           }
@@ -5164,7 +5201,7 @@ class qu {
   parseAnimStacks(e) {
     const t = Ae.Objects.AnimationStack, n = {};
     for (const s in t) {
-      const i = Xe.get(parseInt(s)).children;
+      const i = $e.get(parseInt(s)).children;
       i.length > 1 && console.warn(
         "THREE.FBXLoader: Encountered an animation stack with multiple layers, this is currently not supported. Ignoring subsequent layers."
       );
@@ -5181,12 +5218,12 @@ class qu {
     const n = this;
     return e.layer.forEach(function(s) {
       t = t.concat(n.generateTracks(s));
-    }), new qo(e.name, -1, t);
+    }), new ia(e.name, -1, t);
   }
   generateTracks(e) {
     const t = [];
-    let n = new ee(), s = new He(), i = new ee();
-    if (e.transform && e.transform.decompose(n, s, i), n = n.toArray(), s = new _n().setFromQuaternion(s, e.eulerOrder).toArray(), i = i.toArray(), e.T !== void 0 && Object.keys(e.T.curves).length > 0) {
+    let n = new q(), s = new He(), i = new q();
+    if (e.transform && e.transform.decompose(n, s, i), n = n.toArray(), s = new Tn().setFromQuaternion(s, e.eulerOrder).toArray(), i = i.toArray(), e.T !== void 0 && Object.keys(e.T.curves).length > 0) {
       const r = this.generateVectorTrack(
         e.modelName,
         e.T.curves,
@@ -5218,22 +5255,22 @@ class qu {
   }
   generateVectorTrack(e, t, n, s) {
     const i = this.getTimesForAllAxes(t), r = this.getKeyframeTrackValues(i, t, n);
-    return new Qo(e + "." + s, i, r);
+    return new ra(e + "." + s, i, r);
   }
   generateRotationTrack(e, t, n, s, i, r) {
-    t.x !== void 0 && (this.interpolateRotations(t.x), t.x.values = t.x.values.map(We.degToRad)), t.y !== void 0 && (this.interpolateRotations(t.y), t.y.values = t.y.values.map(We.degToRad)), t.z !== void 0 && (this.interpolateRotations(t.z), t.z.values = t.z.values.map(We.degToRad));
+    t.x !== void 0 && (this.interpolateRotations(t.x), t.x.values = t.x.values.map(Ze.degToRad)), t.y !== void 0 && (this.interpolateRotations(t.y), t.y.values = t.y.values.map(Ze.degToRad)), t.z !== void 0 && (this.interpolateRotations(t.z), t.z.values = t.z.values.map(Ze.degToRad));
     const a = this.getTimesForAllAxes(t), l = this.getKeyframeTrackValues(a, t, n);
-    s !== void 0 && (s = s.map(We.degToRad), s.push(r), s = new _n().fromArray(s), s = new He().setFromEuler(s)), i !== void 0 && (i = i.map(We.degToRad), i.push(r), i = new _n().fromArray(i), i = new He().setFromEuler(i).invert());
-    const c = new He(), u = new _n(), h = [];
-    for (let m = 0; m < l.length; m += 3)
-      u.set(l[m], l[m + 1], l[m + 2], r), c.setFromEuler(u), s !== void 0 && c.premultiply(s), i !== void 0 && c.multiply(i), c.toArray(h, m / 3 * 4);
-    return new Gi(e + ".quaternion", a, h);
+    s !== void 0 && (s = s.map(Ze.degToRad), s.push(r), s = new Tn().fromArray(s), s = new He().setFromEuler(s)), i !== void 0 && (i = i.map(Ze.degToRad), i.push(r), i = new Tn().fromArray(i), i = new He().setFromEuler(i).invert());
+    const c = new He(), u = new Tn(), h = [];
+    for (let f = 0; f < l.length; f += 3)
+      u.set(l[f], l[f + 1], l[f + 2], r), c.setFromEuler(u), s !== void 0 && c.premultiply(s), i !== void 0 && c.multiply(i), c.toArray(h, f / 3 * 4);
+    return new Zi(e + ".quaternion", a, h);
   }
   generateMorphTrack(e) {
     const t = e.DeformPercent.curves.morph, n = t.values.map(function(i) {
       return i / 100;
-    }), s = ut.getObjectByName(e.modelName).morphTargetDictionary[e.morphName];
-    return new Jo(
+    }), s = ft.getObjectByName(e.modelName).morphTargetDictionary[e.morphName];
+    return new oa(
       e.modelName + ".morphTargetInfluences[" + s + "]",
       t.times,
       n
@@ -5286,16 +5323,16 @@ class qu {
         const r = i / 180, a = s / r;
         let l = n + a;
         const c = e.times[t - 1], h = (e.times[t] - c) / r;
-        let m = c + h;
-        const p = [], v = [];
-        for (; m < e.times[t]; )
-          p.push(m), m += h, v.push(l), l += a;
-        e.times = $r(e.times, t, p), e.values = $r(e.values, t, v);
+        let f = c + h;
+        const d = [], y = [];
+        for (; f < e.times[t]; )
+          d.push(f), f += h, y.push(l), l += a;
+        e.times = eo(e.times, t, d), e.values = eo(e.values, t, y);
       }
     }
   }
 }
-class Qu {
+class ah {
   getPrevNode() {
     return this.nodeStack[this.currentIndent - 2];
   }
@@ -5315,7 +5352,7 @@ class Qu {
     this.currentProp = e, this.currentPropName = t;
   }
   parse(e) {
-    this.currentIndent = 0, this.allNodes = new Ma(), this.nodeStack = [], this.currentProp = [], this.currentPropName = "";
+    this.currentIndent = 0, this.allNodes = new Da(), this.nodeStack = [], this.currentProp = [], this.currentPropName = "";
     const t = this, n = e.split(/[\r\n]+/);
     return n.forEach(function(s, i) {
       const r = s.match(/^[\s\t]*;/), a = s.match(/^[\s\t]*$/);
@@ -5348,15 +5385,15 @@ class Qu {
     if (s === "C") {
       const l = i.split(",").slice(1), c = parseInt(l[0]), u = parseInt(l[1]);
       let h = i.split(",").slice(3);
-      h = h.map(function(m) {
-        return m.trim().replace(/^"/, "");
-      }), s = "connections", i = [c, u], ih(i, h), r[s] === void 0 && (r[s] = []);
+      h = h.map(function(f) {
+        return f.trim().replace(/^"/, "");
+      }), s = "connections", i = [c, u], dh(i, h), r[s] === void 0 && (r[s] = []);
     }
-    s === "Node" && (r.id = i), s in r && Array.isArray(r[s]) ? r[s].push(i) : s !== "a" ? r[s] = i : r.a = i, this.setCurrentProp(r, s), s === "a" && i.slice(-1) !== "," && (r.a = _i(i));
+    s === "Node" && (r.id = i), s in r && Array.isArray(r[s]) ? r[s].push(i) : s !== "a" ? r[s] = i : r.a = i, this.setCurrentProp(r, s), s === "a" && i.slice(-1) !== "," && (r.a = Si(i));
   }
   parseNodePropertyContinued(e) {
     const t = this.getCurrentNode();
-    t.a += e, e.slice(-1) !== "," && (t.a = _i(t.a));
+    t.a += e, e.slice(-1) !== "," && (t.a = Si(t.a));
   }
   // parse "Property70"
   parseNodeSpecialProperty(e, t, n) {
@@ -5380,7 +5417,7 @@ class Qu {
       case "Lcl_Translation":
       case "Lcl_Rotation":
       case "Lcl_Scaling":
-        c = _i(c);
+        c = Si(c);
         break;
     }
     this.getPrevNode()[i] = {
@@ -5391,14 +5428,14 @@ class Qu {
     }, this.setCurrentProp(this.getPrevNode(), i);
   }
 }
-class Ju {
+class lh {
   parse(e) {
-    const t = new Xr(e);
+    const t = new Qr(e);
     t.skip(23);
     const n = t.getUint32();
     if (n < 6400)
       throw new Error("THREE.FBXLoader: FBX version not supported, FileVersion: " + n);
-    const s = new Ma();
+    const s = new Da();
     for (; !this.endOfContent(t); ) {
       const i = this.parseNode(t, n);
       i !== null && s.add(i.name, i);
@@ -5417,12 +5454,12 @@ class Ju {
     if (s === 0)
       return null;
     const l = [];
-    for (let m = 0; m < i; m++)
+    for (let f = 0; f < i; f++)
       l.push(this.parseProperty(e));
     const c = l.length > 0 ? l[0] : "", u = l.length > 1 ? l[1] : "", h = l.length > 2 ? l[2] : "";
     for (n.singleProperty = i === 1 && e.getOffset() === s; s > e.getOffset(); ) {
-      const m = this.parseNode(e, t);
-      m !== null && this.parseSubNode(a, n, m);
+      const f = this.parseNode(e, t);
+      f !== null && this.parseSubNode(a, n, f);
     }
     return n.propertyList = l, typeof c == "number" && (n.id = c), u !== "" && (n.attrName = u), h !== "" && (n.attrType = h), a !== "" && (n.name = a), n;
   }
@@ -5493,7 +5530,7 @@ class Ju {
             case "l":
               return e.getInt64Array(s);
           }
-        const a = Gc(new Uint8Array(e.getArrayBuffer(r))), l = new Xr(a.buffer);
+        const a = Kc(new Uint8Array(e.getArrayBuffer(r))), l = new Qr(a.buffer);
         switch (t) {
           case "b":
           case "c":
@@ -5512,7 +5549,7 @@ class Ju {
     }
   }
 }
-class Xr {
+class Qr {
   constructor(e, t) {
     this.dv = new DataView(e), this.offset = 0, this.littleEndian = t !== void 0 ? t : !0;
   }
@@ -5608,19 +5645,19 @@ class Xr {
     for (let s = 0; s < e; s++)
       t[s] = this.getUint8();
     const n = t.indexOf(0);
-    return n >= 0 && (t = t.slice(0, n)), Ft.decodeText(new Uint8Array(t));
+    return n >= 0 && (t = t.slice(0, n)), Bt.decodeText(new Uint8Array(t));
   }
 }
-class Ma {
+class Da {
   add(e, t) {
     this[e] = t;
   }
 }
-function eh(o) {
+function ch(o) {
   const e = "Kaydara FBX Binary  \0";
-  return o.byteLength >= e.length && e === Pa(o, 0, e.length);
+  return o.byteLength >= e.length && e === Fa(o, 0, e.length);
 }
-function th(o) {
+function uh(o) {
   const e = [
     "K",
     "a",
@@ -5653,17 +5690,17 @@ function th(o) {
       return !1;
   return !0;
 }
-function Wr(o) {
+function Jr(o) {
   const e = /FBXVersion: (\d+)/, t = o.match(e);
   if (t)
     return parseInt(t[1]);
   throw new Error("THREE.FBXLoader: Cannot find the version number for the file given.");
 }
-function nh(o) {
+function hh(o) {
   return o / 46186158e3;
 }
-const sh = [];
-function Ps(o, e, t, n) {
+const fh = [];
+function Fs(o, e, t, n) {
   let s;
   switch (n.mappingType) {
     case "ByPolygonVertex":
@@ -5683,43 +5720,43 @@ function Ps(o, e, t, n) {
   }
   n.referenceType === "IndexToDirect" && (s = n.indices[s]);
   const i = s * n.dataSize, r = i + n.dataSize;
-  return rh(sh, n.buffer, i, r);
+  return ph(fh, n.buffer, i, r);
 }
-const vi = new _n(), In = new ee();
-function Sa(o) {
-  const e = new De(), t = new De(), n = new De(), s = new De(), i = new De(), r = new De(), a = new De(), l = new De(), c = new De(), u = new De(), h = new De(), m = new De(), p = o.inheritType ? o.inheritType : 0;
-  if (o.translation && e.setPosition(In.fromArray(o.translation)), o.preRotation) {
-    const f = o.preRotation.map(We.degToRad);
-    f.push(o.eulerOrder), t.makeRotationFromEuler(vi.fromArray(f));
+const Ei = new Tn(), On = new q();
+function Oa(o) {
+  const e = new Pe(), t = new Pe(), n = new Pe(), s = new Pe(), i = new Pe(), r = new Pe(), a = new Pe(), l = new Pe(), c = new Pe(), u = new Pe(), h = new Pe(), f = new Pe(), d = o.inheritType ? o.inheritType : 0;
+  if (o.translation && e.setPosition(On.fromArray(o.translation)), o.preRotation) {
+    const p = o.preRotation.map(Ze.degToRad);
+    p.push(o.eulerOrder), t.makeRotationFromEuler(Ei.fromArray(p));
   }
   if (o.rotation) {
-    const f = o.rotation.map(We.degToRad);
-    f.push(o.eulerOrder), n.makeRotationFromEuler(vi.fromArray(f));
+    const p = o.rotation.map(Ze.degToRad);
+    p.push(o.eulerOrder), n.makeRotationFromEuler(Ei.fromArray(p));
   }
   if (o.postRotation) {
-    const f = o.postRotation.map(We.degToRad);
-    f.push(o.eulerOrder), s.makeRotationFromEuler(vi.fromArray(f)), s.invert();
-  }
-  o.scale && i.scale(In.fromArray(o.scale)), o.scalingOffset && a.setPosition(In.fromArray(o.scalingOffset)), o.scalingPivot && r.setPosition(In.fromArray(o.scalingPivot)), o.rotationOffset && l.setPosition(In.fromArray(o.rotationOffset)), o.rotationPivot && c.setPosition(In.fromArray(o.rotationPivot)), o.parentMatrixWorld && (h.copy(o.parentMatrix), u.copy(o.parentMatrixWorld));
-  const v = t.clone().multiply(n).multiply(s), _ = new De();
-  _.extractRotation(u);
-  const y = new De();
-  y.copyPosition(u);
-  const E = y.clone().invert().multiply(u), R = _.clone().invert().multiply(E), T = i, g = new De();
-  if (p === 0)
-    g.copy(_).multiply(v).multiply(R).multiply(T);
-  else if (p === 1)
-    g.copy(_).multiply(R).multiply(v).multiply(T);
+    const p = o.postRotation.map(Ze.degToRad);
+    p.push(o.eulerOrder), s.makeRotationFromEuler(Ei.fromArray(p)), s.invert();
+  }
+  o.scale && i.scale(On.fromArray(o.scale)), o.scalingOffset && a.setPosition(On.fromArray(o.scalingOffset)), o.scalingPivot && r.setPosition(On.fromArray(o.scalingPivot)), o.rotationOffset && l.setPosition(On.fromArray(o.rotationOffset)), o.rotationPivot && c.setPosition(On.fromArray(o.rotationPivot)), o.parentMatrixWorld && (h.copy(o.parentMatrix), u.copy(o.parentMatrixWorld));
+  const y = t.clone().multiply(n).multiply(s), x = new Pe();
+  x.extractRotation(u);
+  const g = new Pe();
+  g.copyPosition(u);
+  const v = g.clone().invert().multiply(u), M = x.clone().invert().multiply(v), _ = i, w = new Pe();
+  if (d === 0)
+    w.copy(x).multiply(y).multiply(M).multiply(_);
+  else if (d === 1)
+    w.copy(x).multiply(M).multiply(y).multiply(_);
   else {
-    const P = new De().scale(new ee().setFromMatrixScale(h)).clone().invert(), I = R.clone().multiply(P);
-    g.copy(_).multiply(v).multiply(I).multiply(T);
+    const C = new Pe().scale(new q().setFromMatrixScale(h)).clone().invert(), I = M.clone().multiply(C);
+    w.copy(x).multiply(y).multiply(I).multiply(_);
   }
-  const A = c.clone().invert(), x = r.clone().invert();
-  let M = e.clone().multiply(l).multiply(c).multiply(t).multiply(n).multiply(s).multiply(A).multiply(a).multiply(r).multiply(i).multiply(x);
-  const d = new De().copyPosition(M), w = u.clone().multiply(d);
-  return m.copyPosition(w), M = m.clone().multiply(g), M.premultiply(u.invert()), M;
+  const P = c.clone().invert(), T = r.clone().invert();
+  let E = e.clone().multiply(l).multiply(c).multiply(t).multiply(n).multiply(s).multiply(P).multiply(a).multiply(r).multiply(i).multiply(T);
+  const m = new Pe().copyPosition(E), b = u.clone().multiply(m);
+  return f.copyPosition(b), E = f.clone().multiply(w), E.premultiply(u.invert()), E;
 }
-function Aa(o) {
+function La(o) {
   o = o || 0;
   const e = [
     "ZYX",
@@ -5738,33 +5775,33 @@ function Aa(o) {
   ];
   return o === 6 ? (console.warn("THREE.FBXLoader: unsupported Euler Order: Spherical XYZ. Animations and rotations may be incorrect."), e[0]) : e[o];
 }
-function _i(o) {
+function Si(o) {
   return o.split(",").map(function(t) {
     return parseFloat(t);
   });
 }
-function Pa(o, e, t) {
-  return e === void 0 && (e = 0), t === void 0 && (t = o.byteLength), Ft.decodeText(new Uint8Array(o, e, t));
+function Fa(o, e, t) {
+  return e === void 0 && (e = 0), t === void 0 && (t = o.byteLength), Bt.decodeText(new Uint8Array(o, e, t));
 }
-function ih(o, e) {
+function dh(o, e) {
   for (let t = 0, n = o.length, s = e.length; t < s; t++, n++)
     o[n] = e[t];
 }
-function rh(o, e, t, n) {
+function ph(o, e, t, n) {
   for (let s = t, i = 0; s < n; s++, i++)
     o[i] = e[s];
   return o;
 }
-function $r(o, e, t) {
+function eo(o, e, t) {
   return o.slice(0, e).concat(t).concat(o.slice(e));
 }
-var oh = Object.defineProperty, ah = (o, e, t) => e in o ? oh(o, e, { enumerable: !0, configurable: !0, writable: !0, value: t }) : o[e] = t, fr = (o, e, t) => (ah(o, typeof e != "symbol" ? e + "" : e, t), t);
-class lh extends cs {
+var mh = Object.defineProperty, gh = (o, e, t) => e in o ? mh(o, e, { enumerable: !0, configurable: !0, writable: !0, value: t }) : o[e] = t, yr = (o, e, t) => (gh(o, typeof e != "symbol" ? e + "" : e, t), t);
+class vh extends vs {
   constructor(e) {
     super(e);
   }
   load(e, t, n, s) {
-    const i = new Tn(this.manager);
+    const i = new Sn(this.manager);
     i.setPath(this.path), i.setRequestHeader(this.requestHeader), i.setWithCredentials(this.withCredentials), i.load(
       e,
       (r) => {
@@ -5781,23 +5818,23 @@ class lh extends cs {
     return super.loadAsync(e, t);
   }
   parse(e) {
-    return new dr(e);
+    return new _r(e);
   }
 }
-class dr {
+class _r {
   constructor(e) {
-    fr(this, "data"), this.data = e;
+    yr(this, "data"), this.data = e;
   }
   generateShapes(e, t = 100, n) {
-    const s = [], i = { letterSpacing: 0, lineHeight: 1, ...n }, r = ch(e, t, this.data, i);
+    const s = [], i = { letterSpacing: 0, lineHeight: 1, ...n }, r = yh(e, t, this.data, i);
     for (let a = 0, l = r.length; a < l; a++)
       Array.prototype.push.apply(s, r[a].toShapes(!1));
     return s;
   }
 }
-fr(dr, "isFont");
-fr(dr, "type");
-function ch(o, e, t, n) {
+yr(_r, "isFont");
+yr(_r, "type");
+function yh(o, e, t, n) {
   const s = Array.from(o), i = e / t.resolution, r = (t.boundingBox.yMax - t.boundingBox.yMin + t.underlineThickness) * i, a = [];
   let l = 0, c = 0;
   for (let u = 0; u < s.length; u++) {
@@ -5806,71 +5843,71 @@ function ch(o, e, t, n) {
 `)
       l = 0, c -= r * n.lineHeight;
     else {
-      const m = uh(h, i, l, c, t);
-      m && (l += m.offsetX + n.letterSpacing, a.push(m.path));
+      const f = _h(h, i, l, c, t);
+      f && (l += f.offsetX + n.letterSpacing, a.push(f.path));
     }
   }
   return a;
 }
-function uh(o, e, t, n, s) {
+function _h(o, e, t, n, s) {
   const i = s.glyphs[o] || s.glyphs["?"];
   if (!i) {
     console.error('THREE.Font: character "' + o + '" does not exists in font family ' + s.familyName + ".");
     return;
   }
-  const r = new nn();
-  let a, l, c, u, h, m, p, v;
+  const r = new rn();
+  let a, l, c, u, h, f, d, y;
   if (i.o) {
-    const _ = i._cachedOutline || (i._cachedOutline = i.o.split(" "));
-    for (let y = 0, E = _.length; y < E; )
-      switch (_[y++]) {
+    const x = i._cachedOutline || (i._cachedOutline = i.o.split(" "));
+    for (let g = 0, v = x.length; g < v; )
+      switch (x[g++]) {
         case "m":
-          a = parseInt(_[y++]) * e + t, l = parseInt(_[y++]) * e + n, r.moveTo(a, l);
+          a = parseInt(x[g++]) * e + t, l = parseInt(x[g++]) * e + n, r.moveTo(a, l);
           break;
         case "l":
-          a = parseInt(_[y++]) * e + t, l = parseInt(_[y++]) * e + n, r.lineTo(a, l);
+          a = parseInt(x[g++]) * e + t, l = parseInt(x[g++]) * e + n, r.lineTo(a, l);
           break;
         case "q":
-          c = parseInt(_[y++]) * e + t, u = parseInt(_[y++]) * e + n, h = parseInt(_[y++]) * e + t, m = parseInt(_[y++]) * e + n, r.quadraticCurveTo(h, m, c, u);
+          c = parseInt(x[g++]) * e + t, u = parseInt(x[g++]) * e + n, h = parseInt(x[g++]) * e + t, f = parseInt(x[g++]) * e + n, r.quadraticCurveTo(h, f, c, u);
           break;
         case "b":
-          c = parseInt(_[y++]) * e + t, u = parseInt(_[y++]) * e + n, h = parseInt(_[y++]) * e + t, m = parseInt(_[y++]) * e + n, p = parseInt(_[y++]) * e + t, v = parseInt(_[y++]) * e + n, r.bezierCurveTo(h, m, p, v, c, u);
+          c = parseInt(x[g++]) * e + t, u = parseInt(x[g++]) * e + n, h = parseInt(x[g++]) * e + t, f = parseInt(x[g++]) * e + n, d = parseInt(x[g++]) * e + t, y = parseInt(x[g++]) * e + n, r.bezierCurveTo(h, f, d, y, c, u);
           break;
       }
   }
   return { offsetX: i.ha * e, path: r };
 }
-class Zr extends El {
+class to extends Rl {
   constructor(e) {
-    super(e), this.type = un;
+    super(e), this.type = Zt;
   }
   // adapted from http://www.graphics.cornell.edu/~bjw/rgbe.html
   parse(e) {
-    const a = function(T, g) {
-      switch (T) {
+    const a = function(_, w) {
+      switch (_) {
         case 1:
-          console.error("THREE.RGBELoader Read Error: " + (g || ""));
+          console.error("THREE.RGBELoader Read Error: " + (w || ""));
           break;
         case 2:
-          console.error("THREE.RGBELoader Write Error: " + (g || ""));
+          console.error("THREE.RGBELoader Write Error: " + (w || ""));
           break;
         case 3:
-          console.error("THREE.RGBELoader Bad File Format: " + (g || ""));
+          console.error("THREE.RGBELoader Bad File Format: " + (w || ""));
           break;
         default:
         case 4:
-          console.error("THREE.RGBELoader: Error: " + (g || ""));
+          console.error("THREE.RGBELoader: Error: " + (w || ""));
       }
       return -1;
     }, h = `
-`, m = function(T, g, A) {
-      g = g || 1024;
-      let M = T.pos, d = -1, w = 0, f = "", P = String.fromCharCode.apply(null, new Uint16Array(T.subarray(M, M + 128)));
-      for (; 0 > (d = P.indexOf(h)) && w < g && M < T.byteLength; )
-        f += P, w += P.length, M += 128, P += String.fromCharCode.apply(null, new Uint16Array(T.subarray(M, M + 128)));
-      return -1 < d ? (A !== !1 && (T.pos += w + d + 1), f + P.slice(0, d)) : !1;
-    }, p = function(T) {
-      const g = /^#\?(\S+)/, A = /^\s*GAMMA\s*=\s*(\d+(\.\d+)?)\s*$/, x = /^\s*EXPOSURE\s*=\s*(\d+(\.\d+)?)\s*$/, M = /^\s*FORMAT=(\S+)\s*$/, d = /^\s*\-Y\s+(\d+)\s+\+X\s+(\d+)\s*$/, w = {
+`, f = function(_, w, P) {
+      w = w || 1024;
+      let E = _.pos, m = -1, b = 0, p = "", C = String.fromCharCode.apply(null, new Uint16Array(_.subarray(E, E + 128)));
+      for (; 0 > (m = C.indexOf(h)) && b < w && E < _.byteLength; )
+        p += C, b += C.length, E += 128, C += String.fromCharCode.apply(null, new Uint16Array(_.subarray(E, E + 128)));
+      return -1 < m ? (P !== !1 && (_.pos += b + m + 1), p + C.slice(0, m)) : !1;
+    }, d = function(_) {
+      const w = /^#\?(\S+)/, P = /^\s*GAMMA\s*=\s*(\d+(\.\d+)?)\s*$/, T = /^\s*EXPOSURE\s*=\s*(\d+(\.\d+)?)\s*$/, E = /^\s*FORMAT=(\S+)\s*$/, m = /^\s*\-Y\s+(\d+)\s+\+X\s+(\d+)\s*$/, b = {
         valid: 0,
         string: "",
         comments: "",
@@ -5881,105 +5918,105 @@ class Zr extends El {
         width: 0,
         height: 0
       };
-      let f, P;
-      if (T.pos >= T.byteLength || !(f = m(T)))
+      let p, C;
+      if (_.pos >= _.byteLength || !(p = f(_)))
         return a(1, "no header found");
-      if (!(P = f.match(g)))
+      if (!(C = p.match(w)))
         return a(3, "bad initial token");
-      for (w.valid |= 1, w.programtype = P[1], w.string += f + `
-`; f = m(T), f !== !1; ) {
-        if (w.string += f + `
-`, f.charAt(0) === "#") {
-          w.comments += f + `
+      for (b.valid |= 1, b.programtype = C[1], b.string += p + `
+`; p = f(_), p !== !1; ) {
+        if (b.string += p + `
+`, p.charAt(0) === "#") {
+          b.comments += p + `
 `;
           continue;
         }
-        if ((P = f.match(A)) && (w.gamma = parseFloat(P[1])), (P = f.match(x)) && (w.exposure = parseFloat(P[1])), (P = f.match(M)) && (w.valid |= 2, w.format = P[1]), (P = f.match(d)) && (w.valid |= 4, w.height = parseInt(P[1], 10), w.width = parseInt(P[2], 10)), w.valid & 2 && w.valid & 4)
+        if ((C = p.match(P)) && (b.gamma = parseFloat(C[1])), (C = p.match(T)) && (b.exposure = parseFloat(C[1])), (C = p.match(E)) && (b.valid |= 2, b.format = C[1]), (C = p.match(m)) && (b.valid |= 4, b.height = parseInt(C[1], 10), b.width = parseInt(C[2], 10)), b.valid & 2 && b.valid & 4)
           break;
       }
-      return w.valid & 2 ? w.valid & 4 ? w : a(3, "missing image size specifier") : a(3, "missing format specifier");
-    }, v = function(T, g, A) {
-      const x = g;
+      return b.valid & 2 ? b.valid & 4 ? b : a(3, "missing image size specifier") : a(3, "missing format specifier");
+    }, y = function(_, w, P) {
+      const T = w;
       if (
         // run length encoding is not allowed so read flat
-        x < 8 || x > 32767 || // this file is not run length encoded
-        T[0] !== 2 || T[1] !== 2 || T[2] & 128
+        T < 8 || T > 32767 || // this file is not run length encoded
+        _[0] !== 2 || _[1] !== 2 || _[2] & 128
       )
-        return new Uint8Array(T);
-      if (x !== (T[2] << 8 | T[3]))
+        return new Uint8Array(_);
+      if (T !== (_[2] << 8 | _[3]))
         return a(3, "wrong scanline width");
-      const M = new Uint8Array(4 * g * A);
-      if (!M.length)
+      const E = new Uint8Array(4 * w * P);
+      if (!E.length)
         return a(4, "unable to allocate buffer space");
-      let d = 0, w = 0;
-      const f = 4 * x, P = new Uint8Array(4), I = new Uint8Array(f);
-      let K = A;
-      for (; K > 0 && w < T.byteLength; ) {
-        if (w + 4 > T.byteLength)
+      let m = 0, b = 0;
+      const p = 4 * T, C = new Uint8Array(4), I = new Uint8Array(p);
+      let K = P;
+      for (; K > 0 && b < _.byteLength; ) {
+        if (b + 4 > _.byteLength)
           return a(1);
-        if (P[0] = T[w++], P[1] = T[w++], P[2] = T[w++], P[3] = T[w++], P[0] != 2 || P[1] != 2 || (P[2] << 8 | P[3]) != x)
+        if (C[0] = _[b++], C[1] = _[b++], C[2] = _[b++], C[3] = _[b++], C[0] != 2 || C[1] != 2 || (C[2] << 8 | C[3]) != T)
           return a(3, "bad rgbe scanline format");
-        let N = 0, Z;
-        for (; N < f && w < T.byteLength; ) {
-          Z = T[w++];
-          const X = Z > 128;
-          if (X && (Z -= 128), Z === 0 || N + Z > f)
+        let z = 0, Y;
+        for (; z < p && b < _.byteLength; ) {
+          Y = _[b++];
+          const X = Y > 128;
+          if (X && (Y -= 128), Y === 0 || z + Y > p)
             return a(3, "bad scanline data");
           if (X) {
-            const V = T[w++];
-            for (let ne = 0; ne < Z; ne++)
-              I[N++] = V;
+            const V = _[b++];
+            for (let te = 0; te < Y; te++)
+              I[z++] = V;
           } else
-            I.set(T.subarray(w, w + Z), N), N += Z, w += Z;
+            I.set(_.subarray(b, b + Y), z), z += Y, b += Y;
         }
-        const W = x;
+        const W = T;
         for (let X = 0; X < W; X++) {
           let V = 0;
-          M[d] = I[X + V], V += x, M[d + 1] = I[X + V], V += x, M[d + 2] = I[X + V], V += x, M[d + 3] = I[X + V], d += 4;
+          E[m] = I[X + V], V += T, E[m + 1] = I[X + V], V += T, E[m + 2] = I[X + V], V += T, E[m + 3] = I[X + V], m += 4;
         }
         K--;
       }
-      return M;
-    }, _ = function(T, g, A, x) {
-      const M = T[g + 3], d = Math.pow(2, M - 128) / 255;
-      A[x + 0] = T[g + 0] * d, A[x + 1] = T[g + 1] * d, A[x + 2] = T[g + 2] * d, A[x + 3] = 1;
-    }, y = function(T, g, A, x) {
-      const M = T[g + 3], d = Math.pow(2, M - 128) / 255;
-      A[x + 0] = ws.toHalfFloat(Math.min(T[g + 0] * d, 65504)), A[x + 1] = ws.toHalfFloat(Math.min(T[g + 1] * d, 65504)), A[x + 2] = ws.toHalfFloat(Math.min(T[g + 2] * d, 65504)), A[x + 3] = ws.toHalfFloat(1);
-    }, E = new Uint8Array(e);
-    E.pos = 0;
-    const R = p(E);
-    if (R !== -1) {
-      const T = R.width, g = R.height, A = v(E.subarray(E.pos), T, g);
-      if (A !== -1) {
-        let x, M, d;
+      return E;
+    }, x = function(_, w, P, T) {
+      const E = _[w + 3], m = Math.pow(2, E - 128) / 255;
+      P[T + 0] = _[w + 0] * m, P[T + 1] = _[w + 1] * m, P[T + 2] = _[w + 2] * m, P[T + 3] = 1;
+    }, g = function(_, w, P, T) {
+      const E = _[w + 3], m = Math.pow(2, E - 128) / 255;
+      P[T + 0] = Ps.toHalfFloat(Math.min(_[w + 0] * m, 65504)), P[T + 1] = Ps.toHalfFloat(Math.min(_[w + 1] * m, 65504)), P[T + 2] = Ps.toHalfFloat(Math.min(_[w + 2] * m, 65504)), P[T + 3] = Ps.toHalfFloat(1);
+    }, v = new Uint8Array(e);
+    v.pos = 0;
+    const M = d(v);
+    if (M !== -1) {
+      const _ = M.width, w = M.height, P = y(v.subarray(v.pos), _, w);
+      if (P !== -1) {
+        let T, E, m;
         switch (this.type) {
-          case Gs:
-            d = A.length / 4;
-            const w = new Float32Array(d * 4);
-            for (let P = 0; P < d; P++)
-              _(A, P * 4, w, P * 4);
-            x = w, M = Gs;
+          case Zs:
+            m = P.length / 4;
+            const b = new Float32Array(m * 4);
+            for (let C = 0; C < m; C++)
+              x(P, C * 4, b, C * 4);
+            T = b, E = Zs;
             break;
-          case un:
-            d = A.length / 4;
-            const f = new Uint16Array(d * 4);
-            for (let P = 0; P < d; P++)
-              y(A, P * 4, f, P * 4);
-            x = f, M = un;
+          case Zt:
+            m = P.length / 4;
+            const p = new Uint16Array(m * 4);
+            for (let C = 0; C < m; C++)
+              g(P, C * 4, p, C * 4);
+            T = p, E = Zt;
             break;
           default:
             console.error("THREE.RGBELoader: unsupported type: ", this.type);
             break;
         }
         return {
-          width: T,
-          height: g,
-          data: x,
-          header: R.string,
-          gamma: R.gamma,
-          exposure: R.exposure,
-          type: M
+          width: _,
+          height: w,
+          data: T,
+          header: M.string,
+          gamma: M.gamma,
+          exposure: M.exposure,
+          type: E
         };
       }
     }
@@ -5991,9 +6028,9 @@ class Zr extends El {
   load(e, t, n, s) {
     function i(r, a) {
       switch (r.type) {
-        case Gs:
-        case un:
-          "colorSpace" in r ? r.colorSpace = "srgb-linear" : r.encoding = 3e3, r.minFilter = At, r.magFilter = At, r.generateMipmaps = !1, r.flipY = !0;
+        case Zs:
+        case Zt:
+          "colorSpace" in r ? r.colorSpace = "srgb-linear" : r.encoding = 3e3, r.minFilter = Ct, r.magFilter = Ct, r.generateMipmaps = !1, r.flipY = !0;
           break;
       }
       t && t(r, a);
@@ -6001,12 +6038,12 @@ class Zr extends El {
     return super.load(e, i, n, s);
   }
 }
-class is extends cs {
+class hs extends vs {
   constructor(e) {
     super(e), this.defaultDPI = 90, this.defaultUnit = "px";
   }
   load(e, t, n, s) {
-    const i = this, r = new Tn(i.manager);
+    const i = this, r = new Sn(i.manager);
     r.setPath(i.path), r.setRequestHeader(i.requestHeader), r.setWithCredentials(i.withCredentials), r.load(
       e,
       function(a) {
@@ -6025,8 +6062,8 @@ class is extends cs {
     function n(H, k) {
       if (H.nodeType !== 1)
         return;
-      const b = g(H);
-      let U = !0, J = null;
+      const S = w(H);
+      let U = !0, ee = null;
       switch (H.nodeName) {
         case "svg":
           break;
@@ -6034,28 +6071,28 @@ class is extends cs {
           i(H);
           break;
         case "g":
-          k = v(H, k);
+          k = y(H, k);
           break;
         case "path":
-          k = v(H, k), H.hasAttribute("d") && (J = s(H));
+          k = y(H, k), H.hasAttribute("d") && (ee = s(H));
           break;
         case "rect":
-          k = v(H, k), J = l(H);
+          k = y(H, k), ee = l(H);
           break;
         case "polygon":
-          k = v(H, k), J = c(H);
+          k = y(H, k), ee = c(H);
           break;
         case "polyline":
-          k = v(H, k), J = u(H);
+          k = y(H, k), ee = u(H);
           break;
         case "circle":
-          k = v(H, k), J = h(H);
+          k = y(H, k), ee = h(H);
           break;
         case "ellipse":
-          k = v(H, k), J = m(H);
+          k = y(H, k), ee = f(H);
           break;
         case "line":
-          k = v(H, k), J = p(H);
+          k = y(H, k), ee = d(H);
           break;
         case "defs":
           U = !1;
@@ -6064,290 +6101,290 @@ class is extends cs {
           U = !1;
           break;
         case "use":
-          k = v(H, k);
-          const F = H.href.baseVal.substring(1), B = H.viewportElement.getElementById(F);
-          B ? n(B, k) : console.warn("SVGLoader: 'use node' references non-existent node id: " + F);
+          k = y(H, k);
+          const F = H.href.baseVal.substring(1), N = H.viewportElement.getElementById(F);
+          N ? n(N, k) : console.warn("SVGLoader: 'use node' references non-existent node id: " + F);
           break;
       }
-      if (J && (k.fill !== void 0 && k.fill !== "none" && J.color.setStyle(k.fill), x(J, ne), f.push(J), J.userData = { node: H, style: k }), U) {
+      if (ee && (k.fill !== void 0 && k.fill !== "none" && ee.color.setStyle(k.fill), T(ee, te), p.push(ee), ee.userData = { node: H, style: k }), U) {
         const F = H.childNodes;
-        for (let B = 0; B < F.length; B++)
-          n(F[B], k);
+        for (let N = 0; N < F.length; N++)
+          n(F[N], k);
       }
-      b && (I.pop(), I.length > 0 ? ne.copy(I[I.length - 1]) : ne.identity());
+      S && (I.pop(), I.length > 0 ? te.copy(I[I.length - 1]) : te.identity());
     }
     function s(H) {
-      const k = new nn(), b = new le(), U = new le(), J = new le();
-      let F = !0, B = !1;
-      const C = H.getAttribute("d").match(/[a-df-z][^a-df-z]*/gi);
-      for (let D = 0, G = C.length; D < G; D++) {
-        const $ = C[D], Y = $.charAt(0), te = $.substr(1).trim();
-        F === !0 && (B = !0, F = !1);
-        let O;
-        switch (Y) {
+      const k = new rn(), S = new he(), U = new he(), ee = new he();
+      let F = !0, N = !1;
+      const R = H.getAttribute("d").match(/[a-df-z][^a-df-z]*/gi);
+      for (let D = 0, j = R.length; D < j; D++) {
+        const Z = R[D], $ = Z.charAt(0), ne = Z.substr(1).trim();
+        F === !0 && (N = !0, F = !1);
+        let L;
+        switch ($) {
           case "M":
-            O = y(te);
-            for (let L = 0, re = O.length; L < re; L += 2)
-              b.x = O[L + 0], b.y = O[L + 1], U.x = b.x, U.y = b.y, L === 0 ? k.moveTo(b.x, b.y) : k.lineTo(b.x, b.y), L === 0 && J.copy(b);
+            L = g(ne);
+            for (let O = 0, re = L.length; O < re; O += 2)
+              S.x = L[O + 0], S.y = L[O + 1], U.x = S.x, U.y = S.y, O === 0 ? k.moveTo(S.x, S.y) : k.lineTo(S.x, S.y), O === 0 && ee.copy(S);
             break;
           case "H":
-            O = y(te);
-            for (let L = 0, re = O.length; L < re; L++)
-              b.x = O[L], U.x = b.x, U.y = b.y, k.lineTo(b.x, b.y), L === 0 && B === !0 && J.copy(b);
+            L = g(ne);
+            for (let O = 0, re = L.length; O < re; O++)
+              S.x = L[O], U.x = S.x, U.y = S.y, k.lineTo(S.x, S.y), O === 0 && N === !0 && ee.copy(S);
             break;
           case "V":
-            O = y(te);
-            for (let L = 0, re = O.length; L < re; L++)
-              b.y = O[L], U.x = b.x, U.y = b.y, k.lineTo(b.x, b.y), L === 0 && B === !0 && J.copy(b);
+            L = g(ne);
+            for (let O = 0, re = L.length; O < re; O++)
+              S.y = L[O], U.x = S.x, U.y = S.y, k.lineTo(S.x, S.y), O === 0 && N === !0 && ee.copy(S);
             break;
           case "L":
-            O = y(te);
-            for (let L = 0, re = O.length; L < re; L += 2)
-              b.x = O[L + 0], b.y = O[L + 1], U.x = b.x, U.y = b.y, k.lineTo(b.x, b.y), L === 0 && B === !0 && J.copy(b);
+            L = g(ne);
+            for (let O = 0, re = L.length; O < re; O += 2)
+              S.x = L[O + 0], S.y = L[O + 1], U.x = S.x, U.y = S.y, k.lineTo(S.x, S.y), O === 0 && N === !0 && ee.copy(S);
             break;
           case "C":
-            O = y(te);
-            for (let L = 0, re = O.length; L < re; L += 6)
+            L = g(ne);
+            for (let O = 0, re = L.length; O < re; O += 6)
               k.bezierCurveTo(
-                O[L + 0],
-                O[L + 1],
-                O[L + 2],
-                O[L + 3],
-                O[L + 4],
-                O[L + 5]
-              ), U.x = O[L + 2], U.y = O[L + 3], b.x = O[L + 4], b.y = O[L + 5], L === 0 && B === !0 && J.copy(b);
+                L[O + 0],
+                L[O + 1],
+                L[O + 2],
+                L[O + 3],
+                L[O + 4],
+                L[O + 5]
+              ), U.x = L[O + 2], U.y = L[O + 3], S.x = L[O + 4], S.y = L[O + 5], O === 0 && N === !0 && ee.copy(S);
             break;
           case "S":
-            O = y(te);
-            for (let L = 0, re = O.length; L < re; L += 4)
+            L = g(ne);
+            for (let O = 0, re = L.length; O < re; O += 4)
               k.bezierCurveTo(
-                _(b.x, U.x),
-                _(b.y, U.y),
-                O[L + 0],
-                O[L + 1],
-                O[L + 2],
-                O[L + 3]
-              ), U.x = O[L + 0], U.y = O[L + 1], b.x = O[L + 2], b.y = O[L + 3], L === 0 && B === !0 && J.copy(b);
+                x(S.x, U.x),
+                x(S.y, U.y),
+                L[O + 0],
+                L[O + 1],
+                L[O + 2],
+                L[O + 3]
+              ), U.x = L[O + 0], U.y = L[O + 1], S.x = L[O + 2], S.y = L[O + 3], O === 0 && N === !0 && ee.copy(S);
             break;
           case "Q":
-            O = y(te);
-            for (let L = 0, re = O.length; L < re; L += 4)
-              k.quadraticCurveTo(O[L + 0], O[L + 1], O[L + 2], O[L + 3]), U.x = O[L + 0], U.y = O[L + 1], b.x = O[L + 2], b.y = O[L + 3], L === 0 && B === !0 && J.copy(b);
+            L = g(ne);
+            for (let O = 0, re = L.length; O < re; O += 4)
+              k.quadraticCurveTo(L[O + 0], L[O + 1], L[O + 2], L[O + 3]), U.x = L[O + 0], U.y = L[O + 1], S.x = L[O + 2], S.y = L[O + 3], O === 0 && N === !0 && ee.copy(S);
             break;
           case "T":
-            O = y(te);
-            for (let L = 0, re = O.length; L < re; L += 2) {
-              const ce = _(b.x, U.x), be = _(b.y, U.y);
-              k.quadraticCurveTo(ce, be, O[L + 0], O[L + 1]), U.x = ce, U.y = be, b.x = O[L + 0], b.y = O[L + 1], L === 0 && B === !0 && J.copy(b);
+            L = g(ne);
+            for (let O = 0, re = L.length; O < re; O += 2) {
+              const de = x(S.x, U.x), be = x(S.y, U.y);
+              k.quadraticCurveTo(de, be, L[O + 0], L[O + 1]), U.x = de, U.y = be, S.x = L[O + 0], S.y = L[O + 1], O === 0 && N === !0 && ee.copy(S);
             }
             break;
           case "A":
-            O = y(te, [3, 4], 7);
-            for (let L = 0, re = O.length; L < re; L += 7) {
-              if (O[L + 5] == b.x && O[L + 6] == b.y)
+            L = g(ne, [3, 4], 7);
+            for (let O = 0, re = L.length; O < re; O += 7) {
+              if (L[O + 5] == S.x && L[O + 6] == S.y)
                 continue;
-              const ce = b.clone();
-              b.x = O[L + 5], b.y = O[L + 6], U.x = b.x, U.y = b.y, r(
+              const de = S.clone();
+              S.x = L[O + 5], S.y = L[O + 6], U.x = S.x, U.y = S.y, r(
                 k,
-                O[L],
-                O[L + 1],
-                O[L + 2],
-                O[L + 3],
-                O[L + 4],
-                ce,
-                b
-              ), L === 0 && B === !0 && J.copy(b);
+                L[O],
+                L[O + 1],
+                L[O + 2],
+                L[O + 3],
+                L[O + 4],
+                de,
+                S
+              ), O === 0 && N === !0 && ee.copy(S);
             }
             break;
           case "m":
-            O = y(te);
-            for (let L = 0, re = O.length; L < re; L += 2)
-              b.x += O[L + 0], b.y += O[L + 1], U.x = b.x, U.y = b.y, L === 0 ? k.moveTo(b.x, b.y) : k.lineTo(b.x, b.y), L === 0 && J.copy(b);
+            L = g(ne);
+            for (let O = 0, re = L.length; O < re; O += 2)
+              S.x += L[O + 0], S.y += L[O + 1], U.x = S.x, U.y = S.y, O === 0 ? k.moveTo(S.x, S.y) : k.lineTo(S.x, S.y), O === 0 && ee.copy(S);
             break;
           case "h":
-            O = y(te);
-            for (let L = 0, re = O.length; L < re; L++)
-              b.x += O[L], U.x = b.x, U.y = b.y, k.lineTo(b.x, b.y), L === 0 && B === !0 && J.copy(b);
+            L = g(ne);
+            for (let O = 0, re = L.length; O < re; O++)
+              S.x += L[O], U.x = S.x, U.y = S.y, k.lineTo(S.x, S.y), O === 0 && N === !0 && ee.copy(S);
             break;
           case "v":
-            O = y(te);
-            for (let L = 0, re = O.length; L < re; L++)
-              b.y += O[L], U.x = b.x, U.y = b.y, k.lineTo(b.x, b.y), L === 0 && B === !0 && J.copy(b);
+            L = g(ne);
+            for (let O = 0, re = L.length; O < re; O++)
+              S.y += L[O], U.x = S.x, U.y = S.y, k.lineTo(S.x, S.y), O === 0 && N === !0 && ee.copy(S);
             break;
           case "l":
-            O = y(te);
-            for (let L = 0, re = O.length; L < re; L += 2)
-              b.x += O[L + 0], b.y += O[L + 1], U.x = b.x, U.y = b.y, k.lineTo(b.x, b.y), L === 0 && B === !0 && J.copy(b);
+            L = g(ne);
+            for (let O = 0, re = L.length; O < re; O += 2)
+              S.x += L[O + 0], S.y += L[O + 1], U.x = S.x, U.y = S.y, k.lineTo(S.x, S.y), O === 0 && N === !0 && ee.copy(S);
             break;
           case "c":
-            O = y(te);
-            for (let L = 0, re = O.length; L < re; L += 6)
+            L = g(ne);
+            for (let O = 0, re = L.length; O < re; O += 6)
               k.bezierCurveTo(
-                b.x + O[L + 0],
-                b.y + O[L + 1],
-                b.x + O[L + 2],
-                b.y + O[L + 3],
-                b.x + O[L + 4],
-                b.y + O[L + 5]
-              ), U.x = b.x + O[L + 2], U.y = b.y + O[L + 3], b.x += O[L + 4], b.y += O[L + 5], L === 0 && B === !0 && J.copy(b);
+                S.x + L[O + 0],
+                S.y + L[O + 1],
+                S.x + L[O + 2],
+                S.y + L[O + 3],
+                S.x + L[O + 4],
+                S.y + L[O + 5]
+              ), U.x = S.x + L[O + 2], U.y = S.y + L[O + 3], S.x += L[O + 4], S.y += L[O + 5], O === 0 && N === !0 && ee.copy(S);
             break;
           case "s":
-            O = y(te);
-            for (let L = 0, re = O.length; L < re; L += 4)
+            L = g(ne);
+            for (let O = 0, re = L.length; O < re; O += 4)
               k.bezierCurveTo(
-                _(b.x, U.x),
-                _(b.y, U.y),
-                b.x + O[L + 0],
-                b.y + O[L + 1],
-                b.x + O[L + 2],
-                b.y + O[L + 3]
-              ), U.x = b.x + O[L + 0], U.y = b.y + O[L + 1], b.x += O[L + 2], b.y += O[L + 3], L === 0 && B === !0 && J.copy(b);
+                x(S.x, U.x),
+                x(S.y, U.y),
+                S.x + L[O + 0],
+                S.y + L[O + 1],
+                S.x + L[O + 2],
+                S.y + L[O + 3]
+              ), U.x = S.x + L[O + 0], U.y = S.y + L[O + 1], S.x += L[O + 2], S.y += L[O + 3], O === 0 && N === !0 && ee.copy(S);
             break;
           case "q":
-            O = y(te);
-            for (let L = 0, re = O.length; L < re; L += 4)
+            L = g(ne);
+            for (let O = 0, re = L.length; O < re; O += 4)
               k.quadraticCurveTo(
-                b.x + O[L + 0],
-                b.y + O[L + 1],
-                b.x + O[L + 2],
-                b.y + O[L + 3]
-              ), U.x = b.x + O[L + 0], U.y = b.y + O[L + 1], b.x += O[L + 2], b.y += O[L + 3], L === 0 && B === !0 && J.copy(b);
+                S.x + L[O + 0],
+                S.y + L[O + 1],
+                S.x + L[O + 2],
+                S.y + L[O + 3]
+              ), U.x = S.x + L[O + 0], U.y = S.y + L[O + 1], S.x += L[O + 2], S.y += L[O + 3], O === 0 && N === !0 && ee.copy(S);
             break;
           case "t":
-            O = y(te);
-            for (let L = 0, re = O.length; L < re; L += 2) {
-              const ce = _(b.x, U.x), be = _(b.y, U.y);
-              k.quadraticCurveTo(ce, be, b.x + O[L + 0], b.y + O[L + 1]), U.x = ce, U.y = be, b.x = b.x + O[L + 0], b.y = b.y + O[L + 1], L === 0 && B === !0 && J.copy(b);
+            L = g(ne);
+            for (let O = 0, re = L.length; O < re; O += 2) {
+              const de = x(S.x, U.x), be = x(S.y, U.y);
+              k.quadraticCurveTo(de, be, S.x + L[O + 0], S.y + L[O + 1]), U.x = de, U.y = be, S.x = S.x + L[O + 0], S.y = S.y + L[O + 1], O === 0 && N === !0 && ee.copy(S);
             }
             break;
           case "a":
-            O = y(te, [3, 4], 7);
-            for (let L = 0, re = O.length; L < re; L += 7) {
-              if (O[L + 5] == 0 && O[L + 6] == 0)
+            L = g(ne, [3, 4], 7);
+            for (let O = 0, re = L.length; O < re; O += 7) {
+              if (L[O + 5] == 0 && L[O + 6] == 0)
                 continue;
-              const ce = b.clone();
-              b.x += O[L + 5], b.y += O[L + 6], U.x = b.x, U.y = b.y, r(
+              const de = S.clone();
+              S.x += L[O + 5], S.y += L[O + 6], U.x = S.x, U.y = S.y, r(
                 k,
-                O[L],
-                O[L + 1],
-                O[L + 2],
-                O[L + 3],
-                O[L + 4],
-                ce,
-                b
-              ), L === 0 && B === !0 && J.copy(b);
+                L[O],
+                L[O + 1],
+                L[O + 2],
+                L[O + 3],
+                L[O + 4],
+                de,
+                S
+              ), O === 0 && N === !0 && ee.copy(S);
             }
             break;
           case "Z":
           case "z":
-            k.currentPath.autoClose = !0, k.currentPath.curves.length > 0 && (b.copy(J), k.currentPath.currentPoint.copy(b), F = !0);
+            k.currentPath.autoClose = !0, k.currentPath.curves.length > 0 && (S.copy(ee), k.currentPath.currentPoint.copy(S), F = !0);
             break;
           default:
-            console.warn($);
+            console.warn(Z);
         }
-        B = !1;
+        N = !1;
       }
       return k;
     }
     function i(H) {
       if (!(!H.sheet || !H.sheet.cssRules || !H.sheet.cssRules.length))
         for (let k = 0; k < H.sheet.cssRules.length; k++) {
-          const b = H.sheet.cssRules[k];
-          if (b.type !== 1)
+          const S = H.sheet.cssRules[k];
+          if (S.type !== 1)
             continue;
-          const U = b.selectorText.split(/,/gm).filter(Boolean).map((J) => J.trim());
-          for (let J = 0; J < U.length; J++)
-            P[U[J]] = Object.assign(P[U[J]] || {}, b.style);
+          const U = S.selectorText.split(/,/gm).filter(Boolean).map((ee) => ee.trim());
+          for (let ee = 0; ee < U.length; ee++)
+            C[U[ee]] = Object.assign(C[U[ee]] || {}, S.style);
         }
     }
-    function r(H, k, b, U, J, F, B, S) {
-      if (k == 0 || b == 0) {
-        H.lineTo(S.x, S.y);
+    function r(H, k, S, U, ee, F, N, A) {
+      if (k == 0 || S == 0) {
+        H.lineTo(A.x, A.y);
         return;
       }
-      U = U * Math.PI / 180, k = Math.abs(k), b = Math.abs(b);
-      const C = (B.x - S.x) / 2, D = (B.y - S.y) / 2, G = Math.cos(U) * C + Math.sin(U) * D, $ = -Math.sin(U) * C + Math.cos(U) * D;
-      let Y = k * k, te = b * b;
-      const O = G * G, L = $ * $, re = O / Y + L / te;
+      U = U * Math.PI / 180, k = Math.abs(k), S = Math.abs(S);
+      const R = (N.x - A.x) / 2, D = (N.y - A.y) / 2, j = Math.cos(U) * R + Math.sin(U) * D, Z = -Math.sin(U) * R + Math.cos(U) * D;
+      let $ = k * k, ne = S * S;
+      const L = j * j, O = Z * Z, re = L / $ + O / ne;
       if (re > 1) {
-        const An = Math.sqrt(re);
-        k = An * k, b = An * b, Y = k * k, te = b * b;
+        const Cn = Math.sqrt(re);
+        k = Cn * k, S = Cn * S, $ = k * k, ne = S * S;
       }
-      const ce = Y * L + te * O, be = (Y * te - ce) / ce;
-      let Me = Math.sqrt(Math.max(0, be));
-      J === F && (Me = -Me);
-      const Se = Me * k * $ / b, qe = -Me * b * G / k, kt = Math.cos(U) * Se - Math.sin(U) * qe + (B.x + S.x) / 2, jn = Math.sin(U) * Se + Math.cos(U) * qe + (B.y + S.y) / 2, Sn = a(1, 0, (G - Se) / k, ($ - qe) / b), gt = a((G - Se) / k, ($ - qe) / b, (-G - Se) / k, (-$ - qe) / b) % (Math.PI * 2);
-      H.currentPath.absellipse(kt, jn, k, b, Sn, Sn + gt, F === 0, U);
+      const de = $ * O + ne * L, be = ($ * ne - de) / de;
+      let Se = Math.sqrt(Math.max(0, be));
+      ee === F && (Se = -Se);
+      const Me = Se * k * Z / S, qe = -Se * S * j / k, Nt = Math.cos(U) * Me - Math.sin(U) * qe + (N.x + A.x) / 2, Zn = Math.sin(U) * Me + Math.cos(U) * qe + (N.y + A.y) / 2, Pn = a(1, 0, (j - Me) / k, (Z - qe) / S), gt = a((j - Me) / k, (Z - qe) / S, (-j - Me) / k, (-Z - qe) / S) % (Math.PI * 2);
+      H.currentPath.absellipse(Nt, Zn, k, S, Pn, Pn + gt, F === 0, U);
     }
-    function a(H, k, b, U) {
-      const J = H * b + k * U, F = Math.sqrt(H * H + k * k) * Math.sqrt(b * b + U * U);
-      let B = Math.acos(Math.max(-1, Math.min(1, J / F)));
-      return H * U - k * b < 0 && (B = -B), B;
+    function a(H, k, S, U) {
+      const ee = H * S + k * U, F = Math.sqrt(H * H + k * k) * Math.sqrt(S * S + U * U);
+      let N = Math.acos(Math.max(-1, Math.min(1, ee / F)));
+      return H * U - k * S < 0 && (N = -N), N;
     }
     function l(H) {
-      const k = T(H.getAttribute("x") || 0), b = T(H.getAttribute("y") || 0), U = T(H.getAttribute("rx") || H.getAttribute("ry") || 0), J = T(H.getAttribute("ry") || H.getAttribute("rx") || 0), F = T(H.getAttribute("width")), B = T(H.getAttribute("height")), S = 1 - 0.551915024494, C = new nn();
-      return C.moveTo(k + U, b), C.lineTo(k + F - U, b), (U !== 0 || J !== 0) && C.bezierCurveTo(k + F - U * S, b, k + F, b + J * S, k + F, b + J), C.lineTo(k + F, b + B - J), (U !== 0 || J !== 0) && C.bezierCurveTo(k + F, b + B - J * S, k + F - U * S, b + B, k + F - U, b + B), C.lineTo(k + U, b + B), (U !== 0 || J !== 0) && C.bezierCurveTo(k + U * S, b + B, k, b + B - J * S, k, b + B - J), C.lineTo(k, b + J), (U !== 0 || J !== 0) && C.bezierCurveTo(k, b + J * S, k + U * S, b, k + U, b), C;
+      const k = _(H.getAttribute("x") || 0), S = _(H.getAttribute("y") || 0), U = _(H.getAttribute("rx") || H.getAttribute("ry") || 0), ee = _(H.getAttribute("ry") || H.getAttribute("rx") || 0), F = _(H.getAttribute("width")), N = _(H.getAttribute("height")), A = 1 - 0.551915024494, R = new rn();
+      return R.moveTo(k + U, S), R.lineTo(k + F - U, S), (U !== 0 || ee !== 0) && R.bezierCurveTo(k + F - U * A, S, k + F, S + ee * A, k + F, S + ee), R.lineTo(k + F, S + N - ee), (U !== 0 || ee !== 0) && R.bezierCurveTo(k + F, S + N - ee * A, k + F - U * A, S + N, k + F - U, S + N), R.lineTo(k + U, S + N), (U !== 0 || ee !== 0) && R.bezierCurveTo(k + U * A, S + N, k, S + N - ee * A, k, S + N - ee), R.lineTo(k, S + ee), (U !== 0 || ee !== 0) && R.bezierCurveTo(k, S + ee * A, k + U * A, S, k + U, S), R;
     }
     function c(H) {
-      function k(F, B, S) {
-        const C = T(B), D = T(S);
-        J === 0 ? U.moveTo(C, D) : U.lineTo(C, D), J++;
+      function k(F, N, A) {
+        const R = _(N), D = _(A);
+        ee === 0 ? U.moveTo(R, D) : U.lineTo(R, D), ee++;
       }
-      const b = /(-?[\d\.?]+)[,|\s](-?[\d\.?]+)/g, U = new nn();
-      let J = 0;
-      return H.getAttribute("points").replace(b, k), U.currentPath.autoClose = !0, U;
+      const S = /(-?[\d\.?]+)[,|\s](-?[\d\.?]+)/g, U = new rn();
+      let ee = 0;
+      return H.getAttribute("points").replace(S, k), U.currentPath.autoClose = !0, U;
     }
     function u(H) {
-      function k(F, B, S) {
-        const C = T(B), D = T(S);
-        J === 0 ? U.moveTo(C, D) : U.lineTo(C, D), J++;
+      function k(F, N, A) {
+        const R = _(N), D = _(A);
+        ee === 0 ? U.moveTo(R, D) : U.lineTo(R, D), ee++;
       }
-      const b = /(-?[\d\.?]+)[,|\s](-?[\d\.?]+)/g, U = new nn();
-      let J = 0;
-      return H.getAttribute("points").replace(b, k), U.currentPath.autoClose = !1, U;
+      const S = /(-?[\d\.?]+)[,|\s](-?[\d\.?]+)/g, U = new rn();
+      let ee = 0;
+      return H.getAttribute("points").replace(S, k), U.currentPath.autoClose = !1, U;
     }
     function h(H) {
-      const k = T(H.getAttribute("cx") || 0), b = T(H.getAttribute("cy") || 0), U = T(H.getAttribute("r") || 0), J = new ai();
-      J.absarc(k, b, U, 0, Math.PI * 2);
-      const F = new nn();
-      return F.subPaths.push(J), F;
+      const k = _(H.getAttribute("cx") || 0), S = _(H.getAttribute("cy") || 0), U = _(H.getAttribute("r") || 0), ee = new di();
+      ee.absarc(k, S, U, 0, Math.PI * 2);
+      const F = new rn();
+      return F.subPaths.push(ee), F;
     }
-    function m(H) {
-      const k = T(H.getAttribute("cx") || 0), b = T(H.getAttribute("cy") || 0), U = T(H.getAttribute("rx") || 0), J = T(H.getAttribute("ry") || 0), F = new ai();
-      F.absellipse(k, b, U, J, 0, Math.PI * 2);
-      const B = new nn();
-      return B.subPaths.push(F), B;
+    function f(H) {
+      const k = _(H.getAttribute("cx") || 0), S = _(H.getAttribute("cy") || 0), U = _(H.getAttribute("rx") || 0), ee = _(H.getAttribute("ry") || 0), F = new di();
+      F.absellipse(k, S, U, ee, 0, Math.PI * 2);
+      const N = new rn();
+      return N.subPaths.push(F), N;
     }
-    function p(H) {
-      const k = T(H.getAttribute("x1") || 0), b = T(H.getAttribute("y1") || 0), U = T(H.getAttribute("x2") || 0), J = T(H.getAttribute("y2") || 0), F = new nn();
-      return F.moveTo(k, b), F.lineTo(U, J), F.currentPath.autoClose = !1, F;
+    function d(H) {
+      const k = _(H.getAttribute("x1") || 0), S = _(H.getAttribute("y1") || 0), U = _(H.getAttribute("x2") || 0), ee = _(H.getAttribute("y2") || 0), F = new rn();
+      return F.moveTo(k, S), F.lineTo(U, ee), F.currentPath.autoClose = !1, F;
     }
-    function v(H, k) {
+    function y(H, k) {
       k = Object.assign({}, k);
-      let b = {};
+      let S = {};
       if (H.hasAttribute("class")) {
-        const B = H.getAttribute("class").split(/\s/).filter(Boolean).map((S) => S.trim());
-        for (let S = 0; S < B.length; S++)
-          b = Object.assign(b, P["." + B[S]]);
+        const N = H.getAttribute("class").split(/\s/).filter(Boolean).map((A) => A.trim());
+        for (let A = 0; A < N.length; A++)
+          S = Object.assign(S, C["." + N[A]]);
       }
-      H.hasAttribute("id") && (b = Object.assign(b, P["#" + H.getAttribute("id")]));
-      function U(B, S, C) {
-        C === void 0 && (C = function(G) {
-          return G.startsWith("url") && console.warn("SVGLoader: url access in attributes is not implemented."), G;
-        }), H.hasAttribute(B) && (k[S] = C(H.getAttribute(B))), b[B] && (k[S] = C(b[B])), H.style && H.style[B] !== "" && (k[S] = C(H.style[B]));
+      H.hasAttribute("id") && (S = Object.assign(S, C["#" + H.getAttribute("id")]));
+      function U(N, A, R) {
+        R === void 0 && (R = function(j) {
+          return j.startsWith("url") && console.warn("SVGLoader: url access in attributes is not implemented."), j;
+        }), H.hasAttribute(N) && (k[A] = R(H.getAttribute(N))), S[N] && (k[A] = R(S[N])), H.style && H.style[N] !== "" && (k[A] = R(H.style[N]));
       }
-      function J(B) {
-        return Math.max(0, Math.min(1, T(B)));
+      function ee(N) {
+        return Math.max(0, Math.min(1, _(N)));
       }
-      function F(B) {
-        return Math.max(0, T(B));
+      function F(N) {
+        return Math.max(0, _(N));
       }
-      return U("fill", "fill"), U("fill-opacity", "fillOpacity", J), U("fill-rule", "fillRule"), U("opacity", "opacity", J), U("stroke", "stroke"), U("stroke-opacity", "strokeOpacity", J), U("stroke-width", "strokeWidth", F), U("stroke-linejoin", "strokeLineJoin"), U("stroke-linecap", "strokeLineCap"), U("stroke-miterlimit", "strokeMiterLimit", F), U("visibility", "visibility"), k;
+      return U("fill", "fill"), U("fill-opacity", "fillOpacity", ee), U("fill-rule", "fillRule"), U("opacity", "opacity", ee), U("stroke", "stroke"), U("stroke-opacity", "strokeOpacity", ee), U("stroke-width", "strokeWidth", F), U("stroke-linejoin", "strokeLineJoin"), U("stroke-linecap", "strokeLineCap"), U("stroke-miterlimit", "strokeMiterLimit", F), U("visibility", "visibility"), k;
     }
-    function _(H, k) {
+    function x(H, k) {
       return H - (k - H);
     }
-    function y(H, k, b) {
+    function g(H, k, S) {
       if (typeof H != "string")
         throw new TypeError("Invalid input: " + typeof H);
       const U = {
@@ -6359,80 +6396,80 @@ class is extends cs {
         COMMA: /,/,
         EXP: /e/i,
         FLAGS: /[01]/
-      }, J = 0, F = 1, B = 2, S = 3;
-      let C = J, D = !0, G = "", $ = "";
-      const Y = [];
-      function te(ce, be, Me) {
-        const Se = new SyntaxError('Unexpected character "' + ce + '" at index ' + be + ".");
-        throw Se.partial = Me, Se;
+      }, ee = 0, F = 1, N = 2, A = 3;
+      let R = ee, D = !0, j = "", Z = "";
+      const $ = [];
+      function ne(de, be, Se) {
+        const Me = new SyntaxError('Unexpected character "' + de + '" at index ' + be + ".");
+        throw Me.partial = Se, Me;
       }
-      function O() {
-        G !== "" && ($ === "" ? Y.push(Number(G)) : Y.push(Number(G) * Math.pow(10, Number($)))), G = "", $ = "";
+      function L() {
+        j !== "" && (Z === "" ? $.push(Number(j)) : $.push(Number(j) * Math.pow(10, Number(Z)))), j = "", Z = "";
       }
-      let L;
+      let O;
       const re = H.length;
-      for (let ce = 0; ce < re; ce++) {
-        if (L = H[ce], Array.isArray(k) && k.includes(Y.length % b) && U.FLAGS.test(L)) {
-          C = F, G = L, O();
+      for (let de = 0; de < re; de++) {
+        if (O = H[de], Array.isArray(k) && k.includes($.length % S) && U.FLAGS.test(O)) {
+          R = F, j = O, L();
           continue;
         }
-        if (C === J) {
-          if (U.WHITESPACE.test(L))
+        if (R === ee) {
+          if (U.WHITESPACE.test(O))
             continue;
-          if (U.DIGIT.test(L) || U.SIGN.test(L)) {
-            C = F, G = L;
+          if (U.DIGIT.test(O) || U.SIGN.test(O)) {
+            R = F, j = O;
             continue;
           }
-          if (U.POINT.test(L)) {
-            C = B, G = L;
+          if (U.POINT.test(O)) {
+            R = N, j = O;
             continue;
           }
-          U.COMMA.test(L) && (D && te(L, ce, Y), D = !0);
+          U.COMMA.test(O) && (D && ne(O, de, $), D = !0);
         }
-        if (C === F) {
-          if (U.DIGIT.test(L)) {
-            G += L;
+        if (R === F) {
+          if (U.DIGIT.test(O)) {
+            j += O;
             continue;
           }
-          if (U.POINT.test(L)) {
-            G += L, C = B;
+          if (U.POINT.test(O)) {
+            j += O, R = N;
             continue;
           }
-          if (U.EXP.test(L)) {
-            C = S;
+          if (U.EXP.test(O)) {
+            R = A;
             continue;
           }
-          U.SIGN.test(L) && G.length === 1 && U.SIGN.test(G[0]) && te(L, ce, Y);
+          U.SIGN.test(O) && j.length === 1 && U.SIGN.test(j[0]) && ne(O, de, $);
         }
-        if (C === B) {
-          if (U.DIGIT.test(L)) {
-            G += L;
+        if (R === N) {
+          if (U.DIGIT.test(O)) {
+            j += O;
             continue;
           }
-          if (U.EXP.test(L)) {
-            C = S;
+          if (U.EXP.test(O)) {
+            R = A;
             continue;
           }
-          U.POINT.test(L) && G[G.length - 1] === "." && te(L, ce, Y);
+          U.POINT.test(O) && j[j.length - 1] === "." && ne(O, de, $);
         }
-        if (C === S) {
-          if (U.DIGIT.test(L)) {
-            $ += L;
+        if (R === A) {
+          if (U.DIGIT.test(O)) {
+            Z += O;
             continue;
           }
-          if (U.SIGN.test(L)) {
-            if ($ === "") {
-              $ += L;
+          if (U.SIGN.test(O)) {
+            if (Z === "") {
+              Z += O;
               continue;
             }
-            $.length === 1 && U.SIGN.test($) && te(L, ce, Y);
+            Z.length === 1 && U.SIGN.test(Z) && ne(O, de, $);
           }
         }
-        U.WHITESPACE.test(L) ? (O(), C = J, D = !1) : U.COMMA.test(L) ? (O(), C = J, D = !0) : U.SIGN.test(L) ? (O(), C = F, G = L) : U.POINT.test(L) ? (O(), C = B, G = L) : te(L, ce, Y);
+        U.WHITESPACE.test(O) ? (L(), R = ee, D = !1) : U.COMMA.test(O) ? (L(), R = ee, D = !0) : U.SIGN.test(O) ? (L(), R = F, j = O) : U.POINT.test(O) ? (L(), R = N, j = O) : ne(O, de, $);
       }
-      return O(), Y;
+      return L(), $;
     }
-    const E = ["mm", "cm", "in", "pt", "pc", "px"], R = {
+    const v = ["mm", "cm", "in", "pt", "pc", "px"], M = {
       mm: {
         mm: 1,
         cm: 0.1,
@@ -6477,102 +6514,102 @@ class is extends cs {
         px: 1
       }
     };
-    function T(H) {
+    function _(H) {
       let k = "px";
       if (typeof H == "string" || H instanceof String)
-        for (let U = 0, J = E.length; U < J; U++) {
-          const F = E[U];
+        for (let U = 0, ee = v.length; U < ee; U++) {
+          const F = v[U];
           if (H.endsWith(F)) {
             k = F, H = H.substring(0, H.length - F.length);
             break;
           }
         }
-      let b;
-      return k === "px" && t.defaultUnit !== "px" ? b = R.in[t.defaultUnit] / t.defaultDPI : (b = R[k][t.defaultUnit], b < 0 && (b = R[k].in * t.defaultDPI)), b * parseFloat(H);
+      let S;
+      return k === "px" && t.defaultUnit !== "px" ? S = M.in[t.defaultUnit] / t.defaultDPI : (S = M[k][t.defaultUnit], S < 0 && (S = M[k].in * t.defaultDPI)), S * parseFloat(H);
     }
-    function g(H) {
+    function w(H) {
       if (!(H.hasAttribute("transform") || H.nodeName === "use" && (H.hasAttribute("x") || H.hasAttribute("y"))))
         return null;
-      const k = A(H);
-      return I.length > 0 && k.premultiply(I[I.length - 1]), ne.copy(k), I.push(k), k;
+      const k = P(H);
+      return I.length > 0 && k.premultiply(I[I.length - 1]), te.copy(k), I.push(k), k;
     }
-    function A(H) {
-      const k = new vn(), b = K;
+    function P(H) {
+      const k = new wn(), S = K;
       if (H.nodeName === "use" && (H.hasAttribute("x") || H.hasAttribute("y"))) {
-        const U = T(H.getAttribute("x")), J = T(H.getAttribute("y"));
-        k.translate(U, J);
+        const U = _(H.getAttribute("x")), ee = _(H.getAttribute("y"));
+        k.translate(U, ee);
       }
       if (H.hasAttribute("transform")) {
         const U = H.getAttribute("transform").split(")");
-        for (let J = U.length - 1; J >= 0; J--) {
-          const F = U[J].trim();
+        for (let ee = U.length - 1; ee >= 0; ee--) {
+          const F = U[ee].trim();
           if (F === "")
             continue;
-          const B = F.indexOf("("), S = F.length;
-          if (B > 0 && B < S) {
-            const C = F.substr(0, B), D = y(F.substr(B + 1, S - B - 1));
-            switch (b.identity(), C) {
+          const N = F.indexOf("("), A = F.length;
+          if (N > 0 && N < A) {
+            const R = F.substr(0, N), D = g(F.substr(N + 1, A - N - 1));
+            switch (S.identity(), R) {
               case "translate":
                 if (D.length >= 1) {
-                  const G = D[0];
-                  let $ = G;
-                  D.length >= 2 && ($ = D[1]), b.translate(G, $);
+                  const j = D[0];
+                  let Z = j;
+                  D.length >= 2 && (Z = D[1]), S.translate(j, Z);
                 }
                 break;
               case "rotate":
                 if (D.length >= 1) {
-                  let G = 0, $ = 0, Y = 0;
-                  G = -D[0] * Math.PI / 180, D.length >= 3 && ($ = D[1], Y = D[2]), N.identity().translate(-$, -Y), Z.identity().rotate(G), W.multiplyMatrices(Z, N), N.identity().translate($, Y), b.multiplyMatrices(N, W);
+                  let j = 0, Z = 0, $ = 0;
+                  j = -D[0] * Math.PI / 180, D.length >= 3 && (Z = D[1], $ = D[2]), z.identity().translate(-Z, -$), Y.identity().rotate(j), W.multiplyMatrices(Y, z), z.identity().translate(Z, $), S.multiplyMatrices(z, W);
                 }
                 break;
               case "scale":
                 if (D.length >= 1) {
-                  const G = D[0];
-                  let $ = G;
-                  D.length >= 2 && ($ = D[1]), b.scale(G, $);
+                  const j = D[0];
+                  let Z = j;
+                  D.length >= 2 && (Z = D[1]), S.scale(j, Z);
                 }
                 break;
               case "skewX":
-                D.length === 1 && b.set(1, Math.tan(D[0] * Math.PI / 180), 0, 0, 1, 0, 0, 0, 1);
+                D.length === 1 && S.set(1, Math.tan(D[0] * Math.PI / 180), 0, 0, 1, 0, 0, 0, 1);
                 break;
               case "skewY":
-                D.length === 1 && b.set(1, 0, 0, Math.tan(D[0] * Math.PI / 180), 1, 0, 0, 0, 1);
+                D.length === 1 && S.set(1, 0, 0, Math.tan(D[0] * Math.PI / 180), 1, 0, 0, 0, 1);
                 break;
               case "matrix":
-                D.length === 6 && b.set(D[0], D[2], D[4], D[1], D[3], D[5], 0, 0, 1);
+                D.length === 6 && S.set(D[0], D[2], D[4], D[1], D[3], D[5], 0, 0, 1);
                 break;
             }
           }
-          k.premultiply(b);
+          k.premultiply(S);
         }
       }
       return k;
     }
-    function x(H, k) {
-      function b(F) {
+    function T(H, k) {
+      function S(F) {
         V.set(F.x, F.y, 1).applyMatrix3(k), F.set(V.x, V.y);
       }
-      const U = M(k), J = H.subPaths;
-      for (let F = 0, B = J.length; F < B; F++) {
-        const C = J[F].curves;
-        for (let D = 0; D < C.length; D++) {
-          const G = C[D];
-          G.isLineCurve ? (b(G.v1), b(G.v2)) : G.isCubicBezierCurve ? (b(G.v0), b(G.v1), b(G.v2), b(G.v3)) : G.isQuadraticBezierCurve ? (b(G.v0), b(G.v1), b(G.v2)) : G.isEllipseCurve && (U && console.warn("SVGLoader: Elliptic arc or ellipse rotation or skewing is not implemented."), X.set(G.aX, G.aY), b(X), G.aX = X.x, G.aY = X.y, G.xRadius *= d(k), G.yRadius *= w(k));
+      const U = E(k), ee = H.subPaths;
+      for (let F = 0, N = ee.length; F < N; F++) {
+        const R = ee[F].curves;
+        for (let D = 0; D < R.length; D++) {
+          const j = R[D];
+          j.isLineCurve ? (S(j.v1), S(j.v2)) : j.isCubicBezierCurve ? (S(j.v0), S(j.v1), S(j.v2), S(j.v3)) : j.isQuadraticBezierCurve ? (S(j.v0), S(j.v1), S(j.v2)) : j.isEllipseCurve && (U && console.warn("SVGLoader: Elliptic arc or ellipse rotation or skewing is not implemented."), X.set(j.aX, j.aY), S(X), j.aX = X.x, j.aY = X.y, j.xRadius *= m(k), j.yRadius *= b(k));
         }
       }
     }
-    function M(H) {
+    function E(H) {
       return H.elements[1] !== 0 || H.elements[3] !== 0;
     }
-    function d(H) {
+    function m(H) {
       const k = H.elements;
       return Math.sqrt(k[0] * k[0] + k[1] * k[1]);
     }
-    function w(H) {
+    function b(H) {
       const k = H.elements;
       return Math.sqrt(k[3] * k[3] + k[4] * k[4]);
     }
-    const f = [], P = {}, I = [], K = new vn(), N = new vn(), Z = new vn(), W = new vn(), X = new le(), V = new ee(), ne = new vn(), se = new DOMParser().parseFromString(e, "image/svg+xml");
+    const p = [], C = {}, I = [], K = new wn(), z = new wn(), Y = new wn(), W = new wn(), X = new he(), V = new q(), te = new wn(), se = new DOMParser().parseFromString(e, "image/svg+xml");
     return n(se.documentElement, {
       fill: "#000",
       fillOpacity: 1,
@@ -6581,7 +6618,7 @@ class is extends cs {
       strokeLineJoin: "miter",
       strokeLineCap: "butt",
       strokeMiterLimit: 4
-    }), { paths: f, xml: se.documentElement };
+    }), { paths: p, xml: se.documentElement };
   }
   static createShapes(e) {
     const n = {
@@ -6596,137 +6633,137 @@ class is extends cs {
       loc: n.ORIGIN,
       t: 0
     };
-    function i(y, E, R, T) {
-      const g = y.x, A = E.x, x = R.x, M = T.x, d = y.y, w = E.y, f = R.y, P = T.y, I = (M - x) * (d - f) - (P - f) * (g - x), K = (A - g) * (d - f) - (w - d) * (g - x), N = (P - f) * (A - g) - (M - x) * (w - d), Z = I / N, W = K / N;
-      if (N === 0 && I !== 0 || Z <= 0 || Z >= 1 || W < 0 || W > 1)
+    function i(g, v, M, _) {
+      const w = g.x, P = v.x, T = M.x, E = _.x, m = g.y, b = v.y, p = M.y, C = _.y, I = (E - T) * (m - p) - (C - p) * (w - T), K = (P - w) * (m - p) - (b - m) * (w - T), z = (C - p) * (P - w) - (E - T) * (b - m), Y = I / z, W = K / z;
+      if (z === 0 && I !== 0 || Y <= 0 || Y >= 1 || W < 0 || W > 1)
         return null;
-      if (I === 0 && N === 0) {
+      if (I === 0 && z === 0) {
         for (let X = 0; X < 2; X++)
-          if (r(X === 0 ? R : T, y, E), s.loc == n.ORIGIN) {
-            const V = X === 0 ? R : T;
+          if (r(X === 0 ? M : _, g, v), s.loc == n.ORIGIN) {
+            const V = X === 0 ? M : _;
             return { x: V.x, y: V.y, t: s.t };
           } else if (s.loc == n.BETWEEN) {
-            const V = +(g + s.t * (A - g)).toPrecision(10), ne = +(d + s.t * (w - d)).toPrecision(10);
-            return { x: V, y: ne, t: s.t };
+            const V = +(w + s.t * (P - w)).toPrecision(10), te = +(m + s.t * (b - m)).toPrecision(10);
+            return { x: V, y: te, t: s.t };
           }
         return null;
       } else {
-        for (let ne = 0; ne < 2; ne++)
-          if (r(ne === 0 ? R : T, y, E), s.loc == n.ORIGIN) {
-            const se = ne === 0 ? R : T;
+        for (let te = 0; te < 2; te++)
+          if (r(te === 0 ? M : _, g, v), s.loc == n.ORIGIN) {
+            const se = te === 0 ? M : _;
             return { x: se.x, y: se.y, t: s.t };
           }
-        const X = +(g + Z * (A - g)).toPrecision(10), V = +(d + Z * (w - d)).toPrecision(10);
-        return { x: X, y: V, t: Z };
+        const X = +(w + Y * (P - w)).toPrecision(10), V = +(m + Y * (b - m)).toPrecision(10);
+        return { x: X, y: V, t: Y };
       }
     }
-    function r(y, E, R) {
-      const T = R.x - E.x, g = R.y - E.y, A = y.x - E.x, x = y.y - E.y, M = T * x - A * g;
-      if (y.x === E.x && y.y === E.y) {
+    function r(g, v, M) {
+      const _ = M.x - v.x, w = M.y - v.y, P = g.x - v.x, T = g.y - v.y, E = _ * T - P * w;
+      if (g.x === v.x && g.y === v.y) {
         s.loc = n.ORIGIN, s.t = 0;
         return;
       }
-      if (y.x === R.x && y.y === R.y) {
+      if (g.x === M.x && g.y === M.y) {
         s.loc = n.DESTINATION, s.t = 1;
         return;
       }
-      if (M < -Number.EPSILON) {
+      if (E < -Number.EPSILON) {
         s.loc = n.LEFT;
         return;
       }
-      if (M > Number.EPSILON) {
+      if (E > Number.EPSILON) {
         s.loc = n.RIGHT;
         return;
       }
-      if (T * A < 0 || g * x < 0) {
+      if (_ * P < 0 || w * T < 0) {
         s.loc = n.BEHIND;
         return;
       }
-      if (Math.sqrt(T * T + g * g) < Math.sqrt(A * A + x * x)) {
+      if (Math.sqrt(_ * _ + w * w) < Math.sqrt(P * P + T * T)) {
         s.loc = n.BEYOND;
         return;
       }
-      let d;
-      T !== 0 ? d = A / T : d = x / g, s.loc = n.BETWEEN, s.t = d;
-    }
-    function a(y, E) {
-      const R = [], T = [];
-      for (let g = 1; g < y.length; g++) {
-        const A = y[g - 1], x = y[g];
-        for (let M = 1; M < E.length; M++) {
-          const d = E[M - 1], w = E[M], f = i(A, x, d, w);
-          f !== null && R.find(
-            (P) => P.t <= f.t + Number.EPSILON && P.t >= f.t - Number.EPSILON
-          ) === void 0 && (R.push(f), T.push(new le(f.x, f.y)));
+      let m;
+      _ !== 0 ? m = P / _ : m = T / w, s.loc = n.BETWEEN, s.t = m;
+    }
+    function a(g, v) {
+      const M = [], _ = [];
+      for (let w = 1; w < g.length; w++) {
+        const P = g[w - 1], T = g[w];
+        for (let E = 1; E < v.length; E++) {
+          const m = v[E - 1], b = v[E], p = i(P, T, m, b);
+          p !== null && M.find(
+            (C) => C.t <= p.t + Number.EPSILON && C.t >= p.t - Number.EPSILON
+          ) === void 0 && (M.push(p), _.push(new he(p.x, p.y)));
         }
       }
-      return T;
-    }
-    function l(y, E, R) {
-      const T = new le();
-      E.getCenter(T);
-      const g = [];
-      return R.forEach((A) => {
-        A.boundingBox.containsPoint(T) && a(y, A.points).forEach((M) => {
-          g.push({ identifier: A.identifier, isCW: A.isCW, point: M });
+      return _;
+    }
+    function l(g, v, M) {
+      const _ = new he();
+      v.getCenter(_);
+      const w = [];
+      return M.forEach((P) => {
+        P.boundingBox.containsPoint(_) && a(g, P.points).forEach((E) => {
+          w.push({ identifier: P.identifier, isCW: P.isCW, point: E });
         });
-      }), g.sort((A, x) => A.point.x - x.point.x), g;
-    }
-    function c(y, E, R, T, g) {
-      (g == null || g === "") && (g = "nonzero");
-      const A = new le();
-      y.boundingBox.getCenter(A);
-      const x = [new le(R, A.y), new le(T, A.y)], M = l(x, y.boundingBox, E);
-      M.sort((K, N) => K.point.x - N.point.x);
-      const d = [], w = [];
-      M.forEach((K) => {
-        K.identifier === y.identifier ? d.push(K) : w.push(K);
+      }), w.sort((P, T) => P.point.x - T.point.x), w;
+    }
+    function c(g, v, M, _, w) {
+      (w == null || w === "") && (w = "nonzero");
+      const P = new he();
+      g.boundingBox.getCenter(P);
+      const T = [new he(M, P.y), new he(_, P.y)], E = l(T, g.boundingBox, v);
+      E.sort((K, z) => K.point.x - z.point.x);
+      const m = [], b = [];
+      E.forEach((K) => {
+        K.identifier === g.identifier ? m.push(K) : b.push(K);
       });
-      const f = d[0].point.x, P = [];
+      const p = m[0].point.x, C = [];
       let I = 0;
-      for (; I < w.length && w[I].point.x < f; )
-        P.length > 0 && P[P.length - 1] === w[I].identifier ? P.pop() : P.push(w[I].identifier), I++;
-      if (P.push(y.identifier), g === "evenodd") {
-        const K = P.length % 2 === 0, N = P[P.length - 2];
-        return { identifier: y.identifier, isHole: K, for: N };
-      } else if (g === "nonzero") {
-        let K = !0, N = null, Z = null;
-        for (let W = 0; W < P.length; W++) {
-          const X = P[W];
-          K ? (Z = E[X].isCW, K = !1, N = X) : Z !== E[X].isCW && (Z = E[X].isCW, K = !0);
+      for (; I < b.length && b[I].point.x < p; )
+        C.length > 0 && C[C.length - 1] === b[I].identifier ? C.pop() : C.push(b[I].identifier), I++;
+      if (C.push(g.identifier), w === "evenodd") {
+        const K = C.length % 2 === 0, z = C[C.length - 2];
+        return { identifier: g.identifier, isHole: K, for: z };
+      } else if (w === "nonzero") {
+        let K = !0, z = null, Y = null;
+        for (let W = 0; W < C.length; W++) {
+          const X = C[W];
+          K ? (Y = v[X].isCW, K = !1, z = X) : Y !== v[X].isCW && (Y = v[X].isCW, K = !0);
         }
-        return { identifier: y.identifier, isHole: K, for: N };
+        return { identifier: g.identifier, isHole: K, for: z };
       } else
-        console.warn('fill-rule: "' + g + '" is currently not implemented.');
-    }
-    let u = 0, h = 999999999, m = -999999999, p = e.subPaths.map((y) => {
-      const E = y.getPoints();
-      let R = -999999999, T = 999999999, g = -999999999, A = 999999999;
-      for (let x = 0; x < E.length; x++) {
-        const M = E[x];
-        M.y > R && (R = M.y), M.y < T && (T = M.y), M.x > g && (g = M.x), M.x < A && (A = M.x);
+        console.warn('fill-rule: "' + w + '" is currently not implemented.');
+    }
+    let u = 0, h = 999999999, f = -999999999, d = e.subPaths.map((g) => {
+      const v = g.getPoints();
+      let M = -999999999, _ = 999999999, w = -999999999, P = 999999999;
+      for (let T = 0; T < v.length; T++) {
+        const E = v[T];
+        E.y > M && (M = E.y), E.y < _ && (_ = E.y), E.x > w && (w = E.x), E.x < P && (P = E.x);
       }
-      return m <= g && (m = g + 1), h >= A && (h = A - 1), {
-        curves: y.curves,
-        points: E,
-        isCW: Ml.isClockWise(E),
+      return f <= w && (f = w + 1), h >= P && (h = P - 1), {
+        curves: g.curves,
+        points: v,
+        isCW: Il.isClockWise(v),
         identifier: u++,
-        boundingBox: new ea(new le(A, T), new le(g, R))
+        boundingBox: new aa(new he(P, _), new he(w, M))
       };
     });
-    p = p.filter((y) => y.points.length > 1);
-    const v = p.map(
-      (y) => c(y, p, h, m, e.userData.style.fillRule)
-    ), _ = [];
-    return p.forEach((y) => {
-      if (!v[y.identifier].isHole) {
-        const R = new Sl();
-        R.curves = y.curves, v.filter((g) => g.isHole && g.for === y.identifier).forEach((g) => {
-          const A = p[g.identifier], x = new ai();
-          x.curves = A.curves, R.holes.push(x);
-        }), _.push(R);
+    d = d.filter((g) => g.points.length > 1);
+    const y = d.map(
+      (g) => c(g, d, h, f, e.userData.style.fillRule)
+    ), x = [];
+    return d.forEach((g) => {
+      if (!y[g.identifier].isHole) {
+        const M = new Dl();
+        M.curves = g.curves, y.filter((w) => w.isHole && w.for === g.identifier).forEach((w) => {
+          const P = d[w.identifier], T = new di();
+          T.curves = P.curves, M.holes.push(T);
+        }), x.push(M);
       }
-    }), _;
+    }), x;
   }
   static getStrokeStyle(e, t, n, s, i) {
     return e = e !== void 0 ? e : 1, t = t !== void 0 ? t : "#000", n = n !== void 0 ? n : "miter", s = s !== void 0 ? s : "butt", i = i !== void 0 ? i : 4, {
@@ -6739,127 +6776,127 @@ class is extends cs {
   }
   static pointsToStroke(e, t, n, s) {
     const i = [], r = [], a = [];
-    if (is.pointsToStrokeWithBuffers(e, t, n, s, i, r, a) === 0)
+    if (hs.pointsToStrokeWithBuffers(e, t, n, s, i, r, a) === 0)
       return null;
-    const l = new rt();
+    const l = new at();
     return l.setAttribute("position", new it(i, 3)), l.setAttribute("normal", new it(r, 3)), l.setAttribute("uv", new it(a, 2)), l;
   }
   static pointsToStrokeWithBuffers(e, t, n, s, i, r, a, l) {
-    const c = new le(), u = new le(), h = new le(), m = new le(), p = new le(), v = new le(), _ = new le(), y = new le(), E = new le(), R = new le(), T = new le(), g = new le(), A = new le(), x = new le(), M = new le(), d = new le(), w = new le();
-    n = n !== void 0 ? n : 12, s = s !== void 0 ? s : 1e-3, l = l !== void 0 ? l : 0, e = $(e);
-    const f = e.length;
-    if (f < 2)
+    const c = new he(), u = new he(), h = new he(), f = new he(), d = new he(), y = new he(), x = new he(), g = new he(), v = new he(), M = new he(), _ = new he(), w = new he(), P = new he(), T = new he(), E = new he(), m = new he(), b = new he();
+    n = n !== void 0 ? n : 12, s = s !== void 0 ? s : 1e-3, l = l !== void 0 ? l : 0, e = Z(e);
+    const p = e.length;
+    if (p < 2)
       return 0;
-    const P = e[0].equals(e[f - 1]);
-    let I, K = e[0], N;
-    const Z = t.strokeWidth / 2, W = 1 / (f - 1);
-    let X = 0, V, ne, se, he, H = !1, k = 0, b = l * 3, U = l * 2;
-    J(e[0], e[1], c).multiplyScalar(Z), y.copy(e[0]).sub(c), E.copy(e[0]).add(c), R.copy(y), T.copy(E);
-    for (let Y = 1; Y < f; Y++) {
-      I = e[Y], Y === f - 1 ? P ? N = e[1] : N = void 0 : N = e[Y + 1];
-      const te = c;
-      if (J(K, I, te), h.copy(te).multiplyScalar(Z), g.copy(I).sub(h), A.copy(I).add(h), V = X + W, ne = !1, N !== void 0) {
-        J(I, N, u), h.copy(u).multiplyScalar(Z), x.copy(I).sub(h), M.copy(I).add(h), se = !0, h.subVectors(N, K), te.dot(h) < 0 && (se = !1), Y === 1 && (H = se), h.subVectors(N, I), h.normalize();
-        const O = Math.abs(te.dot(h));
-        if (O !== 0) {
-          const L = Z / O;
-          h.multiplyScalar(-L), m.subVectors(I, K), p.copy(m).setLength(L).add(h), d.copy(p).negate();
-          const re = p.length(), ce = m.length();
-          m.divideScalar(ce), v.subVectors(N, I);
-          const be = v.length();
-          switch (v.divideScalar(be), m.dot(d) < ce && v.dot(d) < be && (ne = !0), w.copy(p).add(I), d.add(I), he = !1, ne ? se ? (M.copy(d), A.copy(d)) : (x.copy(d), g.copy(d)) : S(), t.strokeLineJoin) {
+    const C = e[0].equals(e[p - 1]);
+    let I, K = e[0], z;
+    const Y = t.strokeWidth / 2, W = 1 / (p - 1);
+    let X = 0, V, te, se, fe, H = !1, k = 0, S = l * 3, U = l * 2;
+    ee(e[0], e[1], c).multiplyScalar(Y), g.copy(e[0]).sub(c), v.copy(e[0]).add(c), M.copy(g), _.copy(v);
+    for (let $ = 1; $ < p; $++) {
+      I = e[$], $ === p - 1 ? C ? z = e[1] : z = void 0 : z = e[$ + 1];
+      const ne = c;
+      if (ee(K, I, ne), h.copy(ne).multiplyScalar(Y), w.copy(I).sub(h), P.copy(I).add(h), V = X + W, te = !1, z !== void 0) {
+        ee(I, z, u), h.copy(u).multiplyScalar(Y), T.copy(I).sub(h), E.copy(I).add(h), se = !0, h.subVectors(z, K), ne.dot(h) < 0 && (se = !1), $ === 1 && (H = se), h.subVectors(z, I), h.normalize();
+        const L = Math.abs(ne.dot(h));
+        if (L !== 0) {
+          const O = Y / L;
+          h.multiplyScalar(-O), f.subVectors(I, K), d.copy(f).setLength(O).add(h), m.copy(d).negate();
+          const re = d.length(), de = f.length();
+          f.divideScalar(de), y.subVectors(z, I);
+          const be = y.length();
+          switch (y.divideScalar(be), f.dot(m) < de && y.dot(m) < be && (te = !0), b.copy(d).add(I), m.add(I), fe = !1, te ? se ? (E.copy(m), P.copy(m)) : (T.copy(m), w.copy(m)) : A(), t.strokeLineJoin) {
             case "bevel":
-              C(se, ne, V);
+              R(se, te, V);
               break;
             case "round":
-              D(se, ne), se ? B(I, g, x, V, 0) : B(I, M, A, V, 1);
+              D(se, te), se ? N(I, w, T, V, 0) : N(I, E, P, V, 1);
               break;
             case "miter":
             case "miter-clip":
             default:
-              const Me = Z * t.strokeMiterLimit / re;
-              if (Me < 1)
+              const Se = Y * t.strokeMiterLimit / re;
+              if (Se < 1)
                 if (t.strokeLineJoin !== "miter-clip") {
-                  C(se, ne, V);
+                  R(se, te, V);
                   break;
                 } else
-                  D(se, ne), se ? (v.subVectors(w, g).multiplyScalar(Me).add(g), _.subVectors(w, x).multiplyScalar(Me).add(x), F(g, V, 0), F(v, V, 0), F(I, V, 0.5), F(I, V, 0.5), F(v, V, 0), F(_, V, 0), F(I, V, 0.5), F(_, V, 0), F(x, V, 0)) : (v.subVectors(w, A).multiplyScalar(Me).add(A), _.subVectors(w, M).multiplyScalar(Me).add(M), F(A, V, 1), F(v, V, 1), F(I, V, 0.5), F(I, V, 0.5), F(v, V, 1), F(_, V, 1), F(I, V, 0.5), F(_, V, 1), F(M, V, 1));
+                  D(se, te), se ? (y.subVectors(b, w).multiplyScalar(Se).add(w), x.subVectors(b, T).multiplyScalar(Se).add(T), F(w, V, 0), F(y, V, 0), F(I, V, 0.5), F(I, V, 0.5), F(y, V, 0), F(x, V, 0), F(I, V, 0.5), F(x, V, 0), F(T, V, 0)) : (y.subVectors(b, P).multiplyScalar(Se).add(P), x.subVectors(b, E).multiplyScalar(Se).add(E), F(P, V, 1), F(y, V, 1), F(I, V, 0.5), F(I, V, 0.5), F(y, V, 1), F(x, V, 1), F(I, V, 0.5), F(x, V, 1), F(E, V, 1));
               else
-                ne ? (se ? (F(E, X, 1), F(y, X, 0), F(w, V, 0), F(E, X, 1), F(w, V, 0), F(d, V, 1)) : (F(E, X, 1), F(y, X, 0), F(w, V, 1), F(y, X, 0), F(d, V, 0), F(w, V, 1)), se ? x.copy(w) : M.copy(w)) : se ? (F(g, V, 0), F(w, V, 0), F(I, V, 0.5), F(I, V, 0.5), F(w, V, 0), F(x, V, 0)) : (F(A, V, 1), F(w, V, 1), F(I, V, 0.5), F(I, V, 0.5), F(w, V, 1), F(M, V, 1)), he = !0;
+                te ? (se ? (F(v, X, 1), F(g, X, 0), F(b, V, 0), F(v, X, 1), F(b, V, 0), F(m, V, 1)) : (F(v, X, 1), F(g, X, 0), F(b, V, 1), F(g, X, 0), F(m, V, 0), F(b, V, 1)), se ? T.copy(b) : E.copy(b)) : se ? (F(w, V, 0), F(b, V, 0), F(I, V, 0.5), F(I, V, 0.5), F(b, V, 0), F(T, V, 0)) : (F(P, V, 1), F(b, V, 1), F(I, V, 0.5), F(I, V, 0.5), F(b, V, 1), F(E, V, 1)), fe = !0;
               break;
           }
         } else
-          S();
+          A();
       } else
-        S();
-      !P && Y === f - 1 && G(e[0], R, T, se, !0, X), X = V, K = I, y.copy(x), E.copy(M);
+        A();
+      !C && $ === p - 1 && j(e[0], M, _, se, !0, X), X = V, K = I, g.copy(T), v.copy(E);
     }
-    if (!P)
-      G(I, g, A, se, !1, V);
-    else if (ne && i) {
-      let Y = w, te = d;
-      H !== se && (Y = d, te = w), se ? (he || H) && (te.toArray(i, 0 * 3), te.toArray(i, 3 * 3), he && Y.toArray(i, 1 * 3)) : (he || !H) && (te.toArray(i, 1 * 3), te.toArray(i, 3 * 3), he && Y.toArray(i, 0 * 3));
+    if (!C)
+      j(I, w, P, se, !1, V);
+    else if (te && i) {
+      let $ = b, ne = m;
+      H !== se && ($ = m, ne = b), se ? (fe || H) && (ne.toArray(i, 0 * 3), ne.toArray(i, 3 * 3), fe && $.toArray(i, 1 * 3)) : (fe || !H) && (ne.toArray(i, 1 * 3), ne.toArray(i, 3 * 3), fe && $.toArray(i, 0 * 3));
     }
     return k;
-    function J(Y, te, O) {
-      return O.subVectors(te, Y), O.set(-O.y, O.x).normalize();
+    function ee($, ne, L) {
+      return L.subVectors(ne, $), L.set(-L.y, L.x).normalize();
     }
-    function F(Y, te, O) {
-      i && (i[b] = Y.x, i[b + 1] = Y.y, i[b + 2] = 0, r && (r[b] = 0, r[b + 1] = 0, r[b + 2] = 1), b += 3, a && (a[U] = te, a[U + 1] = O, U += 2)), k += 3;
+    function F($, ne, L) {
+      i && (i[S] = $.x, i[S + 1] = $.y, i[S + 2] = 0, r && (r[S] = 0, r[S + 1] = 0, r[S + 2] = 1), S += 3, a && (a[U] = ne, a[U + 1] = L, U += 2)), k += 3;
     }
-    function B(Y, te, O, L, re) {
-      c.copy(te).sub(Y).normalize(), u.copy(O).sub(Y).normalize();
-      let ce = Math.PI;
+    function N($, ne, L, O, re) {
+      c.copy(ne).sub($).normalize(), u.copy(L).sub($).normalize();
+      let de = Math.PI;
       const be = c.dot(u);
-      Math.abs(be) < 1 && (ce = Math.abs(Math.acos(be))), ce /= n, h.copy(te);
-      for (let Me = 0, Se = n - 1; Me < Se; Me++)
-        m.copy(h).rotateAround(Y, ce), F(h, L, re), F(m, L, re), F(Y, L, 0.5), h.copy(m);
-      F(m, L, re), F(O, L, re), F(Y, L, 0.5);
+      Math.abs(be) < 1 && (de = Math.abs(Math.acos(be))), de /= n, h.copy(ne);
+      for (let Se = 0, Me = n - 1; Se < Me; Se++)
+        f.copy(h).rotateAround($, de), F(h, O, re), F(f, O, re), F($, O, 0.5), h.copy(f);
+      F(f, O, re), F(L, O, re), F($, O, 0.5);
     }
-    function S() {
-      F(E, X, 1), F(y, X, 0), F(g, V, 0), F(E, X, 1), F(g, V, 1), F(A, V, 0);
+    function A() {
+      F(v, X, 1), F(g, X, 0), F(w, V, 0), F(v, X, 1), F(w, V, 1), F(P, V, 0);
     }
-    function C(Y, te, O) {
-      te ? Y ? (F(E, X, 1), F(y, X, 0), F(g, V, 0), F(E, X, 1), F(g, V, 0), F(d, V, 1), F(g, O, 0), F(x, O, 0), F(d, O, 0.5)) : (F(E, X, 1), F(y, X, 0), F(A, V, 1), F(y, X, 0), F(d, V, 0), F(A, V, 1), F(A, O, 1), F(M, O, 0), F(d, O, 0.5)) : Y ? (F(g, O, 0), F(x, O, 0), F(I, O, 0.5)) : (F(A, O, 1), F(M, O, 0), F(I, O, 0.5));
+    function R($, ne, L) {
+      ne ? $ ? (F(v, X, 1), F(g, X, 0), F(w, V, 0), F(v, X, 1), F(w, V, 0), F(m, V, 1), F(w, L, 0), F(T, L, 0), F(m, L, 0.5)) : (F(v, X, 1), F(g, X, 0), F(P, V, 1), F(g, X, 0), F(m, V, 0), F(P, V, 1), F(P, L, 1), F(E, L, 0), F(m, L, 0.5)) : $ ? (F(w, L, 0), F(T, L, 0), F(I, L, 0.5)) : (F(P, L, 1), F(E, L, 0), F(I, L, 0.5));
     }
-    function D(Y, te) {
-      te && (Y ? (F(E, X, 1), F(y, X, 0), F(g, V, 0), F(E, X, 1), F(g, V, 0), F(d, V, 1), F(g, X, 0), F(I, V, 0.5), F(d, V, 1), F(I, V, 0.5), F(x, X, 0), F(d, V, 1)) : (F(E, X, 1), F(y, X, 0), F(A, V, 1), F(y, X, 0), F(d, V, 0), F(A, V, 1), F(A, X, 1), F(d, V, 0), F(I, V, 0.5), F(I, V, 0.5), F(d, V, 0), F(M, X, 1)));
+    function D($, ne) {
+      ne && ($ ? (F(v, X, 1), F(g, X, 0), F(w, V, 0), F(v, X, 1), F(w, V, 0), F(m, V, 1), F(w, X, 0), F(I, V, 0.5), F(m, V, 1), F(I, V, 0.5), F(T, X, 0), F(m, V, 1)) : (F(v, X, 1), F(g, X, 0), F(P, V, 1), F(g, X, 0), F(m, V, 0), F(P, V, 1), F(P, X, 1), F(m, V, 0), F(I, V, 0.5), F(I, V, 0.5), F(m, V, 0), F(E, X, 1)));
     }
-    function G(Y, te, O, L, re, ce) {
+    function j($, ne, L, O, re, de) {
       switch (t.strokeLineCap) {
         case "round":
-          re ? B(Y, O, te, ce, 0.5) : B(Y, te, O, ce, 0.5);
+          re ? N($, L, ne, de, 0.5) : N($, ne, L, de, 0.5);
           break;
         case "square":
           if (re)
-            c.subVectors(te, Y), u.set(c.y, -c.x), h.addVectors(c, u).add(Y), m.subVectors(u, c).add(Y), L ? (h.toArray(i, 1 * 3), m.toArray(i, 0 * 3), m.toArray(i, 3 * 3)) : (h.toArray(i, 1 * 3), h.toArray(i, 3 * 3), m.toArray(i, 0 * 3));
+            c.subVectors(ne, $), u.set(c.y, -c.x), h.addVectors(c, u).add($), f.subVectors(u, c).add($), O ? (h.toArray(i, 1 * 3), f.toArray(i, 0 * 3), f.toArray(i, 3 * 3)) : (h.toArray(i, 1 * 3), h.toArray(i, 3 * 3), f.toArray(i, 0 * 3));
           else {
-            c.subVectors(O, Y), u.set(c.y, -c.x), h.addVectors(c, u).add(Y), m.subVectors(u, c).add(Y);
+            c.subVectors(L, $), u.set(c.y, -c.x), h.addVectors(c, u).add($), f.subVectors(u, c).add($);
             const be = i.length;
-            L ? (h.toArray(i, be - 1 * 3), m.toArray(i, be - 2 * 3), m.toArray(i, be - 4 * 3)) : (h.toArray(i, be - 2 * 3), m.toArray(i, be - 1 * 3), m.toArray(i, be - 4 * 3));
+            O ? (h.toArray(i, be - 1 * 3), f.toArray(i, be - 2 * 3), f.toArray(i, be - 4 * 3)) : (h.toArray(i, be - 2 * 3), f.toArray(i, be - 1 * 3), f.toArray(i, be - 4 * 3));
           }
           break;
       }
     }
-    function $(Y) {
-      let te = !1;
-      for (let L = 1, re = Y.length - 1; L < re; L++)
-        if (Y[L].distanceTo(Y[L + 1]) < s) {
-          te = !0;
+    function Z($) {
+      let ne = !1;
+      for (let O = 1, re = $.length - 1; O < re; O++)
+        if ($[O].distanceTo($[O + 1]) < s) {
+          ne = !0;
           break;
         }
-      if (!te)
-        return Y;
-      const O = [];
-      O.push(Y[0]);
-      for (let L = 1, re = Y.length - 1; L < re; L++)
-        Y[L].distanceTo(Y[L + 1]) >= s && O.push(Y[L]);
-      return O.push(Y[Y.length - 1]), O;
+      if (!ne)
+        return $;
+      const L = [];
+      L.push($[0]);
+      for (let O = 1, re = $.length - 1; O < re; O++)
+        $[O].distanceTo($[O + 1]) >= s && L.push($[O]);
+      return L.push($[$.length - 1]), L;
     }
   }
 }
-const xi = /* @__PURE__ */ new WeakMap();
-class hh extends cs {
+const Mi = /* @__PURE__ */ new WeakMap();
+class xh extends vs {
   constructor(e) {
     super(e), this.decoderPath = "", this.decoderConfig = {}, this.decoderBinary = null, this.decoderPending = null, this.workerLimit = 4, this.workerPool = [], this.workerNextTaskID = 1, this.workerSourceURL = "", this.defaultAttributeIDs = {
       position: "POSITION",
@@ -6883,7 +6920,7 @@ class hh extends cs {
     return this.workerLimit = e, this;
   }
   load(e, t, n, s) {
-    const i = new Tn(this.manager);
+    const i = new Sn(this.manager);
     i.setPath(this.path), i.setResponseType("arraybuffer"), i.setRequestHeader(this.requestHeader), i.setWithCredentials(this.withCredentials), i.load(
       e,
       (r) => {
@@ -6913,8 +6950,8 @@ class hh extends cs {
       c.BYTES_PER_ELEMENT !== void 0 && (t.attributeTypes[l] = c.name);
     }
     const n = JSON.stringify(t);
-    if (xi.has(e)) {
-      const l = xi.get(e);
+    if (Mi.has(e)) {
+      const l = Mi.get(e);
       if (l.key === n)
         return l.promise;
       if (e.byteLength === 0)
@@ -6928,13 +6965,13 @@ class hh extends cs {
     }))).then((l) => this._createGeometry(l.geometry));
     return a.catch(() => !0).then(() => {
       s && i && this._releaseTask(s, i);
-    }), xi.set(e, {
+    }), Mi.set(e, {
       key: n,
       promise: a
     }), a;
   }
   _createGeometry(e) {
-    const t = new rt();
+    const t = new at();
     e.index && t.setIndex(new pt(e.index.array, 1));
     for (let n = 0; n < e.attributes.length; n++) {
       const s = e.attributes[n], i = s.name, r = s.array, a = s.itemSize;
@@ -6943,7 +6980,7 @@ class hh extends cs {
     return t;
   }
   _loadLibrary(e, t) {
-    const n = new Tn(this.manager);
+    const n = new Sn(this.manager);
     return n.setPath(this.decoderPath), n.setResponseType(t), n.setWithCredentials(this.withCredentials), new Promise((s, i) => {
       n.load(e, s, void 0, i);
     });
@@ -6958,7 +6995,7 @@ class hh extends cs {
     return e ? t.push(this._loadLibrary("draco_decoder.js", "text")) : (t.push(this._loadLibrary("draco_wasm_wrapper.js", "text")), t.push(this._loadLibrary("draco_decoder.wasm", "arraybuffer"))), this.decoderPending = Promise.all(t).then((n) => {
       const s = n[0];
       e || (this.decoderConfig.wasmBinary = n[1]);
-      const i = fh.toString(), r = [
+      const i = wh.toString(), r = [
         "/* draco decoder */",
         s,
         "",
@@ -7009,7 +7046,7 @@ class hh extends cs {
     return this.workerPool.length = 0, this;
   }
 }
-function fh() {
+function wh() {
   let o, e;
   onmessage = function(r) {
     const a = r.data;
@@ -7024,15 +7061,15 @@ function fh() {
       case "decode":
         const l = a.buffer, c = a.taskConfig;
         e.then((u) => {
-          const h = u.draco, m = new h.Decoder(), p = new h.DecoderBuffer();
-          p.Init(new Int8Array(l), l.byteLength);
+          const h = u.draco, f = new h.Decoder(), d = new h.DecoderBuffer();
+          d.Init(new Int8Array(l), l.byteLength);
           try {
-            const v = t(h, m, p, c), _ = v.attributes.map((y) => y.array.buffer);
-            v.index && _.push(v.index.array.buffer), self.postMessage({ type: "decode", id: a.id, geometry: v }, _);
-          } catch (v) {
-            console.error(v), self.postMessage({ type: "error", id: a.id, error: v.message });
+            const y = t(h, f, d, c), x = y.attributes.map((g) => g.array.buffer);
+            y.index && x.push(y.index.array.buffer), self.postMessage({ type: "decode", id: a.id, geometry: y }, x);
+          } catch (y) {
+            console.error(y), self.postMessage({ type: "error", id: a.id, error: y.message });
           } finally {
-            h.destroy(p), h.destroy(m);
+            h.destroy(d), h.destroy(f);
           }
         });
         break;
@@ -7040,45 +7077,45 @@ function fh() {
   };
   function t(r, a, l, c) {
     const u = c.attributeIDs, h = c.attributeTypes;
-    let m, p;
-    const v = a.GetEncodedGeometryType(l);
-    if (v === r.TRIANGULAR_MESH)
-      m = new r.Mesh(), p = a.DecodeBufferToMesh(l, m);
-    else if (v === r.POINT_CLOUD)
-      m = new r.PointCloud(), p = a.DecodeBufferToPointCloud(l, m);
+    let f, d;
+    const y = a.GetEncodedGeometryType(l);
+    if (y === r.TRIANGULAR_MESH)
+      f = new r.Mesh(), d = a.DecodeBufferToMesh(l, f);
+    else if (y === r.POINT_CLOUD)
+      f = new r.PointCloud(), d = a.DecodeBufferToPointCloud(l, f);
     else
       throw new Error("THREE.DRACOLoader: Unexpected geometry type.");
-    if (!p.ok() || m.ptr === 0)
-      throw new Error("THREE.DRACOLoader: Decoding failed: " + p.error_msg());
-    const _ = { index: null, attributes: [] };
-    for (const y in u) {
-      const E = self[h[y]];
-      let R, T;
+    if (!d.ok() || f.ptr === 0)
+      throw new Error("THREE.DRACOLoader: Decoding failed: " + d.error_msg());
+    const x = { index: null, attributes: [] };
+    for (const g in u) {
+      const v = self[h[g]];
+      let M, _;
       if (c.useUniqueIDs)
-        T = u[y], R = a.GetAttributeByUniqueId(m, T);
+        _ = u[g], M = a.GetAttributeByUniqueId(f, _);
       else {
-        if (T = a.GetAttributeId(m, r[u[y]]), T === -1)
+        if (_ = a.GetAttributeId(f, r[u[g]]), _ === -1)
           continue;
-        R = a.GetAttribute(m, T);
+        M = a.GetAttribute(f, _);
       }
-      _.attributes.push(s(r, a, m, y, E, R));
+      x.attributes.push(s(r, a, f, g, v, M));
     }
-    return v === r.TRIANGULAR_MESH && (_.index = n(r, a, m)), r.destroy(m), _;
+    return y === r.TRIANGULAR_MESH && (x.index = n(r, a, f)), r.destroy(f), x;
   }
   function n(r, a, l) {
-    const u = l.num_faces() * 3, h = u * 4, m = r._malloc(h);
-    a.GetTrianglesUInt32Array(l, h, m);
-    const p = new Uint32Array(r.HEAPF32.buffer, m, u).slice();
-    return r._free(m), { array: p, itemSize: 1 };
+    const u = l.num_faces() * 3, h = u * 4, f = r._malloc(h);
+    a.GetTrianglesUInt32Array(l, h, f);
+    const d = new Uint32Array(r.HEAPF32.buffer, f, u).slice();
+    return r._free(f), { array: d, itemSize: 1 };
   }
   function s(r, a, l, c, u, h) {
-    const m = h.num_components(), v = l.num_points() * m, _ = v * u.BYTES_PER_ELEMENT, y = i(r, u), E = r._malloc(_);
-    a.GetAttributeDataArrayForAllPoints(l, h, y, _, E);
-    const R = new u(r.HEAPF32.buffer, E, v).slice();
-    return r._free(E), {
+    const f = h.num_components(), y = l.num_points() * f, x = y * u.BYTES_PER_ELEMENT, g = i(r, u), v = r._malloc(x);
+    a.GetAttributeDataArrayForAllPoints(l, h, g, x, v);
+    const M = new u(r.HEAPF32.buffer, v, y).slice();
+    return r._free(v), {
       name: c,
-      array: R,
-      itemSize: m
+      array: M,
+      itemSize: f
     };
   }
   function i(r, a) {
@@ -7100,14 +7137,14 @@ function fh() {
     }
   }
 }
-class Ra extends Ie {
+class ka extends De {
   constructor(e, t) {
-    const n = [1, 1, 0, -1, 1, 0, -1, -1, 0, 1, -1, 0, 1, 1, 0], s = new rt();
+    const n = [1, 1, 0, -1, 1, 0, -1, -1, 0, 1, -1, 0, 1, 1, 0], s = new at();
     s.setAttribute("position", new it(n, 3)), s.computeBoundingSphere();
-    const i = new qs({ fog: !1 });
+    const i = new si({ fog: !1 });
     super(s, i), this.light = e, this.color = t, this.type = "RectAreaLightHelper";
-    const r = [1, 1, 0, -1, 1, 0, -1, -1, 0, 1, 1, 0, -1, -1, 0, 1, -1, 0], a = new rt();
-    a.setAttribute("position", new it(r, 3)), a.computeBoundingSphere(), this.add(new ae(a, new Gt({ side: ta, fog: !1 })));
+    const r = [1, 1, 0, -1, 1, 0, -1, -1, 0, 1, 1, 0, -1, -1, 0, 1, -1, 0], a = new at();
+    a.setAttribute("position", new it(r, 3)), a.computeBoundingSphere(), this.add(new ae(a, new Yt({ side: la, fog: !1 })));
   }
   updateMatrixWorld() {
     if (this.scale.set(0.5 * this.light.width, 0.5 * this.light.height, 1), this.color !== void 0)
@@ -7123,7 +7160,7 @@ class Ra extends Ie {
     this.geometry.dispose(), this.material.dispose(), this.children[0].geometry.dispose(), this.children[0].material.dispose();
   }
 }
-const dh = ["args", "center"], Lm = /* @__PURE__ */ pe({
+const Th = ["args", "center"], Jm = /* @__PURE__ */ pe({
   __name: "Text3D",
   props: {
     font: {},
@@ -7149,62 +7186,62 @@ const dh = ["args", "center"], Lm = /* @__PURE__ */ pe({
       size: c,
       height: u,
       curveSegments: h,
-      bevelEnabled: m,
-      bevelThickness: p,
-      bevelSize: v,
-      bevelOffset: _,
-      bevelSegments: y
-    } = Fe(s), { extend: E } = je();
-    E({ TextGeometry: Vr });
-    const R = new lh(), T = ra(), g = Ne(() => {
-      var d;
-      return a != null && a.value ? a.value : T.default ? (d = T.default()[0].children) == null ? void 0 : d.trim() : l.value ? "" : "TresJS";
-    }), A = xe();
+      bevelEnabled: f,
+      bevelThickness: d,
+      bevelSize: y,
+      bevelOffset: x,
+      bevelSegments: g
+    } = Oe(s), { extend: v } = Ue();
+    v({ TextGeometry: Kr });
+    const M = new vh(), _ = gr(), w = Ne(() => {
+      var m;
+      return a != null && a.value ? a.value : _.default ? (m = _.default()[0].children) == null ? void 0 : m.trim() : l.value ? "" : "TresJS";
+    }), P = me();
     e({
-      value: A
+      value: P
     });
-    const x = ([t, n] = fs(() => new Promise((d, w) => {
+    const T = ([t, n] = Xn(() => new Promise((m, b) => {
       try {
-        typeof r.value == "string" ? R.load(r.value, (f) => {
-          d(f);
-        }) : d(r.value);
-      } catch (f) {
-        w(console.error("cientos", f));
+        typeof r.value == "string" ? M.load(r.value, (p) => {
+          m(p);
+        }) : m(r.value);
+      } catch (p) {
+        b(console.error("cientos", p));
       }
-    })), t = await t, n(), t), M = Ne(() => ({
-      font: x,
-      size: Kt(c),
-      height: Kt(u),
-      curveSegments: Kt(h),
-      bevelEnabled: Kt(m),
-      bevelThickness: Kt(p),
-      bevelSize: Kt(v),
-      bevelOffset: Kt(_),
-      bevelSegments: Kt(y)
+    })), t = await t, n(), t), E = Ne(() => ({
+      font: T,
+      size: Jt(c),
+      height: Jt(u),
+      curveSegments: Jt(h),
+      bevelEnabled: Jt(f),
+      bevelThickness: Jt(d),
+      bevelSize: Jt(y),
+      bevelOffset: Jt(x),
+      bevelSegments: Jt(g)
     }));
-    return ft(() => {
-      A.value && l.value && (A.value.geometry.dispose(), A.value.geometry = new Vr(g.value, M.value), i.value && A.value.geometry.center());
-    }), (d, w) => z(r) ? (fe(), de("TresMesh", {
+    return lt(() => {
+      P.value && l.value && (P.value.geometry.dispose(), P.value.geometry = new Kr(w.value, E.value), i.value && P.value.geometry.center());
+    }), (m, b) => B(r) ? (le(), ce("TresMesh", {
       key: 0,
       ref_key: "text3DRef",
-      ref: A
+      ref: P
     }, [
-      g.value ? (fe(), de("TresTextGeometry", {
+      w.value ? (le(), ce("TresTextGeometry", {
         key: 0,
-        args: [g.value, M.value],
-        center: z(i)
-      }, null, 8, dh)) : Wt("", !0),
-      $e(d.$slots, "default")
-    ], 512)) : Wt("", !0);
+        args: [w.value, E.value],
+        center: B(i)
+      }, null, 8, Th)) : Ut("", !0),
+      Ve(m.$slots, "default")
+    ], 512)) : Ut("", !0);
   }
 });
-function Om(o, e) {
-  const t = ue(e), n = new Al(t.value), s = Ql({});
+function eg(o, e) {
+  const t = ue(e), n = new Ol(t.value), s = ac({});
   o.forEach((r) => {
     const a = n.clipAction(r, t.value);
     s[r.name] = a;
   });
-  const { onLoop: i } = Ke();
+  const { onLoop: i } = Xe();
   return i(({ delta: r }) => {
     n.update(r);
   }), {
@@ -7212,7 +7249,7 @@ function Om(o, e) {
     mixer: n
   };
 }
-const Fm = /* @__PURE__ */ pe({
+const tg = /* @__PURE__ */ pe({
   __name: "Levioso",
   props: {
     speed: { default: 1 },
@@ -7221,42 +7258,42 @@ const Fm = /* @__PURE__ */ pe({
     range: { default: () => [-0.1, 0.1] }
   },
   setup(o, { expose: e }) {
-    const t = o, n = xe();
+    const t = o, n = me();
     e({
       value: n
     });
     {
-      const l = Math.random() * 1e4, { onLoop: c } = Ke();
+      const l = Math.random() * 1e4, { onLoop: c } = Xe();
       let u = l;
       c(({ delta: h }) => {
         if (!n.value)
           return;
         u += h * t.speed;
-        const m = u * 0.25, p = n.value;
-        p.rotation.x = Math.cos(m) * 0.125 * t.rotationFactor, p.rotation.y = Math.sin(m) * 0.125 * t.rotationFactor, p.rotation.z = Math.sin(m) * 0.05 * t.rotationFactor, p.position.y = We.mapLinear(Math.sin(m), -1, 1, t.range[0], t.range[1]) * t.floatFactor;
+        const f = u * 0.25, d = n.value;
+        d.rotation.x = Math.cos(f) * 0.125 * t.rotationFactor, d.rotation.y = Math.sin(f) * 0.125 * t.rotationFactor, d.rotation.z = Math.sin(f) * 0.05 * t.rotationFactor, d.position.y = Ze.mapLinear(Math.sin(f), -1, 1, t.range[0], t.range[1]) * t.floatFactor;
       });
     }
-    return (s, i) => (fe(), de("TresGroup", Ye(s.$attrs, {
+    return (s, i) => (le(), ce("TresGroup", Ye(s.$attrs, {
       ref_key: "groupRef",
       ref: n
     }), [
-      $e(s.$slots, "default")
+      Ve(s.$slots, "default")
     ], 16));
   }
 });
-class os extends ae {
+class ps extends ae {
   constructor(e, t = {}) {
-    super(e), this.isReflector = !0, this.type = "Reflector", this.camera = new Mt();
-    const n = this, s = t.color !== void 0 ? new Be(t.color) : new Be(8355711), i = t.textureWidth || 512, r = t.textureHeight || 512, a = t.clipBias || 0, l = t.shader || os.ReflectorShader, c = t.multisample !== void 0 ? t.multisample : 4, u = new lr(), h = new ee(), m = new ee(), p = new ee(), v = new De(), _ = new ee(0, 0, -1), y = new ht(), E = new ee(), R = new ee(), T = new ht(), g = new De(), A = this.camera, x = new bn(i, r, { samples: c, type: un }), M = new Xt({
+    super(e), this.isReflector = !0, this.type = "Reflector", this.camera = new wt();
+    const n = this, s = t.color !== void 0 ? new Re(t.color) : new Re(8355711), i = t.textureWidth || 512, r = t.textureHeight || 512, a = t.clipBias || 0, l = t.shader || ps.ReflectorShader, c = t.multisample !== void 0 ? t.multisample : 4, u = new ii(), h = new q(), f = new q(), d = new q(), y = new Pe(), x = new q(0, 0, -1), g = new rt(), v = new q(), M = new q(), _ = new rt(), w = new Pe(), P = this.camera, T = new pn(i, r, { samples: c, type: Zt }), E = new Pt({
       name: l.name !== void 0 ? l.name : "unspecified",
-      uniforms: Js.clone(l.uniforms),
+      uniforms: Yn.clone(l.uniforms),
       fragmentShader: l.fragmentShader,
       vertexShader: l.vertexShader
     });
-    M.uniforms.tDiffuse.value = x.texture, M.uniforms.color.value = s, M.uniforms.textureMatrix.value = g, this.material = M, this.onBeforeRender = function(d, w, f) {
-      if (m.setFromMatrixPosition(n.matrixWorld), p.setFromMatrixPosition(f.matrixWorld), v.extractRotation(n.matrixWorld), h.set(0, 0, 1), h.applyMatrix4(v), E.subVectors(m, p), E.dot(h) > 0)
+    E.uniforms.tDiffuse.value = T.texture, E.uniforms.color.value = s, E.uniforms.textureMatrix.value = w, this.material = E, this.onBeforeRender = function(m, b, p) {
+      if (f.setFromMatrixPosition(n.matrixWorld), d.setFromMatrixPosition(p.matrixWorld), y.extractRotation(n.matrixWorld), h.set(0, 0, 1), h.applyMatrix4(y), v.subVectors(f, d), v.dot(h) > 0)
         return;
-      E.reflect(h).negate(), E.add(m), v.extractRotation(f.matrixWorld), _.set(0, 0, -1), _.applyMatrix4(v), _.add(p), R.subVectors(m, _), R.reflect(h).negate(), R.add(m), A.position.copy(E), A.up.set(0, 1, 0), A.up.applyMatrix4(v), A.up.reflect(h), A.lookAt(R), A.far = f.far, A.updateMatrixWorld(), A.projectionMatrix.copy(f.projectionMatrix), g.set(
+      v.reflect(h).negate(), v.add(f), y.extractRotation(p.matrixWorld), x.set(0, 0, -1), x.applyMatrix4(y), x.add(d), M.subVectors(f, x), M.reflect(h).negate(), M.add(f), P.position.copy(v), P.up.set(0, 1, 0), P.up.applyMatrix4(y), P.up.reflect(h), P.lookAt(M), P.far = p.far, P.updateMatrixWorld(), P.projectionMatrix.copy(p.projectionMatrix), w.set(
         0.5,
         0,
         0,
@@ -7273,21 +7310,21 @@ class os extends ae {
         0,
         0,
         1
-      ), g.multiply(A.projectionMatrix), g.multiply(A.matrixWorldInverse), g.multiply(n.matrixWorld), u.setFromNormalAndCoplanarPoint(h, m), u.applyMatrix4(A.matrixWorldInverse), y.set(u.normal.x, u.normal.y, u.normal.z, u.constant);
-      const P = A.projectionMatrix;
-      T.x = (Math.sign(y.x) + P.elements[8]) / P.elements[0], T.y = (Math.sign(y.y) + P.elements[9]) / P.elements[5], T.z = -1, T.w = (1 + P.elements[10]) / P.elements[14], y.multiplyScalar(2 / y.dot(T)), P.elements[2] = y.x, P.elements[6] = y.y, P.elements[10] = y.z + 1 - a, P.elements[14] = y.w, n.visible = !1;
-      const I = d.getRenderTarget(), K = d.xr.enabled, N = d.shadowMap.autoUpdate;
-      d.xr.enabled = !1, d.shadowMap.autoUpdate = !1, d.setRenderTarget(x), d.state.buffers.depth.setMask(!0), d.autoClear === !1 && d.clear(), d.render(w, A), d.xr.enabled = K, d.shadowMap.autoUpdate = N, d.setRenderTarget(I);
-      const Z = f.viewport;
-      Z !== void 0 && d.state.viewport(Z), n.visible = !0;
+      ), w.multiply(P.projectionMatrix), w.multiply(P.matrixWorldInverse), w.multiply(n.matrixWorld), u.setFromNormalAndCoplanarPoint(h, f), u.applyMatrix4(P.matrixWorldInverse), g.set(u.normal.x, u.normal.y, u.normal.z, u.constant);
+      const C = P.projectionMatrix;
+      _.x = (Math.sign(g.x) + C.elements[8]) / C.elements[0], _.y = (Math.sign(g.y) + C.elements[9]) / C.elements[5], _.z = -1, _.w = (1 + C.elements[10]) / C.elements[14], g.multiplyScalar(2 / g.dot(_)), C.elements[2] = g.x, C.elements[6] = g.y, C.elements[10] = g.z + 1 - a, C.elements[14] = g.w, n.visible = !1;
+      const I = m.getRenderTarget(), K = m.xr.enabled, z = m.shadowMap.autoUpdate;
+      m.xr.enabled = !1, m.shadowMap.autoUpdate = !1, m.setRenderTarget(T), m.state.buffers.depth.setMask(!0), m.autoClear === !1 && m.clear(), m.render(b, P), m.xr.enabled = K, m.shadowMap.autoUpdate = z, m.setRenderTarget(I);
+      const Y = p.viewport;
+      Y !== void 0 && m.state.viewport(Y), n.visible = !0;
     }, this.getRenderTarget = function() {
-      return x;
+      return T;
     }, this.dispose = function() {
-      x.dispose(), n.material.dispose();
+      T.dispose(), n.material.dispose();
     };
   }
 }
-os.ReflectorShader = {
+ps.ReflectorShader = {
   name: "ReflectorShader",
   uniforms: {
     color: {
@@ -7353,7 +7390,7 @@ os.ReflectorShader = {
 		}`
   )
 };
-const ph = ["args", "material-uniforms-color-value"], mh = /* @__PURE__ */ Te("TresPlaneGeometry", { args: [5, 5] }, null, -1), km = /* @__PURE__ */ pe({
+const bh = ["args", "material-uniforms-color-value"], Eh = /* @__PURE__ */ ye("TresPlaneGeometry", { args: [5, 5] }, null, -1), ng = /* @__PURE__ */ pe({
   __name: "Reflector",
   props: {
     color: { default: "#333" },
@@ -7361,37 +7398,37 @@ const ph = ["args", "material-uniforms-color-value"], mh = /* @__PURE__ */ Te("T
     textureHeight: { default: 512 },
     clipBias: { default: 0 },
     multisample: { default: 4 },
-    shader: { default: os.ReflectorShader }
+    shader: { default: ps.ReflectorShader }
   },
   setup(o, { expose: e }) {
-    const t = o, { extend: n } = je(), s = xe();
-    n({ Reflector: os });
-    const { color: i, textureWidth: r, textureHeight: a, clipBias: l, multisample: c, shader: u } = Fe(t);
+    const t = o, { extend: n } = Ue(), s = me();
+    n({ Reflector: ps });
+    const { color: i, textureWidth: r, textureHeight: a, clipBias: l, multisample: c, shader: u } = Oe(t);
     return e({
       reflectorRef: s
-    }), (h, m) => (fe(), de("TresReflector", {
+    }), (h, f) => (le(), ce("TresReflector", {
       ref_key: "reflectorRef",
       ref: s,
-      args: [void 0, { textureWidth: z(r), textureHeight: z(a), clipBias: z(l), multisample: z(c), shader: z(u) }],
-      "material-uniforms-color-value": z(i)
+      args: [void 0, { textureWidth: B(r), textureHeight: B(a), clipBias: B(l), multisample: B(c), shader: B(u) }],
+      "material-uniforms-color-value": B(i)
     }, [
-      $e(h.$slots, "default", {}, () => [
-        mh
+      Ve(h.$slots, "default", {}, () => [
+        Eh
       ])
-    ], 8, ph));
+    ], 8, bh));
   }
 });
-function Ca(o) {
-  return Jl() ? (ec(o), !0) : !1;
+function Ba(o) {
+  return lc() ? (cc(o), !0) : !1;
 }
 function dt(o) {
-  return typeof o == "function" ? o() : z(o);
+  return typeof o == "function" ? o() : B(o);
 }
-const gh = typeof window < "u" && typeof document < "u";
+const Sh = typeof window < "u" && typeof document < "u";
 typeof WorkerGlobalScope < "u" && globalThis instanceof WorkerGlobalScope;
-const yh = Object.prototype.toString, vh = (o) => yh.call(o) === "[object Object]", En = () => {
+const Mh = Object.prototype.toString, Ah = (o) => Mh.call(o) === "[object Object]", Mn = () => {
 };
-function pr(o, e) {
+function xr(o, e) {
   function t(...n) {
     return new Promise((s, i) => {
       Promise.resolve(o(() => e.apply(this, n), { fn: e, thisArg: this, args: n })).then(s).catch(i);
@@ -7399,11 +7436,11 @@ function pr(o, e) {
   }
   return t;
 }
-const _h = (o) => o();
-function xh(o, e = {}) {
-  let t, n, s = En;
+const Ph = (o) => o();
+function Ch(o, e = {}) {
+  let t, n, s = Mn;
   const i = (a) => {
-    clearTimeout(a), s(), s = En;
+    clearTimeout(a), s(), s = Mn;
   };
   return (a) => {
     const l = dt(o), c = dt(e.maxWait);
@@ -7416,144 +7453,145 @@ function xh(o, e = {}) {
     });
   };
 }
-function Ia(o, e = !0, t = !0, n = !1) {
-  let s = 0, i, r = !0, a = En, l;
-  const c = () => {
-    i && (clearTimeout(i), i = void 0, a(), a = En);
+function Ua(...o) {
+  let e = 0, t, n = !0, s = Mn, i, r, a, l, c;
+  !Qs(o[0]) && typeof o[0] == "object" ? { delay: r, trailing: a = !0, leading: l = !0, rejectOnCancel: c = !1 } = o[0] : [r, a = !0, l = !0, c = !1] = o;
+  const u = () => {
+    t && (clearTimeout(t), t = void 0, s(), s = Mn);
   };
-  return (h) => {
-    const m = dt(o), p = Date.now() - s, v = () => l = h();
-    return c(), m <= 0 ? (s = Date.now(), v()) : (p > m && (t || !r) ? (s = Date.now(), v()) : e && (l = new Promise((_, y) => {
-      a = n ? y : _, i = setTimeout(() => {
-        s = Date.now(), r = !0, _(v()), c();
-      }, Math.max(0, m - p));
-    })), !t && !i && (i = setTimeout(() => r = !0, m)), r = !1, l);
+  return (f) => {
+    const d = dt(r), y = Date.now() - e, x = () => i = f();
+    return u(), d <= 0 ? (e = Date.now(), x()) : (y > d && (l || !n) ? (e = Date.now(), x()) : a && (i = new Promise((g, v) => {
+      s = c ? v : g, t = setTimeout(() => {
+        e = Date.now(), n = !0, g(x()), u();
+      }, Math.max(0, d - y));
+    })), !l && !t && (t = setTimeout(() => n = !0, d)), n = !1, i);
   };
 }
-function wh(o) {
-  return o || oa();
+function Rh(o) {
+  return o || fa();
 }
-function Th(o, e = 200, t = {}) {
-  return pr(
-    xh(e, t),
+function Ih(o, e = 200, t = {}) {
+  return xr(
+    Ch(e, t),
     o
   );
 }
-function bh(o, e = 200, t = !1, n = !0, s = !1) {
-  return pr(
-    Ia(e, t, n, s),
+function Dh(o, e = 200, t = !1, n = !0, s = !1) {
+  return xr(
+    Ua(e, t, n, s),
     o
   );
 }
-function Eh(o, e, t = {}) {
+function Oh(o, e, t = {}) {
   const {
-    eventFilter: n = _h,
+    eventFilter: n = Ph,
     ...s
   } = t;
-  return we(
+  return Te(
     o,
-    pr(
+    xr(
       n,
       e
     ),
     s
   );
 }
-function Da(o, e = !0, t) {
-  wh() ? ds(o, t) : e ? o() : tc(o);
+function Na(o, e = !0, t) {
+  Rh() ? $n(o, t) : e ? o() : ha(o);
 }
-function Mh(o, e, t = {}) {
+function Lh(o, e, t = {}) {
   const {
     throttle: n = 0,
     trailing: s = !0,
     leading: i = !0,
     ...r
   } = t;
-  return Eh(
+  return Oh(
     o,
     e,
     {
       ...r,
-      eventFilter: Ia(n, s, i)
+      eventFilter: Ua(n, s, i)
     }
   );
 }
-function Sh(o) {
+function za(o) {
   var e;
   const t = dt(o);
   return (e = t == null ? void 0 : t.$el) != null ? e : t;
 }
-const Mn = gh ? window : void 0;
-function Ve(...o) {
+const An = Sh ? window : void 0;
+function Ge(...o) {
   let e, t, n, s;
-  if (typeof o[0] == "string" || Array.isArray(o[0]) ? ([t, n, s] = o, e = Mn) : [e, t, n, s] = o, !e)
-    return En;
+  if (typeof o[0] == "string" || Array.isArray(o[0]) ? ([t, n, s] = o, e = An) : [e, t, n, s] = o, !e)
+    return Mn;
   Array.isArray(t) || (t = [t]), Array.isArray(n) || (n = [n]);
   const i = [], r = () => {
     i.forEach((u) => u()), i.length = 0;
-  }, a = (u, h, m, p) => (u.addEventListener(h, m, p), () => u.removeEventListener(h, m, p)), l = we(
-    () => [Sh(e), dt(s)],
+  }, a = (u, h, f, d) => (u.addEventListener(h, f, d), () => u.removeEventListener(h, f, d)), l = Te(
+    () => [za(e), dt(s)],
     ([u, h]) => {
       if (r(), !u)
         return;
-      const m = vh(h) ? { ...h } : h;
+      const f = Ah(h) ? { ...h } : h;
       i.push(
-        ...t.flatMap((p) => n.map((v) => a(u, p, v, m)))
+        ...t.flatMap((d) => n.map((y) => a(u, d, y, f)))
       );
     },
     { immediate: !0, flush: "post" }
   ), c = () => {
     l(), r();
   };
-  return Ca(c), c;
+  return Ba(c), c;
 }
-function Ah(o) {
+function Fh(o) {
   return typeof o == "function" ? o : typeof o == "string" ? (e) => e.key === o : Array.isArray(o) ? (e) => o.includes(e.key) : () => !0;
 }
-function mn(...o) {
+function yn(...o) {
   let e, t, n = {};
   o.length === 3 ? (e = o[0], t = o[1], n = o[2]) : o.length === 2 ? typeof o[1] == "object" ? (e = !0, t = o[0], n = o[1]) : (e = o[0], t = o[1]) : (e = !0, t = o[0]);
   const {
-    target: s = Mn,
+    target: s = An,
     eventName: i = "keydown",
     passive: r = !1,
     dedupe: a = !1
-  } = n, l = Ah(e);
-  return Ve(s, i, (u) => {
+  } = n, l = Fh(e);
+  return Ge(s, i, (u) => {
     u.repeat && dt(a) || l(u) && t(u);
   }, r);
 }
-function Ph() {
-  const o = ue(!1);
-  return oa() && ds(() => {
+function kh() {
+  const o = ue(!1), e = fa();
+  return e && $n(() => {
     o.value = !0;
-  }), o;
+  }, e), o;
 }
-function Rh(o) {
-  const e = Ph();
+function Bh(o) {
+  const e = kh();
   return Ne(() => (e.value, !!o()));
 }
-function Ch(o, e = {}) {
-  const { window: t = Mn } = e, n = Rh(() => t && "matchMedia" in t && typeof t.matchMedia == "function");
+function Uh(o, e = {}) {
+  const { window: t = An } = e, n = Bh(() => t && "matchMedia" in t && typeof t.matchMedia == "function");
   let s;
   const i = ue(!1), r = (c) => {
     i.value = c.matches;
   }, a = () => {
     s && ("removeEventListener" in s ? s.removeEventListener("change", r) : s.removeListener(r));
-  }, l = ft(() => {
+  }, l = lt(() => {
     n.value && (a(), s = t.matchMedia(dt(o)), "addEventListener" in s ? s.addEventListener("change", r) : s.addListener(r), i.value = s.matches);
   });
-  return Ca(() => {
+  return Ba(() => {
     l(), a(), s = void 0;
   }), i;
 }
-const Kr = 1;
-function Ih(o, e = {}) {
+const no = 1;
+function Nh(o, e = {}) {
   const {
     throttle: t = 0,
     idle: n = 200,
-    onStop: s = En,
-    onScroll: i = En,
+    onStop: s = Mn,
+    onScroll: i = Mn,
     offset: r = {
       left: 0,
       right: 0,
@@ -7565,135 +7603,144 @@ function Ih(o, e = {}) {
       passive: !0
     },
     behavior: l = "auto",
-    window: c = Mn
-  } = e, u = ue(0), h = ue(0), m = Ne({
+    window: c = An,
+    onError: u = (E) => {
+      console.error(E);
+    }
+  } = e, h = ue(0), f = ue(0), d = Ne({
     get() {
-      return u.value;
+      return h.value;
     },
-    set(x) {
-      v(x, void 0);
+    set(E) {
+      x(E, void 0);
     }
-  }), p = Ne({
+  }), y = Ne({
     get() {
-      return h.value;
+      return f.value;
     },
-    set(x) {
-      v(void 0, x);
+    set(E) {
+      x(void 0, E);
     }
   });
-  function v(x, M) {
-    var d, w, f;
+  function x(E, m) {
+    var b, p, C;
     if (!c)
       return;
-    const P = dt(o);
-    P && ((f = P instanceof Document ? c.document.body : P) == null || f.scrollTo({
-      top: (d = dt(M)) != null ? d : p.value,
-      left: (w = dt(x)) != null ? w : m.value,
+    const I = dt(o);
+    I && ((C = I instanceof Document ? c.document.body : I) == null || C.scrollTo({
+      top: (b = dt(m)) != null ? b : y.value,
+      left: (p = dt(E)) != null ? p : d.value,
       behavior: dt(l)
     }));
   }
-  const _ = ue(!1), y = Xi({
+  const g = ue(!1), v = Ji({
     left: !0,
     right: !1,
     top: !0,
     bottom: !1
-  }), E = Xi({
+  }), M = Ji({
     left: !1,
     right: !1,
     top: !1,
     bottom: !1
-  }), R = (x) => {
-    _.value && (_.value = !1, E.left = !1, E.right = !1, E.top = !1, E.bottom = !1, s(x));
-  }, T = Th(R, t + n), g = (x) => {
-    var M;
+  }), _ = (E) => {
+    g.value && (g.value = !1, M.left = !1, M.right = !1, M.top = !1, M.bottom = !1, s(E));
+  }, w = Ih(_, t + n), P = (E) => {
+    var m;
     if (!c)
       return;
-    const d = x.document ? x.document.documentElement : (M = x.documentElement) != null ? M : x, { display: w, flexDirection: f } = getComputedStyle(d), P = d.scrollLeft;
-    E.left = P < u.value, E.right = P > u.value;
-    const I = Math.abs(P) <= 0 + (r.left || 0), K = Math.abs(P) + d.clientWidth >= d.scrollWidth - (r.right || 0) - Kr;
-    w === "flex" && f === "row-reverse" ? (y.left = K, y.right = I) : (y.left = I, y.right = K), u.value = P;
-    let N = d.scrollTop;
-    x === c.document && !N && (N = c.document.body.scrollTop), E.top = N < h.value, E.bottom = N > h.value;
-    const Z = Math.abs(N) <= 0 + (r.top || 0), W = Math.abs(N) + d.clientHeight >= d.scrollHeight - (r.bottom || 0) - Kr;
-    w === "flex" && f === "column-reverse" ? (y.top = W, y.bottom = Z) : (y.top = Z, y.bottom = W), h.value = N;
-  }, A = (x) => {
-    var M;
+    const b = ((m = E == null ? void 0 : E.document) == null ? void 0 : m.documentElement) || (E == null ? void 0 : E.documentElement) || za(E), { display: p, flexDirection: C } = getComputedStyle(b), I = b.scrollLeft;
+    M.left = I < h.value, M.right = I > h.value;
+    const K = Math.abs(I) <= (r.left || 0), z = Math.abs(I) + b.clientWidth >= b.scrollWidth - (r.right || 0) - no;
+    p === "flex" && C === "row-reverse" ? (v.left = z, v.right = K) : (v.left = K, v.right = z), h.value = I;
+    let Y = b.scrollTop;
+    E === c.document && !Y && (Y = c.document.body.scrollTop), M.top = Y < f.value, M.bottom = Y > f.value;
+    const W = Math.abs(Y) <= (r.top || 0), X = Math.abs(Y) + b.clientHeight >= b.scrollHeight - (r.bottom || 0) - no;
+    p === "flex" && C === "column-reverse" ? (v.top = X, v.bottom = W) : (v.top = W, v.bottom = X), f.value = Y;
+  }, T = (E) => {
+    var m;
     if (!c)
       return;
-    const d = (M = x.target.documentElement) != null ? M : x.target;
-    g(d), _.value = !0, T(x), i(x);
+    const b = (m = E.target.documentElement) != null ? m : E.target;
+    P(b), g.value = !0, w(E), i(E);
   };
-  return Ve(
+  return Ge(
     o,
     "scroll",
-    t ? bh(A, t, !0, !1) : A,
+    t ? Dh(T, t, !0, !1) : T,
     a
-  ), Da(() => {
-    const x = dt(o);
-    x && g(x);
-  }), Ve(
+  ), Na(() => {
+    try {
+      const E = dt(o);
+      if (!E)
+        return;
+      P(E);
+    } catch (E) {
+      u(E);
+    }
+  }), Ge(
     o,
     "scrollend",
-    R,
+    _,
     a
   ), {
-    x: m,
-    y: p,
-    isScrolling: _,
-    arrivedState: y,
-    directions: E,
+    x: d,
+    y,
+    isScrolling: g,
+    arrivedState: v,
+    directions: M,
     measure() {
-      const x = dt(o);
-      c && x && g(x);
+      const E = dt(o);
+      c && E && P(E);
     }
   };
 }
-const Dh = {
+const zh = {
   page: (o) => [o.pageX, o.pageY],
   client: (o) => [o.clientX, o.clientY],
   screen: (o) => [o.screenX, o.screenY],
   movement: (o) => o instanceof Touch ? null : [o.movementX, o.movementY]
 };
-function Lh(o = {}) {
+function Hh(o = {}) {
   const {
     type: e = "page",
     touch: t = !0,
     resetOnTouchEnds: n = !1,
     initialValue: s = { x: 0, y: 0 },
-    window: i = Mn,
+    window: i = An,
     target: r = i,
     scroll: a = !0,
     eventFilter: l
   } = o;
   let c = null;
-  const u = ue(s.x), h = ue(s.y), m = ue(null), p = typeof e == "function" ? e : Dh[e], v = (A) => {
-    const x = p(A);
-    c = A, x && ([u.value, h.value] = x, m.value = "mouse");
-  }, _ = (A) => {
-    if (A.touches.length > 0) {
-      const x = p(A.touches[0]);
-      x && ([u.value, h.value] = x, m.value = "touch");
-    }
-  }, y = () => {
+  const u = ue(s.x), h = ue(s.y), f = ue(null), d = typeof e == "function" ? e : zh[e], y = (P) => {
+    const T = d(P);
+    c = P, T && ([u.value, h.value] = T, f.value = "mouse");
+  }, x = (P) => {
+    if (P.touches.length > 0) {
+      const T = d(P.touches[0]);
+      T && ([u.value, h.value] = T, f.value = "touch");
+    }
+  }, g = () => {
     if (!c || !i)
       return;
-    const A = p(c);
-    c instanceof MouseEvent && A && (u.value = A[0] + i.scrollX, h.value = A[1] + i.scrollY);
-  }, E = () => {
+    const P = d(c);
+    c instanceof MouseEvent && P && (u.value = P[0] + i.scrollX, h.value = P[1] + i.scrollY);
+  }, v = () => {
     u.value = s.x, h.value = s.y;
-  }, R = l ? (A) => l(() => v(A), {}) : (A) => v(A), T = l ? (A) => l(() => _(A), {}) : (A) => _(A), g = l ? () => l(() => y(), {}) : () => y();
+  }, M = l ? (P) => l(() => y(P), {}) : (P) => y(P), _ = l ? (P) => l(() => x(P), {}) : (P) => x(P), w = l ? () => l(() => g(), {}) : () => g();
   if (r) {
-    const A = { passive: !0 };
-    Ve(r, ["mousemove", "dragover"], R, A), t && e !== "movement" && (Ve(r, ["touchstart", "touchmove"], T, A), n && Ve(r, "touchend", E, A)), a && e === "page" && Ve(i, "scroll", g, { passive: !0 });
+    const P = { passive: !0 };
+    Ge(r, ["mousemove", "dragover"], M, P), t && e !== "movement" && (Ge(r, ["touchstart", "touchmove"], _, P), n && Ge(r, "touchend", v, P)), a && e === "page" && Ge(i, "scroll", w, { passive: !0 });
   }
   return {
     x: u,
     y: h,
-    sourceType: m
+    sourceType: f
   };
 }
-function Oh(o = {}) {
-  const { window: e = Mn, behavior: t = "auto" } = o;
+function jh(o = {}) {
+  const { window: e = An, behavior: t = "auto" } = o;
   if (!e)
     return {
       x: ue(0),
@@ -7714,7 +7761,7 @@ function Oh(o = {}) {
       scrollTo({ top: a, behavior: t });
     }
   });
-  return Ve(
+  return Ge(
     e,
     "scroll",
     () => {
@@ -7726,9 +7773,9 @@ function Oh(o = {}) {
     }
   ), { x: i, y: r };
 }
-function La(o = {}) {
+function Ha(o = {}) {
   const {
-    window: e = Mn,
+    window: e = An,
     initialWidth: t = Number.POSITIVE_INFINITY,
     initialHeight: n = Number.POSITIVE_INFINITY,
     listenOrientation: s = !0,
@@ -7736,13 +7783,13 @@ function La(o = {}) {
   } = o, r = ue(t), a = ue(n), l = () => {
     e && (i ? (r.value = e.innerWidth, a.value = e.innerHeight) : (r.value = e.document.documentElement.clientWidth, a.value = e.document.documentElement.clientHeight));
   };
-  if (l(), Da(l), Ve("resize", l, { passive: !0 }), s) {
-    const c = Ch("(orientation: portrait)");
-    we(c, () => l());
+  if (l(), Na(l), Ge("resize", l, { passive: !0 }), s) {
+    const c = Uh("(orientation: portrait)");
+    Te(c, () => l());
   }
   return { width: r, height: a };
 }
-const Um = /* @__PURE__ */ pe({
+const sg = /* @__PURE__ */ pe({
   __name: "MouseParallax",
   props: {
     disabled: { type: Boolean, default: !1 },
@@ -7750,18 +7797,18 @@ const Um = /* @__PURE__ */ pe({
     ease: { default: 0.1 }
   },
   setup(o) {
-    const e = o, { camera: t } = je(), { disabled: n, factor: s, ease: i } = Fe(e), { x: r, y: a } = Lh(), { width: l, height: c } = La(), u = ue(), h = Ne(() => (r.value / l.value - 0.5) * s.value), m = Ne(() => -(a.value / c.value - 0.5) * s.value), { onLoop: p } = Ke();
-    return p(({ delta: v }) => {
-      n.value || !u.value || (u.value.position.x += (h.value - u.value.position.x) * i.value * v, u.value.position.y += (m.value - u.value.position.y) * i.value * v);
-    }), we(
+    const e = o, { camera: t } = Ue(), { disabled: n, factor: s, ease: i } = Oe(e), { x: r, y: a } = Hh(), { width: l, height: c } = Ha(), u = ue(), h = Ne(() => (r.value / l.value - 0.5) * s.value), f = Ne(() => -(a.value / c.value - 0.5) * s.value), { onLoop: d } = Xe();
+    return d(({ delta: y }) => {
+      n.value || !u.value || (u.value.position.x += (h.value - u.value.position.x) * i.value * y, u.value.position.y += (f.value - u.value.position.y) * i.value * y);
+    }), Te(
       () => u.value,
-      (v) => v == null ? void 0 : v.add(t.value)
-    ), (v, _) => (fe(), de("TresGroup", {
+      (y) => y == null ? void 0 : y.add(t.value)
+    ), (y, x) => (le(), ce("TresGroup", {
       ref_key: "cameraGroupRef",
       ref: u
     }, null, 512));
   }
-}), Bm = pe({
+}), ig = pe({
   name: "GlobalAudio",
   props: [
     "src",
@@ -7773,31 +7820,31 @@ const Um = /* @__PURE__ */ pe({
   ],
   async setup(o, { expose: e, emit: t }) {
     var h;
-    const { camera: n, renderer: s } = je(), i = new Pl();
+    const { camera: n, renderer: s } = Ue(), i = new Ll();
     (h = n.value) == null || h.add(i);
-    const r = new Rl(i), a = new Cl();
+    const r = new Fl(i), a = new kl();
     e({ sound: r }), ot(() => {
       r && r.disconnect();
-    }), we(() => [o.playbackRate], () => r.setPlaybackRate(o.playbackRate ?? 1), { immediate: !0 }), we(() => [o.volume], () => r.setVolume(o.volume ?? 0.5), { immediate: !0 }), we(() => [o.loop], () => r.setLoop(o.loop ?? !1), { immediate: !0 }), we(() => [o.src], async () => {
-      const m = await a.loadAsync(o.src);
-      r.setBuffer(m);
+    }), Te(() => [o.playbackRate], () => r.setPlaybackRate(o.playbackRate ?? 1), { immediate: !0 }), Te(() => [o.volume], () => r.setVolume(o.volume ?? 0.5), { immediate: !0 }), Te(() => [o.loop], () => r.setLoop(o.loop ?? !1), { immediate: !0 }), Te(() => [o.src], async () => {
+      const f = await a.loadAsync(o.src);
+      r.setBuffer(f);
     }, { immediate: !0 });
     const l = document.getElementById(o.playTrigger ?? ""), c = l || s.value.domElement;
-    Ve(c, "click", () => {
+    Ge(c, "click", () => {
       r.isPlaying ? r.pause() : r.play(), t("isPlaying", r.isPlaying);
     });
     const u = document.getElementById(o.stopTrigger ?? "");
-    return u && Ve(u, "click", () => {
+    return u && Ge(u, "click", () => {
       r.stop(), t("isPlaying", r.isPlaying);
     }), null;
   }
 });
-class as extends ae {
+class ms extends ae {
   constructor() {
-    super(as.Geometry, new Gt({ opacity: 0, transparent: !0 })), this.isLensflare = !0, this.type = "Lensflare", this.frustumCulled = !1, this.renderOrder = 1 / 0;
-    const e = new ee(), t = new ee(), n = new Pr(16, 16), s = new Pr(16, 16);
-    let i = Vi;
-    const r = as.Geometry, a = new li({
+    super(ms.Geometry, new Yt({ opacity: 0, transparent: !0 })), this.isLensflare = !0, this.type = "Lensflare", this.frustumCulled = !1, this.renderOrder = 1 / 0;
+    const e = new q(), t = new q(), n = new Lr(16, 16), s = new Lr(16, 16);
+    let i = qi;
+    const r = ms.Geometry, a = new pi({
       uniforms: {
         scale: { value: null },
         screenPosition: { value: null }
@@ -7834,7 +7881,7 @@ class as extends ae {
       depthTest: !0,
       depthWrite: !1,
       transparent: !1
-    }), l = new li({
+    }), l = new pi({
       uniforms: {
         map: { value: n },
         scale: { value: null },
@@ -7881,56 +7928,56 @@ class as extends ae {
       depthTest: !1,
       depthWrite: !1,
       transparent: !1
-    }), c = new ae(r, a), u = [], h = Oa.Shader, m = new li({
+    }), c = new ae(r, a), u = [], h = ja.Shader, f = new pi({
       name: h.name,
       uniforms: {
         map: { value: null },
         occlusionMap: { value: s },
-        color: { value: new Be(16777215) },
-        scale: { value: new le() },
-        screenPosition: { value: new ee() }
+        color: { value: new Re(16777215) },
+        scale: { value: new he() },
+        screenPosition: { value: new q() }
       },
       vertexShader: h.vertexShader,
       fragmentShader: h.fragmentShader,
-      blending: na,
+      blending: mr,
       transparent: !0,
       depthWrite: !1
-    }), p = new ae(r, m);
-    this.addElement = function(R) {
-      u.push(R);
+    }), d = new ae(r, f);
+    this.addElement = function(M) {
+      u.push(M);
     };
-    const v = new le(), _ = new le(), y = new ea(), E = new ht();
-    this.onBeforeRender = function(R, T, g) {
-      R.getCurrentViewport(E);
-      const A = R.getRenderTarget(), x = A !== null ? A.texture.type : Vi;
-      i !== x && (n.dispose(), s.dispose(), n.type = s.type = x, i = x);
-      const M = E.w / E.z, d = E.z / 2, w = E.w / 2;
-      let f = 16 / E.w;
-      if (v.set(f * M, f), y.min.set(E.x, E.y), y.max.set(E.x + (E.z - 16), E.y + (E.w - 16)), t.setFromMatrixPosition(this.matrixWorld), t.applyMatrix4(g.matrixWorldInverse), !(t.z > 0) && (e.copy(t).applyMatrix4(g.projectionMatrix), _.x = E.x + e.x * d + d - 8, _.y = E.y + e.y * w + w - 8, y.containsPoint(_))) {
-        R.copyFramebufferToTexture(_, n);
-        let P = a.uniforms;
-        P.scale.value = v, P.screenPosition.value = e, R.renderBufferDirect(g, null, r, a, c, null), R.copyFramebufferToTexture(_, s), P = l.uniforms, P.scale.value = v, P.screenPosition.value = e, R.renderBufferDirect(g, null, r, l, c, null);
+    const y = new he(), x = new he(), g = new aa(), v = new rt();
+    this.onBeforeRender = function(M, _, w) {
+      M.getCurrentViewport(v);
+      const P = M.getRenderTarget(), T = P !== null ? P.texture.type : qi;
+      i !== T && (n.dispose(), s.dispose(), n.type = s.type = T, i = T);
+      const E = v.w / v.z, m = v.z / 2, b = v.w / 2;
+      let p = 16 / v.w;
+      if (y.set(p * E, p), g.min.set(v.x, v.y), g.max.set(v.x + (v.z - 16), v.y + (v.w - 16)), t.setFromMatrixPosition(this.matrixWorld), t.applyMatrix4(w.matrixWorldInverse), !(t.z > 0) && (e.copy(t).applyMatrix4(w.projectionMatrix), x.x = v.x + e.x * m + m - 8, x.y = v.y + e.y * b + b - 8, g.containsPoint(x))) {
+        M.copyFramebufferToTexture(x, n);
+        let C = a.uniforms;
+        C.scale.value = y, C.screenPosition.value = e, M.renderBufferDirect(w, null, r, a, c, null), M.copyFramebufferToTexture(x, s), C = l.uniforms, C.scale.value = y, C.screenPosition.value = e, M.renderBufferDirect(w, null, r, l, c, null);
         const I = -e.x * 2, K = -e.y * 2;
-        for (let N = 0, Z = u.length; N < Z; N++) {
-          const W = u[N], X = m.uniforms;
-          X.color.value.copy(W.color), X.map.value = W.texture, X.screenPosition.value.x = e.x + I * W.distance, X.screenPosition.value.y = e.y + K * W.distance, f = W.size / E.w;
-          const V = E.w / E.z;
-          X.scale.value.set(f * V, f), m.uniformsNeedUpdate = !0, R.renderBufferDirect(g, null, r, m, p, null);
+        for (let z = 0, Y = u.length; z < Y; z++) {
+          const W = u[z], X = f.uniforms;
+          X.color.value.copy(W.color), X.map.value = W.texture, X.screenPosition.value.x = e.x + I * W.distance, X.screenPosition.value.y = e.y + K * W.distance, p = W.size / v.w;
+          const V = v.w / v.z;
+          X.scale.value.set(p * V, p), f.uniformsNeedUpdate = !0, M.renderBufferDirect(w, null, r, f, d, null);
         }
       }
     }, this.dispose = function() {
-      a.dispose(), l.dispose(), m.dispose(), n.dispose(), s.dispose();
-      for (let R = 0, T = u.length; R < T; R++)
-        u[R].texture.dispose();
+      a.dispose(), l.dispose(), f.dispose(), n.dispose(), s.dispose();
+      for (let M = 0, _ = u.length; M < _; M++)
+        u[M].texture.dispose();
     };
   }
 }
-class Oa {
-  constructor(e, t = 1, n = 0, s = new Be(16777215)) {
+class ja {
+  constructor(e, t = 1, n = 0, s = new Re(16777215)) {
     this.texture = e, this.size = t, this.distance = n, this.color = s;
   }
 }
-Oa.Shader = {
+ja.Shader = {
   name: "LensflareElementShader",
   uniforms: {
     map: { value: null },
@@ -8002,8 +8049,8 @@ Oa.Shader = {
 		}`
   )
 };
-as.Geometry = function() {
-  const o = new rt(), e = new Float32Array([
+ms.Geometry = function() {
+  const o = new at(), e = new Float32Array([
     -1,
     -1,
     0,
@@ -8024,26 +8071,26 @@ as.Geometry = function() {
     0,
     0,
     1
-  ]), t = new ur(e, 5);
-  return o.setIndex([0, 1, 2, 0, 2, 3]), o.setAttribute("position", new Vt(t, 3, 0, !1)), o.setAttribute("uv", new Vt(t, 2, 3, !1)), o;
+  ]), t = new pr(e, 5);
+  return o.setIndex([0, 1, 2, 0, 2, 3]), o.setAttribute("position", new $t(t, 3, 0, !1)), o.setAttribute("uv", new $t(t, 2, 3, !1)), o;
 }();
-function Fh(o) {
+function Gh(o) {
   return o;
 }
-function kh(o) {
+function Vh(o) {
   return o * o * o;
 }
-function Uh(o) {
+function Wh(o) {
   return o < 0.5 ? 4 * o * o * o : 1 - (-2 * o + 2) ** 3 / 2;
 }
-function Bh(o) {
+function Yh(o) {
   return o * o * o * o;
 }
-function Nh(o) {
+function Xh(o) {
   return o < 1 / 2.75 ? 7.5625 * o * o : o < 2 / 2.75 ? 7.5625 * (o -= 1.5 / 2.75) * o + 0.75 : o < 2.5 / 2.75 ? 7.5625 * (o -= 2.25 / 2.75) * o + 0.9375 : 7.5625 * (o -= 2.625 / 2.75) * o + 0.984375;
 }
-const qr = We.clamp;
-class Qr {
+const so = Ze.clamp;
+class io {
   /**
    * Create a new seeded pseudorandom number generator.
    * @param [seed=0] - the seed for the generator
@@ -8115,7 +8162,7 @@ class Qr {
    */
   sample(e, t, n) {
     const s = e.length;
-    t = qr(t, 0, s - 1), n = qr(n ?? s - 1, 0, s - 1);
+    t = so(t, 0, s - 1), n = so(n ?? s - 1, 0, s - 1);
     const i = this.int(t, n), r = this.shuffle(e.map((l, c) => c)), a = Math.min(e.length, i);
     return r.slice(0, a).sort().map((l) => e[l]);
   }
@@ -8137,50 +8184,50 @@ class Qr {
     };
   }
 }
-const $t = "https://raw.githubusercontent.com/Tresjs/assets/93976c7d63ac83d4a254a41a10b2362bc17e90c9/textures/lensflare/", mr = `${$t}circle.png`, ei = `${$t}circleBlur.png`, zh = `${$t}circleRainbow.png`, Hh = `${$t}line.png`, Fa = `${$t}poly6.png`, ka = `${$t}polyStroke6.png`, Gh = `${$t}rays.png`, ti = `${$t}ring.png`, jh = `${$t}starThin6.png`, Vh = {
-  texture: [Hh, ti],
+const qt = "https://raw.githubusercontent.com/Tresjs/assets/93976c7d63ac83d4a254a41a10b2362bc17e90c9/textures/lensflare/", wr = `${qt}circle.png`, oi = `${qt}circleBlur.png`, $h = `${qt}circleRainbow.png`, Zh = `${qt}line.png`, Ga = `${qt}poly6.png`, Va = `${qt}polyStroke6.png`, Kh = `${qt}rays.png`, ai = `${qt}ring.png`, qh = `${qt}starThin6.png`, Qh = {
+  texture: [Zh, ai],
   color: ["white"],
   distance: [0, 0],
   size: [750, 1024],
   length: [0, 2]
-}, Yh = {
-  texture: [ei],
+}, Jh = {
+  texture: [oi],
   color: ["white"],
   distance: [0, 0],
   size: [180, 512],
   length: [1, 1]
-}, Xh = {
-  texture: [Gh],
+}, ef = {
+  texture: [Kh],
   color: ["white"],
   distance: [0, 0],
   size: [180, 512],
   length: [1, 1]
-}, Wh = {
-  texture: [mr, zh, ti, jh],
+}, tf = {
+  texture: [wr, $h, ai, qh],
   color: ["white"],
   distance: [0, 0],
   size: [180, 512],
   length: [2, 3]
-}, [Ua, Ba] = [3679071, 132442], $h = {
-  texture: [ei, mr, ti, Fa, ka],
-  color: ["dimgray", "gray", "darkgray", Ua, Ba],
+}, [Wa, Ya] = [3679071, 132442], nf = {
+  texture: [oi, wr, ai, Ga, Va],
+  color: ["dimgray", "gray", "darkgray", Wa, Ya],
   distance: [0.5, 2.5],
   size: [20, 180],
   length: [5, 21]
-}, Zh = {
-  texture: [ei, mr, ti, Fa, ka],
-  color: ["dimgray", "gray", "darkgray", Ua, Ba],
+}, sf = {
+  texture: [oi, wr, ai, Ga, Va],
+  color: ["dimgray", "gray", "darkgray", Wa, Ya],
   distance: [-0.6, -0.1],
   size: [180, 360],
   length: [0, 5]
-}, er = [Vh, Yh, Xh, Wh, $h, Zh], $s = {
+}, rr = [Qh, Jh, ef, tf, nf, sf], ei = {
   color: "white",
   distance: 0,
   size: 512,
-  texture: ei
-}, Jr = (o, e, t = void 0, n = void 0, s = $s) => {
+  texture: oi
+}, ro = (o, e, t = void 0, n = void 0, s = ei) => {
   if (o !== void 0 && o.length > 0 && (typeof t == "number" || typeof n < "u")) {
-    const a = to(t ?? 0, n ?? er), l = a.length, c = o.length;
+    const a = ao(t ?? 0, n ?? rr), l = a.length, c = o.length;
     return l >= c ? a.map(
       (u, h) => Object.assign(u, e, h < c ? o[h] : {})
     ) : o.map(
@@ -8191,18 +8238,18 @@ const $t = "https://raw.githubusercontent.com/Tresjs/assets/93976c7d63ac83d4a254
     const a = Object.assign({}, s, e);
     return o.map((l) => Object.assign({}, a, l));
   }
-  const i = n === void 0 || n.length === 0 ? er : n;
-  return to(t ?? 0, i).map((a) => Object.assign({}, a, e));
-}, Kh = [
-  Fh,
-  kh,
-  Uh,
-  Bh,
-  Nh
-], eo = We.lerp, to = (o = 0, e = er) => {
-  const n = new Qr(o).choice(Kh);
+  const i = n === void 0 || n.length === 0 ? rr : n;
+  return ao(t ?? 0, i).map((a) => Object.assign({}, a, e));
+}, rf = [
+  Gh,
+  Vh,
+  Wh,
+  Yh,
+  Xh
+], oo = Ze.lerp, ao = (o = 0, e = rr) => {
+  const n = new io(o).choice(rf);
   return e.map((s, i) => {
-    const r = new Qr(
+    const r = new io(
       o * (i * 7907 + 1) + (typeof s.seed == "number" ? s.seed : 0)
     ), a = r.int(s.length[0], s.length[1]);
     return new Array(a).fill(0).map(() => {
@@ -8210,28 +8257,28 @@ const $t = "https://raw.githubusercontent.com/Tresjs/assets/93976c7d63ac83d4a254
       return {
         texture: r.defaultChoice(
           s.texture,
-          $s.texture
+          ei.texture
         ),
-        size: eo(s.size[0], s.size[1], n(1 - l)),
-        distance: eo(s.distance[0], s.distance[1], l),
+        size: oo(s.size[0], s.size[1], n(1 - l)),
+        distance: oo(s.distance[0], s.distance[1], l),
         color: r.defaultChoice(
           s.color,
-          $s.color
+          ei.color
         )
       };
     });
   }).flat();
 };
-function qh(o) {
-  return Qh(o, (e, t) => t in $s && e !== void 0);
+function of(o) {
+  return af(o, (e, t) => t in ei && e !== void 0);
 }
-function Qh(o, e) {
+function af(o, e) {
   const t = {};
   return Object.keys(o).forEach((n) => {
     e(o[n], n) && (t[n] = o[n]);
   }), t;
 }
-const Nm = /* @__PURE__ */ pe({
+const rg = /* @__PURE__ */ pe({
   __name: "component",
   props: {
     scale: { default: 1 },
@@ -8244,93 +8291,93 @@ const Nm = /* @__PURE__ */ pe({
     texture: { default: void 0 }
   },
   setup(o, { expose: e }) {
-    const t = o, n = xe(), s = xe([]), i = xe(qh(t));
+    const t = o, n = me(), s = me([]), i = me(of(t));
     e({
       value: n
     });
-    const r = new cr(), a = new as(), l = [], c = () => {
-      var p, v, _;
+    const r = new dr(), a = new ms(), l = [], c = () => {
+      var d, y, x;
       for (; l.length; )
         l.pop();
-      (p = n.value) == null || p.children.forEach((y) => {
-        "dispose" in y && y.dispose();
-      }), (v = n.value) == null || v.remove(...n.value.children), (_ = n.value) == null || _.dispose();
-    }, u = (p) => {
-      if (typeof p.texture == "string") {
-        const v = p.texture;
-        p.texture = r.load(v), p.texture.name = v;
+      (d = n.value) == null || d.children.forEach((g) => {
+        "dispose" in g && g.dispose();
+      }), (y = n.value) == null || y.remove(...n.value.children), (x = n.value) == null || x.dispose();
+    }, u = (d) => {
+      if (typeof d.texture == "string") {
+        const y = d.texture;
+        d.texture = r.load(y), d.texture.name = y;
       }
-      return p.color = ln(p.color), p;
+      return d.color = un(d.color), d;
     }, h = () => {
       for (; s.value.length > l.length; ) {
-        const v = { ...u(s.value[l.length]) };
-        l.push(v), a.addElement(v);
+        const y = { ...u(s.value[l.length]) };
+        l.push(y), a.addElement(y);
       }
-      s.value.forEach((p, v) => {
-        const _ = l[v], { texture: y, size: E, distance: R, color: T } = p;
-        if (typeof y == "string") {
-          if (_.texture.name !== y) {
-            _.texture.dispose();
-            const g = y;
-            _.texture = r.load(g), _.texture.name = g;
+      s.value.forEach((d, y) => {
+        const x = l[y], { texture: g, size: v, distance: M, color: _ } = d;
+        if (typeof g == "string") {
+          if (x.texture.name !== g) {
+            x.texture.dispose();
+            const w = g;
+            x.texture = r.load(w), x.texture.name = w;
           }
         } else
-          _.texture !== y && (_.texture.dispose(), _.texture = y);
-        _.size = E, _.distance = R, _.color = ln(T);
-      }), m();
-    }, m = () => {
-      for (let p = s.value.length - 1; p < l.length; p++)
-        l[p].size = 0;
-      s.value.forEach((p, v) => {
-        l[v].size = p.size * t.scale;
+          x.texture !== g && (x.texture.dispose(), x.texture = g);
+        x.size = v, x.distance = M, x.color = un(_);
+      }), f();
+    }, f = () => {
+      for (let d = s.value.length - 1; d < l.length; d++)
+        l[d].size = 0;
+      s.value.forEach((d, y) => {
+        l[y].size = d.size * t.scale;
       });
     };
     return ot(() => {
       c();
-    }), ds(() => {
-      var p;
-      (p = n.value) == null || p.add(a), s.value = Jr(t.elements, i.value, t.seed, t.seedProps);
-    }), we(() => [t.color, t.distance, t.size, t.texture], () => {
+    }), $n(() => {
+      var d;
+      (d = n.value) == null || d.add(a), s.value = ro(t.elements, i.value, t.seed, t.seedProps);
+    }), Te(() => [t.color, t.distance, t.size, t.texture], () => {
       i.value = {
         color: t.color,
         distance: t.distance,
         size: t.size,
         texture: t.texture
       };
-    }), we(() => [i.value, t.elements, t.seed, t.seedProps], () => {
-      s.value = Jr(t.elements, i.value, t.seed, t.seedProps);
-    }), we(() => t.scale, () => {
-      m();
-    }), we(() => s.value, () => {
+    }), Te(() => [i.value, t.elements, t.seed, t.seedProps], () => {
+      s.value = ro(t.elements, i.value, t.seed, t.seedProps);
+    }), Te(() => t.scale, () => {
+      f();
+    }), Te(() => s.value, () => {
       h();
-    }), (p, v) => (fe(), de("TresGroup", {
+    }), (d, y) => (le(), ce("TresGroup", {
       ref_key: "lensflareRef",
       ref: n
     }, null, 512));
   }
 });
-function Jh(o) {
-  const e = ue(null), { height: t, width: n, settings: s, depth: i } = nc(o) ? Fe(o) : Fe(Xi(o)), { onLoop: r } = Ke(), { camera: a, renderer: l, scene: c, sizes: u } = je();
-  return ft(() => {
+function lf(o) {
+  const e = ue(null), { height: t, width: n, settings: s, depth: i } = uc(o) ? Oe(o) : Oe(Ji(o)), { onLoop: r } = Xe(), { camera: a, renderer: l, scene: c, sizes: u } = Ue();
+  return lt(() => {
     var h;
-    (h = e.value) == null || h.dispose(), e.value = new bn((n == null ? void 0 : n.value) || u.width.value, (t == null ? void 0 : t.value) || u.height.value, {
-      minFilter: At,
-      magFilter: At,
-      type: un,
+    (h = e.value) == null || h.dispose(), e.value = new pn((n == null ? void 0 : n.value) || u.width.value, (t == null ? void 0 : t.value) || u.height.value, {
+      minFilter: Ct,
+      magFilter: Ct,
+      type: Zt,
       ...s == null ? void 0 : s.value
-    }), i != null && i.value && (e.value.depthTexture = new sa(
+    }), i != null && i.value && (e.value.depthTexture = new ca(
       (n == null ? void 0 : n.value) || u.width.value,
       (t == null ? void 0 : t.value) || u.height.value,
-      Gs
+      Zs
     ));
   }), r(() => {
     l.value.setRenderTarget(e.value), l.value.clear(), l.value.render(c.value, a.value), l.value.setRenderTarget(null);
-  }), aa(() => {
+  }), da(() => {
     var h;
     (h = e.value) == null || h.dispose();
   }), e;
 }
-const zm = /* @__PURE__ */ pe({
+const og = /* @__PURE__ */ pe({
   __name: "component",
   props: {
     width: {},
@@ -8339,35 +8386,35 @@ const zm = /* @__PURE__ */ pe({
     settings: { default: void 0 }
   },
   setup(o, { expose: e }) {
-    const n = Jh(o);
+    const n = lf(o);
     return e({
       value: n
     }), () => {
     };
   }
-}), ef = (o, e = 16, t, n, s) => {
-  const i = new Float32Array(e * 16), r = ue(new ur(i, 16));
+}), cf = (o, e = 16, t, n, s) => {
+  const i = new Float32Array(e * 16), r = ue(new pr(i, 16));
   return (() => {
     if (!o)
       return;
-    const l = new Yc(o);
+    const l = new Jc(o);
     n && l.setWeightAttribute(n), l.build();
-    const c = new ee(), u = new ee(), h = new Be(), m = new St();
+    const c = new q(), u = new q(), h = new Re(), f = new Tt();
     o.updateMatrixWorld(!0);
-    for (let p = 0; p < e; p++)
+    for (let d = 0; d < e; d++)
       l.sample(c, u, h), typeof s == "function" ? s(
         {
-          dummy: m,
+          dummy: f,
           sampledMesh: o,
           position: c,
           normal: u,
           color: h
         },
-        p
-      ) : m.position.copy(c), m.updateMatrix(), t && t.setMatrixAt(p, m.matrix), m.matrix.toArray(r.value.array, p * 16);
+        d
+      ) : f.position.copy(c), f.updateMatrix(), t && t.setMatrixAt(d, f.matrix), f.matrix.toArray(r.value.array, d * 16);
     t && (t.instanceMatrix.needsUpdate = !0), r.value.needsUpdate = !0;
   })(), { buffer: r };
-}, Hm = /* @__PURE__ */ pe({
+}, ag = /* @__PURE__ */ pe({
   __name: "component",
   props: {
     transform: { type: Function },
@@ -8378,19 +8425,19 @@ const zm = /* @__PURE__ */ pe({
   },
   setup(o, { expose: e }) {
     const t = o, n = ue(), s = ue(), i = ue();
-    return ft(() => {
+    return lt(() => {
       var r, a;
-      s.value = t.instanceMesh ?? ((r = n.value) == null ? void 0 : r.children.find((l) => l.hasOwnProperty("instanceMatrix"))), i.value = t.mesh ?? ((a = n.value) == null ? void 0 : a.children.find((l) => l.type === "Mesh")), ef(i.value, t.count, s.value, t.weight, t.transform);
+      s.value = t.instanceMesh ?? ((r = n.value) == null ? void 0 : r.children.find((l) => l.hasOwnProperty("instanceMatrix"))), i.value = t.mesh ?? ((a = n.value) == null ? void 0 : a.children.find((l) => l.type === "Mesh")), cf(i.value, t.count, s.value, t.weight, t.transform);
     }), e({
       samplerRef: n
-    }), (r, a) => (fe(), de("TresGroup", {
+    }), (r, a) => (le(), ce("TresGroup", {
       ref_key: "samplerRef",
       ref: n
     }, [
-      $e(r.$slots, "default")
+      Ve(r.$slots, "default")
     ], 512));
   }
-}), Rs = {
+}), ks = {
   sunset: "venice/venice_sunset_1k.hdr",
   studio: "studio/poly_haven_studio_1k.hdr",
   city: "city/canary_wharf_1k.hdr",
@@ -8403,81 +8450,84 @@ const zm = /* @__PURE__ */ pe({
   urban: "indoor/abandoned_games_room_02_1k.hdr",
   modern: "city/modern_buildings_2_1k.hdr",
   shangai: "city/shanghai_bund_1k.hdr"
-}, tf = "https://raw.githubusercontent.com/Tresjs/assets/main/textures/hdr/";
-async function nf(o) {
-  const { scene: e } = je(), {
-    preset: t,
-    blur: n,
-    files: s = [],
-    path: i = "",
-    background: r
-  } = Fe(o), a = ue(), l = Ne(() => Array.isArray(s.value)), c = Ne(() => l.value ? Il : Zr), u = ue(null);
-  return we(() => [s, i], async ([h, m]) => {
-    if (h.value.length > 0 && !t.value) {
+}, uf = "https://raw.githubusercontent.com/Tresjs/assets/main/textures/hdr/";
+async function hf(o, e) {
+  const { scene: t } = Ue(), {
+    preset: n,
+    blur: s,
+    files: i = [],
+    path: r = "",
+    background: a
+  } = Oe(o), l = ue(), c = Ne(() => Array.isArray(i.value)), u = Ne(() => c.value ? Bl : to), h = ue(null);
+  return Te(() => [i, r], async ([f, d]) => {
+    if (f.value.length > 0 && !n.value) {
       try {
-        u.value = await rs(
-          z(c),
-          l.value ? [z(h)] : z(h),
-          (p) => {
-            m.value && p.setPath(z(m));
+        h.value = await ds(
+          B(u),
+          c.value ? [B(f)] : B(f),
+          (y) => {
+            d.value && y.setPath(B(d));
           }
         );
-      } catch (p) {
-        throw new Error(`Failed to load environment map: ${p}`);
+      } catch (y) {
+        throw new Error(`Failed to load environment map: ${y}`);
       }
-      u.value && (a.value = l.value ? u.value[0] : u.value, a.value.mapping = l.value ? Dl : ji);
+      h.value && (l.value = c.value ? h.value[0] : h.value, l.value.mapping = c.value ? Ul : Ki);
     }
   }, {
     immediate: !0
-  }), we(() => a.value, (h) => {
-    e.value && (e.value.environment = h);
+  }), Te(() => l.value, (f) => {
+    t.value && (t.value.environment = f);
   }, {
     immediate: !0
-  }), we(() => [r.value, a.value], ([h, m]) => {
-    e.value && (e.value.background = h ? m : void 0);
+  }), Te(() => [a.value, l.value], ([f, d]) => {
+    if (t.value) {
+      let y = e != null && e.value ? e.value.texture : d;
+      t.value.background = f ? y : void 0;
+    }
   }, {
     immediate: !0
-  }), we(() => n == null ? void 0 : n.value, (h) => {
-    e.value && (e.value.backgroundBlurriness = h);
+  }), Te(() => s == null ? void 0 : s.value, (f) => {
+    t.value && (t.value.backgroundBlurriness = f);
   }, {
     immediate: !0
-  }), we(t, async (h) => {
-    if (h && h in Rs) {
-      const m = tf, p = Rs[h];
+  }), Te(n, async (f) => {
+    if (f && f in ks) {
+      const d = uf, y = ks[f];
       try {
-        u.value = await rs(
-          Zr,
-          p,
-          (v) => {
-            m && v.setPath(m);
+        h.value = await ds(
+          to,
+          y,
+          (x) => {
+            d && x.setPath(d);
           }
         );
-      } catch (v) {
-        throw new Error(`Failed to load environment map: ${v}`);
+      } catch (x) {
+        throw new Error(`Failed to load environment map: ${x}`);
       }
-      u.value && (a.value = u.value, a.value.mapping = ji);
-    } else if (h && !(h in Rs))
-      throw new Error(`Preset must be one of: ${Object.keys(Rs).join(", ")}`);
+      h.value && (l.value = h.value, l.value.mapping = Ki);
+    } else if (f && !(f in ks))
+      throw new Error(`Preset must be one of: ${Object.keys(ks).join(", ")}`);
   }, {
     immediate: !0
-  }), { texture: a };
+  }), { texture: l };
 }
-let Cs = null;
-function sf(o, e) {
+let Bs = null;
+function ff(o, e) {
   return (t) => {
-    e && e(t), o.draco && (Cs || (Cs = new hh()), Cs.setDecoderPath(o.decoderPath || "https://www.gstatic.com/draco/versioned/decoders/1.4.3/"), t.setDRACOLoader(Cs));
+    e && e(t), o.draco && (Bs || (Bs = new xh()), Bs.setDecoderPath(o.decoderPath || "https://www.gstatic.com/draco/versioned/decoders/1.4.3/"), t.setDRACOLoader(Bs));
   };
 }
-async function rf(o, e = {
+async function df(o, e = {
   draco: !1
 }, t) {
-  return await rs(
-    ou,
+  return await ds(
+    pu,
     o,
-    sf(e, t)
+    ff(e, t)
   );
 }
-const of = ["object"], Gm = /* @__PURE__ */ pe({
+const pf = ["object"], lg = /* @__PURE__ */ pe({
   __name: "component",
   props: {
     path: {},
@@ -8492,23 +8542,23 @@ const of = ["object"], Gm = /* @__PURE__ */ pe({
     e({
       value: i
     });
-    const { scene: r } = ([t, n] = fs(() => rf(s.path, {
+    const { scene: r } = ([t, n] = Xn(() => df(s.path, {
       draco: s.draco,
       decoderPath: s.decoderPath
     })), t = await t, n(), t);
     return (s.castShadow || s.receiveShadow) && r.traverse((a) => {
       a.isMesh && (a.castShadow = s.castShadow, a.receiveShadow = s.receiveShadow);
-    }), (a, l) => (fe(), de("primitive", Ye({
+    }), (a, l) => (le(), ce("primitive", Ye({
       ref_key: "modelRef",
       ref: i,
-      object: z(r)
-    }, a.$attrs), null, 16, of));
+      object: B(r)
+    }, a.$attrs), null, 16, pf));
   }
 });
-async function af(o) {
-  return await rs($u, o);
+async function mf(o) {
+  return await ds(sh, o);
 }
-const lf = ["object"], jm = /* @__PURE__ */ pe({
+const gf = ["object"], cg = /* @__PURE__ */ pe({
   __name: "component",
   props: {
     path: {},
@@ -8521,16 +8571,16 @@ const lf = ["object"], jm = /* @__PURE__ */ pe({
     e({
       value: i
     });
-    const r = ([t, n] = fs(() => af(s.path)), t = await t, n(), t);
+    const r = ([t, n] = Xn(() => mf(s.path)), t = await t, n(), t);
     return (s.castShadow || s.receiveShadow) && r.traverse((a) => {
       a.isMesh && (a.castShadow = s.castShadow, a.receiveShadow = s.receiveShadow);
-    }), (a, l) => (fe(), de("primitive", Ye({
+    }), (a, l) => (le(), ce("primitive", Ye({
       ref_key: "modelRef",
       ref: i,
-      object: z(r)
-    }, a.$attrs), null, 16, lf));
+      object: B(r)
+    }, a.$attrs), null, 16, gf));
   }
-}), cf = ["geometry", "render-order"], Vm = /* @__PURE__ */ pe({
+}), vf = ["geometry", "render-order"], ug = /* @__PURE__ */ pe({
   __name: "component",
   props: {
     src: {},
@@ -8552,88 +8602,88 @@ const lf = ["object"], jm = /* @__PURE__ */ pe({
       fillMeshProps: l,
       strokeMeshProps: c,
       depth: u
-    } = Fe(t), h = xe(), m = xe([]), p = xe([]);
-    e({ value: h }), ft(async () => v(n.value).then((E) => p.value = E.paths)), we([i, s, r, a, p], y);
-    async function v(E) {
-      const R = E.startsWith("<svg") ? encodeURI(`data:image/svg+xml;utf8,${E}`) : E;
-      return rs(is, R);
-    }
-    ot(_);
-    function _() {
-      m.value.forEach((E) => E.geometry.dispose());
-    }
-    function y() {
-      var A, x, M;
-      _();
-      const E = [], [R, T] = (() => {
-        const d = { flat: !1, renderOrder: !1, offsetZ: !0 }, w = { flat: 0, renderOrder: 0, offsetZ: 0.025 }, f = u.value;
-        return typeof f == "number" ? [!0, f] : [d[f], w[f]];
+    } = Oe(t), h = me(), f = me([]), d = me([]);
+    e({ value: h }), lt(async () => y(n.value).then((v) => d.value = v.paths)), Te([i, s, r, a, d], g);
+    async function y(v) {
+      const M = v.startsWith("<svg") ? encodeURI(`data:image/svg+xml;utf8,${v}`) : v;
+      return ds(hs, M);
+    }
+    ot(x);
+    function x() {
+      f.value.forEach((v) => v.geometry.dispose());
+    }
+    function g() {
+      var P, T, E;
+      x();
+      const v = [], [M, _] = (() => {
+        const m = { flat: !1, renderOrder: !1, offsetZ: !0 }, b = { flat: 0, renderOrder: 0, offsetZ: 0.025 }, p = u.value;
+        return typeof p == "number" ? [!0, p] : [m[p], b[p]];
       })();
-      let g = 0;
-      for (const d of p.value) {
-        const w = ((A = d.userData) == null ? void 0 : A.style) ?? {}, f = Object.assign(
+      let w = 0;
+      for (const m of d.value) {
+        const b = ((P = m.userData) == null ? void 0 : P.style) ?? {}, p = Object.assign(
           {
-            color: w.fill,
-            opacity: w.fillOpacity,
+            color: b.fill,
+            opacity: b.fillOpacity,
             transparent: !0,
-            side: wn,
-            depthWrite: R
+            side: dn,
+            depthWrite: M
           },
           t.fillMaterial
         );
-        if (!i.value && w.fill !== void 0 && w.fill !== "none")
-          for (const P of is.createShapes(d)) {
-            const I = new Ll(P);
-            I.scale(1, -1, 1), T && I.translate(0, 0, g++ * T), E.push({
+        if (!i.value && b.fill !== void 0 && b.fill !== "none")
+          for (const C of hs.createShapes(m)) {
+            const I = new Nl(C);
+            I.scale(1, -1, 1), _ && I.translate(0, 0, w++ * _), v.push({
               geometry: I,
-              material: f,
+              material: p,
               isStroke: !1
             });
           }
-        if (!s.value && w.stroke !== void 0 && w.stroke !== "none") {
-          const P = Object.assign(
+        if (!s.value && b.stroke !== void 0 && b.stroke !== "none") {
+          const C = Object.assign(
             {
-              color: (x = d.userData) == null ? void 0 : x.style.stroke,
-              opacity: (M = d.userData) == null ? void 0 : M.style.strokeOpacity,
+              color: (T = m.userData) == null ? void 0 : T.style.stroke,
+              opacity: (E = m.userData) == null ? void 0 : E.style.strokeOpacity,
               transparent: !0,
-              side: wn,
-              depthWrite: R
+              side: dn,
+              depthWrite: M
             },
             t.strokeMaterial
           );
-          for (const I of d.subPaths) {
-            const K = I.getPoints().map((Z) => new le(Z.x, -Z.y)), N = is.pointsToStroke(K, w || "none");
-            T && N.translate(0, 0, g++ * T), E.push({
-              geometry: N,
-              material: P,
+          for (const I of m.subPaths) {
+            const K = I.getPoints().map((Y) => new he(Y.x, -Y.y)), z = hs.pointsToStroke(K, b || "none");
+            _ && z.translate(0, 0, w++ * _), v.push({
+              geometry: z,
+              material: C,
               isStroke: !0
             });
           }
         }
       }
-      m.value = E;
+      f.value = v;
     }
-    return (E, R) => (fe(), de("TresGroup", {
+    return (v, M) => (le(), ce("TresGroup", {
       ref_key: "svgRef",
       ref: h
     }, [
-      (fe(!0), de(la, null, ca(m.value, ({ geometry: T, material: g, isStroke: A }, x) => (fe(), de("TresMesh", Ye({
-        key: `${x}`
-      }, A ? z(c) : z(l), {
-        geometry: T,
-        "render-order": z(u) === "renderOrder" ? x : 0
+      (le(!0), ce(pa, null, ma(f.value, ({ geometry: _, material: w, isStroke: P }, T) => (le(), ce("TresMesh", Ye({
+        key: `${T}`
+      }, P ? B(c) : B(l), {
+        geometry: _,
+        "render-order": B(u) === "renderOrder" ? T : 0
       }), [
-        Te("TresMeshBasicMaterial", ua(ha(g)), null, 16)
-      ], 16, cf))), 128))
+        ye("TresMeshBasicMaterial", ga(va(w)), null, 16)
+      ], 16, vf))), 128))
     ], 512));
   }
-}), no = "[TresJS - Cientos ▲ ■ ♥] ";
-function gr() {
+}), lo = "[TresJS - Cientos ▲ ■ ♥] ";
+function Tr() {
   function o(n, s) {
-    console.error(`${no} ${n}`, s || "");
+    console.error(`${lo} ${n}`, s || "");
   }
   function e(n) {
-    console.warn(`${no} ${n}`);
+    console.warn(`${lo} ${n}`);
   }
   function t(n, s) {
   }
@@ -8643,17 +8693,17 @@ function gr() {
     logMessage: t
   };
 }
-let wi = 0;
-function Ym() {
-  const o = ue(!1), e = ue(0), t = ue([]), { logError: n } = gr();
+let Ai = 0;
+function hg() {
+  const o = ue(!1), e = ue(0), t = ue([]), { logError: n } = Tr();
   return new Promise((s) => {
-    Ts.onStart = () => {
+    Cs.onStart = () => {
       o.value = !1;
-    }, Ts.onLoad = () => {
+    }, Cs.onLoad = () => {
       o.value = !0;
-    }, Ts.onProgress = (i, r, a) => {
-      r === a && (wi = a, o.value = !0, t.value.push(i)), e.value = Math.round((r - wi) / (a - wi) * 100 || 100, 2);
-    }, Ts.onError = (i) => {
+    }, Cs.onProgress = (i, r, a) => {
+      r === a && (Ai = a, o.value = !0, t.value.push(i)), e.value = Math.round((r - Ai) / (a - Ai) * 100 || 100, 2);
+    }, Cs.onError = (i) => {
       n("Error loading assets", new Error(i)), o.value = !0;
     }, s({
       items: t,
@@ -8662,8 +8712,8 @@ function Ym() {
     });
   });
 }
-async function Xm(o, e) {
-  const { logError: t } = gr();
+async function fg(o, e) {
+  const { logError: t } = Tr();
   if (!o)
     return t("Error no path provided");
   const { unsuspend: n, start: s, crossOrigin: i, muted: r, loop: a, ...l } = {
@@ -8677,15 +8727,15 @@ async function Xm(o, e) {
   };
   function c() {
     return new Promise((u, h) => {
-      const m = Object.assign(document.createElement("video"), {
+      const f = Object.assign(document.createElement("video"), {
         src: typeof o == "string" && o || void 0,
         crossOrigin: i,
         loop: a,
         muted: r,
         autoplay: !0,
         ...l
-      }), p = new Ol(m);
-      return m.addEventListener(n, () => u(p)), m.addEventListener("error", () => h()), p;
+      }), d = new zl(f);
+      return f.addEventListener(n, () => u(d)), f.addEventListener("error", () => h()), d;
     });
   }
   try {
@@ -8695,7 +8745,7 @@ async function Xm(o, e) {
     t("Error loading resource");
   }
 }
-const uf = ["target", "auto-rotate", "auto-rotate-speed", "enable-damping", "damping-factor", "enable-pan", "key-pan-speed", "keys", "max-azimuth-angle", "min-azimuth-angle", "max-polar-angle", "min-polar-angle", "min-distance", "max-distance", "min-zoom", "max-zoom", "touches", "enable-zoom", "zoom-speed", "enable-rotate", "rotate-speed", "args"], Wm = /* @__PURE__ */ pe({
+const yf = ["target", "auto-rotate", "auto-rotate-speed", "enable-damping", "damping-factor", "enable-pan", "key-pan-speed", "keys", "max-azimuth-angle", "min-azimuth-angle", "max-polar-angle", "min-polar-angle", "min-distance", "max-distance", "min-zoom", "max-zoom", "touches", "enable-zoom", "zoom-speed", "enable-rotate", "rotate-speed", "args"], dg = /* @__PURE__ */ pe({
   __name: "OrbitControls",
   props: {
     makeDefault: { type: Boolean, default: !1 },
@@ -8717,7 +8767,7 @@ const uf = ["target", "auto-rotate", "auto-rotate-speed", "enable-damping", "dam
     maxDistance: { default: 1 / 0 },
     minZoom: { default: 0 },
     maxZoom: { default: 1 / 0 },
-    touches: { default: () => ({ ONE: Lt.ROTATE, TWO: Lt.DOLLY_PAN }) },
+    touches: { default: () => ({ ONE: Ft.ROTATE, TWO: Ft.DOLLY_PAN }) },
     enableZoom: { type: Boolean, default: !0 },
     zoomSpeed: { default: 1 },
     enableRotate: { type: Boolean, default: !0 },
@@ -8733,61 +8783,61 @@ const uf = ["target", "auto-rotate", "auto-rotate-speed", "enable-damping", "dam
       dampingFactor: c,
       enablePan: u,
       keyPanSpeed: h,
-      maxAzimuthAngle: m,
-      minAzimuthAngle: p,
-      maxPolarAngle: v,
-      minPolarAngle: _,
-      minDistance: y,
-      maxDistance: E,
-      minZoom: R,
-      maxZoom: T,
-      enableZoom: g,
-      zoomSpeed: A,
-      enableRotate: x,
-      touches: M,
-      rotateSpeed: d,
-      target: w
-    } = Fe(n), { camera: f, renderer: P, extend: I, controls: K } = je(), N = ue(null);
-    I({ OrbitControls: wa }), we(N, (X) => {
-      Z(), X && i.value ? K.value = X : K.value = null;
+      maxAzimuthAngle: f,
+      minAzimuthAngle: d,
+      maxPolarAngle: y,
+      minPolarAngle: x,
+      minDistance: g,
+      maxDistance: v,
+      minZoom: M,
+      maxZoom: _,
+      enableZoom: w,
+      zoomSpeed: P,
+      enableRotate: T,
+      touches: E,
+      rotateSpeed: m,
+      target: b
+    } = Oe(n), { camera: p, renderer: C, extend: I, controls: K } = Ue(), z = ue(null);
+    I({ OrbitControls: Pa }), Te(z, (X) => {
+      Y(), X && i.value ? K.value = X : K.value = null;
     });
-    function Z() {
-      Ve(N.value, "change", () => s("change", N.value)), Ve(N.value, "start", () => s("start", N.value)), Ve(N.value, "end", () => s("end", N.value));
+    function Y() {
+      Ge(z.value, "change", () => s("change", z.value)), Ge(z.value, "start", () => s("start", z.value)), Ge(z.value, "end", () => s("end", z.value));
     }
-    const { onLoop: W } = Ke();
+    const { onLoop: W } = Xe();
     return W(() => {
-      N.value && (l.value || r.value) && N.value.update();
+      z.value && (l.value || r.value) && z.value.update();
     }), ot(() => {
-      N.value && N.value.dispose();
-    }), e({ value: N }), (X, V) => (X.camera || z(f)) && (X.domElement || z(P)) ? (fe(), de("TresOrbitControls", {
+      z.value && z.value.dispose();
+    }), e({ value: z }), (X, V) => (X.camera || B(p)) && (X.domElement || B(C)) ? (le(), ce("TresOrbitControls", {
       key: 0,
       ref_key: "controlsRef",
-      ref: N,
-      target: z(w),
-      "auto-rotate": z(r),
-      "auto-rotate-speed": z(a),
-      "enable-damping": z(l),
-      "damping-factor": z(c),
-      "enable-pan": z(u),
-      "key-pan-speed": z(h),
+      ref: z,
+      target: B(b),
+      "auto-rotate": B(r),
+      "auto-rotate-speed": B(a),
+      "enable-damping": B(l),
+      "damping-factor": B(c),
+      "enable-pan": B(u),
+      "key-pan-speed": B(h),
       keys: X.keys,
-      "max-azimuth-angle": z(m),
-      "min-azimuth-angle": z(p),
-      "max-polar-angle": z(v),
-      "min-polar-angle": z(_),
-      "min-distance": z(y),
-      "max-distance": z(E),
-      "min-zoom": z(R),
-      "max-zoom": z(T),
-      touches: z(M),
-      "enable-zoom": z(g),
-      "zoom-speed": z(A),
-      "enable-rotate": z(x),
-      "rotate-speed": z(d),
-      args: [X.camera || z(f), X.domElement || z(P).domElement]
-    }, null, 8, uf)) : Wt("", !0);
-  }
-}), hf = 5, ff = 6, df = 0.3, $m = /* @__PURE__ */ pe({
+      "max-azimuth-angle": B(f),
+      "min-azimuth-angle": B(d),
+      "max-polar-angle": B(y),
+      "min-polar-angle": B(x),
+      "min-distance": B(g),
+      "max-distance": B(v),
+      "min-zoom": B(M),
+      "max-zoom": B(_),
+      touches: B(E),
+      "enable-zoom": B(w),
+      "zoom-speed": B(P),
+      "enable-rotate": B(T),
+      "rotate-speed": B(m),
+      args: [X.camera || B(p), X.domElement || B(C).domElement]
+    }, null, 8, yf)) : Ut("", !0);
+  }
+}), _f = 5, xf = 6, wf = 0.3, pg = /* @__PURE__ */ pe({
   __name: "KeyboardControls",
   props: {
     forward: { default: () => ["w", "W"] },
@@ -8801,68 +8851,69 @@ const uf = ["target", "auto-rotate", "auto-rotate-speed", "enable-damping", "dam
     is2D: { type: Boolean, default: !1 }
   },
   setup(o) {
-    var f;
-    const e = o, { forward: t, back: n, left: s, right: i, jump: r, gravity: a, moveSpeed: l, headBobbing: c, is2D: u } = Fe(e), { camera: h, controls: m } = je(), p = ue(0), v = ue(0), _ = ue(!1), y = ue(!1), E = ue(0), R = xe(), T = u.value ? "y" : "z", g = ((f = h.value.position) == null ? void 0 : f.y) || 0;
-    mn(
+    var p;
+    const e = o, { forward: t, back: n, left: s, right: i, jump: r, gravity: a, moveSpeed: l, headBobbing: c, is2D: u } = Oe(e), { camera: h, controls: f } = Ue(), d = ue(0), y = ue(0), x = ue(!1), g = ue(!1), v = ue(0), M = me(), _ = u.value ? "y" : "z", w = ((p = h.value.position) == null ? void 0 : p.y) || 0;
+    yn(
       t.value,
       () => {
-        _.value = !0, v.value = l.value;
+        x.value = !0, y.value = l.value;
       },
       { eventName: "keydown" }
-    ), mn(
+    ), yn(
       n.value,
       () => {
-        _.value = !0, v.value = -l.value;
+        x.value = !0, y.value = -l.value;
       },
       { eventName: "keydown" }
-    ), mn(
+    ), yn(
       [...t.value, ...n.value],
       () => {
-        _.value = !1, v.value = 0;
+        x.value = !1, y.value = 0;
       },
       { eventName: "keyup" }
-    ), mn(
+    ), yn(
       s.value,
       () => {
-        _.value = !0, p.value = -l.value;
+        x.value = !0, d.value = -l.value;
       },
       { eventName: "keydown" }
-    ), mn(
+    ), yn(
       i.value,
       () => {
-        _.value = !0, p.value = l.value;
+        x.value = !0, d.value = l.value;
       },
       { eventName: "keydown" }
-    ), mn(
+    ), yn(
       [...s.value, ...i.value],
       () => {
-        _.value = !1, p.value = 0;
+        x.value = !1, d.value = 0;
       },
       { eventName: "keyup" }
-    ), mn(r.value, () => {
-      y.value || (E.value = Date.now()), y.value = !0;
+    ), yn(r.value, () => {
+      g.value || (v.value = Date.now()), g.value = !0;
     });
-    const A = (P) => _.value ? Math.sin(P * hf) * df + g : g, x = () => (Date.now() - E.value) / 1e3 * 3, M = (P) => g + ff * P - 0.5 * a.value * P ** 2, d = () => {
-      if (y.value) {
-        const P = M(x());
-        return P <= g && (y.value = !1), P;
+    const P = (C) => x.value ? Math.sin(C * _f) * wf + w : w, T = () => (Date.now() - v.value) / 1e3 * 3, E = (C) => w + xf * C - 0.5 * a.value * C ** 2, m = () => {
+      if (g.value) {
+        const C = E(T());
+        return C <= w && (g.value = !1), C;
       }
       return 0;
-    }, { onLoop: w } = Ke();
-    return w(({ elapsed: P }) => {
+    }, { onLoop: b } = Xe();
+    return b(({ elapsed: C }) => {
       var I;
-      m.value instanceof qi && ((I = m.value) != null && I.isLocked) ? (m.value.moveForward(v.value), m.value.moveRight(p.value), h.value.position && (h.value.position.y = c.value ? A(P) : g, h.value.position.y += d())) : R.value.children.length > 0 && !(m.value instanceof qi) && (R.value.position.x += p.value, R.value.position[T] += u.value ? v.value : -v.value);
-    }), (P, I) => (fe(), de("TresGroup", {
+      f.value instanceof nr && ((I = f.value) != null && I.isLocked) ? (f.value.moveForward(y.value), f.value.moveRight(d.value), h.value.position && (h.value.position.y = c.value ? P(C) : w, h.value.position.y += m())) : M.value.children.length > 0 && !(f.value instanceof nr) && (M.value.position.x += d.value, M.value.position[_] += u.value ? y.value : -y.value);
+    }), (C, I) => (le(), ce("TresGroup", {
       ref_key: "wrapperRef",
-      ref: R
+      ref: M
     }, [
-      $e(P.$slots, "default")
+      Ve(C.$slots, "default")
     ], 512));
   }
-}), pf = ["object", "args", "mode", "enabled", "axis", "translation-snap", "rotation-snap", "scale-snap", "space", "size", "show-x", "show-y", "show-z"], Zm = /* @__PURE__ */ pe({
+}), Tf = ["object", "args", "mode", "enabled", "axis", "translation-snap", "rotation-snap", "scale-snap", "space", "size", "show-x", "show-y", "show-z"], mg = /* @__PURE__ */ pe({
   __name: "TransformControls",
   props: {
     object: {},
+    camera: {},
     mode: { default: "translate" },
     enabled: { type: Boolean, default: !0 },
     axis: { default: "XYZ" },
@@ -8877,39 +8928,42 @@ const uf = ["target", "auto-rotate", "auto-rotate-speed", "enable-damping", "dam
   },
   emits: ["dragging", "change", "mouseDown", "mouseUp", "objectChange"],
   setup(o, { emit: e }) {
-    const t = o, n = e, { object: s, mode: i, enabled: r, axis: a, translationSnap: l, rotationSnap: c, scaleSnap: u, space: h, size: m, showX: p, showY: v, showZ: _ } = Fe(t), y = xe(), { controls: E, camera: R, renderer: T, extend: g } = je();
-    g({ TransformControls: $c });
-    const A = (M) => {
-      E.value && (E.value.enabled = !M.value), n("dragging", M.value);
+    const t = o, n = e, { object: s, mode: i, enabled: r, axis: a, translationSnap: l, rotationSnap: c, scaleSnap: u, space: h, size: f, showX: d, showY: y, showZ: x } = Oe(t), g = me(), { controls: v, camera: M, renderer: _, extend: w } = Ue();
+    w({ TransformControls: nu });
+    const P = (E) => {
+      v.value && (v.value.enabled = !E.value), n("dragging", E.value);
     };
-    function x() {
-      Ve(y.value, "change", () => n("change")), Ve(y.value, "dragging-changed", A), Ve(y.value, "mouseDown", () => n("mouseDown")), Ve(y.value, "mouseUp", () => n("mouseUp")), Ve(y.value, "objectChange", () => n("objectChange"));
+    function T() {
+      Ge(g.value, "change", () => n("change")), Ge(g.value, "dragging-changed", P), Ge(g.value, "mouseDown", () => n("mouseDown")), Ge(g.value, "mouseUp", () => n("mouseUp")), Ge(g.value, "objectChange", () => n("objectChange"));
     }
-    return ft(() => {
-      y.value && x();
+    return lt(() => {
+      g.value && T();
     }), ot(() => {
-      y.value && y.value.dispose();
-    }), (M, d) => z(R) && z(T) ? (fe(), de("TresTransformControls", {
-      key: 0,
-      ref_key: "controlsRef",
-      ref: y,
-      object: z(s),
-      args: [z(R), z(T).domElement],
-      mode: z(i),
-      enabled: z(r),
-      axis: z(a),
-      "translation-snap": z(l),
-      "rotation-snap": z(c),
-      "scale-snap": z(u),
-      space: z(h),
-      size: z(m),
-      "show-x": z(p),
-      "show-y": z(v),
-      "show-z": z(_),
-      visible: !0
-    }, null, 8, pf)) : Wt("", !0);
-  }
-}), mf = ["args"], Km = /* @__PURE__ */ pe({
+      g.value && g.value.dispose();
+    }), (E, m) => {
+      var b;
+      return (E.camera || B(M)) && B(_) ? (le(), ce("TresTransformControls", {
+        ref_key: "controlsRef",
+        ref: g,
+        key: (b = E.camera || B(M)) == null ? void 0 : b.uuid,
+        object: B(s),
+        args: [E.camera || B(M), B(_).domElement],
+        mode: B(i),
+        enabled: B(r),
+        axis: B(a),
+        "translation-snap": B(l),
+        "rotation-snap": B(c),
+        "scale-snap": B(u),
+        space: B(h),
+        size: B(f),
+        "show-x": B(d),
+        "show-y": B(y),
+        "show-z": B(x),
+        visible: !0
+      }, null, 8, Tf)) : Ut("", !0);
+    };
+  }
+}), bf = ["args"], gg = /* @__PURE__ */ pe({
   __name: "PointerLockControls",
   props: {
     makeDefault: { type: Boolean, default: !1 },
@@ -8919,32 +8973,32 @@ const uf = ["target", "auto-rotate", "auto-rotate-speed", "enable-damping", "dam
   },
   emits: ["isLock", "change"],
   setup(o, { expose: e, emit: t }) {
-    const n = o, s = t, { camera: i, renderer: r, extend: a, controls: l } = je(), c = ue(null);
+    const n = o, s = t, { camera: i, renderer: r, extend: a, controls: l } = Ue(), c = ue(null);
     let u;
-    a({ PointerLockControls: qi });
-    const h = (m) => {
-      s("isLock", m);
+    a({ PointerLockControls: nr });
+    const h = (f) => {
+      s("isLock", f);
     };
-    return we(c, (m) => {
-      m && n.makeDefault ? l.value = m : l.value = null;
-      const p = document.getElementById(n.selector || "");
-      u = p || r.value.domElement, Ve(l.value, "change", () => s("change", l.value)), Ve(u, "click", () => {
-        var v, _, y;
-        (v = l.value) == null || v.lock(), (_ = l.value) == null || _.addEventListener("lock", () => h(!0)), (y = l.value) == null || y.addEventListener("unlock", () => h(!1));
+    return Te(c, (f) => {
+      f && n.makeDefault ? l.value = f : l.value = null;
+      const d = document.getElementById(n.selector || "");
+      u = d || r.value.domElement, Ge(l.value, "change", () => s("change", l.value)), Ge(u, "click", () => {
+        var y, x, g;
+        (y = l.value) == null || y.lock(), (x = l.value) == null || x.addEventListener("lock", () => h(!0)), (g = l.value) == null || g.addEventListener("unlock", () => h(!1));
       });
     }), ot(() => {
-      var m, p;
-      (m = l.value) == null || m.removeEventListener("lock", () => h(!0)), (p = l.value) == null || p.removeEventListener("unlock", () => h(!1)), c.value && c.value.dispose();
+      var f, d;
+      (f = l.value) == null || f.removeEventListener("lock", () => h(!0)), (d = l.value) == null || d.removeEventListener("unlock", () => h(!1)), c.value && c.value.dispose();
     }), e({
       value: l
-    }), (m, p) => (m.camera || z(i)) && (m.domElement || z(r)) ? (fe(), de("TresPointerLockControls", {
+    }), (f, d) => (f.camera || B(i)) && (f.domElement || B(r)) ? (le(), ce("TresPointerLockControls", {
       key: 0,
       ref_key: "controlsRef",
       ref: c,
-      args: [m.camera || z(i), m.domElement || z(r).domElement]
-    }, null, 8, mf)) : Wt("", !0);
+      args: [f.camera || B(i), f.domElement || B(r).domElement]
+    }, null, 8, bf)) : Ut("", !0);
   }
-}), gf = ["args"], qm = /* @__PURE__ */ pe({
+}), Ef = ["args"], vg = /* @__PURE__ */ pe({
   __name: "MapControls",
   props: {
     makeDefault: { type: Boolean, default: !1 },
@@ -8952,19 +9006,19 @@ const uf = ["target", "auto-rotate", "auto-rotate-speed", "enable-damping", "dam
     domElement: {}
   },
   setup(o) {
-    const e = o, { camera: t, renderer: n, extend: s, controls: i } = je(), r = ue(null);
-    return s({ MapControls: ru }), we(i, (a) => {
+    const e = o, { camera: t, renderer: n, extend: s, controls: i } = Ue(), r = ue(null);
+    return s({ MapControls: du }), Te(i, (a) => {
       a && e.makeDefault ? i.value = a : i.value = null;
     }), ot(() => {
       r.value && r.value.dispose();
-    }), (a, l) => (a.camera || z(t)) && (a.domElement || z(n)) ? (fe(), de("TresMapControls", {
+    }), (a, l) => (a.camera || B(t)) && (a.domElement || B(n)) ? (le(), ce("TresMapControls", {
       key: 0,
       ref_key: "controlsRef",
       ref: r,
-      args: [a.camera || z(t), a.domElement || z(n).domElement]
-    }, null, 8, gf)) : Wt("", !0);
+      args: [a.camera || B(t), a.domElement || B(n).domElement]
+    }, null, 8, Ef)) : Ut("", !0);
   }
-}), Qm = /* @__PURE__ */ pe({
+}), yg = /* @__PURE__ */ pe({
   __name: "ScrollControls",
   props: {
     pages: { default: 4 },
@@ -8975,65 +9029,65 @@ const uf = ["target", "auto-rotate", "auto-rotate-speed", "enable-damping", "dam
   },
   emits: ["update:modelValue"],
   setup(o, { emit: e }) {
-    const t = o, n = e, { logWarning: s } = ps();
+    const t = o, n = e, { logWarning: s } = ws();
     t.smoothScroll < 0 && s("SmoothControl must be greater than zero"), t.pages < 0 && s("Pages must be greater than zero");
-    const { camera: i, controls: r, renderer: a } = je(), l = xe(), c = document.createElement("div"), { y: u } = Oh(), { x: h, y: m, isScrolling: p } = Ih(c), { height: v, width: _ } = La();
-    let y = 0;
-    const E = ue(!1), R = ue(0), T = ue(0), g = ue(0), A = t.horizontal ? "x" : "y", x = we(
+    const { camera: i, controls: r, renderer: a } = Ue(), l = me(), c = document.createElement("div"), { y: u } = jh(), { x: h, y: f, isScrolling: d } = Nh(c), { height: y, width: x } = Ha();
+    let g = 0;
+    const v = ue(!1), M = ue(0), _ = ue(0), w = ue(0), P = t.horizontal ? "x" : "y", T = Te(
       i,
-      (d) => {
-        if (E.value) {
-          x();
+      (m) => {
+        if (v.value) {
+          T();
           return;
         }
-        y = t.horizontal ? (d == null ? void 0 : d.position.x) || 0 : (d == null ? void 0 : d.position.y) || 0, E.value = !0;
+        g = t.horizontal ? (m == null ? void 0 : m.position.x) || 0 : (m == null ? void 0 : m.position.y) || 0, v.value = !0;
       },
       {
         immediate: !0
       }
     );
-    we(
-      p,
-      (d) => {
-        r.value && (r.value.enabled = !d);
+    Te(
+      d,
+      (m) => {
+        r.value && (r.value.enabled = !m);
       },
       {
         immediate: !0
       }
-    ), we(u, (d) => {
-      !p.value && !t.htmlScroll || (T.value = d / v.value / (g.value / v.value - 1), R.value = -1 * T.value, n("update:modelValue", T.value));
-    }), we(m, (d) => {
-      T.value = d / v.value / (g.value / v.value), R.value = -1 * T.value, n("update:modelValue", T.value);
-    }), we(h, (d) => {
-      T.value = d / _.value / (g.value / _.value - 1), R.value = +T.value, n("update:modelValue", T.value);
-    }), we(
+    ), Te(u, (m) => {
+      !d.value && !t.htmlScroll || (_.value = m / y.value / (w.value / y.value - 1), M.value = -1 * _.value, n("update:modelValue", _.value));
+    }), Te(f, (m) => {
+      _.value = m / y.value / (w.value / y.value), M.value = -1 * _.value, n("update:modelValue", _.value);
+    }), Te(h, (m) => {
+      _.value = m / x.value / (w.value / x.value - 1), M.value = +_.value, n("update:modelValue", _.value);
+    }), Te(
       a,
-      (d) => {
-        var f, P;
-        const w = d == null ? void 0 : d.domElement;
-        if (t.htmlScroll && (d != null && d.domElement))
-          w != null && w.style.width && (w != null && w.style.position) && (w != null && w.style.top) && (w != null && w.style.left) && (w.style.width = "100%", w.style.position = "fixed", w.style.zIndex = " -99999", w.style.top = "0", w.style.left = "0"), g.value = document.body.scrollHeight;
+      (m) => {
+        var p, C;
+        const b = m == null ? void 0 : m.domElement;
+        if (t.htmlScroll && (m != null && m.domElement))
+          b != null && b.style.width && (b != null && b.style.position) && (b != null && b.style.top) && (b != null && b.style.left) && (b.style.width = "100%", b.style.position = "fixed", b.style.zIndex = " -99999", b.style.top = "0", b.style.left = "0"), w.value = document.body.scrollHeight;
         else {
           const I = document.createElement("div"), K = document.createElement("div");
-          c.style[t.horizontal ? "overflowX" : "overflowY"] = "auto", c.style[t.horizontal ? "overflowY" : "overflowX"] = "hidden", c.style.position = "absolute", c.style.width = "100%", c.style.height = " 100%", c.style.top = "0", c.style.left = "0", c.classList.add("scrollContainer"), I.style.position = "sticky", I.style.top = "0px", I.style.left = "0px", I.style.width = "100%", I.style.height = "100%", I.style.overflow = "hidden", c.appendChild(I), K.style.height = t.horizontal ? "100%" : `${v.value * t.pages}px`, K.style.width = t.horizontal ? `${_.value * t.pages}px` : "100vw", K.style.pointerEvents = "none", w.style.position = "fixed", w.style.zIndex = "0", w != null && w.style.width && (w.style.width = "100%"), c.appendChild(K), d.domElement.parentNode.style.position = "relative", (P = (f = d == null ? void 0 : d.domElement) == null ? void 0 : f.parentNode) == null || P.appendChild(c), g.value = t.horizontal ? _.value * t.pages : v.value * t.pages;
+          c.style[t.horizontal ? "overflowX" : "overflowY"] = "auto", c.style[t.horizontal ? "overflowY" : "overflowX"] = "hidden", c.style.position = "absolute", c.style.width = "100%", c.style.height = " 100%", c.style.top = "0", c.style.left = "0", c.classList.add("scrollContainer"), I.style.position = "sticky", I.style.top = "0px", I.style.left = "0px", I.style.width = "100%", I.style.height = "100%", I.style.overflow = "hidden", c.appendChild(I), K.style.height = t.horizontal ? "100%" : `${y.value * t.pages}px`, K.style.width = t.horizontal ? `${x.value * t.pages}px` : "100vw", K.style.pointerEvents = "none", b.style.position = "fixed", b.style.zIndex = "0", b != null && b.style.width && (b.style.width = "100%"), c.appendChild(K), m.domElement.parentNode.style.position = "relative", (C = (p = m == null ? void 0 : m.domElement) == null ? void 0 : p.parentNode) == null || C.appendChild(c), w.value = t.horizontal ? x.value * t.pages : y.value * t.pages;
         }
       },
       {
         immediate: !0
       }
     );
-    const { onLoop: M } = Ke();
-    return M(() => {
-      var d;
-      if ((d = i.value) != null && d.position) {
-        const w = (R.value * t.distance - i.value.position[A] + y) * t.smoothScroll;
-        i.value.position[A] += w, l.value.children.length > 0 && (l.value.position[A] += w);
+    const { onLoop: E } = Xe();
+    return E(() => {
+      var m;
+      if ((m = i.value) != null && m.position) {
+        const b = (M.value * t.distance - i.value.position[P] + g) * t.smoothScroll;
+        i.value.position[P] += b, l.value.children.length > 0 && (l.value.position[P] += b);
       }
-    }), (d, w) => (fe(), de("TresGroup", {
+    }), (m, b) => (le(), ce("TresGroup", {
       ref_key: "wrapperRef",
       ref: l
     }, [
-      $e(d.$slots, "default")
+      Ve(m.$slots, "default")
     ], 512));
   }
 });
@@ -9043,11 +9097,11 @@ const uf = ["target", "auto-rotate", "auto-rotate-speed", "enable-damping", "dam
  * (c) 2017 @yomotsu
  * Released under the MIT License.
  */
-const ye = {
+const We = {
   LEFT: 1,
   RIGHT: 2,
   MIDDLE: 4
-}, Q = Object.freeze({
+}, J = Object.freeze({
   NONE: 0,
   ROTATE: 1,
   TRUCK: 2,
@@ -9065,71 +9119,71 @@ const ye = {
   TOUCH_ZOOM_TRUCK: 8192,
   TOUCH_ZOOM_OFFSET: 16384,
   TOUCH_ZOOM_ROTATE: 32768
-}), Dn = {
+}), Ln = {
   NONE: 0,
   IN: 1,
   OUT: -1
 };
-function gn(o) {
+function _n(o) {
   return o.isPerspectiveCamera;
 }
-function sn(o) {
+function on(o) {
   return o.isOrthographicCamera;
 }
-const Ln = Math.PI * 2, so = Math.PI / 2, Na = 1e-5, $n = Math.PI / 180;
-function Et(o, e, t) {
+const Fn = Math.PI * 2, co = Math.PI / 2, Xa = 1e-5, ts = Math.PI / 180;
+function At(o, e, t) {
   return Math.max(e, Math.min(t, o));
 }
-function ze(o, e = Na) {
+function ze(o, e = Xa) {
   return Math.abs(o) < e;
 }
-function ke(o, e, t = Na) {
+function ke(o, e, t = Xa) {
   return ze(o - e, t);
 }
-function io(o, e) {
+function uo(o, e) {
   return Math.round(o / e) * e;
 }
-function Zn(o) {
+function ns(o) {
   return isFinite(o) ? o : o < 0 ? -Number.MAX_VALUE : Number.MAX_VALUE;
 }
-function Kn(o) {
+function ss(o) {
   return Math.abs(o) < Number.MAX_VALUE ? o : o * (1 / 0);
 }
-function Is(o, e, t, n, s = 1 / 0, i) {
+function Us(o, e, t, n, s = 1 / 0, i) {
   n = Math.max(1e-4, n);
   const r = 2 / n, a = r * i, l = 1 / (1 + a + 0.48 * a * a + 0.235 * a * a * a);
   let c = o - e;
   const u = e, h = s * n;
-  c = Et(c, -h, h), e = o - c;
-  const m = (t.value + r * c) * i;
-  t.value = (t.value - r * m) * l;
-  let p = e + (c + m) * l;
-  return u - o > 0 == p > u && (p = u, t.value = (p - u) / i), p;
+  c = At(c, -h, h), e = o - c;
+  const f = (t.value + r * c) * i;
+  t.value = (t.value - r * f) * l;
+  let d = e + (c + f) * l;
+  return u - o > 0 == d > u && (d = u, t.value = (d - u) / i), d;
 }
-function ro(o, e, t, n, s = 1 / 0, i, r) {
+function ho(o, e, t, n, s = 1 / 0, i, r) {
   n = Math.max(1e-4, n);
   const a = 2 / n, l = a * i, c = 1 / (1 + l + 0.48 * l * l + 0.235 * l * l * l);
-  let u = e.x, h = e.y, m = e.z, p = o.x - u, v = o.y - h, _ = o.z - m;
-  const y = u, E = h, R = m, T = s * n, g = T * T, A = p * p + v * v + _ * _;
-  if (A > g) {
-    const Z = Math.sqrt(A);
-    p = p / Z * T, v = v / Z * T, _ = _ / Z * T;
-  }
-  u = o.x - p, h = o.y - v, m = o.z - _;
-  const x = (t.x + a * p) * i, M = (t.y + a * v) * i, d = (t.z + a * _) * i;
-  t.x = (t.x - a * x) * c, t.y = (t.y - a * M) * c, t.z = (t.z - a * d) * c, r.x = u + (p + x) * c, r.y = h + (v + M) * c, r.z = m + (_ + d) * c;
-  const w = y - o.x, f = E - o.y, P = R - o.z, I = r.x - y, K = r.y - E, N = r.z - R;
-  return w * I + f * K + P * N > 0 && (r.x = y, r.y = E, r.z = R, t.x = (r.x - y) / i, t.y = (r.y - E) / i, t.z = (r.z - R) / i), r;
+  let u = e.x, h = e.y, f = e.z, d = o.x - u, y = o.y - h, x = o.z - f;
+  const g = u, v = h, M = f, _ = s * n, w = _ * _, P = d * d + y * y + x * x;
+  if (P > w) {
+    const Y = Math.sqrt(P);
+    d = d / Y * _, y = y / Y * _, x = x / Y * _;
+  }
+  u = o.x - d, h = o.y - y, f = o.z - x;
+  const T = (t.x + a * d) * i, E = (t.y + a * y) * i, m = (t.z + a * x) * i;
+  t.x = (t.x - a * T) * c, t.y = (t.y - a * E) * c, t.z = (t.z - a * m) * c, r.x = u + (d + T) * c, r.y = h + (y + E) * c, r.z = f + (x + m) * c;
+  const b = g - o.x, p = v - o.y, C = M - o.z, I = r.x - g, K = r.y - v, z = r.z - M;
+  return b * I + p * K + C * z > 0 && (r.x = g, r.y = v, r.z = M, t.x = (r.x - g) / i, t.y = (r.y - v) / i, t.z = (r.z - M) / i), r;
 }
-function Ti(o, e) {
+function Pi(o, e) {
   e.set(0, 0), o.forEach((t) => {
     e.x += t.clientX, e.y += t.clientY;
   }), e.x /= o.length, e.y /= o.length;
 }
-function bi(o, e) {
-  return sn(o) ? (console.warn(`${e} is not supported in OrthographicCamera`), !0) : !1;
+function Ci(o, e) {
+  return on(o) ? (console.warn(`${e} is not supported in OrthographicCamera`), !0) : !1;
 }
-class yf {
+class Sf {
   constructor() {
     this._listeners = {};
   }
@@ -9193,9 +9247,10 @@ class yf {
     }
   }
 }
-const vf = "2.7.4", Ds = 1 / 8, za = typeof window < "u", _f = za && /Mac/.test(navigator.platform), xf = !(za && "PointerEvent" in window);
-let me, oo, Ls, Ei, at, Ee, Le, On, qn, Pt, Rt, yn, ao, lo, yt, Qn, Fn, co, Mi, uo, Si, Ai, Os;
-class ls extends yf {
+var Ri;
+const Mf = "2.8.3", Ns = 1 / 8, Af = /Mac/.test((Ri = globalThis == null ? void 0 : globalThis.navigator) === null || Ri === void 0 ? void 0 : Ri.platform);
+let ge, fo, zs, Ii, ct, Ee, Le, kn, is, Rt, It, xn, po, mo, yt, rs, Bn, go, Di, vo, Oi, Li, Hs;
+class gs extends Sf {
   /**
        * Injects THREE as the dependency. You can then proceed to use CameraControls.
        *
@@ -9237,14 +9292,14 @@ class ls extends yf {
        * @category Statics
        */
   static install(e) {
-    me = e.THREE, oo = Object.freeze(new me.Vector3(0, 0, 0)), Ls = Object.freeze(new me.Vector3(0, 1, 0)), Ei = Object.freeze(new me.Vector3(0, 0, 1)), at = new me.Vector2(), Ee = new me.Vector3(), Le = new me.Vector3(), On = new me.Vector3(), qn = new me.Vector3(), Pt = new me.Vector3(), Rt = new me.Vector3(), yn = new me.Vector3(), ao = new me.Vector3(), lo = new me.Vector3(), yt = new me.Spherical(), Qn = new me.Spherical(), Fn = new me.Box3(), co = new me.Box3(), Mi = new me.Sphere(), uo = new me.Quaternion(), Si = new me.Quaternion(), Ai = new me.Matrix4(), Os = new me.Raycaster();
+    ge = e.THREE, fo = Object.freeze(new ge.Vector3(0, 0, 0)), zs = Object.freeze(new ge.Vector3(0, 1, 0)), Ii = Object.freeze(new ge.Vector3(0, 0, 1)), ct = new ge.Vector2(), Ee = new ge.Vector3(), Le = new ge.Vector3(), kn = new ge.Vector3(), is = new ge.Vector3(), Rt = new ge.Vector3(), It = new ge.Vector3(), xn = new ge.Vector3(), po = new ge.Vector3(), mo = new ge.Vector3(), yt = new ge.Spherical(), rs = new ge.Spherical(), Bn = new ge.Box3(), go = new ge.Box3(), Di = new ge.Sphere(), vo = new ge.Quaternion(), Oi = new ge.Quaternion(), Li = new ge.Matrix4(), Hs = new ge.Raycaster();
   }
   /**
    * list all ACTIONs
    * @category Statics
    */
   static get ACTION() {
-    return Q;
+    return J;
   }
   /**
    * Creates a `CameraControls` instance.
@@ -9265,92 +9320,70 @@ class ls extends yf {
    */
   constructor(e, t) {
     super(), this.minPolarAngle = 0, this.maxPolarAngle = Math.PI, this.minAzimuthAngle = -1 / 0, this.maxAzimuthAngle = 1 / 0, this.minDistance = Number.EPSILON, this.maxDistance = 1 / 0, this.infinityDolly = !1, this.minZoom = 0.01, this.maxZoom = 1 / 0, this.smoothTime = 0.25, this.draggingSmoothTime = 0.125, this.maxSpeed = 1 / 0, this.azimuthRotateSpeed = 1, this.polarRotateSpeed = 1, this.dollySpeed = 1, this.dollyDragInverted = !1, this.truckSpeed = 2, this.dollyToCursor = !1, this.dragToOffset = !1, this.verticalDragToForward = !1, this.boundaryFriction = 0, this.restThreshold = 0.01, this.colliderMeshes = [], this.cancel = () => {
-    }, this._enabled = !0, this._state = Q.NONE, this._viewport = null, this._changedDolly = 0, this._changedZoom = 0, this._hasRested = !0, this._boundaryEnclosesCamera = !1, this._needsUpdate = !0, this._updatedLastTime = !1, this._elementRect = new DOMRect(), this._isDragging = !1, this._dragNeedsUpdate = !0, this._activePointers = [], this._lockedPointer = null, this._interactiveArea = new DOMRect(0, 0, 1, 1), this._isUserControllingRotate = !1, this._isUserControllingDolly = !1, this._isUserControllingTruck = !1, this._isUserControllingOffset = !1, this._isUserControllingZoom = !1, this._lastDollyDirection = Dn.NONE, this._thetaVelocity = { value: 0 }, this._phiVelocity = { value: 0 }, this._radiusVelocity = { value: 0 }, this._targetVelocity = new me.Vector3(), this._focalOffsetVelocity = new me.Vector3(), this._zoomVelocity = { value: 0 }, this._truckInternal = (g, A, x) => {
-      let M, d;
-      if (gn(this._camera)) {
-        const w = Ee.copy(this._camera.position).sub(this._target), f = this._camera.getEffectiveFOV() * $n, P = w.length() * Math.tan(f * 0.5);
-        M = this.truckSpeed * g * P / this._elementRect.height, d = this.truckSpeed * A * P / this._elementRect.height;
-      } else if (sn(this._camera)) {
-        const w = this._camera;
-        M = g * (w.right - w.left) / w.zoom / this._elementRect.width, d = A * (w.top - w.bottom) / w.zoom / this._elementRect.height;
+    }, this._enabled = !0, this._state = J.NONE, this._viewport = null, this._changedDolly = 0, this._changedZoom = 0, this._hasRested = !0, this._boundaryEnclosesCamera = !1, this._needsUpdate = !0, this._updatedLastTime = !1, this._elementRect = new DOMRect(), this._isDragging = !1, this._dragNeedsUpdate = !0, this._activePointers = [], this._lockedPointer = null, this._interactiveArea = new DOMRect(0, 0, 1, 1), this._isUserControllingRotate = !1, this._isUserControllingDolly = !1, this._isUserControllingTruck = !1, this._isUserControllingOffset = !1, this._isUserControllingZoom = !1, this._lastDollyDirection = Ln.NONE, this._thetaVelocity = { value: 0 }, this._phiVelocity = { value: 0 }, this._radiusVelocity = { value: 0 }, this._targetVelocity = new ge.Vector3(), this._focalOffsetVelocity = new ge.Vector3(), this._zoomVelocity = { value: 0 }, this._truckInternal = (v, M, _) => {
+      let w, P;
+      if (_n(this._camera)) {
+        const T = Ee.copy(this._camera.position).sub(this._target), E = this._camera.getEffectiveFOV() * ts, m = T.length() * Math.tan(E * 0.5);
+        w = this.truckSpeed * v * m / this._elementRect.height, P = this.truckSpeed * M * m / this._elementRect.height;
+      } else if (on(this._camera)) {
+        const T = this._camera;
+        w = v * (T.right - T.left) / T.zoom / this._elementRect.width, P = M * (T.top - T.bottom) / T.zoom / this._elementRect.height;
       } else
         return;
-      this.verticalDragToForward ? (x ? this.setFocalOffset(this._focalOffsetEnd.x + M, this._focalOffsetEnd.y, this._focalOffsetEnd.z, !0) : this.truck(M, 0, !0), this.forward(-d, !0)) : x ? this.setFocalOffset(this._focalOffsetEnd.x + M, this._focalOffsetEnd.y + d, this._focalOffsetEnd.z, !0) : this.truck(M, d, !0);
-    }, this._rotateInternal = (g, A) => {
-      const x = Ln * this.azimuthRotateSpeed * g / this._elementRect.height, M = Ln * this.polarRotateSpeed * A / this._elementRect.height;
-      this.rotate(x, M, !0);
-    }, this._dollyInternal = (g, A, x) => {
-      const M = Math.pow(0.95, -g * this.dollySpeed), d = this._sphericalEnd.radius, w = this._sphericalEnd.radius * M, f = Et(w, this.minDistance, this.maxDistance), P = f - w;
-      this.infinityDolly && this.dollyToCursor ? this._dollyToNoClamp(w, !0) : this.infinityDolly && !this.dollyToCursor ? (this.dollyInFixed(P, !0), this._dollyToNoClamp(f, !0)) : this._dollyToNoClamp(f, !0), this.dollyToCursor && (this._changedDolly += (this.infinityDolly ? w : f) - d, this._dollyControlCoord.set(A, x)), this._lastDollyDirection = Math.sign(-g);
-    }, this._zoomInternal = (g, A, x) => {
-      const M = Math.pow(0.95, g * this.dollySpeed), d = this._zoom, w = this._zoom * M;
-      this.zoomTo(w, !0), this.dollyToCursor && (this._changedZoom += w - d, this._dollyControlCoord.set(A, x));
-    }, typeof me > "u" && console.error("camera-controls: `THREE` is undefined. You must first run `CameraControls.install( { THREE: THREE } )`. Check the docs for further information."), this._camera = e, this._yAxisUpSpace = new me.Quaternion().setFromUnitVectors(this._camera.up, Ls), this._yAxisUpSpaceInverse = this._yAxisUpSpace.clone().invert(), this._state = Q.NONE, this._target = new me.Vector3(), this._targetEnd = this._target.clone(), this._focalOffset = new me.Vector3(), this._focalOffsetEnd = this._focalOffset.clone(), this._spherical = new me.Spherical().setFromVector3(Ee.copy(this._camera.position).applyQuaternion(this._yAxisUpSpace)), this._sphericalEnd = this._spherical.clone(), this._lastDistance = this._spherical.radius, this._zoom = this._camera.zoom, this._zoomEnd = this._zoom, this._lastZoom = this._zoom, this._nearPlaneCorners = [
-      new me.Vector3(),
-      new me.Vector3(),
-      new me.Vector3(),
-      new me.Vector3()
-    ], this._updateNearPlaneCorners(), this._boundary = new me.Box3(new me.Vector3(-1 / 0, -1 / 0, -1 / 0), new me.Vector3(1 / 0, 1 / 0, 1 / 0)), this._cameraUp0 = this._camera.up.clone(), this._target0 = this._target.clone(), this._position0 = this._camera.position.clone(), this._zoom0 = this._zoom, this._focalOffset0 = this._focalOffset.clone(), this._dollyControlCoord = new me.Vector2(), this.mouseButtons = {
-      left: Q.ROTATE,
-      middle: Q.DOLLY,
-      right: Q.TRUCK,
-      wheel: gn(this._camera) ? Q.DOLLY : sn(this._camera) ? Q.ZOOM : Q.NONE
+      this.verticalDragToForward ? (_ ? this.setFocalOffset(this._focalOffsetEnd.x + w, this._focalOffsetEnd.y, this._focalOffsetEnd.z, !0) : this.truck(w, 0, !0), this.forward(-P, !0)) : _ ? this.setFocalOffset(this._focalOffsetEnd.x + w, this._focalOffsetEnd.y + P, this._focalOffsetEnd.z, !0) : this.truck(w, P, !0);
+    }, this._rotateInternal = (v, M) => {
+      const _ = Fn * this.azimuthRotateSpeed * v / this._elementRect.height, w = Fn * this.polarRotateSpeed * M / this._elementRect.height;
+      this.rotate(_, w, !0);
+    }, this._dollyInternal = (v, M, _) => {
+      const w = Math.pow(0.95, -v * this.dollySpeed), P = this._sphericalEnd.radius, T = this._sphericalEnd.radius * w, E = At(T, this.minDistance, this.maxDistance), m = E - T;
+      this.infinityDolly && this.dollyToCursor ? this._dollyToNoClamp(T, !0) : this.infinityDolly && !this.dollyToCursor ? (this.dollyInFixed(m, !0), this._dollyToNoClamp(E, !0)) : this._dollyToNoClamp(E, !0), this.dollyToCursor && (this._changedDolly += (this.infinityDolly ? T : E) - P, this._dollyControlCoord.set(M, _)), this._lastDollyDirection = Math.sign(-v);
+    }, this._zoomInternal = (v, M, _) => {
+      const w = Math.pow(0.95, v * this.dollySpeed), P = this._zoom, T = this._zoom * w;
+      this.zoomTo(T, !0), this.dollyToCursor && (this._changedZoom += T - P, this._dollyControlCoord.set(M, _));
+    }, typeof ge > "u" && console.error("camera-controls: `THREE` is undefined. You must first run `CameraControls.install( { THREE: THREE } )`. Check the docs for further information."), this._camera = e, this._yAxisUpSpace = new ge.Quaternion().setFromUnitVectors(this._camera.up, zs), this._yAxisUpSpaceInverse = this._yAxisUpSpace.clone().invert(), this._state = J.NONE, this._target = new ge.Vector3(), this._targetEnd = this._target.clone(), this._focalOffset = new ge.Vector3(), this._focalOffsetEnd = this._focalOffset.clone(), this._spherical = new ge.Spherical().setFromVector3(Ee.copy(this._camera.position).applyQuaternion(this._yAxisUpSpace)), this._sphericalEnd = this._spherical.clone(), this._lastDistance = this._spherical.radius, this._zoom = this._camera.zoom, this._zoomEnd = this._zoom, this._lastZoom = this._zoom, this._nearPlaneCorners = [
+      new ge.Vector3(),
+      new ge.Vector3(),
+      new ge.Vector3(),
+      new ge.Vector3()
+    ], this._updateNearPlaneCorners(), this._boundary = new ge.Box3(new ge.Vector3(-1 / 0, -1 / 0, -1 / 0), new ge.Vector3(1 / 0, 1 / 0, 1 / 0)), this._cameraUp0 = this._camera.up.clone(), this._target0 = this._target.clone(), this._position0 = this._camera.position.clone(), this._zoom0 = this._zoom, this._focalOffset0 = this._focalOffset.clone(), this._dollyControlCoord = new ge.Vector2(), this.mouseButtons = {
+      left: J.ROTATE,
+      middle: J.DOLLY,
+      right: J.TRUCK,
+      wheel: _n(this._camera) ? J.DOLLY : on(this._camera) ? J.ZOOM : J.NONE
     }, this.touches = {
-      one: Q.TOUCH_ROTATE,
-      two: gn(this._camera) ? Q.TOUCH_DOLLY_TRUCK : sn(this._camera) ? Q.TOUCH_ZOOM_TRUCK : Q.NONE,
-      three: Q.TOUCH_TRUCK
+      one: J.TOUCH_ROTATE,
+      two: _n(this._camera) ? J.TOUCH_DOLLY_TRUCK : on(this._camera) ? J.TOUCH_ZOOM_TRUCK : J.NONE,
+      three: J.TOUCH_TRUCK
     };
-    const n = new me.Vector2(), s = new me.Vector2(), i = new me.Vector2(), r = (g) => {
+    const n = new ge.Vector2(), s = new ge.Vector2(), i = new ge.Vector2(), r = (v) => {
       if (!this._enabled || !this._domElement)
         return;
       if (this._interactiveArea.left !== 0 || this._interactiveArea.top !== 0 || this._interactiveArea.width !== 1 || this._interactiveArea.height !== 1) {
-        const M = this._domElement.getBoundingClientRect(), d = g.clientX / M.width, w = g.clientY / M.height;
-        if (d < this._interactiveArea.left || d > this._interactiveArea.right || w < this._interactiveArea.top || w > this._interactiveArea.bottom)
+        const w = this._domElement.getBoundingClientRect(), P = v.clientX / w.width, T = v.clientY / w.height;
+        if (P < this._interactiveArea.left || P > this._interactiveArea.right || T < this._interactiveArea.top || T > this._interactiveArea.bottom)
           return;
       }
-      const A = g.pointerType !== "mouse" ? null : (g.buttons & ye.LEFT) === ye.LEFT ? ye.LEFT : (g.buttons & ye.MIDDLE) === ye.MIDDLE ? ye.MIDDLE : (g.buttons & ye.RIGHT) === ye.RIGHT ? ye.RIGHT : null;
-      if (A !== null) {
-        const M = this._findPointerByMouseButton(A);
-        M && this._disposePointer(M);
+      const M = v.pointerType !== "mouse" ? null : (v.buttons & We.LEFT) === We.LEFT ? We.LEFT : (v.buttons & We.MIDDLE) === We.MIDDLE ? We.MIDDLE : (v.buttons & We.RIGHT) === We.RIGHT ? We.RIGHT : null;
+      if (M !== null) {
+        const w = this._findPointerByMouseButton(M);
+        w && this._disposePointer(w);
       }
-      if ((g.buttons & ye.LEFT) === ye.LEFT && this._lockedPointer)
+      if ((v.buttons & We.LEFT) === We.LEFT && this._lockedPointer)
         return;
-      const x = {
-        pointerId: g.pointerId,
-        clientX: g.clientX,
-        clientY: g.clientY,
+      const _ = {
+        pointerId: v.pointerId,
+        clientX: v.clientX,
+        clientY: v.clientY,
         deltaX: 0,
         deltaY: 0,
-        mouseButton: A
+        mouseButton: M
       };
-      this._activePointers.push(x), this._domElement.ownerDocument.removeEventListener("pointermove", l, { passive: !1 }), this._domElement.ownerDocument.removeEventListener("pointerup", u), this._domElement.ownerDocument.addEventListener("pointermove", l, { passive: !1 }), this._domElement.ownerDocument.addEventListener("pointerup", u), this._isDragging = !0, _(g);
-    }, a = (g) => {
-      if (!this._enabled || !this._domElement || this._lockedPointer)
-        return;
-      if (this._interactiveArea.left !== 0 || this._interactiveArea.top !== 0 || this._interactiveArea.width !== 1 || this._interactiveArea.height !== 1) {
-        const M = this._domElement.getBoundingClientRect(), d = g.clientX / M.width, w = g.clientY / M.height;
-        if (d < this._interactiveArea.left || d > this._interactiveArea.right || w < this._interactiveArea.top || w > this._interactiveArea.bottom)
-          return;
-      }
-      const A = (g.buttons & ye.LEFT) === ye.LEFT ? ye.LEFT : (g.buttons & ye.MIDDLE) === ye.MIDDLE ? ye.MIDDLE : (g.buttons & ye.RIGHT) === ye.RIGHT ? ye.RIGHT : null;
-      if (A !== null) {
-        const M = this._findPointerByMouseButton(A);
-        M && this._disposePointer(M);
-      }
-      const x = {
-        pointerId: 1,
-        clientX: g.clientX,
-        clientY: g.clientY,
-        deltaX: 0,
-        deltaY: 0,
-        mouseButton: (g.buttons & ye.LEFT) === ye.LEFT ? ye.LEFT : (g.buttons & ye.MIDDLE) === ye.LEFT ? ye.MIDDLE : (g.buttons & ye.RIGHT) === ye.LEFT ? ye.RIGHT : null
-      };
-      this._activePointers.push(x), this._domElement.ownerDocument.removeEventListener("mousemove", c), this._domElement.ownerDocument.removeEventListener("mouseup", h), this._domElement.ownerDocument.addEventListener("mousemove", c), this._domElement.ownerDocument.addEventListener("mouseup", h), this._isDragging = !0, _(g);
-    }, l = (g) => {
-      g.cancelable && g.preventDefault();
-      const A = g.pointerId, x = this._lockedPointer || this._findPointerById(A);
-      if (x) {
-        if (x.clientX = g.clientX, x.clientY = g.clientY, x.deltaX = g.movementX, x.deltaY = g.movementY, this._state = 0, g.pointerType === "touch")
+      this._activePointers.push(_), this._domElement.ownerDocument.removeEventListener("pointermove", a, { passive: !1 }), this._domElement.ownerDocument.removeEventListener("pointerup", l), this._domElement.ownerDocument.addEventListener("pointermove", a, { passive: !1 }), this._domElement.ownerDocument.addEventListener("pointerup", l), this._isDragging = !0, f(v);
+    }, a = (v) => {
+      v.cancelable && v.preventDefault();
+      const M = v.pointerId, _ = this._lockedPointer || this._findPointerById(M);
+      if (_) {
+        if (_.clientX = v.clientX, _.clientY = v.clientY, _.deltaX = v.movementX, _.deltaY = v.movementY, this._state = 0, v.pointerType === "touch")
           switch (this._activePointers.length) {
             case 1:
               this._state = this.touches.one;
@@ -9363,19 +9396,16 @@ class ls extends yf {
               break;
           }
         else
-          (!this._isDragging && this._lockedPointer || this._isDragging && (g.buttons & ye.LEFT) === ye.LEFT) && (this._state = this._state | this.mouseButtons.left), this._isDragging && (g.buttons & ye.MIDDLE) === ye.MIDDLE && (this._state = this._state | this.mouseButtons.middle), this._isDragging && (g.buttons & ye.RIGHT) === ye.RIGHT && (this._state = this._state | this.mouseButtons.right);
-        y();
+          (!this._isDragging && this._lockedPointer || this._isDragging && (v.buttons & We.LEFT) === We.LEFT) && (this._state = this._state | this.mouseButtons.left), this._isDragging && (v.buttons & We.MIDDLE) === We.MIDDLE && (this._state = this._state | this.mouseButtons.middle), this._isDragging && (v.buttons & We.RIGHT) === We.RIGHT && (this._state = this._state | this.mouseButtons.right);
+        d();
       }
-    }, c = (g) => {
-      const A = this._lockedPointer || this._findPointerById(1);
-      A && (A.clientX = g.clientX, A.clientY = g.clientY, A.deltaX = g.movementX, A.deltaY = g.movementY, this._state = 0, (this._lockedPointer || (g.buttons & ye.LEFT) === ye.LEFT) && (this._state = this._state | this.mouseButtons.left), (g.buttons & ye.MIDDLE) === ye.MIDDLE && (this._state = this._state | this.mouseButtons.middle), (g.buttons & ye.RIGHT) === ye.RIGHT && (this._state = this._state | this.mouseButtons.right), y());
-    }, u = (g) => {
-      const A = this._findPointerById(g.pointerId);
-      if (!(A && A === this._lockedPointer)) {
-        if (A && this._disposePointer(A), g.pointerType === "touch")
+    }, l = (v) => {
+      const M = this._findPointerById(v.pointerId);
+      if (!(M && M === this._lockedPointer)) {
+        if (M && this._disposePointer(M), v.pointerType === "touch")
           switch (this._activePointers.length) {
             case 0:
-              this._state = Q.NONE;
+              this._state = J.NONE;
               break;
             case 1:
               this._state = this.touches.one;
@@ -9388,71 +9418,68 @@ class ls extends yf {
               break;
           }
         else
-          this._state = Q.NONE;
-        E();
+          this._state = J.NONE;
+        y();
       }
-    }, h = () => {
-      const g = this._findPointerById(1);
-      g && g === this._lockedPointer || (g && this._disposePointer(g), this._state = Q.NONE, E());
     };
-    let m = -1;
-    const p = (g) => {
-      if (!this._domElement || !this._enabled || this.mouseButtons.wheel === Q.NONE)
+    let c = -1;
+    const u = (v) => {
+      if (!this._domElement || !this._enabled || this.mouseButtons.wheel === J.NONE)
         return;
       if (this._interactiveArea.left !== 0 || this._interactiveArea.top !== 0 || this._interactiveArea.width !== 1 || this._interactiveArea.height !== 1) {
-        const w = this._domElement.getBoundingClientRect(), f = g.clientX / w.width, P = g.clientY / w.height;
-        if (f < this._interactiveArea.left || f > this._interactiveArea.right || P < this._interactiveArea.top || P > this._interactiveArea.bottom)
+        const T = this._domElement.getBoundingClientRect(), E = v.clientX / T.width, m = v.clientY / T.height;
+        if (E < this._interactiveArea.left || E > this._interactiveArea.right || m < this._interactiveArea.top || m > this._interactiveArea.bottom)
           return;
       }
-      if (g.preventDefault(), this.dollyToCursor || this.mouseButtons.wheel === Q.ROTATE || this.mouseButtons.wheel === Q.TRUCK) {
-        const w = performance.now();
-        m - w < 1e3 && this._getClientRect(this._elementRect), m = w;
+      if (v.preventDefault(), this.dollyToCursor || this.mouseButtons.wheel === J.ROTATE || this.mouseButtons.wheel === J.TRUCK) {
+        const T = performance.now();
+        c - T < 1e3 && this._getClientRect(this._elementRect), c = T;
       }
-      const A = _f ? -1 : -3, x = g.deltaMode === 1 ? g.deltaY / A : g.deltaY / (A * 10), M = this.dollyToCursor ? (g.clientX - this._elementRect.x) / this._elementRect.width * 2 - 1 : 0, d = this.dollyToCursor ? (g.clientY - this._elementRect.y) / this._elementRect.height * -2 + 1 : 0;
+      const M = Af ? -1 : -3, _ = v.deltaMode === 1 ? v.deltaY / M : v.deltaY / (M * 10), w = this.dollyToCursor ? (v.clientX - this._elementRect.x) / this._elementRect.width * 2 - 1 : 0, P = this.dollyToCursor ? (v.clientY - this._elementRect.y) / this._elementRect.height * -2 + 1 : 0;
       switch (this.mouseButtons.wheel) {
-        case Q.ROTATE: {
-          this._rotateInternal(g.deltaX, g.deltaY), this._isUserControllingRotate = !0;
+        case J.ROTATE: {
+          this._rotateInternal(v.deltaX, v.deltaY), this._isUserControllingRotate = !0;
           break;
         }
-        case Q.TRUCK: {
-          this._truckInternal(g.deltaX, g.deltaY, !1), this._isUserControllingTruck = !0;
+        case J.TRUCK: {
+          this._truckInternal(v.deltaX, v.deltaY, !1), this._isUserControllingTruck = !0;
           break;
         }
-        case Q.OFFSET: {
-          this._truckInternal(g.deltaX, g.deltaY, !0), this._isUserControllingOffset = !0;
+        case J.OFFSET: {
+          this._truckInternal(v.deltaX, v.deltaY, !0), this._isUserControllingOffset = !0;
           break;
         }
-        case Q.DOLLY: {
-          this._dollyInternal(-x, M, d), this._isUserControllingDolly = !0;
+        case J.DOLLY: {
+          this._dollyInternal(-_, w, P), this._isUserControllingDolly = !0;
           break;
         }
-        case Q.ZOOM: {
-          this._zoomInternal(-x, M, d), this._isUserControllingZoom = !0;
+        case J.ZOOM: {
+          this._zoomInternal(-_, w, P), this._isUserControllingZoom = !0;
           break;
         }
       }
       this.dispatchEvent({ type: "control" });
-    }, v = (g) => {
+    }, h = (v) => {
       if (!(!this._domElement || !this._enabled)) {
-        if (this.mouseButtons.right === ls.ACTION.NONE) {
-          const A = g instanceof PointerEvent ? g.pointerId : (g instanceof MouseEvent, 0), x = this._findPointerById(A);
-          x && this._disposePointer(x), this._domElement.ownerDocument.removeEventListener("pointermove", l, { passive: !1 }), this._domElement.ownerDocument.removeEventListener("pointerup", u), this._domElement.ownerDocument.removeEventListener("mousemove", c), this._domElement.ownerDocument.removeEventListener("mouseup", h);
+        if (this.mouseButtons.right === gs.ACTION.NONE) {
+          const M = v instanceof PointerEvent ? v.pointerId : 0, _ = this._findPointerById(M);
+          _ && this._disposePointer(_), this._domElement.ownerDocument.removeEventListener("pointermove", a, { passive: !1 }), this._domElement.ownerDocument.removeEventListener("pointerup", l);
           return;
         }
-        g.preventDefault();
+        v.preventDefault();
       }
-    }, _ = (g) => {
+    }, f = (v) => {
       if (!this._enabled)
         return;
-      if (Ti(this._activePointers, at), this._getClientRect(this._elementRect), n.copy(at), s.copy(at), this._activePointers.length >= 2) {
-        const x = at.x - this._activePointers[1].clientX, M = at.y - this._activePointers[1].clientY, d = Math.sqrt(x * x + M * M);
-        i.set(0, d);
-        const w = (this._activePointers[0].clientX + this._activePointers[1].clientX) * 0.5, f = (this._activePointers[0].clientY + this._activePointers[1].clientY) * 0.5;
-        s.set(w, f);
+      if (Pi(this._activePointers, ct), this._getClientRect(this._elementRect), n.copy(ct), s.copy(ct), this._activePointers.length >= 2) {
+        const _ = ct.x - this._activePointers[1].clientX, w = ct.y - this._activePointers[1].clientY, P = Math.sqrt(_ * _ + w * w);
+        i.set(0, P);
+        const T = (this._activePointers[0].clientX + this._activePointers[1].clientX) * 0.5, E = (this._activePointers[0].clientY + this._activePointers[1].clientY) * 0.5;
+        s.set(T, E);
       }
-      if (this._state = 0, !g)
+      if (this._state = 0, !v)
         this._lockedPointer && (this._state = this._state | this.mouseButtons.left);
-      else if ("pointerType" in g && g.pointerType === "touch")
+      else if ("pointerType" in v && v.pointerType === "touch")
         switch (this._activePointers.length) {
           case 1:
             this._state = this.touches.one;
@@ -9465,26 +9492,26 @@ class ls extends yf {
             break;
         }
       else
-        !this._lockedPointer && (g.buttons & ye.LEFT) === ye.LEFT && (this._state = this._state | this.mouseButtons.left), (g.buttons & ye.MIDDLE) === ye.MIDDLE && (this._state = this._state | this.mouseButtons.middle), (g.buttons & ye.RIGHT) === ye.RIGHT && (this._state = this._state | this.mouseButtons.right);
-      ((this._state & Q.ROTATE) === Q.ROTATE || (this._state & Q.TOUCH_ROTATE) === Q.TOUCH_ROTATE || (this._state & Q.TOUCH_DOLLY_ROTATE) === Q.TOUCH_DOLLY_ROTATE || (this._state & Q.TOUCH_ZOOM_ROTATE) === Q.TOUCH_ZOOM_ROTATE) && (this._sphericalEnd.theta = this._spherical.theta, this._sphericalEnd.phi = this._spherical.phi, this._thetaVelocity.value = 0, this._phiVelocity.value = 0), ((this._state & Q.TRUCK) === Q.TRUCK || (this._state & Q.TOUCH_TRUCK) === Q.TOUCH_TRUCK || (this._state & Q.TOUCH_DOLLY_TRUCK) === Q.TOUCH_DOLLY_TRUCK || (this._state & Q.TOUCH_ZOOM_TRUCK) === Q.TOUCH_ZOOM_TRUCK) && (this._targetEnd.copy(this._target), this._targetVelocity.set(0, 0, 0)), ((this._state & Q.DOLLY) === Q.DOLLY || (this._state & Q.TOUCH_DOLLY) === Q.TOUCH_DOLLY || (this._state & Q.TOUCH_DOLLY_TRUCK) === Q.TOUCH_DOLLY_TRUCK || (this._state & Q.TOUCH_DOLLY_OFFSET) === Q.TOUCH_DOLLY_OFFSET || (this._state & Q.TOUCH_DOLLY_ROTATE) === Q.TOUCH_DOLLY_ROTATE) && (this._sphericalEnd.radius = this._spherical.radius, this._radiusVelocity.value = 0), ((this._state & Q.ZOOM) === Q.ZOOM || (this._state & Q.TOUCH_ZOOM) === Q.TOUCH_ZOOM || (this._state & Q.TOUCH_ZOOM_TRUCK) === Q.TOUCH_ZOOM_TRUCK || (this._state & Q.TOUCH_ZOOM_OFFSET) === Q.TOUCH_ZOOM_OFFSET || (this._state & Q.TOUCH_ZOOM_ROTATE) === Q.TOUCH_ZOOM_ROTATE) && (this._zoomEnd = this._zoom, this._zoomVelocity.value = 0), ((this._state & Q.OFFSET) === Q.OFFSET || (this._state & Q.TOUCH_OFFSET) === Q.TOUCH_OFFSET || (this._state & Q.TOUCH_DOLLY_OFFSET) === Q.TOUCH_DOLLY_OFFSET || (this._state & Q.TOUCH_ZOOM_OFFSET) === Q.TOUCH_ZOOM_OFFSET) && (this._focalOffsetEnd.copy(this._focalOffset), this._focalOffsetVelocity.set(0, 0, 0)), this.dispatchEvent({ type: "controlstart" });
-    }, y = () => {
+        !this._lockedPointer && (v.buttons & We.LEFT) === We.LEFT && (this._state = this._state | this.mouseButtons.left), (v.buttons & We.MIDDLE) === We.MIDDLE && (this._state = this._state | this.mouseButtons.middle), (v.buttons & We.RIGHT) === We.RIGHT && (this._state = this._state | this.mouseButtons.right);
+      ((this._state & J.ROTATE) === J.ROTATE || (this._state & J.TOUCH_ROTATE) === J.TOUCH_ROTATE || (this._state & J.TOUCH_DOLLY_ROTATE) === J.TOUCH_DOLLY_ROTATE || (this._state & J.TOUCH_ZOOM_ROTATE) === J.TOUCH_ZOOM_ROTATE) && (this._sphericalEnd.theta = this._spherical.theta, this._sphericalEnd.phi = this._spherical.phi, this._thetaVelocity.value = 0, this._phiVelocity.value = 0), ((this._state & J.TRUCK) === J.TRUCK || (this._state & J.TOUCH_TRUCK) === J.TOUCH_TRUCK || (this._state & J.TOUCH_DOLLY_TRUCK) === J.TOUCH_DOLLY_TRUCK || (this._state & J.TOUCH_ZOOM_TRUCK) === J.TOUCH_ZOOM_TRUCK) && (this._targetEnd.copy(this._target), this._targetVelocity.set(0, 0, 0)), ((this._state & J.DOLLY) === J.DOLLY || (this._state & J.TOUCH_DOLLY) === J.TOUCH_DOLLY || (this._state & J.TOUCH_DOLLY_TRUCK) === J.TOUCH_DOLLY_TRUCK || (this._state & J.TOUCH_DOLLY_OFFSET) === J.TOUCH_DOLLY_OFFSET || (this._state & J.TOUCH_DOLLY_ROTATE) === J.TOUCH_DOLLY_ROTATE) && (this._sphericalEnd.radius = this._spherical.radius, this._radiusVelocity.value = 0), ((this._state & J.ZOOM) === J.ZOOM || (this._state & J.TOUCH_ZOOM) === J.TOUCH_ZOOM || (this._state & J.TOUCH_ZOOM_TRUCK) === J.TOUCH_ZOOM_TRUCK || (this._state & J.TOUCH_ZOOM_OFFSET) === J.TOUCH_ZOOM_OFFSET || (this._state & J.TOUCH_ZOOM_ROTATE) === J.TOUCH_ZOOM_ROTATE) && (this._zoomEnd = this._zoom, this._zoomVelocity.value = 0), ((this._state & J.OFFSET) === J.OFFSET || (this._state & J.TOUCH_OFFSET) === J.TOUCH_OFFSET || (this._state & J.TOUCH_DOLLY_OFFSET) === J.TOUCH_DOLLY_OFFSET || (this._state & J.TOUCH_ZOOM_OFFSET) === J.TOUCH_ZOOM_OFFSET) && (this._focalOffsetEnd.copy(this._focalOffset), this._focalOffsetVelocity.set(0, 0, 0)), this.dispatchEvent({ type: "controlstart" });
+    }, d = () => {
       if (!this._enabled || !this._dragNeedsUpdate)
         return;
-      this._dragNeedsUpdate = !1, Ti(this._activePointers, at);
-      const A = this._domElement && document.pointerLockElement === this._domElement ? this._lockedPointer || this._activePointers[0] : null, x = A ? -A.deltaX : s.x - at.x, M = A ? -A.deltaY : s.y - at.y;
-      if (s.copy(at), ((this._state & Q.ROTATE) === Q.ROTATE || (this._state & Q.TOUCH_ROTATE) === Q.TOUCH_ROTATE || (this._state & Q.TOUCH_DOLLY_ROTATE) === Q.TOUCH_DOLLY_ROTATE || (this._state & Q.TOUCH_ZOOM_ROTATE) === Q.TOUCH_ZOOM_ROTATE) && (this._rotateInternal(x, M), this._isUserControllingRotate = !0), (this._state & Q.DOLLY) === Q.DOLLY || (this._state & Q.ZOOM) === Q.ZOOM) {
-        const d = this.dollyToCursor ? (n.x - this._elementRect.x) / this._elementRect.width * 2 - 1 : 0, w = this.dollyToCursor ? (n.y - this._elementRect.y) / this._elementRect.height * -2 + 1 : 0, f = this.dollyDragInverted ? -1 : 1;
-        (this._state & Q.DOLLY) === Q.DOLLY ? (this._dollyInternal(f * M * Ds, d, w), this._isUserControllingDolly = !0) : (this._zoomInternal(f * M * Ds, d, w), this._isUserControllingZoom = !0);
+      this._dragNeedsUpdate = !1, Pi(this._activePointers, ct);
+      const M = this._domElement && this._domElement.ownerDocument.pointerLockElement === this._domElement ? this._lockedPointer || this._activePointers[0] : null, _ = M ? -M.deltaX : s.x - ct.x, w = M ? -M.deltaY : s.y - ct.y;
+      if (s.copy(ct), ((this._state & J.ROTATE) === J.ROTATE || (this._state & J.TOUCH_ROTATE) === J.TOUCH_ROTATE || (this._state & J.TOUCH_DOLLY_ROTATE) === J.TOUCH_DOLLY_ROTATE || (this._state & J.TOUCH_ZOOM_ROTATE) === J.TOUCH_ZOOM_ROTATE) && (this._rotateInternal(_, w), this._isUserControllingRotate = !0), (this._state & J.DOLLY) === J.DOLLY || (this._state & J.ZOOM) === J.ZOOM) {
+        const P = this.dollyToCursor ? (n.x - this._elementRect.x) / this._elementRect.width * 2 - 1 : 0, T = this.dollyToCursor ? (n.y - this._elementRect.y) / this._elementRect.height * -2 + 1 : 0, E = this.dollyDragInverted ? -1 : 1;
+        (this._state & J.DOLLY) === J.DOLLY ? (this._dollyInternal(E * w * Ns, P, T), this._isUserControllingDolly = !0) : (this._zoomInternal(E * w * Ns, P, T), this._isUserControllingZoom = !0);
       }
-      if ((this._state & Q.TOUCH_DOLLY) === Q.TOUCH_DOLLY || (this._state & Q.TOUCH_ZOOM) === Q.TOUCH_ZOOM || (this._state & Q.TOUCH_DOLLY_TRUCK) === Q.TOUCH_DOLLY_TRUCK || (this._state & Q.TOUCH_ZOOM_TRUCK) === Q.TOUCH_ZOOM_TRUCK || (this._state & Q.TOUCH_DOLLY_OFFSET) === Q.TOUCH_DOLLY_OFFSET || (this._state & Q.TOUCH_ZOOM_OFFSET) === Q.TOUCH_ZOOM_OFFSET || (this._state & Q.TOUCH_DOLLY_ROTATE) === Q.TOUCH_DOLLY_ROTATE || (this._state & Q.TOUCH_ZOOM_ROTATE) === Q.TOUCH_ZOOM_ROTATE) {
-        const d = at.x - this._activePointers[1].clientX, w = at.y - this._activePointers[1].clientY, f = Math.sqrt(d * d + w * w), P = i.y - f;
-        i.set(0, f);
-        const I = this.dollyToCursor ? (s.x - this._elementRect.x) / this._elementRect.width * 2 - 1 : 0, K = this.dollyToCursor ? (s.y - this._elementRect.y) / this._elementRect.height * -2 + 1 : 0;
-        (this._state & Q.TOUCH_DOLLY) === Q.TOUCH_DOLLY || (this._state & Q.TOUCH_DOLLY_ROTATE) === Q.TOUCH_DOLLY_ROTATE || (this._state & Q.TOUCH_DOLLY_TRUCK) === Q.TOUCH_DOLLY_TRUCK || (this._state & Q.TOUCH_DOLLY_OFFSET) === Q.TOUCH_DOLLY_OFFSET ? (this._dollyInternal(P * Ds, I, K), this._isUserControllingDolly = !0) : (this._zoomInternal(P * Ds, I, K), this._isUserControllingZoom = !0);
+      if ((this._state & J.TOUCH_DOLLY) === J.TOUCH_DOLLY || (this._state & J.TOUCH_ZOOM) === J.TOUCH_ZOOM || (this._state & J.TOUCH_DOLLY_TRUCK) === J.TOUCH_DOLLY_TRUCK || (this._state & J.TOUCH_ZOOM_TRUCK) === J.TOUCH_ZOOM_TRUCK || (this._state & J.TOUCH_DOLLY_OFFSET) === J.TOUCH_DOLLY_OFFSET || (this._state & J.TOUCH_ZOOM_OFFSET) === J.TOUCH_ZOOM_OFFSET || (this._state & J.TOUCH_DOLLY_ROTATE) === J.TOUCH_DOLLY_ROTATE || (this._state & J.TOUCH_ZOOM_ROTATE) === J.TOUCH_ZOOM_ROTATE) {
+        const P = ct.x - this._activePointers[1].clientX, T = ct.y - this._activePointers[1].clientY, E = Math.sqrt(P * P + T * T), m = i.y - E;
+        i.set(0, E);
+        const b = this.dollyToCursor ? (s.x - this._elementRect.x) / this._elementRect.width * 2 - 1 : 0, p = this.dollyToCursor ? (s.y - this._elementRect.y) / this._elementRect.height * -2 + 1 : 0;
+        (this._state & J.TOUCH_DOLLY) === J.TOUCH_DOLLY || (this._state & J.TOUCH_DOLLY_ROTATE) === J.TOUCH_DOLLY_ROTATE || (this._state & J.TOUCH_DOLLY_TRUCK) === J.TOUCH_DOLLY_TRUCK || (this._state & J.TOUCH_DOLLY_OFFSET) === J.TOUCH_DOLLY_OFFSET ? (this._dollyInternal(m * Ns, b, p), this._isUserControllingDolly = !0) : (this._zoomInternal(m * Ns, b, p), this._isUserControllingZoom = !0);
       }
-      ((this._state & Q.TRUCK) === Q.TRUCK || (this._state & Q.TOUCH_TRUCK) === Q.TOUCH_TRUCK || (this._state & Q.TOUCH_DOLLY_TRUCK) === Q.TOUCH_DOLLY_TRUCK || (this._state & Q.TOUCH_ZOOM_TRUCK) === Q.TOUCH_ZOOM_TRUCK) && (this._truckInternal(x, M, !1), this._isUserControllingTruck = !0), ((this._state & Q.OFFSET) === Q.OFFSET || (this._state & Q.TOUCH_OFFSET) === Q.TOUCH_OFFSET || (this._state & Q.TOUCH_DOLLY_OFFSET) === Q.TOUCH_DOLLY_OFFSET || (this._state & Q.TOUCH_ZOOM_OFFSET) === Q.TOUCH_ZOOM_OFFSET) && (this._truckInternal(x, M, !0), this._isUserControllingOffset = !0), this.dispatchEvent({ type: "control" });
-    }, E = () => {
-      Ti(this._activePointers, at), s.copy(at), this._dragNeedsUpdate = !1, (this._activePointers.length === 0 || this._activePointers.length === 1 && this._activePointers[0] === this._lockedPointer) && (this._isDragging = !1), this._activePointers.length === 0 && this._domElement && (this._domElement.ownerDocument.removeEventListener("pointermove", l, { passive: !1 }), this._domElement.ownerDocument.removeEventListener("mousemove", c), this._domElement.ownerDocument.removeEventListener("pointerup", u), this._domElement.ownerDocument.removeEventListener("mouseup", h), this.dispatchEvent({ type: "controlend" }));
+      ((this._state & J.TRUCK) === J.TRUCK || (this._state & J.TOUCH_TRUCK) === J.TOUCH_TRUCK || (this._state & J.TOUCH_DOLLY_TRUCK) === J.TOUCH_DOLLY_TRUCK || (this._state & J.TOUCH_ZOOM_TRUCK) === J.TOUCH_ZOOM_TRUCK) && (this._truckInternal(_, w, !1), this._isUserControllingTruck = !0), ((this._state & J.OFFSET) === J.OFFSET || (this._state & J.TOUCH_OFFSET) === J.TOUCH_OFFSET || (this._state & J.TOUCH_DOLLY_OFFSET) === J.TOUCH_DOLLY_OFFSET || (this._state & J.TOUCH_ZOOM_OFFSET) === J.TOUCH_ZOOM_OFFSET) && (this._truckInternal(_, w, !0), this._isUserControllingOffset = !0), this.dispatchEvent({ type: "control" });
+    }, y = () => {
+      Pi(this._activePointers, ct), s.copy(ct), this._dragNeedsUpdate = !1, (this._activePointers.length === 0 || this._activePointers.length === 1 && this._activePointers[0] === this._lockedPointer) && (this._isDragging = !1), this._activePointers.length === 0 && this._domElement && (this._domElement.ownerDocument.removeEventListener("pointermove", a, { passive: !1 }), this._domElement.ownerDocument.removeEventListener("pointerup", l), this.dispatchEvent({ type: "controlend" }));
     };
     this.lockPointer = () => {
       !this._enabled || !this._domElement || (this.cancel(), this._lockedPointer = {
@@ -9494,21 +9521,22 @@ class ls extends yf {
         deltaX: 0,
         deltaY: 0,
         mouseButton: null
-      }, this._activePointers.push(this._lockedPointer), this._domElement.ownerDocument.removeEventListener("pointermove", l, { passive: !1 }), this._domElement.ownerDocument.removeEventListener("pointerup", u), this._domElement.requestPointerLock(), this._domElement.ownerDocument.addEventListener("pointerlockchange", R), this._domElement.ownerDocument.addEventListener("pointerlockerror", T), this._domElement.ownerDocument.addEventListener("pointermove", l, { passive: !1 }), this._domElement.ownerDocument.addEventListener("pointerup", u), _());
+      }, this._activePointers.push(this._lockedPointer), this._domElement.ownerDocument.removeEventListener("pointermove", a, { passive: !1 }), this._domElement.ownerDocument.removeEventListener("pointerup", l), this._domElement.requestPointerLock(), this._domElement.ownerDocument.addEventListener("pointerlockchange", x), this._domElement.ownerDocument.addEventListener("pointerlockerror", g), this._domElement.ownerDocument.addEventListener("pointermove", a, { passive: !1 }), this._domElement.ownerDocument.addEventListener("pointerup", l), f());
     }, this.unlockPointer = () => {
-      this._lockedPointer !== null && (this._disposePointer(this._lockedPointer), this._lockedPointer = null), document.exitPointerLock(), this.cancel(), this._domElement && (this._domElement.ownerDocument.removeEventListener("pointerlockchange", R), this._domElement.ownerDocument.removeEventListener("pointerlockerror", T));
+      var v, M, _;
+      this._lockedPointer !== null && (this._disposePointer(this._lockedPointer), this._lockedPointer = null), (v = this._domElement) === null || v === void 0 || v.ownerDocument.exitPointerLock(), (M = this._domElement) === null || M === void 0 || M.ownerDocument.removeEventListener("pointerlockchange", x), (_ = this._domElement) === null || _ === void 0 || _.ownerDocument.removeEventListener("pointerlockerror", g), this.cancel();
     };
-    const R = () => {
+    const x = () => {
       this._domElement && this._domElement.ownerDocument.pointerLockElement === this._domElement || this.unlockPointer();
-    }, T = () => {
+    }, g = () => {
       this.unlockPointer();
     };
-    this._addAllEventListeners = (g) => {
-      this._domElement = g, this._domElement.style.touchAction = "none", this._domElement.style.userSelect = "none", this._domElement.style.webkitUserSelect = "none", this._domElement.addEventListener("pointerdown", r), xf && this._domElement.addEventListener("mousedown", a), this._domElement.addEventListener("pointercancel", u), this._domElement.addEventListener("wheel", p, { passive: !1 }), this._domElement.addEventListener("contextmenu", v);
+    this._addAllEventListeners = (v) => {
+      this._domElement = v, this._domElement.style.touchAction = "none", this._domElement.style.userSelect = "none", this._domElement.style.webkitUserSelect = "none", this._domElement.addEventListener("pointerdown", r), this._domElement.addEventListener("pointercancel", l), this._domElement.addEventListener("wheel", u, { passive: !1 }), this._domElement.addEventListener("contextmenu", h);
     }, this._removeAllEventListeners = () => {
-      this._domElement && (this._domElement.style.touchAction = "", this._domElement.style.userSelect = "", this._domElement.style.webkitUserSelect = "", this._domElement.removeEventListener("pointerdown", r), this._domElement.removeEventListener("mousedown", a), this._domElement.removeEventListener("pointercancel", u), this._domElement.removeEventListener("wheel", p, { passive: !1 }), this._domElement.removeEventListener("contextmenu", v), this._domElement.ownerDocument.removeEventListener("pointermove", l, { passive: !1 }), this._domElement.ownerDocument.removeEventListener("mousemove", c), this._domElement.ownerDocument.removeEventListener("pointerup", u), this._domElement.ownerDocument.removeEventListener("mouseup", h), this._domElement.ownerDocument.removeEventListener("pointerlockchange", R), this._domElement.ownerDocument.removeEventListener("pointerlockerror", T));
+      this._domElement && (this._domElement.style.touchAction = "", this._domElement.style.userSelect = "", this._domElement.style.webkitUserSelect = "", this._domElement.removeEventListener("pointerdown", r), this._domElement.removeEventListener("pointercancel", l), this._domElement.removeEventListener("wheel", u, { passive: !1 }), this._domElement.removeEventListener("contextmenu", h), this._domElement.ownerDocument.removeEventListener("pointermove", a, { passive: !1 }), this._domElement.ownerDocument.removeEventListener("pointerup", l), this._domElement.ownerDocument.removeEventListener("pointerlockchange", x), this._domElement.ownerDocument.removeEventListener("pointerlockerror", g));
     }, this.cancel = () => {
-      this._state !== Q.NONE && (this._state = Q.NONE, this._activePointers.length = 0, E());
+      this._state !== J.NONE && (this._state = J.NONE, this._activePointers.length = 0, y());
     }, t && this.connect(t), this.update(0);
   }
   /**
@@ -9598,7 +9626,7 @@ class ls extends yf {
    * @category Properties
    */
   set interactiveArea(e) {
-    this._interactiveArea.width = Et(e.width, 0, 1), this._interactiveArea.height = Et(e.height, 0, 1), this._interactiveArea.x = Et(e.x, 0, 1 - this._interactiveArea.width), this._interactiveArea.y = Et(e.y, 0, 1 - this._interactiveArea.height);
+    this._interactiveArea.width = At(e.width, 0, 1), this._interactiveArea.height = At(e.height, 0, 1), this._interactiveArea.x = At(e.x, 0, 1 - this._interactiveArea.width), this._interactiveArea.y = At(e.y, 0, 1 - this._interactiveArea.height);
   }
   /**
    * Adds the specified event listener.
@@ -9720,7 +9748,7 @@ class ls extends yf {
    */
   rotateTo(e, t, n = !1) {
     this._isUserControllingRotate = !1;
-    const s = Et(e, this.minAzimuthAngle, this.maxAzimuthAngle), i = Et(t, this.minPolarAngle, this.maxPolarAngle);
+    const s = At(e, this.minAzimuthAngle, this.maxAzimuthAngle), i = At(t, this.minPolarAngle, this.maxPolarAngle);
     this._sphericalEnd.theta = s, this._sphericalEnd.phi = i, this._sphericalEnd.makeSafe(), this._needsUpdate = !0, n || (this._spherical.theta = this._sphericalEnd.theta, this._spherical.phi = this._sphericalEnd.phi);
     const r = !n || ke(this._spherical.theta, this._sphericalEnd.theta, this.restThreshold) && ke(this._spherical.phi, this._sphericalEnd.phi, this.restThreshold);
     return this._createOnRestPromise(r);
@@ -9741,7 +9769,7 @@ class ls extends yf {
    * @category Methods
    */
   dollyTo(e, t = !1) {
-    return this._isUserControllingDolly = !1, this._lastDollyDirection = Dn.NONE, this._changedDolly = 0, this._dollyToNoClamp(Et(e, this.minDistance, this.maxDistance), t);
+    return this._isUserControllingDolly = !1, this._lastDollyDirection = Ln.NONE, this._changedDolly = 0, this._dollyToNoClamp(At(e, this.minDistance, this.maxDistance), t);
   }
   _dollyToNoClamp(e, t = !1) {
     const n = this._sphericalEnd.radius;
@@ -9764,7 +9792,7 @@ class ls extends yf {
    * @category Methods
    */
   dollyInFixed(e, t = !1) {
-    this._targetEnd.add(this._getCameraDirection(qn).multiplyScalar(e)), t || this._target.copy(this._targetEnd);
+    this._targetEnd.add(this._getCameraDirection(is).multiplyScalar(e)), t || this._target.copy(this._targetEnd);
     const n = !t || ke(this._target.x, this._targetEnd.x, this.restThreshold) && ke(this._target.y, this._targetEnd.y, this.restThreshold) && ke(this._target.z, this._targetEnd.z, this.restThreshold);
     return this._createOnRestPromise(n);
   }
@@ -9786,7 +9814,7 @@ class ls extends yf {
    * @category Methods
    */
   zoomTo(e, t = !1) {
-    this._isUserControllingZoom = !1, this._zoomEnd = Et(e, this.minZoom, this.maxZoom), this._needsUpdate = !0, t || (this._zoom = this._zoomEnd);
+    this._isUserControllingZoom = !1, this._zoomEnd = At(e, this.minZoom, this.maxZoom), this._needsUpdate = !0, t || (this._zoom = this._zoomEnd);
     const n = !t || ke(this._zoom, this._zoomEnd, this.restThreshold);
     return this._changedZoom = 0, this._createOnRestPromise(n);
   }
@@ -9805,8 +9833,8 @@ class ls extends yf {
    * @category Methods
    */
   truck(e, t, n = !1) {
-    this._camera.updateMatrix(), Pt.setFromMatrixColumn(this._camera.matrix, 0), Rt.setFromMatrixColumn(this._camera.matrix, 1), Pt.multiplyScalar(e), Rt.multiplyScalar(-t);
-    const s = Ee.copy(Pt).add(Rt), i = Le.copy(this._targetEnd).add(s);
+    this._camera.updateMatrix(), Rt.setFromMatrixColumn(this._camera.matrix, 0), It.setFromMatrixColumn(this._camera.matrix, 1), Rt.multiplyScalar(e), It.multiplyScalar(-t);
+    const s = Ee.copy(Rt).add(It), i = Le.copy(this._targetEnd).add(s);
     return this.moveTo(i.x, i.y, i.z, n);
   }
   /**
@@ -9871,21 +9899,21 @@ class ls extends yf {
    * @category Methods
    */
   fitToBox(e, t, { cover: n = !1, paddingLeft: s = 0, paddingRight: i = 0, paddingBottom: r = 0, paddingTop: a = 0 } = {}) {
-    const l = [], c = e.isBox3 ? Fn.copy(e) : Fn.setFromObject(e);
+    const l = [], c = e.isBox3 ? Bn.copy(e) : Bn.setFromObject(e);
     c.isEmpty() && (console.warn("camera-controls: fitTo() cannot be used with an empty box. Aborting"), Promise.resolve());
-    const u = io(this._sphericalEnd.theta, so), h = io(this._sphericalEnd.phi, so);
+    const u = uo(this._sphericalEnd.theta, co), h = uo(this._sphericalEnd.phi, co);
     l.push(this.rotateTo(u, h, t));
-    const m = Ee.setFromSpherical(this._sphericalEnd).normalize(), p = uo.setFromUnitVectors(m, Ei), v = ke(Math.abs(m.y), 1);
-    v && p.multiply(Si.setFromAxisAngle(Ls, u)), p.multiply(this._yAxisUpSpaceInverse);
-    const _ = co.makeEmpty();
-    Le.copy(c.min).applyQuaternion(p), _.expandByPoint(Le), Le.copy(c.min).setX(c.max.x).applyQuaternion(p), _.expandByPoint(Le), Le.copy(c.min).setY(c.max.y).applyQuaternion(p), _.expandByPoint(Le), Le.copy(c.max).setZ(c.min.z).applyQuaternion(p), _.expandByPoint(Le), Le.copy(c.min).setZ(c.max.z).applyQuaternion(p), _.expandByPoint(Le), Le.copy(c.max).setY(c.min.y).applyQuaternion(p), _.expandByPoint(Le), Le.copy(c.max).setX(c.min.x).applyQuaternion(p), _.expandByPoint(Le), Le.copy(c.max).applyQuaternion(p), _.expandByPoint(Le), _.min.x -= s, _.min.y -= r, _.max.x += i, _.max.y += a, p.setFromUnitVectors(Ei, m), v && p.premultiply(Si.invert()), p.premultiply(this._yAxisUpSpace);
-    const y = _.getSize(Ee), E = _.getCenter(Le).applyQuaternion(p);
-    if (gn(this._camera)) {
-      const R = this.getDistanceToFitBox(y.x, y.y, y.z, n);
-      l.push(this.moveTo(E.x, E.y, E.z, t)), l.push(this.dollyTo(R, t)), l.push(this.setFocalOffset(0, 0, 0, t));
-    } else if (sn(this._camera)) {
-      const R = this._camera, T = R.right - R.left, g = R.top - R.bottom, A = n ? Math.max(T / y.x, g / y.y) : Math.min(T / y.x, g / y.y);
-      l.push(this.moveTo(E.x, E.y, E.z, t)), l.push(this.zoomTo(A, t)), l.push(this.setFocalOffset(0, 0, 0, t));
+    const f = Ee.setFromSpherical(this._sphericalEnd).normalize(), d = vo.setFromUnitVectors(f, Ii), y = ke(Math.abs(f.y), 1);
+    y && d.multiply(Oi.setFromAxisAngle(zs, u)), d.multiply(this._yAxisUpSpaceInverse);
+    const x = go.makeEmpty();
+    Le.copy(c.min).applyQuaternion(d), x.expandByPoint(Le), Le.copy(c.min).setX(c.max.x).applyQuaternion(d), x.expandByPoint(Le), Le.copy(c.min).setY(c.max.y).applyQuaternion(d), x.expandByPoint(Le), Le.copy(c.max).setZ(c.min.z).applyQuaternion(d), x.expandByPoint(Le), Le.copy(c.min).setZ(c.max.z).applyQuaternion(d), x.expandByPoint(Le), Le.copy(c.max).setY(c.min.y).applyQuaternion(d), x.expandByPoint(Le), Le.copy(c.max).setX(c.min.x).applyQuaternion(d), x.expandByPoint(Le), Le.copy(c.max).applyQuaternion(d), x.expandByPoint(Le), x.min.x -= s, x.min.y -= r, x.max.x += i, x.max.y += a, d.setFromUnitVectors(Ii, f), y && d.premultiply(Oi.invert()), d.premultiply(this._yAxisUpSpace);
+    const g = x.getSize(Ee), v = x.getCenter(Le).applyQuaternion(d);
+    if (_n(this._camera)) {
+      const M = this.getDistanceToFitBox(g.x, g.y, g.z, n);
+      l.push(this.moveTo(v.x, v.y, v.z, t)), l.push(this.dollyTo(M, t)), l.push(this.setFocalOffset(0, 0, 0, t));
+    } else if (on(this._camera)) {
+      const M = this._camera, _ = M.right - M.left, w = M.top - M.bottom, P = n ? Math.max(_ / g.x, w / g.y) : Math.min(_ / g.x, w / g.y);
+      l.push(this.moveTo(v.x, v.y, v.z, t)), l.push(this.zoomTo(P, t)), l.push(this.setFocalOffset(0, 0, 0, t));
     }
     return Promise.all(l);
   }
@@ -9896,11 +9924,11 @@ class ls extends yf {
    * @category Methods
    */
   fitToSphere(e, t) {
-    const n = [], i = e instanceof me.Sphere ? Mi.copy(e) : ls.createBoundingSphere(e, Mi);
-    if (n.push(this.moveTo(i.center.x, i.center.y, i.center.z, t)), gn(this._camera)) {
+    const n = [], i = e instanceof ge.Sphere ? Di.copy(e) : gs.createBoundingSphere(e, Di);
+    if (n.push(this.moveTo(i.center.x, i.center.y, i.center.z, t)), _n(this._camera)) {
       const r = this.getDistanceToFitSphere(i.radius);
       n.push(this.dollyTo(r, t));
-    } else if (sn(this._camera)) {
+    } else if (on(this._camera)) {
       const r = this._camera.right - this._camera.left, a = this._camera.top - this._camera.bottom, l = 2 * i.radius, c = Math.min(r / l, a / l);
       n.push(this.zoomTo(c, t));
     }
@@ -9918,7 +9946,7 @@ class ls extends yf {
    * @category Methods
    */
   setLookAt(e, t, n, s, i, r, a = !1) {
-    this._isUserControllingRotate = !1, this._isUserControllingDolly = !1, this._isUserControllingTruck = !1, this._lastDollyDirection = Dn.NONE, this._changedDolly = 0;
+    this._isUserControllingRotate = !1, this._isUserControllingDolly = !1, this._isUserControllingTruck = !1, this._lastDollyDirection = Ln.NONE, this._changedDolly = 0;
     const l = Le.set(s, i, r), c = Ee.set(e, t, n);
     this._targetEnd.copy(l), this._sphericalEnd.setFromVector3(c.sub(l).applyQuaternion(this._yAxisUpSpace)), this.normalizeRotations(), this._needsUpdate = !0, a || (this._target.copy(this._targetEnd), this._spherical.copy(this._sphericalEnd));
     const u = !a || ke(this._target.x, this._targetEnd.x, this.restThreshold) && ke(this._target.y, this._targetEnd.y, this.restThreshold) && ke(this._target.z, this._targetEnd.z, this.restThreshold) && ke(this._spherical.theta, this._sphericalEnd.theta, this.restThreshold) && ke(this._spherical.phi, this._sphericalEnd.phi, this.restThreshold) && ke(this._spherical.radius, this._sphericalEnd.radius, this.restThreshold);
@@ -9942,16 +9970,16 @@ class ls extends yf {
    * @param enableTransition
    * @category Methods
    */
-  lerpLookAt(e, t, n, s, i, r, a, l, c, u, h, m, p, v = !1) {
-    this._isUserControllingRotate = !1, this._isUserControllingDolly = !1, this._isUserControllingTruck = !1, this._lastDollyDirection = Dn.NONE, this._changedDolly = 0;
-    const _ = Ee.set(s, i, r), y = Le.set(e, t, n);
-    yt.setFromVector3(y.sub(_).applyQuaternion(this._yAxisUpSpace));
-    const E = On.set(u, h, m), R = Le.set(a, l, c);
-    Qn.setFromVector3(R.sub(E).applyQuaternion(this._yAxisUpSpace)), this._targetEnd.copy(_.lerp(E, p));
-    const T = Qn.theta - yt.theta, g = Qn.phi - yt.phi, A = Qn.radius - yt.radius;
-    this._sphericalEnd.set(yt.radius + A * p, yt.phi + g * p, yt.theta + T * p), this.normalizeRotations(), this._needsUpdate = !0, v || (this._target.copy(this._targetEnd), this._spherical.copy(this._sphericalEnd));
-    const x = !v || ke(this._target.x, this._targetEnd.x, this.restThreshold) && ke(this._target.y, this._targetEnd.y, this.restThreshold) && ke(this._target.z, this._targetEnd.z, this.restThreshold) && ke(this._spherical.theta, this._sphericalEnd.theta, this.restThreshold) && ke(this._spherical.phi, this._sphericalEnd.phi, this.restThreshold) && ke(this._spherical.radius, this._sphericalEnd.radius, this.restThreshold);
-    return this._createOnRestPromise(x);
+  lerpLookAt(e, t, n, s, i, r, a, l, c, u, h, f, d, y = !1) {
+    this._isUserControllingRotate = !1, this._isUserControllingDolly = !1, this._isUserControllingTruck = !1, this._lastDollyDirection = Ln.NONE, this._changedDolly = 0;
+    const x = Ee.set(s, i, r), g = Le.set(e, t, n);
+    yt.setFromVector3(g.sub(x).applyQuaternion(this._yAxisUpSpace));
+    const v = kn.set(u, h, f), M = Le.set(a, l, c);
+    rs.setFromVector3(M.sub(v).applyQuaternion(this._yAxisUpSpace)), this._targetEnd.copy(x.lerp(v, d));
+    const _ = rs.theta - yt.theta, w = rs.phi - yt.phi, P = rs.radius - yt.radius;
+    this._sphericalEnd.set(yt.radius + P * d, yt.phi + w * d, yt.theta + _ * d), this.normalizeRotations(), this._needsUpdate = !0, y || (this._target.copy(this._targetEnd), this._spherical.copy(this._sphericalEnd));
+    const T = !y || ke(this._target.x, this._targetEnd.x, this.restThreshold) && ke(this._target.y, this._targetEnd.y, this.restThreshold) && ke(this._target.z, this._targetEnd.z, this.restThreshold) && ke(this._spherical.theta, this._sphericalEnd.theta, this.restThreshold) && ke(this._spherical.phi, this._sphericalEnd.phi, this.restThreshold) && ke(this._spherical.radius, this._sphericalEnd.radius, this.restThreshold);
+    return this._createOnRestPromise(T);
   }
   /**
    * Set angle and distance by given position.
@@ -9976,7 +10004,7 @@ class ls extends yf {
    */
   setTarget(e, t, n, s = !1) {
     const i = this.getPosition(Ee), r = this.setLookAt(i.x, i.y, i.z, e, t, n, s);
-    return this._sphericalEnd.phi = Et(this._sphericalEnd.phi, this.minPolarAngle, this.maxPolarAngle), r;
+    return this._sphericalEnd.phi = At(this._sphericalEnd.phi, this.minPolarAngle, this.maxPolarAngle), r;
   }
   /**
    * Set focal offset using the screen parallel coordinates. z doesn't affect in Orthographic as with Dolly.
@@ -10000,9 +10028,9 @@ class ls extends yf {
    * @category Methods
    */
   setOrbitPoint(e, t, n) {
-    this._camera.updateMatrixWorld(), Pt.setFromMatrixColumn(this._camera.matrixWorldInverse, 0), Rt.setFromMatrixColumn(this._camera.matrixWorldInverse, 1), yn.setFromMatrixColumn(this._camera.matrixWorldInverse, 2);
+    this._camera.updateMatrixWorld(), Rt.setFromMatrixColumn(this._camera.matrixWorldInverse, 0), It.setFromMatrixColumn(this._camera.matrixWorldInverse, 1), xn.setFromMatrixColumn(this._camera.matrixWorldInverse, 2);
     const s = Ee.set(e, t, n), i = s.distanceTo(this._camera.position), r = s.sub(this._camera.position);
-    Pt.multiplyScalar(r.x), Rt.multiplyScalar(r.y), yn.multiplyScalar(r.z), Ee.copy(Pt).add(Rt).add(yn), Ee.z = Ee.z + i, this.dollyTo(i, !1), this.setFocalOffset(-Ee.x, Ee.y, -Ee.z, !1), this.moveTo(e, t, n, !1);
+    Rt.multiplyScalar(r.x), It.multiplyScalar(r.y), xn.multiplyScalar(r.z), Ee.copy(Rt).add(It).add(xn), Ee.z = Ee.z + i, this.dollyTo(i, !1), this.setFocalOffset(-Ee.x, Ee.y, -Ee.z, !1), this.moveTo(e, t, n, !1);
   }
   /**
    * Set the boundary box that encloses the target of the camera. box3 is in THREE.Box3
@@ -10030,7 +10058,7 @@ class ls extends yf {
       this._viewport = null;
       return;
     }
-    this._viewport = this._viewport || new me.Vector4(), typeof e == "number" ? this._viewport.set(e, t, n, s) : this._viewport.copy(e);
+    this._viewport = this._viewport || new ge.Vector4(), typeof e == "number" ? this._viewport.set(e, t, n, s) : this._viewport.copy(e);
   }
   /**
    * Calculate the distance to fit the box.
@@ -10041,9 +10069,9 @@ class ls extends yf {
    * @category Methods
    */
   getDistanceToFitBox(e, t, n, s = !1) {
-    if (bi(this._camera, "getDistanceToFitBox"))
+    if (Ci(this._camera, "getDistanceToFitBox"))
       return this._spherical.radius;
-    const i = e / t, r = this._camera.getEffectiveFOV() * $n, a = this._camera.aspect;
+    const i = e / t, r = this._camera.getEffectiveFOV() * ts, a = this._camera.aspect;
     return ((s ? i > a : i < a) ? t : e / a) * 0.5 / Math.tan(r * 0.5) + n * 0.5;
   }
   /**
@@ -10053,9 +10081,9 @@ class ls extends yf {
    * @category Methods
    */
   getDistanceToFitSphere(e) {
-    if (bi(this._camera, "getDistanceToFitSphere"))
+    if (Ci(this._camera, "getDistanceToFitSphere"))
       return this._spherical.radius;
-    const t = this._camera.getEffectiveFOV() * $n, n = Math.atan(Math.tan(t * 0.5) * this._camera.aspect) * 2, s = 1 < this._camera.aspect ? t : n;
+    const t = this._camera.getEffectiveFOV() * ts, n = Math.atan(Math.tan(t * 0.5) * this._camera.aspect) * 2, s = 1 < this._camera.aspect ? t : n;
     return e / Math.sin(s * 0.5);
   }
   /**
@@ -10065,7 +10093,7 @@ class ls extends yf {
    * @category Methods
    */
   getTarget(e, t = !0) {
-    return (e && e.isVector3 ? e : new me.Vector3()).copy(t ? this._targetEnd : this._target);
+    return (e && e.isVector3 ? e : new ge.Vector3()).copy(t ? this._targetEnd : this._target);
   }
   /**
    * Returns the camera position.
@@ -10074,7 +10102,7 @@ class ls extends yf {
    * @category Methods
    */
   getPosition(e, t = !0) {
-    return (e && e.isVector3 ? e : new me.Vector3()).setFromSpherical(t ? this._sphericalEnd : this._spherical).applyQuaternion(this._yAxisUpSpaceInverse).add(t ? this._targetEnd : this._target);
+    return (e && e.isVector3 ? e : new ge.Vector3()).setFromSpherical(t ? this._sphericalEnd : this._spherical).applyQuaternion(this._yAxisUpSpaceInverse).add(t ? this._targetEnd : this._target);
   }
   /**
    * Returns the spherical coordinates of the orbit.
@@ -10083,7 +10111,7 @@ class ls extends yf {
    * @category Methods
    */
   getSpherical(e, t = !0) {
-    return (e && e instanceof me.Spherical ? e : new me.Spherical()).copy(t ? this._sphericalEnd : this._spherical);
+    return (e && e instanceof ge.Spherical ? e : new ge.Spherical()).copy(t ? this._sphericalEnd : this._spherical);
   }
   /**
    * Returns the focal offset, which is how much the camera appears to be translated in screen parallel coordinates.
@@ -10092,14 +10120,14 @@ class ls extends yf {
    * @category Methods
    */
   getFocalOffset(e, t = !0) {
-    return (e && e.isVector3 ? e : new me.Vector3()).copy(t ? this._focalOffsetEnd : this._focalOffset);
+    return (e && e.isVector3 ? e : new ge.Vector3()).copy(t ? this._focalOffsetEnd : this._focalOffset);
   }
   /**
    * Normalize camera azimuth angle rotation between 0 and 360 degrees.
    * @category Methods
    */
   normalizeRotations() {
-    this._sphericalEnd.theta = this._sphericalEnd.theta % Ln, this._sphericalEnd.theta < 0 && (this._sphericalEnd.theta += Ln), this._spherical.theta += Ln * Math.round((this._sphericalEnd.theta - this._spherical.theta) / Ln);
+    this._sphericalEnd.theta = this._sphericalEnd.theta % Fn, this._sphericalEnd.theta < 0 && (this._sphericalEnd.theta += Fn), this._spherical.theta += Fn * Math.round((this._sphericalEnd.theta - this._spherical.theta) / Fn);
   }
   /**
    * Reset all rotation and position to defaults.
@@ -10132,7 +10160,7 @@ class ls extends yf {
    * @category Methods
    */
   updateCameraUp() {
-    this._yAxisUpSpace.setFromUnitVectors(this._camera.up, Ls), this._yAxisUpSpaceInverse.copy(this._yAxisUpSpace).invert();
+    this._yAxisUpSpace.setFromUnitVectors(this._camera.up, zs), this._yAxisUpSpaceInverse.copy(this._yAxisUpSpace).invert();
   }
   /**
    * Apply current camera-up direction to the camera.
@@ -10153,66 +10181,66 @@ class ls extends yf {
    * @category Methods
    */
   update(e) {
-    const t = this._sphericalEnd.theta - this._spherical.theta, n = this._sphericalEnd.phi - this._spherical.phi, s = this._sphericalEnd.radius - this._spherical.radius, i = ao.subVectors(this._targetEnd, this._target), r = lo.subVectors(this._focalOffsetEnd, this._focalOffset), a = this._zoomEnd - this._zoom;
+    const t = this._sphericalEnd.theta - this._spherical.theta, n = this._sphericalEnd.phi - this._spherical.phi, s = this._sphericalEnd.radius - this._spherical.radius, i = po.subVectors(this._targetEnd, this._target), r = mo.subVectors(this._focalOffsetEnd, this._focalOffset), a = this._zoomEnd - this._zoom;
     if (ze(t))
       this._thetaVelocity.value = 0, this._spherical.theta = this._sphericalEnd.theta;
     else {
       const h = this._isUserControllingRotate ? this.draggingSmoothTime : this.smoothTime;
-      this._spherical.theta = Is(this._spherical.theta, this._sphericalEnd.theta, this._thetaVelocity, h, 1 / 0, e), this._needsUpdate = !0;
+      this._spherical.theta = Us(this._spherical.theta, this._sphericalEnd.theta, this._thetaVelocity, h, 1 / 0, e), this._needsUpdate = !0;
     }
     if (ze(n))
       this._phiVelocity.value = 0, this._spherical.phi = this._sphericalEnd.phi;
     else {
       const h = this._isUserControllingRotate ? this.draggingSmoothTime : this.smoothTime;
-      this._spherical.phi = Is(this._spherical.phi, this._sphericalEnd.phi, this._phiVelocity, h, 1 / 0, e), this._needsUpdate = !0;
+      this._spherical.phi = Us(this._spherical.phi, this._sphericalEnd.phi, this._phiVelocity, h, 1 / 0, e), this._needsUpdate = !0;
     }
     if (ze(s))
       this._radiusVelocity.value = 0, this._spherical.radius = this._sphericalEnd.radius;
     else {
       const h = this._isUserControllingDolly ? this.draggingSmoothTime : this.smoothTime;
-      this._spherical.radius = Is(this._spherical.radius, this._sphericalEnd.radius, this._radiusVelocity, h, this.maxSpeed, e), this._needsUpdate = !0;
+      this._spherical.radius = Us(this._spherical.radius, this._sphericalEnd.radius, this._radiusVelocity, h, this.maxSpeed, e), this._needsUpdate = !0;
     }
     if (ze(i.x) && ze(i.y) && ze(i.z))
       this._targetVelocity.set(0, 0, 0), this._target.copy(this._targetEnd);
     else {
       const h = this._isUserControllingTruck ? this.draggingSmoothTime : this.smoothTime;
-      ro(this._target, this._targetEnd, this._targetVelocity, h, this.maxSpeed, e, this._target), this._needsUpdate = !0;
+      ho(this._target, this._targetEnd, this._targetVelocity, h, this.maxSpeed, e, this._target), this._needsUpdate = !0;
     }
     if (ze(r.x) && ze(r.y) && ze(r.z))
       this._focalOffsetVelocity.set(0, 0, 0), this._focalOffset.copy(this._focalOffsetEnd);
     else {
       const h = this._isUserControllingOffset ? this.draggingSmoothTime : this.smoothTime;
-      ro(this._focalOffset, this._focalOffsetEnd, this._focalOffsetVelocity, h, this.maxSpeed, e, this._focalOffset), this._needsUpdate = !0;
+      ho(this._focalOffset, this._focalOffsetEnd, this._focalOffsetVelocity, h, this.maxSpeed, e, this._focalOffset), this._needsUpdate = !0;
     }
     if (ze(a))
       this._zoomVelocity.value = 0, this._zoom = this._zoomEnd;
     else {
       const h = this._isUserControllingZoom ? this.draggingSmoothTime : this.smoothTime;
-      this._zoom = Is(this._zoom, this._zoomEnd, this._zoomVelocity, h, 1 / 0, e);
+      this._zoom = Us(this._zoom, this._zoomEnd, this._zoomVelocity, h, 1 / 0, e);
     }
     if (this.dollyToCursor) {
-      if (gn(this._camera) && this._changedDolly !== 0) {
-        const h = this._spherical.radius - this._lastDistance, m = this._camera, p = this._getCameraDirection(qn), v = Ee.copy(p).cross(m.up).normalize();
-        v.lengthSq() === 0 && (v.x = 1);
-        const _ = Le.crossVectors(v, p), y = this._sphericalEnd.radius * Math.tan(m.getEffectiveFOV() * $n * 0.5), R = (this._sphericalEnd.radius - h - this._sphericalEnd.radius) / this._sphericalEnd.radius, T = On.copy(this._targetEnd).add(v.multiplyScalar(this._dollyControlCoord.x * y * m.aspect)).add(_.multiplyScalar(this._dollyControlCoord.y * y)), g = Ee.copy(this._targetEnd).lerp(T, R), A = this._lastDollyDirection === Dn.IN && this._spherical.radius <= this.minDistance, x = this._lastDollyDirection === Dn.OUT && this.maxDistance <= this._spherical.radius;
-        if (this.infinityDolly && (A || x)) {
+      if (_n(this._camera) && this._changedDolly !== 0) {
+        const h = this._spherical.radius - this._lastDistance, f = this._camera, d = this._getCameraDirection(is), y = Ee.copy(d).cross(f.up).normalize();
+        y.lengthSq() === 0 && (y.x = 1);
+        const x = Le.crossVectors(y, d), g = this._sphericalEnd.radius * Math.tan(f.getEffectiveFOV() * ts * 0.5), M = (this._sphericalEnd.radius - h - this._sphericalEnd.radius) / this._sphericalEnd.radius, _ = kn.copy(this._targetEnd).add(y.multiplyScalar(this._dollyControlCoord.x * g * f.aspect)).add(x.multiplyScalar(this._dollyControlCoord.y * g)), w = Ee.copy(this._targetEnd).lerp(_, M), P = this._lastDollyDirection === Ln.IN && this._spherical.radius <= this.minDistance, T = this._lastDollyDirection === Ln.OUT && this.maxDistance <= this._spherical.radius;
+        if (this.infinityDolly && (P || T)) {
           this._sphericalEnd.radius -= h, this._spherical.radius -= h;
-          const d = Le.copy(p).multiplyScalar(-h);
-          g.add(d);
+          const m = Le.copy(d).multiplyScalar(-h);
+          w.add(m);
         }
-        this._boundary.clampPoint(g, g);
-        const M = Le.subVectors(g, this._targetEnd);
-        this._targetEnd.copy(g), this._target.add(M), this._changedDolly -= h, ze(this._changedDolly) && (this._changedDolly = 0);
-      } else if (sn(this._camera) && this._changedZoom !== 0) {
-        const h = this._zoom - this._lastZoom, m = this._camera, p = Ee.set(this._dollyControlCoord.x, this._dollyControlCoord.y, (m.near + m.far) / (m.near - m.far)).unproject(m), v = Le.set(0, 0, -1).applyQuaternion(m.quaternion), _ = On.copy(p).add(v.multiplyScalar(-p.dot(m.up))), E = -(this._zoom - h - this._zoom) / this._zoom, R = this._getCameraDirection(qn), T = this._targetEnd.dot(R), g = Ee.copy(this._targetEnd).lerp(_, E), A = g.dot(R), x = R.multiplyScalar(A - T);
-        g.sub(x), this._boundary.clampPoint(g, g);
-        const M = Le.subVectors(g, this._targetEnd);
-        this._targetEnd.copy(g), this._target.add(M), this._changedZoom -= h, ze(this._changedZoom) && (this._changedZoom = 0);
+        this._boundary.clampPoint(w, w);
+        const E = Le.subVectors(w, this._targetEnd);
+        this._targetEnd.copy(w), this._target.add(E), this._changedDolly -= h, ze(this._changedDolly) && (this._changedDolly = 0);
+      } else if (on(this._camera) && this._changedZoom !== 0) {
+        const h = this._zoom - this._lastZoom, f = this._camera, d = Ee.set(this._dollyControlCoord.x, this._dollyControlCoord.y, (f.near + f.far) / (f.near - f.far)).unproject(f), y = Le.set(0, 0, -1).applyQuaternion(f.quaternion), x = kn.copy(d).add(y.multiplyScalar(-d.dot(f.up))), v = -(this._zoom - h - this._zoom) / this._zoom, M = this._getCameraDirection(is), _ = this._targetEnd.dot(M), w = Ee.copy(this._targetEnd).lerp(x, v), P = w.dot(M), T = M.multiplyScalar(P - _);
+        w.sub(T), this._boundary.clampPoint(w, w);
+        const E = Le.subVectors(w, this._targetEnd);
+        this._targetEnd.copy(w), this._target.add(E), this._changedZoom -= h, ze(this._changedZoom) && (this._changedZoom = 0);
       }
     }
     this._camera.zoom !== this._zoom && (this._camera.zoom = this._zoom, this._camera.updateProjectionMatrix(), this._updateNearPlaneCorners(), this._needsUpdate = !0), this._dragNeedsUpdate = !0;
     const l = this._collisionTest();
-    this._spherical.radius = Math.min(this._spherical.radius, l), this._spherical.makeSafe(), this._camera.position.setFromSpherical(this._spherical).applyQuaternion(this._yAxisUpSpaceInverse).add(this._target), this._camera.lookAt(this._target), (!ze(this._focalOffset.x) || !ze(this._focalOffset.y) || !ze(this._focalOffset.z)) && (this._camera.updateMatrixWorld(), Pt.setFromMatrixColumn(this._camera.matrix, 0), Rt.setFromMatrixColumn(this._camera.matrix, 1), yn.setFromMatrixColumn(this._camera.matrix, 2), Pt.multiplyScalar(this._focalOffset.x), Rt.multiplyScalar(-this._focalOffset.y), yn.multiplyScalar(this._focalOffset.z), Ee.copy(Pt).add(Rt).add(yn), this._camera.position.add(Ee)), this._boundaryEnclosesCamera && this._encloseToBoundary(this._camera.position.copy(this._target), Ee.setFromSpherical(this._spherical).applyQuaternion(this._yAxisUpSpaceInverse), 1);
+    this._spherical.radius = Math.min(this._spherical.radius, l), this._spherical.makeSafe(), this._camera.position.setFromSpherical(this._spherical).applyQuaternion(this._yAxisUpSpaceInverse).add(this._target), this._camera.lookAt(this._target), (!ze(this._focalOffset.x) || !ze(this._focalOffset.y) || !ze(this._focalOffset.z)) && (this._camera.updateMatrixWorld(), Rt.setFromMatrixColumn(this._camera.matrix, 0), It.setFromMatrixColumn(this._camera.matrix, 1), xn.setFromMatrixColumn(this._camera.matrix, 2), Rt.multiplyScalar(this._focalOffset.x), It.multiplyScalar(-this._focalOffset.y), xn.multiplyScalar(this._focalOffset.z), Ee.copy(Rt).add(It).add(xn), this._camera.position.add(Ee)), this._boundaryEnclosesCamera && this._encloseToBoundary(this._camera.position.copy(this._target), Ee.setFromSpherical(this._spherical).applyQuaternion(this._yAxisUpSpaceInverse), 1);
     const u = this._needsUpdate;
     return u && !this._updatedLastTime ? (this._hasRested = !1, this.dispatchEvent({ type: "wake" }), this.dispatchEvent({ type: "update" })) : u ? (this.dispatchEvent({ type: "update" }), ze(t, this.restThreshold) && ze(n, this.restThreshold) && ze(s, this.restThreshold) && ze(i.x, this.restThreshold) && ze(i.y, this.restThreshold) && ze(i.z, this.restThreshold) && ze(r.x, this.restThreshold) && ze(r.y, this.restThreshold) && ze(r.z, this.restThreshold) && ze(a, this.restThreshold) && !this._hasRested && (this._hasRested = !0, this.dispatchEvent({ type: "rest" }))) : !u && this._updatedLastTime && this.dispatchEvent({ type: "sleep" }), this._lastDistance = this._spherical.radius, this._lastZoom = this._zoom, this._updatedLastTime = u, this._needsUpdate = !1, u;
   }
@@ -10224,13 +10252,13 @@ class ls extends yf {
     return JSON.stringify({
       enabled: this._enabled,
       minDistance: this.minDistance,
-      maxDistance: Zn(this.maxDistance),
+      maxDistance: ns(this.maxDistance),
       minZoom: this.minZoom,
-      maxZoom: Zn(this.maxZoom),
+      maxZoom: ns(this.maxZoom),
       minPolarAngle: this.minPolarAngle,
-      maxPolarAngle: Zn(this.maxPolarAngle),
-      minAzimuthAngle: Zn(this.minAzimuthAngle),
-      maxAzimuthAngle: Zn(this.maxAzimuthAngle),
+      maxPolarAngle: ns(this.maxPolarAngle),
+      minAzimuthAngle: ns(this.minAzimuthAngle),
+      maxAzimuthAngle: ns(this.maxAzimuthAngle),
       smoothTime: this.smoothTime,
       draggingSmoothTime: this.draggingSmoothTime,
       dollySpeed: this.dollySpeed,
@@ -10255,7 +10283,7 @@ class ls extends yf {
    */
   fromJSON(e, t = !1) {
     const n = JSON.parse(e);
-    this.enabled = n.enabled, this.minDistance = n.minDistance, this.maxDistance = Kn(n.maxDistance), this.minZoom = n.minZoom, this.maxZoom = Kn(n.maxZoom), this.minPolarAngle = n.minPolarAngle, this.maxPolarAngle = Kn(n.maxPolarAngle), this.minAzimuthAngle = Kn(n.minAzimuthAngle), this.maxAzimuthAngle = Kn(n.maxAzimuthAngle), this.smoothTime = n.smoothTime, this.draggingSmoothTime = n.draggingSmoothTime, this.dollySpeed = n.dollySpeed, this.truckSpeed = n.truckSpeed, this.dollyToCursor = n.dollyToCursor, this.verticalDragToForward = n.verticalDragToForward, this._target0.fromArray(n.target0), this._position0.fromArray(n.position0), this._zoom0 = n.zoom0, this._focalOffset0.fromArray(n.focalOffset0), this.moveTo(n.target[0], n.target[1], n.target[2], t), yt.setFromVector3(Ee.fromArray(n.position).sub(this._targetEnd).applyQuaternion(this._yAxisUpSpace)), this.rotateTo(yt.theta, yt.phi, t), this.dollyTo(yt.radius, t), this.zoomTo(n.zoom, t), this.setFocalOffset(n.focalOffset[0], n.focalOffset[1], n.focalOffset[2], t), this._needsUpdate = !0;
+    this.enabled = n.enabled, this.minDistance = n.minDistance, this.maxDistance = ss(n.maxDistance), this.minZoom = n.minZoom, this.maxZoom = ss(n.maxZoom), this.minPolarAngle = n.minPolarAngle, this.maxPolarAngle = ss(n.maxPolarAngle), this.minAzimuthAngle = ss(n.minAzimuthAngle), this.maxAzimuthAngle = ss(n.maxAzimuthAngle), this.smoothTime = n.smoothTime, this.draggingSmoothTime = n.draggingSmoothTime, this.dollySpeed = n.dollySpeed, this.truckSpeed = n.truckSpeed, this.dollyToCursor = n.dollyToCursor, this.verticalDragToForward = n.verticalDragToForward, this._target0.fromArray(n.target0), this._position0.fromArray(n.position0), this._zoom0 = n.zoom0, this._focalOffset0.fromArray(n.focalOffset0), this.moveTo(n.target[0], n.target[1], n.target[2], t), yt.setFromVector3(Ee.fromArray(n.position).sub(this._targetEnd).applyQuaternion(this._yAxisUpSpace)), this.rotateTo(yt.theta, yt.phi, t), this.dollyTo(yt.radius, t), this.zoomTo(n.zoom, t), this.setFocalOffset(n.focalOffset[0], n.focalOffset[1], n.focalOffset[2], t), this._needsUpdate = !0;
   }
   /**
    * Attach all internal event handlers to enable drag control.
@@ -10266,7 +10294,7 @@ class ls extends yf {
       console.warn("camera-controls is already connected.");
       return;
     }
-    e.setAttribute("data-camera-controls-version", vf), this._addAllEventListeners(e), this._getClientRect(this._elementRect);
+    e.setAttribute("data-camera-controls-version", Mf), this._addAllEventListeners(e), this._getClientRect(this._elementRect);
   }
   /**
    * Detach all internal event handlers to disable drag control.
@@ -10302,7 +10330,7 @@ class ls extends yf {
     const s = t.lengthSq();
     if (s === 0)
       return e;
-    const i = Le.copy(t).add(e), a = this._boundary.clampPoint(i, On).sub(i), l = a.lengthSq();
+    const i = Le.copy(t).add(e), a = this._boundary.clampPoint(i, kn).sub(i), l = a.lengthSq();
     if (l === 0)
       return e.add(t);
     if (l === s)
@@ -10315,10 +10343,10 @@ class ls extends yf {
     }
   }
   _updateNearPlaneCorners() {
-    if (gn(this._camera)) {
-      const e = this._camera, t = e.near, n = e.getEffectiveFOV() * $n, s = Math.tan(n * 0.5) * t, i = s * e.aspect;
+    if (_n(this._camera)) {
+      const e = this._camera, t = e.near, n = e.getEffectiveFOV() * ts, s = Math.tan(n * 0.5) * t, i = s * e.aspect;
       this._nearPlaneCorners[0].set(-i, -s, 0), this._nearPlaneCorners[1].set(i, -s, 0), this._nearPlaneCorners[2].set(i, s, 0), this._nearPlaneCorners[3].set(-i, s, 0);
-    } else if (sn(this._camera)) {
+    } else if (on(this._camera)) {
       const e = this._camera, t = 1 / e.zoom, n = e.left * t, s = e.right * t, i = e.top * t, r = e.bottom * t;
       this._nearPlaneCorners[0].set(n, i, 0), this._nearPlaneCorners[1].set(s, i, 0), this._nearPlaneCorners[2].set(s, r, 0), this._nearPlaneCorners[3].set(n, r, 0);
     }
@@ -10326,16 +10354,16 @@ class ls extends yf {
   // lateUpdate
   _collisionTest() {
     let e = 1 / 0;
-    if (!(this.colliderMeshes.length >= 1) || bi(this._camera, "_collisionTest"))
+    if (!(this.colliderMeshes.length >= 1) || Ci(this._camera, "_collisionTest"))
       return e;
-    const n = this._getTargetDirection(qn);
-    Ai.lookAt(oo, n, this._camera.up);
+    const n = this._getTargetDirection(is);
+    Li.lookAt(fo, n, this._camera.up);
     for (let s = 0; s < 4; s++) {
       const i = Le.copy(this._nearPlaneCorners[s]);
-      i.applyMatrix4(Ai);
-      const r = On.addVectors(this._target, i);
-      Os.set(r, n), Os.far = this._spherical.radius + 1;
-      const a = Os.intersectObjects(this.colliderMeshes);
+      i.applyMatrix4(Li);
+      const r = kn.addVectors(this._target, i);
+      Hs.set(r, n), Hs.far = this._spherical.radius + 1;
+      const a = Hs.intersectObjects(this.colliderMeshes);
       a.length !== 0 && a[0].distance < e && (e = a[0].distance);
     }
     return e;
@@ -10394,11 +10422,11 @@ class ls extends yf {
   set draggingDampingFactor(e) {
     console.warn(".draggingDampingFactor has been deprecated. use draggingSmoothTime (in seconds) instead.");
   }
-  static createBoundingSphere(e, t = new me.Sphere()) {
+  static createBoundingSphere(e, t = new ge.Sphere()) {
     const n = t, s = n.center;
-    Fn.makeEmpty(), e.traverseVisible((r) => {
-      r.isMesh && Fn.expandByObject(r);
-    }), Fn.getCenter(s);
+    Bn.makeEmpty(), e.traverseVisible((r) => {
+      r.isMesh && Bn.expandByObject(r);
+    }), Bn.getCenter(s);
     let i = 0;
     return e.traverseVisible((r) => {
       if (!r.isMesh)
@@ -10406,12 +10434,12 @@ class ls extends yf {
       const a = r, l = a.geometry.clone();
       l.applyMatrix4(a.matrixWorld);
       const u = l.attributes.position;
-      for (let h = 0, m = u.count; h < m; h++)
+      for (let h = 0, f = u.count; h < f; h++)
         Ee.fromBufferAttribute(u, h), i = Math.max(i, s.distanceToSquared(Ee));
     }), n.radius = Math.sqrt(i), n;
   }
 }
-const wf = ["min-polar-angle", "max-polar-angle", "min-azimuth-angle", "max-azimuth-angle", "distance", "min-distance", "max-distance", "infinity-dolly", "min-zoom", "max-zoom", "smooth-time", "dragging-smooth-time", "max-speed", "azimuth-rotate-speed", "polar-rotate-speed", "dolly-speed", "dolly-drag-inverted", "truck-speed", "dolly-to-cursor", "drag-to-offset", "vertical-drag-to-forward", "boundary-friction", "rest-threshold", "collider-meshes", "args"], Jm = /* @__PURE__ */ pe({
+const Pf = ["min-polar-angle", "max-polar-angle", "min-azimuth-angle", "max-azimuth-angle", "distance", "min-distance", "max-distance", "infinity-dolly", "min-zoom", "max-zoom", "smooth-time", "dragging-smooth-time", "max-speed", "azimuth-rotate-speed", "polar-rotate-speed", "dolly-speed", "dolly-drag-inverted", "truck-speed", "dolly-to-cursor", "drag-to-offset", "vertical-drag-to-forward", "boundary-friction", "rest-threshold", "collider-meshes", "args"], _g = /* @__PURE__ */ pe({
   __name: "CameraControls",
   props: {
     makeDefault: { type: Boolean, default: !1 },
@@ -10421,7 +10449,7 @@ const wf = ["min-polar-angle", "max-polar-angle", "min-azimuth-angle", "max-azim
     maxPolarAngle: { default: Math.PI },
     minAzimuthAngle: { default: -1 / 0 },
     maxAzimuthAngle: { default: 1 / 0 },
-    distance: { default: () => je().camera.value.position.z },
+    distance: { default: () => Ue().camera.value.position.z },
     minDistance: { default: Number.EPSILON },
     maxDistance: { default: 1 / 0 },
     infinityDolly: { type: Boolean, default: !1 },
@@ -10454,87 +10482,87 @@ const wf = ["min-polar-angle", "max-polar-angle", "min-azimuth-angle", "max-azim
       maxAzimuthAngle: c,
       distance: u,
       minDistance: h,
-      maxDistance: m,
-      infinityDolly: p,
-      minZoom: v,
-      maxZoom: _,
-      smoothTime: y,
-      draggingSmoothTime: E,
-      maxSpeed: R,
-      azimuthRotateSpeed: T,
-      polarRotateSpeed: g,
-      dollySpeed: A,
-      dollyDragInverted: x,
-      truckSpeed: M,
-      dollyToCursor: d,
-      dragToOffset: w,
-      verticalDragToForward: f,
-      boundaryFriction: P,
+      maxDistance: f,
+      infinityDolly: d,
+      minZoom: y,
+      maxZoom: x,
+      smoothTime: g,
+      draggingSmoothTime: v,
+      maxSpeed: M,
+      azimuthRotateSpeed: _,
+      polarRotateSpeed: w,
+      dollySpeed: P,
+      dollyDragInverted: T,
+      truckSpeed: E,
+      dollyToCursor: m,
+      dragToOffset: b,
+      verticalDragToForward: p,
+      boundaryFriction: C,
       restThreshold: I,
       colliderMeshes: K
-    } = Fe(n), N = {
-      Box3: hs,
+    } = Oe(n), z = {
+      Box3: xs,
       MathUtils: {
-        clamp: We.clamp
+        clamp: Ze.clamp
       },
-      Matrix4: De,
+      Matrix4: Pe,
       Quaternion: He,
-      Raycaster: Vo,
-      Sphere: Qs,
-      Spherical: Ws,
-      Vector2: le,
-      Vector3: ee,
-      Vector4: ht
+      Raycaster: qo,
+      Sphere: ri,
+      Spherical: qs,
+      Vector2: he,
+      Vector3: q,
+      Vector4: rt
     };
-    ls.install({ THREE: N });
-    const { camera: Z, renderer: W, extend: X, controls: V } = je(), ne = ue(null);
-    X({ CameraControls: ls }), ft(() => {
-      se(), ne.value && i.value ? V.value = ne.value : V.value = null;
+    gs.install({ THREE: z });
+    const { camera: Y, renderer: W, extend: X, controls: V } = Ue(), te = ue(null);
+    X({ CameraControls: gs }), lt(() => {
+      se(), te.value && i.value ? V.value = te.value : V.value = null;
     });
     function se() {
-      Ve(ne.value, "update", () => s("change", ne.value)), Ve(ne.value, "controlend", () => s("end", ne.value)), Ve(ne.value, "controlstart", () => s("start", ne.value));
+      Ge(te.value, "update", () => s("change", te.value)), Ge(te.value, "controlend", () => s("end", te.value)), Ge(te.value, "controlstart", () => s("start", te.value));
     }
-    const { onLoop: he } = Ke();
-    return he(({ delta: H }) => {
-      var k, b;
-      (k = ne.value) != null && k.enabled && ((b = ne.value) == null || b.update(H));
+    const { onLoop: fe } = Xe();
+    return fe(({ delta: H }) => {
+      var k, S;
+      (k = te.value) != null && k.enabled && ((S = te.value) == null || S.update(H));
     }), ot(() => {
-      ne.value && ne.value.disconnect();
+      te.value && te.value.disconnect();
     }), e({
-      value: ne
-    }), (H, k) => (H.camera || z(Z)) && (H.domElement || z(W)) ? (fe(), de("TresCameraControls", {
+      value: te
+    }), (H, k) => (H.camera || B(Y)) && (H.domElement || B(W)) ? (le(), ce("TresCameraControls", {
       key: 0,
       ref_key: "controlsRef",
-      ref: ne,
-      "min-polar-angle": z(r),
-      "max-polar-angle": z(a),
-      "min-azimuth-angle": z(l),
-      "max-azimuth-angle": z(c),
-      distance: z(u),
-      "min-distance": z(h),
-      "max-distance": z(m),
-      "infinity-dolly": z(p),
-      "min-zoom": z(v),
-      "max-zoom": z(_),
-      "smooth-time": z(y),
-      "dragging-smooth-time": z(E),
-      "max-speed": z(R),
-      "azimuth-rotate-speed": z(T),
-      "polar-rotate-speed": z(g),
-      "dolly-speed": z(A),
-      "dolly-drag-inverted": z(x),
-      "truck-speed": z(M),
-      "dolly-to-cursor": z(d),
-      "drag-to-offset": z(w),
-      "vertical-drag-to-forward": z(f),
-      "boundary-friction": z(P),
-      "rest-threshold": z(I),
-      "collider-meshes": z(K),
-      args: [H.camera || z(Z), H.domElement || z(W).domElement]
-    }, null, 8, wf)) : Wt("", !0);
+      ref: te,
+      "min-polar-angle": B(r),
+      "max-polar-angle": B(a),
+      "min-azimuth-angle": B(l),
+      "max-azimuth-angle": B(c),
+      distance: B(u),
+      "min-distance": B(h),
+      "max-distance": B(f),
+      "infinity-dolly": B(d),
+      "min-zoom": B(y),
+      "max-zoom": B(x),
+      "smooth-time": B(g),
+      "dragging-smooth-time": B(v),
+      "max-speed": B(M),
+      "azimuth-rotate-speed": B(_),
+      "polar-rotate-speed": B(w),
+      "dolly-speed": B(P),
+      "dolly-drag-inverted": B(T),
+      "truck-speed": B(E),
+      "dolly-to-cursor": B(m),
+      "drag-to-offset": B(b),
+      "vertical-drag-to-forward": B(p),
+      "boundary-friction": B(C),
+      "rest-threshold": B(I),
+      "collider-meshes": B(K),
+      args: [H.camera || B(Y), H.domElement || B(W).domElement]
+    }, null, 8, Pf)) : Ut("", !0);
   }
 });
-class Tf extends us {
+class Cf extends ys {
   constructor(t = {}) {
     super(t);
     oe(this, "_time");
@@ -10569,40 +10597,40 @@ class Tf extends us {
     this._factor.value = t;
   }
 }
-const bf = ["factor"], eg = /* @__PURE__ */ pe({
+const Rf = ["factor"], xg = /* @__PURE__ */ pe({
   __name: "index",
   props: {
     speed: { default: 1 },
     factor: { default: 1 }
   },
   setup(o) {
-    const e = o, t = xe(), { extend: n } = je();
-    n({ MeshWobbleMaterial: Tf });
-    const { onLoop: s } = Ke();
+    const e = o, t = me(), { extend: n } = Ue();
+    n({ MeshWobbleMaterial: Cf });
+    const { onLoop: s } = Xe();
     return s(({ elapsed: i }) => {
       t.value && (t.value.time = i * (e == null ? void 0 : e.speed));
-    }), (i, r) => (fe(), de("TresMeshWobbleMaterial", Ye({
+    }), (i, r) => (le(), ce("TresMeshWobbleMaterial", Ye({
       ref_key: "materialRef",
       ref: t,
       factor: i.factor
-    }, i.$attrs), null, 16, bf));
+    }, i.$attrs), null, 16, Rf));
   }
 });
-function cn(o, e, t) {
+function hn(o, e, t) {
   return Math.max(e, Math.min(t, o));
 }
-function Ef(o, e) {
+function If(o, e) {
   return (o % e + e) % e;
 }
-function Mf(o, e, t, n, s) {
+function Df(o, e, t, n, s) {
   return n + (o - e) * (s - n) / (t - e);
 }
-function Pi(o, e, t) {
+function Fi(o, e, t) {
   return (1 - t) * o + t * e;
 }
-class yr {
+class br {
   constructor(e = 0, t = 0) {
-    yr.prototype.isVector2 = !0, this.x = e, this.y = t;
+    br.prototype.isVector2 = !0, this.x = e, this.y = t;
   }
   get width() {
     return this.x;
@@ -10751,7 +10779,7 @@ class yr {
     if (t === 0)
       return Math.PI / 2;
     const n = this.dot(e) / t;
-    return Math.acos(cn(n, -1, 1));
+    return Math.acos(hn(n, -1, 1));
   }
   distanceTo(e) {
     return Math.sqrt(this.distanceToSquared(e));
@@ -10795,10 +10823,10 @@ class yr {
     yield this.x, yield this.y;
   }
 }
-const Sf = "", rn = "srgb", vr = "srgb-linear", Af = "display-p3", Ha = "display-p3-linear", tr = "linear", ho = "srgb", fo = "rec709", po = "p3";
-class gs {
+const Of = "", an = "srgb", Er = "srgb-linear", Lf = "display-p3", $a = "display-p3-linear", or = "linear", yo = "srgb", _o = "rec709", xo = "p3";
+class bs {
   constructor(e, t, n, s, i, r, a, l, c) {
-    gs.prototype.isMatrix3 = !0, this.elements = [
+    bs.prototype.isMatrix3 = !0, this.elements = [
       1,
       0,
       0,
@@ -10855,8 +10883,8 @@ class gs {
     return this.multiplyMatrices(e, this);
   }
   multiplyMatrices(e, t) {
-    const n = e.elements, s = t.elements, i = this.elements, r = n[0], a = n[3], l = n[6], c = n[1], u = n[4], h = n[7], m = n[2], p = n[5], v = n[8], _ = s[0], y = s[3], E = s[6], R = s[1], T = s[4], g = s[7], A = s[2], x = s[5], M = s[8];
-    return i[0] = r * _ + a * R + l * A, i[3] = r * y + a * T + l * x, i[6] = r * E + a * g + l * M, i[1] = c * _ + u * R + h * A, i[4] = c * y + u * T + h * x, i[7] = c * E + u * g + h * M, i[2] = m * _ + p * R + v * A, i[5] = m * y + p * T + v * x, i[8] = m * E + p * g + v * M, this;
+    const n = e.elements, s = t.elements, i = this.elements, r = n[0], a = n[3], l = n[6], c = n[1], u = n[4], h = n[7], f = n[2], d = n[5], y = n[8], x = s[0], g = s[3], v = s[6], M = s[1], _ = s[4], w = s[7], P = s[2], T = s[5], E = s[8];
+    return i[0] = r * x + a * M + l * P, i[3] = r * g + a * _ + l * T, i[6] = r * v + a * w + l * E, i[1] = c * x + u * M + h * P, i[4] = c * g + u * _ + h * T, i[7] = c * v + u * w + h * E, i[2] = f * x + d * M + y * P, i[5] = f * g + d * _ + y * T, i[8] = f * v + d * w + y * E, this;
   }
   multiplyScalar(e) {
     const t = this.elements;
@@ -10867,11 +10895,11 @@ class gs {
     return t * r * u - t * a * c - n * i * u + n * a * l + s * i * c - s * r * l;
   }
   invert() {
-    const e = this.elements, t = e[0], n = e[1], s = e[2], i = e[3], r = e[4], a = e[5], l = e[6], c = e[7], u = e[8], h = u * r - a * c, m = a * l - u * i, p = c * i - r * l, v = t * h + n * m + s * p;
-    if (v === 0)
+    const e = this.elements, t = e[0], n = e[1], s = e[2], i = e[3], r = e[4], a = e[5], l = e[6], c = e[7], u = e[8], h = u * r - a * c, f = a * l - u * i, d = c * i - r * l, y = t * h + n * f + s * d;
+    if (y === 0)
       return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0);
-    const _ = 1 / v;
-    return e[0] = h * _, e[1] = (s * c - u * n) * _, e[2] = (a * n - s * r) * _, e[3] = m * _, e[4] = (u * t - s * l) * _, e[5] = (s * i - a * t) * _, e[6] = p * _, e[7] = (n * l - c * t) * _, e[8] = (r * t - n * i) * _, this;
+    const x = 1 / y;
+    return e[0] = h * x, e[1] = (s * c - u * n) * x, e[2] = (a * n - s * r) * x, e[3] = f * x, e[4] = (u * t - s * l) * x, e[5] = (s * i - a * t) * x, e[6] = d * x, e[7] = (n * l - c * t) * x, e[8] = (r * t - n * i) * x, this;
   }
   transpose() {
     let e;
@@ -10901,13 +10929,13 @@ class gs {
   }
   //
   scale(e, t) {
-    return this.premultiply(Ri.makeScale(e, t)), this;
+    return this.premultiply(ki.makeScale(e, t)), this;
   }
   rotate(e) {
-    return this.premultiply(Ri.makeRotation(-e)), this;
+    return this.premultiply(ki.makeRotation(-e)), this;
   }
   translate(e, t) {
-    return this.premultiply(Ri.makeTranslation(e, t)), this;
+    return this.premultiply(ki.makeTranslation(e, t)), this;
   }
   // for 2D Transforms
   makeTranslation(e, t) {
@@ -10981,7 +11009,7 @@ class gs {
     return new this.constructor().fromArray(this.elements);
   }
 }
-const Ri = /* @__PURE__ */ new gs(), mo = /* @__PURE__ */ new gs().set(
+const ki = /* @__PURE__ */ new bs(), wo = /* @__PURE__ */ new bs().set(
   0.8224621,
   0.177538,
   0,
@@ -10991,7 +11019,7 @@ const Ri = /* @__PURE__ */ new gs(), mo = /* @__PURE__ */ new gs().set(
   0.0170827,
   0.0723974,
   0.9105199
-), go = /* @__PURE__ */ new gs().set(
+), To = /* @__PURE__ */ new bs().set(
   1.2249401,
   -0.2249404,
   0,
@@ -11001,46 +11029,46 @@ const Ri = /* @__PURE__ */ new gs(), mo = /* @__PURE__ */ new gs().set(
   -0.0196376,
   -0.0786361,
   1.0982735
-), Fs = {
-  [vr]: {
-    transfer: tr,
-    primaries: fo,
+), js = {
+  [Er]: {
+    transfer: or,
+    primaries: _o,
     toReference: (o) => o,
     fromReference: (o) => o
   },
-  [rn]: {
-    transfer: ho,
-    primaries: fo,
+  [an]: {
+    transfer: yo,
+    primaries: _o,
     toReference: (o) => o.convertSRGBToLinear(),
     fromReference: (o) => o.convertLinearToSRGB()
   },
-  [Ha]: {
-    transfer: tr,
-    primaries: po,
-    toReference: (o) => o.applyMatrix3(go),
-    fromReference: (o) => o.applyMatrix3(mo)
+  [$a]: {
+    transfer: or,
+    primaries: xo,
+    toReference: (o) => o.applyMatrix3(To),
+    fromReference: (o) => o.applyMatrix3(wo)
   },
-  [Af]: {
-    transfer: ho,
-    primaries: po,
-    toReference: (o) => o.convertSRGBToLinear().applyMatrix3(go),
-    fromReference: (o) => o.applyMatrix3(mo).convertLinearToSRGB()
+  [Lf]: {
+    transfer: yo,
+    primaries: xo,
+    toReference: (o) => o.convertSRGBToLinear().applyMatrix3(To),
+    fromReference: (o) => o.applyMatrix3(wo).convertLinearToSRGB()
   }
-}, Pf = /* @__PURE__ */ new Set([vr, Ha]), Tt = {
+}, Ff = /* @__PURE__ */ new Set([Er, $a]), St = {
   enabled: !0,
-  _workingColorSpace: vr,
+  _workingColorSpace: Er,
   get workingColorSpace() {
     return this._workingColorSpace;
   },
   set workingColorSpace(o) {
-    if (!Pf.has(o))
+    if (!Ff.has(o))
       throw new Error(`Unsupported working color space, "${o}".`);
     this._workingColorSpace = o;
   },
   convert: function(o, e, t) {
     if (this.enabled === !1 || e === t || !e || !t)
       return o;
-    const n = Fs[e].toReference, s = Fs[t].fromReference;
+    const n = js[e].toReference, s = js[t].fromReference;
     return s(n(o));
   },
   fromWorkingColorSpace: function(o, e) {
@@ -11050,19 +11078,19 @@ const Ri = /* @__PURE__ */ new gs(), mo = /* @__PURE__ */ new gs().set(
     return this.convert(o, e, this._workingColorSpace);
   },
   getPrimaries: function(o) {
-    return Fs[o].primaries;
+    return js[o].primaries;
   },
   getTransfer: function(o) {
-    return o === Sf ? tr : Fs[o].transfer;
+    return o === Of ? or : js[o].transfer;
   }
 };
-function Ci(o) {
+function Bi(o) {
   return o < 0.04045 ? o * 0.0773993808 : Math.pow(o * 0.9478672986 + 0.0521327014, 2.4);
 }
-function Ii(o) {
+function Ui(o) {
   return o < 31308e-7 ? o * 12.92 : 1.055 * Math.pow(o, 0.41666) - 0.055;
 }
-const Ga = {
+const Za = {
   aliceblue: 15792383,
   antiquewhite: 16444375,
   aqua: 65535,
@@ -11211,11 +11239,11 @@ const Ga = {
   whitesmoke: 16119285,
   yellow: 16776960,
   yellowgreen: 10145074
-}, Jt = { h: 0, s: 0, l: 0 }, ks = { h: 0, s: 0, l: 0 };
-function Di(o, e, t) {
+}, nn = { h: 0, s: 0, l: 0 }, Gs = { h: 0, s: 0, l: 0 };
+function Ni(o, e, t) {
   return t < 0 && (t += 1), t > 1 && (t -= 1), t < 1 / 6 ? o + (e - o) * 6 * t : t < 1 / 2 ? e : t < 2 / 3 ? o + (e - o) * 6 * (2 / 3 - t) : o;
 }
-class Zs {
+class ti {
   constructor(e, t, n) {
     return this.isColor = !0, this.r = 1, this.g = 1, this.b = 1, this.set(e, t, n);
   }
@@ -11230,22 +11258,22 @@ class Zs {
   setScalar(e) {
     return this.r = e, this.g = e, this.b = e, this;
   }
-  setHex(e, t = rn) {
-    return e = Math.floor(e), this.r = (e >> 16 & 255) / 255, this.g = (e >> 8 & 255) / 255, this.b = (e & 255) / 255, Tt.toWorkingColorSpace(this, t), this;
+  setHex(e, t = an) {
+    return e = Math.floor(e), this.r = (e >> 16 & 255) / 255, this.g = (e >> 8 & 255) / 255, this.b = (e & 255) / 255, St.toWorkingColorSpace(this, t), this;
   }
-  setRGB(e, t, n, s = Tt.workingColorSpace) {
-    return this.r = e, this.g = t, this.b = n, Tt.toWorkingColorSpace(this, s), this;
+  setRGB(e, t, n, s = St.workingColorSpace) {
+    return this.r = e, this.g = t, this.b = n, St.toWorkingColorSpace(this, s), this;
   }
-  setHSL(e, t, n, s = Tt.workingColorSpace) {
-    if (e = Ef(e, 1), t = cn(t, 0, 1), n = cn(n, 0, 1), t === 0)
+  setHSL(e, t, n, s = St.workingColorSpace) {
+    if (e = If(e, 1), t = hn(t, 0, 1), n = hn(n, 0, 1), t === 0)
       this.r = this.g = this.b = n;
     else {
       const i = n <= 0.5 ? n * (1 + t) : n + t - n * t, r = 2 * n - i;
-      this.r = Di(r, i, e + 1 / 3), this.g = Di(r, i, e), this.b = Di(r, i, e - 1 / 3);
+      this.r = Ni(r, i, e + 1 / 3), this.g = Ni(r, i, e), this.b = Ni(r, i, e - 1 / 3);
     }
-    return Tt.toWorkingColorSpace(this, s), this;
+    return St.toWorkingColorSpace(this, s), this;
   }
-  setStyle(e, t = rn) {
+  setStyle(e, t = an) {
     function n(i) {
       i !== void 0 && parseFloat(i) < 1 && console.warn("THREE.Color: Alpha component of " + e + " will be ignored.");
     }
@@ -11300,8 +11328,8 @@ class Zs {
       return this.setColorName(e, t);
     return this;
   }
-  setColorName(e, t = rn) {
-    const n = Ga[e.toLowerCase()];
+  setColorName(e, t = an) {
+    const n = Za[e.toLowerCase()];
     return n !== void 0 ? this.setHex(n, t) : console.warn("THREE.Color: Unknown color " + e), this;
   }
   clone() {
@@ -11311,10 +11339,10 @@ class Zs {
     return this.r = e.r, this.g = e.g, this.b = e.b, this;
   }
   copySRGBToLinear(e) {
-    return this.r = Ci(e.r), this.g = Ci(e.g), this.b = Ci(e.b), this;
+    return this.r = Bi(e.r), this.g = Bi(e.g), this.b = Bi(e.b), this;
   }
   copyLinearToSRGB(e) {
-    return this.r = Ii(e.r), this.g = Ii(e.g), this.b = Ii(e.b), this;
+    return this.r = Ui(e.r), this.g = Ui(e.g), this.b = Ui(e.b), this;
   }
   convertSRGBToLinear() {
     return this.copySRGBToLinear(this), this;
@@ -11322,14 +11350,14 @@ class Zs {
   convertLinearToSRGB() {
     return this.copyLinearToSRGB(this), this;
   }
-  getHex(e = rn) {
-    return Tt.fromWorkingColorSpace(st.copy(this), e), Math.round(cn(st.r * 255, 0, 255)) * 65536 + Math.round(cn(st.g * 255, 0, 255)) * 256 + Math.round(cn(st.b * 255, 0, 255));
+  getHex(e = an) {
+    return St.fromWorkingColorSpace(st.copy(this), e), Math.round(hn(st.r * 255, 0, 255)) * 65536 + Math.round(hn(st.g * 255, 0, 255)) * 256 + Math.round(hn(st.b * 255, 0, 255));
   }
-  getHexString(e = rn) {
+  getHexString(e = an) {
     return ("000000" + this.getHex(e).toString(16)).slice(-6);
   }
-  getHSL(e, t = Tt.workingColorSpace) {
-    Tt.fromWorkingColorSpace(st.copy(this), t);
+  getHSL(e, t = St.workingColorSpace) {
+    St.fromWorkingColorSpace(st.copy(this), t);
     const n = st.r, s = st.g, i = st.b, r = Math.max(n, s, i), a = Math.min(n, s, i);
     let l, c;
     const u = (a + r) / 2;
@@ -11352,16 +11380,16 @@ class Zs {
     }
     return e.h = l, e.s = c, e.l = u, e;
   }
-  getRGB(e, t = Tt.workingColorSpace) {
-    return Tt.fromWorkingColorSpace(st.copy(this), t), e.r = st.r, e.g = st.g, e.b = st.b, e;
+  getRGB(e, t = St.workingColorSpace) {
+    return St.fromWorkingColorSpace(st.copy(this), t), e.r = st.r, e.g = st.g, e.b = st.b, e;
   }
-  getStyle(e = rn) {
-    Tt.fromWorkingColorSpace(st.copy(this), e);
+  getStyle(e = an) {
+    St.fromWorkingColorSpace(st.copy(this), e);
     const t = st.r, n = st.g, s = st.b;
-    return e !== rn ? `color(${e} ${t.toFixed(3)} ${n.toFixed(3)} ${s.toFixed(3)})` : `rgb(${Math.round(t * 255)},${Math.round(n * 255)},${Math.round(s * 255)})`;
+    return e !== an ? `color(${e} ${t.toFixed(3)} ${n.toFixed(3)} ${s.toFixed(3)})` : `rgb(${Math.round(t * 255)},${Math.round(n * 255)},${Math.round(s * 255)})`;
   }
   offsetHSL(e, t, n) {
-    return this.getHSL(Jt), this.setHSL(Jt.h + e, Jt.s + t, Jt.l + n);
+    return this.getHSL(nn), this.setHSL(nn.h + e, nn.s + t, nn.l + n);
   }
   add(e) {
     return this.r += e.r, this.g += e.g, this.b += e.b, this;
@@ -11388,8 +11416,8 @@ class Zs {
     return this.r = e.r + (t.r - e.r) * n, this.g = e.g + (t.g - e.g) * n, this.b = e.b + (t.b - e.b) * n, this;
   }
   lerpHSL(e, t) {
-    this.getHSL(Jt), e.getHSL(ks);
-    const n = Pi(Jt.h, ks.h, t), s = Pi(Jt.s, ks.s, t), i = Pi(Jt.l, ks.l, t);
+    this.getHSL(nn), e.getHSL(Gs);
+    const n = Fi(nn.h, Gs.h, t), s = Fi(nn.s, Gs.s, t), i = Fi(nn.l, Gs.l, t);
     return this.setHSL(n, s, i), this;
   }
   setFromVector3(e) {
@@ -11418,9 +11446,9 @@ class Zs {
     yield this.r, yield this.g, yield this.b;
   }
 }
-const st = /* @__PURE__ */ new Zs();
-Zs.NAMES = Ga;
-class Rf extends us {
+const st = /* @__PURE__ */ new ti();
+ti.NAMES = Za;
+class kf extends ys {
   constructor(t = {}) {
     super();
     oe(this, "isMeshPhysicalMaterial");
@@ -11444,14 +11472,14 @@ class Rf extends us {
     this.isMeshPhysicalMaterial = !0, this.defines = {
       STANDARD: "",
       PHYSICAL: ""
-    }, this.type = "MeshPhysicalMaterial", this.clearcoatMap = null, this.clearcoatRoughness = 0, this.clearcoatRoughnessMap = null, this.clearcoatNormalScale = new yr(1, 1), this.clearcoatNormalMap = null, this.ior = 1.5, Object.defineProperty(this, "reflectivity", {
+    }, this.type = "MeshPhysicalMaterial", this.clearcoatMap = null, this.clearcoatRoughness = 0, this.clearcoatRoughnessMap = null, this.clearcoatNormalScale = new br(1, 1), this.clearcoatNormalMap = null, this.ior = 1.5, Object.defineProperty(this, "reflectivity", {
       get() {
-        return cn(2.5 * (this.ior - 1) / (this.ior + 1), 0, 1);
+        return hn(2.5 * (this.ior - 1) / (this.ior + 1), 0, 1);
       },
       set(n) {
         this.ior = (1 + 0.4 * n) / (1 - 0.4 * n);
       }
-    }), this.roughness = 0, this.transmissionMap = null, this.thickness = 0.5, this.thicknessMap = null, this.attenuationDistance = 1 / 0, this.attenuationColor = new Zs(1, 1, 1), this.specularIntensity = 1, this.specularIntensityMap = null, this.specularColor = new Zs(1, 1, 1), this.specularColorMap = null, this._clearcoat = 0.5, this._transmission = 1, this.setValues(t);
+    }), this.roughness = 0, this.transmissionMap = null, this.thickness = 0.5, this.thicknessMap = null, this.attenuationDistance = 1 / 0, this.attenuationColor = new ti(1, 1, 1), this.specularIntensity = 1, this.specularIntensityMap = null, this.specularColor = new ti(1, 1, 1), this.specularColorMap = null, this._clearcoat = 0.5, this._transmission = 1, this.setValues(t);
   }
   get clearcoat() {
     return this._clearcoat;
@@ -11472,24 +11500,24 @@ class Rf extends us {
     }, this.clearcoat = t.clearcoat, this.clearcoatMap = t.clearcoatMap, this.clearcoatRoughness = t.clearcoatRoughness, this.clearcoatRoughnessMap = t.clearcoatRoughnessMap, this.clearcoatNormalMap = t.clearcoatNormalMap, this.clearcoatNormalScale.copy(t.clearcoatNormalScale), this.ior = t.ior, this.transmission = t.transmission, this.transmissionMap = t.transmissionMap, this.thickness = t.thickness, this.thicknessMap = t.thicknessMap, this.attenuationDistance = t.attenuationDistance, this.attenuationColor.copy(t.attenuationColor), this.specularIntensity = t.specularIntensity, this.specularIntensityMap = t.specularIntensityMap, this.specularColor.copy(t.specularColor), this.specularColorMap = t.specularColorMap, this;
   }
 }
-const Cf = Rf, tg = /* @__PURE__ */ pe({
+const Bf = kf, wg = /* @__PURE__ */ pe({
   __name: "index",
   setup(o, { expose: e }) {
-    const t = xe(), { extend: n } = je();
-    return n({ MeshGlassMaterial: Cf }), e({ MeshGlassMaterialClass: t }), (s, i) => (fe(), de("TresMeshGlassMaterial", {
+    const t = me(), { extend: n } = Ue();
+    return n({ MeshGlassMaterial: Bf }), e({ MeshGlassMaterialClass: t }), (s, i) => (le(), ce("TresMeshGlassMaterial", {
       ref_key: "MeshGlassMaterialClass",
       ref: t
     }, null, 512));
   }
 });
-var If = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
-function ys(o) {
+var Uf = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
+function Es(o) {
   return o && o.__esModule && Object.prototype.hasOwnProperty.call(o, "default") ? o.default : o;
 }
-function Us(o) {
+function Vs(o) {
   throw new Error('Could not dynamically require "' + o + '". Please configure the dynamicRequireTargets or/and ignoreDynamicRequires option of @rollup/plugin-commonjs appropriately for this require call to work.');
 }
-var ja = { exports: {} };
+var Ka = { exports: {} };
 (function(o, e) {
   (function(t) {
     o.exports = t();
@@ -11498,351 +11526,351 @@ var ja = { exports: {} };
       function r(c, u) {
         if (!s[c]) {
           if (!n[c]) {
-            var h = typeof Us == "function" && Us;
+            var h = typeof Vs == "function" && Vs;
             if (!u && h)
               return h(c, !0);
             if (a)
               return a(c, !0);
             throw new Error("Cannot find module '" + c + "'");
           }
-          u = s[c] = { exports: {} }, n[c][0].call(u.exports, function(m) {
-            var p = n[c][1][m];
-            return r(p || m);
+          u = s[c] = { exports: {} }, n[c][0].call(u.exports, function(f) {
+            var d = n[c][1][f];
+            return r(d || f);
           }, u, u.exports, t, n, s, i);
         }
         return s[c].exports;
       }
-      for (var a = typeof Us == "function" && Us, l = 0; l < i.length; l++)
+      for (var a = typeof Vs == "function" && Vs, l = 0; l < i.length; l++)
         r(i[l]);
       return r;
     }({ 1: [function(t, n, s) {
-      (function(i, r, a, l, c, u, h, m, p) {
-        var v = t("crypto");
-        function _(x, M) {
-          M = R(x, M);
-          var d;
-          return (d = M.algorithm !== "passthrough" ? v.createHash(M.algorithm) : new A()).write === void 0 && (d.write = d.update, d.end = d.update), g(M, d).dispatch(x), d.update || d.end(""), d.digest ? d.digest(M.encoding === "buffer" ? void 0 : M.encoding) : (x = d.read(), M.encoding !== "buffer" ? x.toString(M.encoding) : x);
+      (function(i, r, a, l, c, u, h, f, d) {
+        var y = t("crypto");
+        function x(T, E) {
+          E = M(T, E);
+          var m;
+          return (m = E.algorithm !== "passthrough" ? y.createHash(E.algorithm) : new P()).write === void 0 && (m.write = m.update, m.end = m.update), w(E, m).dispatch(T), m.update || m.end(""), m.digest ? m.digest(E.encoding === "buffer" ? void 0 : E.encoding) : (T = m.read(), E.encoding !== "buffer" ? T.toString(E.encoding) : T);
         }
-        (s = n.exports = _).sha1 = function(x) {
-          return _(x);
-        }, s.keys = function(x) {
-          return _(x, { excludeValues: !0, algorithm: "sha1", encoding: "hex" });
-        }, s.MD5 = function(x) {
-          return _(x, { algorithm: "md5", encoding: "hex" });
-        }, s.keysMD5 = function(x) {
-          return _(x, { algorithm: "md5", encoding: "hex", excludeValues: !0 });
+        (s = n.exports = x).sha1 = function(T) {
+          return x(T);
+        }, s.keys = function(T) {
+          return x(T, { excludeValues: !0, algorithm: "sha1", encoding: "hex" });
+        }, s.MD5 = function(T) {
+          return x(T, { algorithm: "md5", encoding: "hex" });
+        }, s.keysMD5 = function(T) {
+          return x(T, { algorithm: "md5", encoding: "hex", excludeValues: !0 });
         };
-        var y = v.getHashes ? v.getHashes().slice() : ["sha1", "md5"], E = (y.push("passthrough"), ["buffer", "hex", "binary", "base64"]);
-        function R(x, M) {
-          var d = {};
-          if (d.algorithm = (M = M || {}).algorithm || "sha1", d.encoding = M.encoding || "hex", d.excludeValues = !!M.excludeValues, d.algorithm = d.algorithm.toLowerCase(), d.encoding = d.encoding.toLowerCase(), d.ignoreUnknown = M.ignoreUnknown === !0, d.respectType = M.respectType !== !1, d.respectFunctionNames = M.respectFunctionNames !== !1, d.respectFunctionProperties = M.respectFunctionProperties !== !1, d.unorderedArrays = M.unorderedArrays === !0, d.unorderedSets = M.unorderedSets !== !1, d.unorderedObjects = M.unorderedObjects !== !1, d.replacer = M.replacer || void 0, d.excludeKeys = M.excludeKeys || void 0, x === void 0)
+        var g = y.getHashes ? y.getHashes().slice() : ["sha1", "md5"], v = (g.push("passthrough"), ["buffer", "hex", "binary", "base64"]);
+        function M(T, E) {
+          var m = {};
+          if (m.algorithm = (E = E || {}).algorithm || "sha1", m.encoding = E.encoding || "hex", m.excludeValues = !!E.excludeValues, m.algorithm = m.algorithm.toLowerCase(), m.encoding = m.encoding.toLowerCase(), m.ignoreUnknown = E.ignoreUnknown === !0, m.respectType = E.respectType !== !1, m.respectFunctionNames = E.respectFunctionNames !== !1, m.respectFunctionProperties = E.respectFunctionProperties !== !1, m.unorderedArrays = E.unorderedArrays === !0, m.unorderedSets = E.unorderedSets !== !1, m.unorderedObjects = E.unorderedObjects !== !1, m.replacer = E.replacer || void 0, m.excludeKeys = E.excludeKeys || void 0, T === void 0)
             throw new Error("Object argument required.");
-          for (var w = 0; w < y.length; ++w)
-            y[w].toLowerCase() === d.algorithm.toLowerCase() && (d.algorithm = y[w]);
-          if (y.indexOf(d.algorithm) === -1)
-            throw new Error('Algorithm "' + d.algorithm + '"  not supported. supported values: ' + y.join(", "));
-          if (E.indexOf(d.encoding) === -1 && d.algorithm !== "passthrough")
-            throw new Error('Encoding "' + d.encoding + '"  not supported. supported values: ' + E.join(", "));
-          return d;
+          for (var b = 0; b < g.length; ++b)
+            g[b].toLowerCase() === m.algorithm.toLowerCase() && (m.algorithm = g[b]);
+          if (g.indexOf(m.algorithm) === -1)
+            throw new Error('Algorithm "' + m.algorithm + '"  not supported. supported values: ' + g.join(", "));
+          if (v.indexOf(m.encoding) === -1 && m.algorithm !== "passthrough")
+            throw new Error('Encoding "' + m.encoding + '"  not supported. supported values: ' + v.join(", "));
+          return m;
         }
-        function T(x) {
-          if (typeof x == "function")
-            return /^function\s+\w*\s*\(\s*\)\s*{\s+\[native code\]\s+}$/i.exec(Function.prototype.toString.call(x)) != null;
+        function _(T) {
+          if (typeof T == "function")
+            return /^function\s+\w*\s*\(\s*\)\s*{\s+\[native code\]\s+}$/i.exec(Function.prototype.toString.call(T)) != null;
         }
-        function g(x, M, d) {
-          d = d || [];
-          function w(f) {
-            return M.update ? M.update(f, "utf8") : M.write(f, "utf8");
+        function w(T, E, m) {
+          m = m || [];
+          function b(p) {
+            return E.update ? E.update(p, "utf8") : E.write(p, "utf8");
           }
-          return { dispatch: function(f) {
-            return this["_" + ((f = x.replacer ? x.replacer(f) : f) === null ? "null" : typeof f)](f);
-          }, _object: function(f) {
-            var P, I = Object.prototype.toString.call(f), K = /\[object (.*)\]/i.exec(I);
-            if (K = (K = K ? K[1] : "unknown:[" + I + "]").toLowerCase(), 0 <= (I = d.indexOf(f)))
+          return { dispatch: function(p) {
+            return this["_" + ((p = T.replacer ? T.replacer(p) : p) === null ? "null" : typeof p)](p);
+          }, _object: function(p) {
+            var C, I = Object.prototype.toString.call(p), K = /\[object (.*)\]/i.exec(I);
+            if (K = (K = K ? K[1] : "unknown:[" + I + "]").toLowerCase(), 0 <= (I = m.indexOf(p)))
               return this.dispatch("[CIRCULAR:" + I + "]");
-            if (d.push(f), a !== void 0 && a.isBuffer && a.isBuffer(f))
-              return w("buffer:"), w(f);
+            if (m.push(p), a !== void 0 && a.isBuffer && a.isBuffer(p))
+              return b("buffer:"), b(p);
             if (K === "object" || K === "function" || K === "asyncfunction")
-              return I = Object.keys(f), x.unorderedObjects && (I = I.sort()), x.respectType === !1 || T(f) || I.splice(0, 0, "prototype", "__proto__", "constructor"), x.excludeKeys && (I = I.filter(function(N) {
-                return !x.excludeKeys(N);
-              })), w("object:" + I.length + ":"), P = this, I.forEach(function(N) {
-                P.dispatch(N), w(":"), x.excludeValues || P.dispatch(f[N]), w(",");
+              return I = Object.keys(p), T.unorderedObjects && (I = I.sort()), T.respectType === !1 || _(p) || I.splice(0, 0, "prototype", "__proto__", "constructor"), T.excludeKeys && (I = I.filter(function(z) {
+                return !T.excludeKeys(z);
+              })), b("object:" + I.length + ":"), C = this, I.forEach(function(z) {
+                C.dispatch(z), b(":"), T.excludeValues || C.dispatch(p[z]), b(",");
               });
             if (!this["_" + K]) {
-              if (x.ignoreUnknown)
-                return w("[" + K + "]");
+              if (T.ignoreUnknown)
+                return b("[" + K + "]");
               throw new Error('Unknown object type "' + K + '"');
             }
-            this["_" + K](f);
-          }, _array: function(f, N) {
-            N = N !== void 0 ? N : x.unorderedArrays !== !1;
+            this["_" + K](p);
+          }, _array: function(p, z) {
+            z = z !== void 0 ? z : T.unorderedArrays !== !1;
             var I = this;
-            if (w("array:" + f.length + ":"), !N || f.length <= 1)
-              return f.forEach(function(Z) {
-                return I.dispatch(Z);
+            if (b("array:" + p.length + ":"), !z || p.length <= 1)
+              return p.forEach(function(Y) {
+                return I.dispatch(Y);
               });
-            var K = [], N = f.map(function(Z) {
-              var W = new A(), X = d.slice();
-              return g(x, W, X).dispatch(Z), K = K.concat(X.slice(d.length)), W.read().toString();
+            var K = [], z = p.map(function(Y) {
+              var W = new P(), X = m.slice();
+              return w(T, W, X).dispatch(Y), K = K.concat(X.slice(m.length)), W.read().toString();
             });
-            return d = d.concat(K), N.sort(), this._array(N, !1);
-          }, _date: function(f) {
-            return w("date:" + f.toJSON());
-          }, _symbol: function(f) {
-            return w("symbol:" + f.toString());
-          }, _error: function(f) {
-            return w("error:" + f.toString());
-          }, _boolean: function(f) {
-            return w("bool:" + f.toString());
-          }, _string: function(f) {
-            w("string:" + f.length + ":"), w(f.toString());
-          }, _function: function(f) {
-            w("fn:"), T(f) ? this.dispatch("[native]") : this.dispatch(f.toString()), x.respectFunctionNames !== !1 && this.dispatch("function-name:" + String(f.name)), x.respectFunctionProperties && this._object(f);
-          }, _number: function(f) {
-            return w("number:" + f.toString());
-          }, _xml: function(f) {
-            return w("xml:" + f.toString());
+            return m = m.concat(K), z.sort(), this._array(z, !1);
+          }, _date: function(p) {
+            return b("date:" + p.toJSON());
+          }, _symbol: function(p) {
+            return b("symbol:" + p.toString());
+          }, _error: function(p) {
+            return b("error:" + p.toString());
+          }, _boolean: function(p) {
+            return b("bool:" + p.toString());
+          }, _string: function(p) {
+            b("string:" + p.length + ":"), b(p.toString());
+          }, _function: function(p) {
+            b("fn:"), _(p) ? this.dispatch("[native]") : this.dispatch(p.toString()), T.respectFunctionNames !== !1 && this.dispatch("function-name:" + String(p.name)), T.respectFunctionProperties && this._object(p);
+          }, _number: function(p) {
+            return b("number:" + p.toString());
+          }, _xml: function(p) {
+            return b("xml:" + p.toString());
           }, _null: function() {
-            return w("Null");
+            return b("Null");
           }, _undefined: function() {
-            return w("Undefined");
-          }, _regexp: function(f) {
-            return w("regex:" + f.toString());
-          }, _uint8array: function(f) {
-            return w("uint8array:"), this.dispatch(Array.prototype.slice.call(f));
-          }, _uint8clampedarray: function(f) {
-            return w("uint8clampedarray:"), this.dispatch(Array.prototype.slice.call(f));
-          }, _int8array: function(f) {
-            return w("int8array:"), this.dispatch(Array.prototype.slice.call(f));
-          }, _uint16array: function(f) {
-            return w("uint16array:"), this.dispatch(Array.prototype.slice.call(f));
-          }, _int16array: function(f) {
-            return w("int16array:"), this.dispatch(Array.prototype.slice.call(f));
-          }, _uint32array: function(f) {
-            return w("uint32array:"), this.dispatch(Array.prototype.slice.call(f));
-          }, _int32array: function(f) {
-            return w("int32array:"), this.dispatch(Array.prototype.slice.call(f));
-          }, _float32array: function(f) {
-            return w("float32array:"), this.dispatch(Array.prototype.slice.call(f));
-          }, _float64array: function(f) {
-            return w("float64array:"), this.dispatch(Array.prototype.slice.call(f));
-          }, _arraybuffer: function(f) {
-            return w("arraybuffer:"), this.dispatch(new Uint8Array(f));
-          }, _url: function(f) {
-            return w("url:" + f.toString());
-          }, _map: function(f) {
-            return w("map:"), f = Array.from(f), this._array(f, x.unorderedSets !== !1);
-          }, _set: function(f) {
-            return w("set:"), f = Array.from(f), this._array(f, x.unorderedSets !== !1);
-          }, _file: function(f) {
-            return w("file:"), this.dispatch([f.name, f.size, f.type, f.lastModfied]);
+            return b("Undefined");
+          }, _regexp: function(p) {
+            return b("regex:" + p.toString());
+          }, _uint8array: function(p) {
+            return b("uint8array:"), this.dispatch(Array.prototype.slice.call(p));
+          }, _uint8clampedarray: function(p) {
+            return b("uint8clampedarray:"), this.dispatch(Array.prototype.slice.call(p));
+          }, _int8array: function(p) {
+            return b("int8array:"), this.dispatch(Array.prototype.slice.call(p));
+          }, _uint16array: function(p) {
+            return b("uint16array:"), this.dispatch(Array.prototype.slice.call(p));
+          }, _int16array: function(p) {
+            return b("int16array:"), this.dispatch(Array.prototype.slice.call(p));
+          }, _uint32array: function(p) {
+            return b("uint32array:"), this.dispatch(Array.prototype.slice.call(p));
+          }, _int32array: function(p) {
+            return b("int32array:"), this.dispatch(Array.prototype.slice.call(p));
+          }, _float32array: function(p) {
+            return b("float32array:"), this.dispatch(Array.prototype.slice.call(p));
+          }, _float64array: function(p) {
+            return b("float64array:"), this.dispatch(Array.prototype.slice.call(p));
+          }, _arraybuffer: function(p) {
+            return b("arraybuffer:"), this.dispatch(new Uint8Array(p));
+          }, _url: function(p) {
+            return b("url:" + p.toString());
+          }, _map: function(p) {
+            return b("map:"), p = Array.from(p), this._array(p, T.unorderedSets !== !1);
+          }, _set: function(p) {
+            return b("set:"), p = Array.from(p), this._array(p, T.unorderedSets !== !1);
+          }, _file: function(p) {
+            return b("file:"), this.dispatch([p.name, p.size, p.type, p.lastModfied]);
           }, _blob: function() {
-            if (x.ignoreUnknown)
-              return w("[blob]");
+            if (T.ignoreUnknown)
+              return b("[blob]");
             throw Error(`Hashing Blob objects is currently not supported
 (see https://github.com/puleos/object-hash/issues/26)
 Use "options.replacer" or "options.ignoreUnknown"
 `);
           }, _domwindow: function() {
-            return w("domwindow");
-          }, _bigint: function(f) {
-            return w("bigint:" + f.toString());
+            return b("domwindow");
+          }, _bigint: function(p) {
+            return b("bigint:" + p.toString());
           }, _process: function() {
-            return w("process");
+            return b("process");
           }, _timer: function() {
-            return w("timer");
+            return b("timer");
           }, _pipe: function() {
-            return w("pipe");
+            return b("pipe");
           }, _tcp: function() {
-            return w("tcp");
+            return b("tcp");
           }, _udp: function() {
-            return w("udp");
+            return b("udp");
           }, _tty: function() {
-            return w("tty");
+            return b("tty");
           }, _statwatcher: function() {
-            return w("statwatcher");
+            return b("statwatcher");
           }, _securecontext: function() {
-            return w("securecontext");
+            return b("securecontext");
           }, _connection: function() {
-            return w("connection");
+            return b("connection");
           }, _zlib: function() {
-            return w("zlib");
+            return b("zlib");
           }, _context: function() {
-            return w("context");
+            return b("context");
           }, _nodescript: function() {
-            return w("nodescript");
+            return b("nodescript");
           }, _httpparser: function() {
-            return w("httpparser");
+            return b("httpparser");
           }, _dataview: function() {
-            return w("dataview");
+            return b("dataview");
           }, _signal: function() {
-            return w("signal");
+            return b("signal");
           }, _fsevent: function() {
-            return w("fsevent");
+            return b("fsevent");
           }, _tlswrap: function() {
-            return w("tlswrap");
+            return b("tlswrap");
           } };
         }
-        function A() {
-          return { buf: "", write: function(x) {
-            this.buf += x;
-          }, end: function(x) {
-            this.buf += x;
+        function P() {
+          return { buf: "", write: function(T) {
+            this.buf += T;
+          }, end: function(T) {
+            this.buf += T;
           }, read: function() {
             return this.buf;
           } };
         }
-        s.writeToStream = function(x, M, d) {
-          return d === void 0 && (d = M, M = {}), g(M = R(x, M), d).dispatch(x);
+        s.writeToStream = function(T, E, m) {
+          return m === void 0 && (m = E, E = {}), w(E = M(T, E), m).dispatch(T);
         };
       }).call(this, t("lYpoI2"), typeof self < "u" ? self : typeof window < "u" ? window : {}, t("buffer").Buffer, arguments[3], arguments[4], arguments[5], arguments[6], "/fake_9a5aa49d.js", "/");
     }, { buffer: 3, crypto: 5, lYpoI2: 11 }], 2: [function(t, n, s) {
-      (function(i, r, a, l, c, u, h, m, p) {
-        (function(v) {
-          var _ = typeof Uint8Array < "u" ? Uint8Array : Array, y = 43, E = 47, R = 48, T = 97, g = 65, A = 45, x = 95;
-          function M(d) {
-            return d = d.charCodeAt(0), d === y || d === A ? 62 : d === E || d === x ? 63 : d < R ? -1 : d < R + 10 ? d - R + 26 + 26 : d < g + 26 ? d - g : d < T + 26 ? d - T + 26 : void 0;
+      (function(i, r, a, l, c, u, h, f, d) {
+        (function(y) {
+          var x = typeof Uint8Array < "u" ? Uint8Array : Array, g = 43, v = 47, M = 48, _ = 97, w = 65, P = 45, T = 95;
+          function E(m) {
+            return m = m.charCodeAt(0), m === g || m === P ? 62 : m === v || m === T ? 63 : m < M ? -1 : m < M + 10 ? m - M + 26 + 26 : m < w + 26 ? m - w : m < _ + 26 ? m - _ + 26 : void 0;
           }
-          v.toByteArray = function(d) {
-            var w, f;
-            if (0 < d.length % 4)
+          y.toByteArray = function(m) {
+            var b, p;
+            if (0 < m.length % 4)
               throw new Error("Invalid string. Length must be a multiple of 4");
-            var P = d.length, P = d.charAt(P - 2) === "=" ? 2 : d.charAt(P - 1) === "=" ? 1 : 0, I = new _(3 * d.length / 4 - P), K = 0 < P ? d.length - 4 : d.length, N = 0;
-            function Z(W) {
-              I[N++] = W;
+            var C = m.length, C = m.charAt(C - 2) === "=" ? 2 : m.charAt(C - 1) === "=" ? 1 : 0, I = new x(3 * m.length / 4 - C), K = 0 < C ? m.length - 4 : m.length, z = 0;
+            function Y(W) {
+              I[z++] = W;
             }
-            for (w = 0; w < K; w += 4, 0)
-              Z((16711680 & (f = M(d.charAt(w)) << 18 | M(d.charAt(w + 1)) << 12 | M(d.charAt(w + 2)) << 6 | M(d.charAt(w + 3)))) >> 16), Z((65280 & f) >> 8), Z(255 & f);
-            return P == 2 ? Z(255 & (f = M(d.charAt(w)) << 2 | M(d.charAt(w + 1)) >> 4)) : P == 1 && (Z((f = M(d.charAt(w)) << 10 | M(d.charAt(w + 1)) << 4 | M(d.charAt(w + 2)) >> 2) >> 8 & 255), Z(255 & f)), I;
-          }, v.fromByteArray = function(d) {
-            var w, f, P, I, K = d.length % 3, N = "";
-            function Z(W) {
+            for (b = 0; b < K; b += 4, 0)
+              Y((16711680 & (p = E(m.charAt(b)) << 18 | E(m.charAt(b + 1)) << 12 | E(m.charAt(b + 2)) << 6 | E(m.charAt(b + 3)))) >> 16), Y((65280 & p) >> 8), Y(255 & p);
+            return C == 2 ? Y(255 & (p = E(m.charAt(b)) << 2 | E(m.charAt(b + 1)) >> 4)) : C == 1 && (Y((p = E(m.charAt(b)) << 10 | E(m.charAt(b + 1)) << 4 | E(m.charAt(b + 2)) >> 2) >> 8 & 255), Y(255 & p)), I;
+          }, y.fromByteArray = function(m) {
+            var b, p, C, I, K = m.length % 3, z = "";
+            function Y(W) {
               return "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/".charAt(W);
             }
-            for (w = 0, P = d.length - K; w < P; w += 3)
-              f = (d[w] << 16) + (d[w + 1] << 8) + d[w + 2], N += Z((I = f) >> 18 & 63) + Z(I >> 12 & 63) + Z(I >> 6 & 63) + Z(63 & I);
+            for (b = 0, C = m.length - K; b < C; b += 3)
+              p = (m[b] << 16) + (m[b + 1] << 8) + m[b + 2], z += Y((I = p) >> 18 & 63) + Y(I >> 12 & 63) + Y(I >> 6 & 63) + Y(63 & I);
             switch (K) {
               case 1:
-                N = (N += Z((f = d[d.length - 1]) >> 2)) + Z(f << 4 & 63) + "==";
+                z = (z += Y((p = m[m.length - 1]) >> 2)) + Y(p << 4 & 63) + "==";
                 break;
               case 2:
-                N = (N = (N += Z((f = (d[d.length - 2] << 8) + d[d.length - 1]) >> 10)) + Z(f >> 4 & 63)) + Z(f << 2 & 63) + "=";
+                z = (z = (z += Y((p = (m[m.length - 2] << 8) + m[m.length - 1]) >> 10)) + Y(p >> 4 & 63)) + Y(p << 2 & 63) + "=";
             }
-            return N;
+            return z;
           };
         })(s === void 0 ? this.base64js = {} : s);
       }).call(this, t("lYpoI2"), typeof self < "u" ? self : typeof window < "u" ? window : {}, t("buffer").Buffer, arguments[3], arguments[4], arguments[5], arguments[6], "/node_modules/gulp-browserify/node_modules/base64-js/lib/b64.js", "/node_modules/gulp-browserify/node_modules/base64-js/lib");
     }, { buffer: 3, lYpoI2: 11 }], 3: [function(t, n, s) {
-      (function(i, r, y, l, c, u, h, m, p) {
-        var v = t("base64-js"), _ = t("ieee754");
-        function y(S, C, D) {
-          if (!(this instanceof y))
-            return new y(S, C, D);
-          var G, $, Y, te, O = typeof S;
-          if (C === "base64" && O == "string")
-            for (S = (te = S).trim ? te.trim() : te.replace(/^\s+|\s+$/g, ""); S.length % 4 != 0; )
-              S += "=";
-          if (O == "number")
-            G = V(S);
-          else if (O == "string")
-            G = y.byteLength(S, C);
+      (function(i, r, g, l, c, u, h, f, d) {
+        var y = t("base64-js"), x = t("ieee754");
+        function g(A, R, D) {
+          if (!(this instanceof g))
+            return new g(A, R, D);
+          var j, Z, $, ne, L = typeof A;
+          if (R === "base64" && L == "string")
+            for (A = (ne = A).trim ? ne.trim() : ne.replace(/^\s+|\s+$/g, ""); A.length % 4 != 0; )
+              A += "=";
+          if (L == "number")
+            j = V(A);
+          else if (L == "string")
+            j = g.byteLength(A, R);
           else {
-            if (O != "object")
+            if (L != "object")
               throw new Error("First argument needs to be a number, array or string.");
-            G = V(S.length);
+            j = V(A.length);
           }
-          if (y._useTypedArrays ? $ = y._augment(new Uint8Array(G)) : (($ = this).length = G, $._isBuffer = !0), y._useTypedArrays && typeof S.byteLength == "number")
-            $._set(S);
-          else if (ne(te = S) || y.isBuffer(te) || te && typeof te == "object" && typeof te.length == "number")
-            for (Y = 0; Y < G; Y++)
-              y.isBuffer(S) ? $[Y] = S.readUInt8(Y) : $[Y] = S[Y];
-          else if (O == "string")
-            $.write(S, 0, C);
-          else if (O == "number" && !y._useTypedArrays && !D)
-            for (Y = 0; Y < G; Y++)
-              $[Y] = 0;
-          return $;
+          if (g._useTypedArrays ? Z = g._augment(new Uint8Array(j)) : ((Z = this).length = j, Z._isBuffer = !0), g._useTypedArrays && typeof A.byteLength == "number")
+            Z._set(A);
+          else if (te(ne = A) || g.isBuffer(ne) || ne && typeof ne == "object" && typeof ne.length == "number")
+            for ($ = 0; $ < j; $++)
+              g.isBuffer(A) ? Z[$] = A.readUInt8($) : Z[$] = A[$];
+          else if (L == "string")
+            Z.write(A, 0, R);
+          else if (L == "number" && !g._useTypedArrays && !D)
+            for ($ = 0; $ < j; $++)
+              Z[$] = 0;
+          return Z;
         }
-        function E(S, C, D, G) {
-          return y._charsWritten = k(function($) {
-            for (var Y = [], te = 0; te < $.length; te++)
-              Y.push(255 & $.charCodeAt(te));
-            return Y;
-          }(C), S, D, G);
+        function v(A, R, D, j) {
+          return g._charsWritten = k(function(Z) {
+            for (var $ = [], ne = 0; ne < Z.length; ne++)
+              $.push(255 & Z.charCodeAt(ne));
+            return $;
+          }(R), A, D, j);
         }
-        function R(S, C, D, G) {
-          return y._charsWritten = k(function($) {
-            for (var Y, te, O = [], L = 0; L < $.length; L++)
-              te = $.charCodeAt(L), Y = te >> 8, te = te % 256, O.push(te), O.push(Y);
-            return O;
-          }(C), S, D, G);
+        function M(A, R, D, j) {
+          return g._charsWritten = k(function(Z) {
+            for (var $, ne, L = [], O = 0; O < Z.length; O++)
+              ne = Z.charCodeAt(O), $ = ne >> 8, ne = ne % 256, L.push(ne), L.push($);
+            return L;
+          }(R), A, D, j);
         }
-        function T(S, C, D) {
-          var G = "";
-          D = Math.min(S.length, D);
-          for (var $ = C; $ < D; $++)
-            G += String.fromCharCode(S[$]);
-          return G;
+        function _(A, R, D) {
+          var j = "";
+          D = Math.min(A.length, D);
+          for (var Z = R; Z < D; Z++)
+            j += String.fromCharCode(A[Z]);
+          return j;
         }
-        function g(S, C, D, Y) {
-          Y || (B(typeof D == "boolean", "missing or invalid endian"), B(C != null, "missing offset"), B(C + 1 < S.length, "Trying to read beyond buffer length"));
-          var $, Y = S.length;
-          if (!(Y <= C))
-            return D ? ($ = S[C], C + 1 < Y && ($ |= S[C + 1] << 8)) : ($ = S[C] << 8, C + 1 < Y && ($ |= S[C + 1])), $;
+        function w(A, R, D, $) {
+          $ || (N(typeof D == "boolean", "missing or invalid endian"), N(R != null, "missing offset"), N(R + 1 < A.length, "Trying to read beyond buffer length"));
+          var Z, $ = A.length;
+          if (!($ <= R))
+            return D ? (Z = A[R], R + 1 < $ && (Z |= A[R + 1] << 8)) : (Z = A[R] << 8, R + 1 < $ && (Z |= A[R + 1])), Z;
         }
-        function A(S, C, D, Y) {
-          Y || (B(typeof D == "boolean", "missing or invalid endian"), B(C != null, "missing offset"), B(C + 3 < S.length, "Trying to read beyond buffer length"));
-          var $, Y = S.length;
-          if (!(Y <= C))
-            return D ? (C + 2 < Y && ($ = S[C + 2] << 16), C + 1 < Y && ($ |= S[C + 1] << 8), $ |= S[C], C + 3 < Y && ($ += S[C + 3] << 24 >>> 0)) : (C + 1 < Y && ($ = S[C + 1] << 16), C + 2 < Y && ($ |= S[C + 2] << 8), C + 3 < Y && ($ |= S[C + 3]), $ += S[C] << 24 >>> 0), $;
+        function P(A, R, D, $) {
+          $ || (N(typeof D == "boolean", "missing or invalid endian"), N(R != null, "missing offset"), N(R + 3 < A.length, "Trying to read beyond buffer length"));
+          var Z, $ = A.length;
+          if (!($ <= R))
+            return D ? (R + 2 < $ && (Z = A[R + 2] << 16), R + 1 < $ && (Z |= A[R + 1] << 8), Z |= A[R], R + 3 < $ && (Z += A[R + 3] << 24 >>> 0)) : (R + 1 < $ && (Z = A[R + 1] << 16), R + 2 < $ && (Z |= A[R + 2] << 8), R + 3 < $ && (Z |= A[R + 3]), Z += A[R] << 24 >>> 0), Z;
         }
-        function x(S, C, D, G) {
-          if (G || (B(typeof D == "boolean", "missing or invalid endian"), B(C != null, "missing offset"), B(C + 1 < S.length, "Trying to read beyond buffer length")), !(S.length <= C))
-            return G = g(S, C, D, !0), 32768 & G ? -1 * (65535 - G + 1) : G;
+        function T(A, R, D, j) {
+          if (j || (N(typeof D == "boolean", "missing or invalid endian"), N(R != null, "missing offset"), N(R + 1 < A.length, "Trying to read beyond buffer length")), !(A.length <= R))
+            return j = w(A, R, D, !0), 32768 & j ? -1 * (65535 - j + 1) : j;
         }
-        function M(S, C, D, G) {
-          if (G || (B(typeof D == "boolean", "missing or invalid endian"), B(C != null, "missing offset"), B(C + 3 < S.length, "Trying to read beyond buffer length")), !(S.length <= C))
-            return G = A(S, C, D, !0), 2147483648 & G ? -1 * (4294967295 - G + 1) : G;
+        function E(A, R, D, j) {
+          if (j || (N(typeof D == "boolean", "missing or invalid endian"), N(R != null, "missing offset"), N(R + 3 < A.length, "Trying to read beyond buffer length")), !(A.length <= R))
+            return j = P(A, R, D, !0), 2147483648 & j ? -1 * (4294967295 - j + 1) : j;
         }
-        function d(S, C, D, G) {
-          return G || (B(typeof D == "boolean", "missing or invalid endian"), B(C + 3 < S.length, "Trying to read beyond buffer length")), _.read(S, C, D, 23, 4);
+        function m(A, R, D, j) {
+          return j || (N(typeof D == "boolean", "missing or invalid endian"), N(R + 3 < A.length, "Trying to read beyond buffer length")), x.read(A, R, D, 23, 4);
         }
-        function w(S, C, D, G) {
-          return G || (B(typeof D == "boolean", "missing or invalid endian"), B(C + 7 < S.length, "Trying to read beyond buffer length")), _.read(S, C, D, 52, 8);
+        function b(A, R, D, j) {
+          return j || (N(typeof D == "boolean", "missing or invalid endian"), N(R + 7 < A.length, "Trying to read beyond buffer length")), x.read(A, R, D, 52, 8);
         }
-        function f(S, C, D, G, $) {
-          if ($ || (B(C != null, "missing value"), B(typeof G == "boolean", "missing or invalid endian"), B(D != null, "missing offset"), B(D + 1 < S.length, "trying to write beyond buffer length"), U(C, 65535)), $ = S.length, !($ <= D))
-            for (var Y = 0, te = Math.min($ - D, 2); Y < te; Y++)
-              S[D + Y] = (C & 255 << 8 * (G ? Y : 1 - Y)) >>> 8 * (G ? Y : 1 - Y);
+        function p(A, R, D, j, Z) {
+          if (Z || (N(R != null, "missing value"), N(typeof j == "boolean", "missing or invalid endian"), N(D != null, "missing offset"), N(D + 1 < A.length, "trying to write beyond buffer length"), U(R, 65535)), Z = A.length, !(Z <= D))
+            for (var $ = 0, ne = Math.min(Z - D, 2); $ < ne; $++)
+              A[D + $] = (R & 255 << 8 * (j ? $ : 1 - $)) >>> 8 * (j ? $ : 1 - $);
         }
-        function P(S, C, D, G, $) {
-          if ($ || (B(C != null, "missing value"), B(typeof G == "boolean", "missing or invalid endian"), B(D != null, "missing offset"), B(D + 3 < S.length, "trying to write beyond buffer length"), U(C, 4294967295)), $ = S.length, !($ <= D))
-            for (var Y = 0, te = Math.min($ - D, 4); Y < te; Y++)
-              S[D + Y] = C >>> 8 * (G ? Y : 3 - Y) & 255;
+        function C(A, R, D, j, Z) {
+          if (Z || (N(R != null, "missing value"), N(typeof j == "boolean", "missing or invalid endian"), N(D != null, "missing offset"), N(D + 3 < A.length, "trying to write beyond buffer length"), U(R, 4294967295)), Z = A.length, !(Z <= D))
+            for (var $ = 0, ne = Math.min(Z - D, 4); $ < ne; $++)
+              A[D + $] = R >>> 8 * (j ? $ : 3 - $) & 255;
         }
-        function I(S, C, D, G, $) {
-          $ || (B(C != null, "missing value"), B(typeof G == "boolean", "missing or invalid endian"), B(D != null, "missing offset"), B(D + 1 < S.length, "Trying to write beyond buffer length"), J(C, 32767, -32768)), S.length <= D || f(S, 0 <= C ? C : 65535 + C + 1, D, G, $);
+        function I(A, R, D, j, Z) {
+          Z || (N(R != null, "missing value"), N(typeof j == "boolean", "missing or invalid endian"), N(D != null, "missing offset"), N(D + 1 < A.length, "Trying to write beyond buffer length"), ee(R, 32767, -32768)), A.length <= D || p(A, 0 <= R ? R : 65535 + R + 1, D, j, Z);
         }
-        function K(S, C, D, G, $) {
-          $ || (B(C != null, "missing value"), B(typeof G == "boolean", "missing or invalid endian"), B(D != null, "missing offset"), B(D + 3 < S.length, "Trying to write beyond buffer length"), J(C, 2147483647, -2147483648)), S.length <= D || P(S, 0 <= C ? C : 4294967295 + C + 1, D, G, $);
+        function K(A, R, D, j, Z) {
+          Z || (N(R != null, "missing value"), N(typeof j == "boolean", "missing or invalid endian"), N(D != null, "missing offset"), N(D + 3 < A.length, "Trying to write beyond buffer length"), ee(R, 2147483647, -2147483648)), A.length <= D || C(A, 0 <= R ? R : 4294967295 + R + 1, D, j, Z);
         }
-        function N(S, C, D, G, $) {
-          $ || (B(C != null, "missing value"), B(typeof G == "boolean", "missing or invalid endian"), B(D != null, "missing offset"), B(D + 3 < S.length, "Trying to write beyond buffer length"), F(C, 34028234663852886e22, -34028234663852886e22)), S.length <= D || _.write(S, C, D, G, 23, 4);
+        function z(A, R, D, j, Z) {
+          Z || (N(R != null, "missing value"), N(typeof j == "boolean", "missing or invalid endian"), N(D != null, "missing offset"), N(D + 3 < A.length, "Trying to write beyond buffer length"), F(R, 34028234663852886e22, -34028234663852886e22)), A.length <= D || x.write(A, R, D, j, 23, 4);
         }
-        function Z(S, C, D, G, $) {
-          $ || (B(C != null, "missing value"), B(typeof G == "boolean", "missing or invalid endian"), B(D != null, "missing offset"), B(D + 7 < S.length, "Trying to write beyond buffer length"), F(C, 17976931348623157e292, -17976931348623157e292)), S.length <= D || _.write(S, C, D, G, 52, 8);
+        function Y(A, R, D, j, Z) {
+          Z || (N(R != null, "missing value"), N(typeof j == "boolean", "missing or invalid endian"), N(D != null, "missing offset"), N(D + 7 < A.length, "Trying to write beyond buffer length"), F(R, 17976931348623157e292, -17976931348623157e292)), A.length <= D || x.write(A, R, D, j, 52, 8);
         }
-        s.Buffer = y, s.SlowBuffer = y, s.INSPECT_MAX_BYTES = 50, y.poolSize = 8192, y._useTypedArrays = function() {
+        s.Buffer = g, s.SlowBuffer = g, s.INSPECT_MAX_BYTES = 50, g.poolSize = 8192, g._useTypedArrays = function() {
           try {
-            var S = new ArrayBuffer(0), C = new Uint8Array(S);
-            return C.foo = function() {
+            var A = new ArrayBuffer(0), R = new Uint8Array(A);
+            return R.foo = function() {
               return 42;
-            }, C.foo() === 42 && typeof C.subarray == "function";
+            }, R.foo() === 42 && typeof R.subarray == "function";
           } catch {
             return !1;
           }
-        }(), y.isEncoding = function(S) {
-          switch (String(S).toLowerCase()) {
+        }(), g.isEncoding = function(A) {
+          switch (String(A).toLowerCase()) {
             case "hex":
             case "utf8":
             case "utf-8":
@@ -11858,493 +11886,493 @@ Use "options.replacer" or "options.ignoreUnknown"
             default:
               return !1;
           }
-        }, y.isBuffer = function(S) {
-          return !(S == null || !S._isBuffer);
-        }, y.byteLength = function(S, C) {
+        }, g.isBuffer = function(A) {
+          return !(A == null || !A._isBuffer);
+        }, g.byteLength = function(A, R) {
           var D;
-          switch (S += "", C || "utf8") {
+          switch (A += "", R || "utf8") {
             case "hex":
-              D = S.length / 2;
+              D = A.length / 2;
               break;
             case "utf8":
             case "utf-8":
-              D = he(S).length;
+              D = fe(A).length;
               break;
             case "ascii":
             case "binary":
             case "raw":
-              D = S.length;
+              D = A.length;
               break;
             case "base64":
-              D = H(S).length;
+              D = H(A).length;
               break;
             case "ucs2":
             case "ucs-2":
             case "utf16le":
             case "utf-16le":
-              D = 2 * S.length;
+              D = 2 * A.length;
               break;
             default:
               throw new Error("Unknown encoding");
           }
           return D;
-        }, y.concat = function(S, C) {
-          if (B(ne(S), `Usage: Buffer.concat(list, [totalLength])
-list should be an Array.`), S.length === 0)
-            return new y(0);
-          if (S.length === 1)
-            return S[0];
-          if (typeof C != "number")
-            for ($ = C = 0; $ < S.length; $++)
-              C += S[$].length;
-          for (var D = new y(C), G = 0, $ = 0; $ < S.length; $++) {
-            var Y = S[$];
-            Y.copy(D, G), G += Y.length;
+        }, g.concat = function(A, R) {
+          if (N(te(A), `Usage: Buffer.concat(list, [totalLength])
+list should be an Array.`), A.length === 0)
+            return new g(0);
+          if (A.length === 1)
+            return A[0];
+          if (typeof R != "number")
+            for (Z = R = 0; Z < A.length; Z++)
+              R += A[Z].length;
+          for (var D = new g(R), j = 0, Z = 0; Z < A.length; Z++) {
+            var $ = A[Z];
+            $.copy(D, j), j += $.length;
           }
           return D;
-        }, y.prototype.write = function(S, C, D, G) {
-          isFinite(C) ? isFinite(D) || (G = D, D = void 0) : (L = G, G = C, C = D, D = L), C = Number(C) || 0;
-          var $, Y, te, O, L = this.length - C;
-          switch ((!D || L < (D = Number(D))) && (D = L), G = String(G || "utf8").toLowerCase()) {
+        }, g.prototype.write = function(A, R, D, j) {
+          isFinite(R) ? isFinite(D) || (j = D, D = void 0) : (O = j, j = R, R = D, D = O), R = Number(R) || 0;
+          var Z, $, ne, L, O = this.length - R;
+          switch ((!D || O < (D = Number(D))) && (D = O), j = String(j || "utf8").toLowerCase()) {
             case "hex":
-              $ = function(re, ce, be, Me) {
+              Z = function(re, de, be, Se) {
                 be = Number(be) || 0;
-                var Se = re.length - be;
-                (!Me || Se < (Me = Number(Me))) && (Me = Se), B((Se = ce.length) % 2 == 0, "Invalid hex string"), Se / 2 < Me && (Me = Se / 2);
-                for (var qe = 0; qe < Me; qe++) {
-                  var kt = parseInt(ce.substr(2 * qe, 2), 16);
-                  B(!isNaN(kt), "Invalid hex string"), re[be + qe] = kt;
+                var Me = re.length - be;
+                (!Se || Me < (Se = Number(Se))) && (Se = Me), N((Me = de.length) % 2 == 0, "Invalid hex string"), Me / 2 < Se && (Se = Me / 2);
+                for (var qe = 0; qe < Se; qe++) {
+                  var Nt = parseInt(de.substr(2 * qe, 2), 16);
+                  N(!isNaN(Nt), "Invalid hex string"), re[be + qe] = Nt;
                 }
-                return y._charsWritten = 2 * qe, qe;
-              }(this, S, C, D);
+                return g._charsWritten = 2 * qe, qe;
+              }(this, A, R, D);
               break;
             case "utf8":
             case "utf-8":
-              Y = this, te = C, O = D, $ = y._charsWritten = k(he(S), Y, te, O);
+              $ = this, ne = R, L = D, Z = g._charsWritten = k(fe(A), $, ne, L);
               break;
             case "ascii":
             case "binary":
-              $ = E(this, S, C, D);
+              Z = v(this, A, R, D);
               break;
             case "base64":
-              Y = this, te = C, O = D, $ = y._charsWritten = k(H(S), Y, te, O);
+              $ = this, ne = R, L = D, Z = g._charsWritten = k(H(A), $, ne, L);
               break;
             case "ucs2":
             case "ucs-2":
             case "utf16le":
             case "utf-16le":
-              $ = R(this, S, C, D);
+              Z = M(this, A, R, D);
               break;
             default:
               throw new Error("Unknown encoding");
           }
-          return $;
-        }, y.prototype.toString = function(S, C, D) {
-          var G, $, Y, te, O = this;
-          if (S = String(S || "utf8").toLowerCase(), C = Number(C) || 0, (D = D !== void 0 ? Number(D) : O.length) === C)
+          return Z;
+        }, g.prototype.toString = function(A, R, D) {
+          var j, Z, $, ne, L = this;
+          if (A = String(A || "utf8").toLowerCase(), R = Number(R) || 0, (D = D !== void 0 ? Number(D) : L.length) === R)
             return "";
-          switch (S) {
+          switch (A) {
             case "hex":
-              G = function(L, re, ce) {
-                var be = L.length;
-                (!re || re < 0) && (re = 0), (!ce || ce < 0 || be < ce) && (ce = be);
-                for (var Me = "", Se = re; Se < ce; Se++)
-                  Me += se(L[Se]);
-                return Me;
-              }(O, C, D);
+              j = function(O, re, de) {
+                var be = O.length;
+                (!re || re < 0) && (re = 0), (!de || de < 0 || be < de) && (de = be);
+                for (var Se = "", Me = re; Me < de; Me++)
+                  Se += se(O[Me]);
+                return Se;
+              }(L, R, D);
               break;
             case "utf8":
             case "utf-8":
-              G = function(L, re, ce) {
-                var be = "", Me = "";
-                ce = Math.min(L.length, ce);
-                for (var Se = re; Se < ce; Se++)
-                  L[Se] <= 127 ? (be += b(Me) + String.fromCharCode(L[Se]), Me = "") : Me += "%" + L[Se].toString(16);
-                return be + b(Me);
-              }(O, C, D);
+              j = function(O, re, de) {
+                var be = "", Se = "";
+                de = Math.min(O.length, de);
+                for (var Me = re; Me < de; Me++)
+                  O[Me] <= 127 ? (be += S(Se) + String.fromCharCode(O[Me]), Se = "") : Se += "%" + O[Me].toString(16);
+                return be + S(Se);
+              }(L, R, D);
               break;
             case "ascii":
             case "binary":
-              G = T(O, C, D);
+              j = _(L, R, D);
               break;
             case "base64":
-              $ = O, te = D, G = (Y = C) === 0 && te === $.length ? v.fromByteArray($) : v.fromByteArray($.slice(Y, te));
+              Z = L, ne = D, j = ($ = R) === 0 && ne === Z.length ? y.fromByteArray(Z) : y.fromByteArray(Z.slice($, ne));
               break;
             case "ucs2":
             case "ucs-2":
             case "utf16le":
             case "utf-16le":
-              G = function(L, re, ce) {
-                for (var be = L.slice(re, ce), Me = "", Se = 0; Se < be.length; Se += 2)
-                  Me += String.fromCharCode(be[Se] + 256 * be[Se + 1]);
-                return Me;
-              }(O, C, D);
+              j = function(O, re, de) {
+                for (var be = O.slice(re, de), Se = "", Me = 0; Me < be.length; Me += 2)
+                  Se += String.fromCharCode(be[Me] + 256 * be[Me + 1]);
+                return Se;
+              }(L, R, D);
               break;
             default:
               throw new Error("Unknown encoding");
           }
-          return G;
-        }, y.prototype.toJSON = function() {
+          return j;
+        }, g.prototype.toJSON = function() {
           return { type: "Buffer", data: Array.prototype.slice.call(this._arr || this, 0) };
-        }, y.prototype.copy = function(S, C, D, G) {
-          if (C = C || 0, (G = G || G === 0 ? G : this.length) !== (D = D || 0) && S.length !== 0 && this.length !== 0) {
-            B(D <= G, "sourceEnd < sourceStart"), B(0 <= C && C < S.length, "targetStart out of bounds"), B(0 <= D && D < this.length, "sourceStart out of bounds"), B(0 <= G && G <= this.length, "sourceEnd out of bounds"), G > this.length && (G = this.length);
-            var $ = (G = S.length - C < G - D ? S.length - C + D : G) - D;
-            if ($ < 100 || !y._useTypedArrays)
-              for (var Y = 0; Y < $; Y++)
-                S[Y + C] = this[Y + D];
+        }, g.prototype.copy = function(A, R, D, j) {
+          if (R = R || 0, (j = j || j === 0 ? j : this.length) !== (D = D || 0) && A.length !== 0 && this.length !== 0) {
+            N(D <= j, "sourceEnd < sourceStart"), N(0 <= R && R < A.length, "targetStart out of bounds"), N(0 <= D && D < this.length, "sourceStart out of bounds"), N(0 <= j && j <= this.length, "sourceEnd out of bounds"), j > this.length && (j = this.length);
+            var Z = (j = A.length - R < j - D ? A.length - R + D : j) - D;
+            if (Z < 100 || !g._useTypedArrays)
+              for (var $ = 0; $ < Z; $++)
+                A[$ + R] = this[$ + D];
             else
-              S._set(this.subarray(D, D + $), C);
+              A._set(this.subarray(D, D + Z), R);
           }
-        }, y.prototype.slice = function(S, C) {
+        }, g.prototype.slice = function(A, R) {
           var D = this.length;
-          if (S = X(S, D, 0), C = X(C, D, D), y._useTypedArrays)
-            return y._augment(this.subarray(S, C));
-          for (var G = C - S, $ = new y(G, void 0, !0), Y = 0; Y < G; Y++)
-            $[Y] = this[Y + S];
-          return $;
-        }, y.prototype.get = function(S) {
-          return console.log(".get() is deprecated. Access using array indexes instead."), this.readUInt8(S);
-        }, y.prototype.set = function(S, C) {
-          return console.log(".set() is deprecated. Access using array indexes instead."), this.writeUInt8(S, C);
-        }, y.prototype.readUInt8 = function(S, C) {
-          if (C || (B(S != null, "missing offset"), B(S < this.length, "Trying to read beyond buffer length")), !(S >= this.length))
-            return this[S];
-        }, y.prototype.readUInt16LE = function(S, C) {
-          return g(this, S, !0, C);
-        }, y.prototype.readUInt16BE = function(S, C) {
-          return g(this, S, !1, C);
-        }, y.prototype.readUInt32LE = function(S, C) {
-          return A(this, S, !0, C);
-        }, y.prototype.readUInt32BE = function(S, C) {
-          return A(this, S, !1, C);
-        }, y.prototype.readInt8 = function(S, C) {
-          if (C || (B(S != null, "missing offset"), B(S < this.length, "Trying to read beyond buffer length")), !(S >= this.length))
-            return 128 & this[S] ? -1 * (255 - this[S] + 1) : this[S];
-        }, y.prototype.readInt16LE = function(S, C) {
-          return x(this, S, !0, C);
-        }, y.prototype.readInt16BE = function(S, C) {
-          return x(this, S, !1, C);
-        }, y.prototype.readInt32LE = function(S, C) {
-          return M(this, S, !0, C);
-        }, y.prototype.readInt32BE = function(S, C) {
-          return M(this, S, !1, C);
-        }, y.prototype.readFloatLE = function(S, C) {
-          return d(this, S, !0, C);
-        }, y.prototype.readFloatBE = function(S, C) {
-          return d(this, S, !1, C);
-        }, y.prototype.readDoubleLE = function(S, C) {
-          return w(this, S, !0, C);
-        }, y.prototype.readDoubleBE = function(S, C) {
-          return w(this, S, !1, C);
-        }, y.prototype.writeUInt8 = function(S, C, D) {
-          D || (B(S != null, "missing value"), B(C != null, "missing offset"), B(C < this.length, "trying to write beyond buffer length"), U(S, 255)), C >= this.length || (this[C] = S);
-        }, y.prototype.writeUInt16LE = function(S, C, D) {
-          f(this, S, C, !0, D);
-        }, y.prototype.writeUInt16BE = function(S, C, D) {
-          f(this, S, C, !1, D);
-        }, y.prototype.writeUInt32LE = function(S, C, D) {
-          P(this, S, C, !0, D);
-        }, y.prototype.writeUInt32BE = function(S, C, D) {
-          P(this, S, C, !1, D);
-        }, y.prototype.writeInt8 = function(S, C, D) {
-          D || (B(S != null, "missing value"), B(C != null, "missing offset"), B(C < this.length, "Trying to write beyond buffer length"), J(S, 127, -128)), C >= this.length || (0 <= S ? this.writeUInt8(S, C, D) : this.writeUInt8(255 + S + 1, C, D));
-        }, y.prototype.writeInt16LE = function(S, C, D) {
-          I(this, S, C, !0, D);
-        }, y.prototype.writeInt16BE = function(S, C, D) {
-          I(this, S, C, !1, D);
-        }, y.prototype.writeInt32LE = function(S, C, D) {
-          K(this, S, C, !0, D);
-        }, y.prototype.writeInt32BE = function(S, C, D) {
-          K(this, S, C, !1, D);
-        }, y.prototype.writeFloatLE = function(S, C, D) {
-          N(this, S, C, !0, D);
-        }, y.prototype.writeFloatBE = function(S, C, D) {
-          N(this, S, C, !1, D);
-        }, y.prototype.writeDoubleLE = function(S, C, D) {
-          Z(this, S, C, !0, D);
-        }, y.prototype.writeDoubleBE = function(S, C, D) {
-          Z(this, S, C, !1, D);
-        }, y.prototype.fill = function(S, C, D) {
-          if (C = C || 0, D = D || this.length, B(typeof (S = typeof (S = S || 0) == "string" ? S.charCodeAt(0) : S) == "number" && !isNaN(S), "value is not a number"), B(C <= D, "end < start"), D !== C && this.length !== 0) {
-            B(0 <= C && C < this.length, "start out of bounds"), B(0 <= D && D <= this.length, "end out of bounds");
-            for (var G = C; G < D; G++)
-              this[G] = S;
+          if (A = X(A, D, 0), R = X(R, D, D), g._useTypedArrays)
+            return g._augment(this.subarray(A, R));
+          for (var j = R - A, Z = new g(j, void 0, !0), $ = 0; $ < j; $++)
+            Z[$] = this[$ + A];
+          return Z;
+        }, g.prototype.get = function(A) {
+          return console.log(".get() is deprecated. Access using array indexes instead."), this.readUInt8(A);
+        }, g.prototype.set = function(A, R) {
+          return console.log(".set() is deprecated. Access using array indexes instead."), this.writeUInt8(A, R);
+        }, g.prototype.readUInt8 = function(A, R) {
+          if (R || (N(A != null, "missing offset"), N(A < this.length, "Trying to read beyond buffer length")), !(A >= this.length))
+            return this[A];
+        }, g.prototype.readUInt16LE = function(A, R) {
+          return w(this, A, !0, R);
+        }, g.prototype.readUInt16BE = function(A, R) {
+          return w(this, A, !1, R);
+        }, g.prototype.readUInt32LE = function(A, R) {
+          return P(this, A, !0, R);
+        }, g.prototype.readUInt32BE = function(A, R) {
+          return P(this, A, !1, R);
+        }, g.prototype.readInt8 = function(A, R) {
+          if (R || (N(A != null, "missing offset"), N(A < this.length, "Trying to read beyond buffer length")), !(A >= this.length))
+            return 128 & this[A] ? -1 * (255 - this[A] + 1) : this[A];
+        }, g.prototype.readInt16LE = function(A, R) {
+          return T(this, A, !0, R);
+        }, g.prototype.readInt16BE = function(A, R) {
+          return T(this, A, !1, R);
+        }, g.prototype.readInt32LE = function(A, R) {
+          return E(this, A, !0, R);
+        }, g.prototype.readInt32BE = function(A, R) {
+          return E(this, A, !1, R);
+        }, g.prototype.readFloatLE = function(A, R) {
+          return m(this, A, !0, R);
+        }, g.prototype.readFloatBE = function(A, R) {
+          return m(this, A, !1, R);
+        }, g.prototype.readDoubleLE = function(A, R) {
+          return b(this, A, !0, R);
+        }, g.prototype.readDoubleBE = function(A, R) {
+          return b(this, A, !1, R);
+        }, g.prototype.writeUInt8 = function(A, R, D) {
+          D || (N(A != null, "missing value"), N(R != null, "missing offset"), N(R < this.length, "trying to write beyond buffer length"), U(A, 255)), R >= this.length || (this[R] = A);
+        }, g.prototype.writeUInt16LE = function(A, R, D) {
+          p(this, A, R, !0, D);
+        }, g.prototype.writeUInt16BE = function(A, R, D) {
+          p(this, A, R, !1, D);
+        }, g.prototype.writeUInt32LE = function(A, R, D) {
+          C(this, A, R, !0, D);
+        }, g.prototype.writeUInt32BE = function(A, R, D) {
+          C(this, A, R, !1, D);
+        }, g.prototype.writeInt8 = function(A, R, D) {
+          D || (N(A != null, "missing value"), N(R != null, "missing offset"), N(R < this.length, "Trying to write beyond buffer length"), ee(A, 127, -128)), R >= this.length || (0 <= A ? this.writeUInt8(A, R, D) : this.writeUInt8(255 + A + 1, R, D));
+        }, g.prototype.writeInt16LE = function(A, R, D) {
+          I(this, A, R, !0, D);
+        }, g.prototype.writeInt16BE = function(A, R, D) {
+          I(this, A, R, !1, D);
+        }, g.prototype.writeInt32LE = function(A, R, D) {
+          K(this, A, R, !0, D);
+        }, g.prototype.writeInt32BE = function(A, R, D) {
+          K(this, A, R, !1, D);
+        }, g.prototype.writeFloatLE = function(A, R, D) {
+          z(this, A, R, !0, D);
+        }, g.prototype.writeFloatBE = function(A, R, D) {
+          z(this, A, R, !1, D);
+        }, g.prototype.writeDoubleLE = function(A, R, D) {
+          Y(this, A, R, !0, D);
+        }, g.prototype.writeDoubleBE = function(A, R, D) {
+          Y(this, A, R, !1, D);
+        }, g.prototype.fill = function(A, R, D) {
+          if (R = R || 0, D = D || this.length, N(typeof (A = typeof (A = A || 0) == "string" ? A.charCodeAt(0) : A) == "number" && !isNaN(A), "value is not a number"), N(R <= D, "end < start"), D !== R && this.length !== 0) {
+            N(0 <= R && R < this.length, "start out of bounds"), N(0 <= D && D <= this.length, "end out of bounds");
+            for (var j = R; j < D; j++)
+              this[j] = A;
           }
-        }, y.prototype.inspect = function() {
-          for (var S = [], C = this.length, D = 0; D < C; D++)
-            if (S[D] = se(this[D]), D === s.INSPECT_MAX_BYTES) {
-              S[D + 1] = "...";
+        }, g.prototype.inspect = function() {
+          for (var A = [], R = this.length, D = 0; D < R; D++)
+            if (A[D] = se(this[D]), D === s.INSPECT_MAX_BYTES) {
+              A[D + 1] = "...";
               break;
             }
-          return "<Buffer " + S.join(" ") + ">";
-        }, y.prototype.toArrayBuffer = function() {
+          return "<Buffer " + A.join(" ") + ">";
+        }, g.prototype.toArrayBuffer = function() {
           if (typeof Uint8Array > "u")
             throw new Error("Buffer.toArrayBuffer not supported in this browser");
-          if (y._useTypedArrays)
-            return new y(this).buffer;
-          for (var S = new Uint8Array(this.length), C = 0, D = S.length; C < D; C += 1)
-            S[C] = this[C];
-          return S.buffer;
+          if (g._useTypedArrays)
+            return new g(this).buffer;
+          for (var A = new Uint8Array(this.length), R = 0, D = A.length; R < D; R += 1)
+            A[R] = this[R];
+          return A.buffer;
         };
-        var W = y.prototype;
-        function X(S, C, D) {
-          return typeof S != "number" ? D : C <= (S = ~~S) ? C : 0 <= S || 0 <= (S += C) ? S : 0;
+        var W = g.prototype;
+        function X(A, R, D) {
+          return typeof A != "number" ? D : R <= (A = ~~A) ? R : 0 <= A || 0 <= (A += R) ? A : 0;
         }
-        function V(S) {
-          return (S = ~~Math.ceil(+S)) < 0 ? 0 : S;
+        function V(A) {
+          return (A = ~~Math.ceil(+A)) < 0 ? 0 : A;
         }
-        function ne(S) {
-          return (Array.isArray || function(C) {
-            return Object.prototype.toString.call(C) === "[object Array]";
-          })(S);
+        function te(A) {
+          return (Array.isArray || function(R) {
+            return Object.prototype.toString.call(R) === "[object Array]";
+          })(A);
         }
-        function se(S) {
-          return S < 16 ? "0" + S.toString(16) : S.toString(16);
+        function se(A) {
+          return A < 16 ? "0" + A.toString(16) : A.toString(16);
         }
-        function he(S) {
-          for (var C = [], D = 0; D < S.length; D++) {
-            var G = S.charCodeAt(D);
-            if (G <= 127)
-              C.push(S.charCodeAt(D));
+        function fe(A) {
+          for (var R = [], D = 0; D < A.length; D++) {
+            var j = A.charCodeAt(D);
+            if (j <= 127)
+              R.push(A.charCodeAt(D));
             else
-              for (var $ = D, Y = (55296 <= G && G <= 57343 && D++, encodeURIComponent(S.slice($, D + 1)).substr(1).split("%")), te = 0; te < Y.length; te++)
-                C.push(parseInt(Y[te], 16));
+              for (var Z = D, $ = (55296 <= j && j <= 57343 && D++, encodeURIComponent(A.slice(Z, D + 1)).substr(1).split("%")), ne = 0; ne < $.length; ne++)
+                R.push(parseInt($[ne], 16));
           }
-          return C;
+          return R;
         }
-        function H(S) {
-          return v.toByteArray(S);
+        function H(A) {
+          return y.toByteArray(A);
         }
-        function k(S, C, D, G) {
-          for (var $ = 0; $ < G && !($ + D >= C.length || $ >= S.length); $++)
-            C[$ + D] = S[$];
-          return $;
+        function k(A, R, D, j) {
+          for (var Z = 0; Z < j && !(Z + D >= R.length || Z >= A.length); Z++)
+            R[Z + D] = A[Z];
+          return Z;
         }
-        function b(S) {
+        function S(A) {
           try {
-            return decodeURIComponent(S);
+            return decodeURIComponent(A);
           } catch {
             return "�";
           }
         }
-        function U(S, C) {
-          B(typeof S == "number", "cannot write a non-number as a number"), B(0 <= S, "specified a negative value for writing an unsigned value"), B(S <= C, "value is larger than maximum value for type"), B(Math.floor(S) === S, "value has a fractional component");
+        function U(A, R) {
+          N(typeof A == "number", "cannot write a non-number as a number"), N(0 <= A, "specified a negative value for writing an unsigned value"), N(A <= R, "value is larger than maximum value for type"), N(Math.floor(A) === A, "value has a fractional component");
         }
-        function J(S, C, D) {
-          B(typeof S == "number", "cannot write a non-number as a number"), B(S <= C, "value larger than maximum allowed value"), B(D <= S, "value smaller than minimum allowed value"), B(Math.floor(S) === S, "value has a fractional component");
+        function ee(A, R, D) {
+          N(typeof A == "number", "cannot write a non-number as a number"), N(A <= R, "value larger than maximum allowed value"), N(D <= A, "value smaller than minimum allowed value"), N(Math.floor(A) === A, "value has a fractional component");
         }
-        function F(S, C, D) {
-          B(typeof S == "number", "cannot write a non-number as a number"), B(S <= C, "value larger than maximum allowed value"), B(D <= S, "value smaller than minimum allowed value");
+        function F(A, R, D) {
+          N(typeof A == "number", "cannot write a non-number as a number"), N(A <= R, "value larger than maximum allowed value"), N(D <= A, "value smaller than minimum allowed value");
         }
-        function B(S, C) {
-          if (!S)
-            throw new Error(C || "Failed assertion");
+        function N(A, R) {
+          if (!A)
+            throw new Error(R || "Failed assertion");
         }
-        y._augment = function(S) {
-          return S._isBuffer = !0, S._get = S.get, S._set = S.set, S.get = W.get, S.set = W.set, S.write = W.write, S.toString = W.toString, S.toLocaleString = W.toString, S.toJSON = W.toJSON, S.copy = W.copy, S.slice = W.slice, S.readUInt8 = W.readUInt8, S.readUInt16LE = W.readUInt16LE, S.readUInt16BE = W.readUInt16BE, S.readUInt32LE = W.readUInt32LE, S.readUInt32BE = W.readUInt32BE, S.readInt8 = W.readInt8, S.readInt16LE = W.readInt16LE, S.readInt16BE = W.readInt16BE, S.readInt32LE = W.readInt32LE, S.readInt32BE = W.readInt32BE, S.readFloatLE = W.readFloatLE, S.readFloatBE = W.readFloatBE, S.readDoubleLE = W.readDoubleLE, S.readDoubleBE = W.readDoubleBE, S.writeUInt8 = W.writeUInt8, S.writeUInt16LE = W.writeUInt16LE, S.writeUInt16BE = W.writeUInt16BE, S.writeUInt32LE = W.writeUInt32LE, S.writeUInt32BE = W.writeUInt32BE, S.writeInt8 = W.writeInt8, S.writeInt16LE = W.writeInt16LE, S.writeInt16BE = W.writeInt16BE, S.writeInt32LE = W.writeInt32LE, S.writeInt32BE = W.writeInt32BE, S.writeFloatLE = W.writeFloatLE, S.writeFloatBE = W.writeFloatBE, S.writeDoubleLE = W.writeDoubleLE, S.writeDoubleBE = W.writeDoubleBE, S.fill = W.fill, S.inspect = W.inspect, S.toArrayBuffer = W.toArrayBuffer, S;
+        g._augment = function(A) {
+          return A._isBuffer = !0, A._get = A.get, A._set = A.set, A.get = W.get, A.set = W.set, A.write = W.write, A.toString = W.toString, A.toLocaleString = W.toString, A.toJSON = W.toJSON, A.copy = W.copy, A.slice = W.slice, A.readUInt8 = W.readUInt8, A.readUInt16LE = W.readUInt16LE, A.readUInt16BE = W.readUInt16BE, A.readUInt32LE = W.readUInt32LE, A.readUInt32BE = W.readUInt32BE, A.readInt8 = W.readInt8, A.readInt16LE = W.readInt16LE, A.readInt16BE = W.readInt16BE, A.readInt32LE = W.readInt32LE, A.readInt32BE = W.readInt32BE, A.readFloatLE = W.readFloatLE, A.readFloatBE = W.readFloatBE, A.readDoubleLE = W.readDoubleLE, A.readDoubleBE = W.readDoubleBE, A.writeUInt8 = W.writeUInt8, A.writeUInt16LE = W.writeUInt16LE, A.writeUInt16BE = W.writeUInt16BE, A.writeUInt32LE = W.writeUInt32LE, A.writeUInt32BE = W.writeUInt32BE, A.writeInt8 = W.writeInt8, A.writeInt16LE = W.writeInt16LE, A.writeInt16BE = W.writeInt16BE, A.writeInt32LE = W.writeInt32LE, A.writeInt32BE = W.writeInt32BE, A.writeFloatLE = W.writeFloatLE, A.writeFloatBE = W.writeFloatBE, A.writeDoubleLE = W.writeDoubleLE, A.writeDoubleBE = W.writeDoubleBE, A.fill = W.fill, A.inspect = W.inspect, A.toArrayBuffer = W.toArrayBuffer, A;
         };
       }).call(this, t("lYpoI2"), typeof self < "u" ? self : typeof window < "u" ? window : {}, t("buffer").Buffer, arguments[3], arguments[4], arguments[5], arguments[6], "/node_modules/gulp-browserify/node_modules/buffer/index.js", "/node_modules/gulp-browserify/node_modules/buffer");
     }, { "base64-js": 2, buffer: 3, ieee754: 10, lYpoI2: 11 }], 4: [function(t, n, s) {
-      (function(i, r, v, l, c, u, h, m, p) {
-        var v = t("buffer").Buffer, _ = 4, y = new v(_);
-        y.fill(0), n.exports = { hash: function(E, R, T, g) {
-          for (var A = R(function(f, P) {
-            f.length % _ != 0 && (I = f.length + (_ - f.length % _), f = v.concat([f, y], I));
-            for (var I, K = [], N = P ? f.readInt32BE : f.readInt32LE, Z = 0; Z < f.length; Z += _)
-              K.push(N.call(f, Z));
+      (function(i, r, y, l, c, u, h, f, d) {
+        var y = t("buffer").Buffer, x = 4, g = new y(x);
+        g.fill(0), n.exports = { hash: function(v, M, _, w) {
+          for (var P = M(function(p, C) {
+            p.length % x != 0 && (I = p.length + (x - p.length % x), p = y.concat([p, g], I));
+            for (var I, K = [], z = C ? p.readInt32BE : p.readInt32LE, Y = 0; Y < p.length; Y += x)
+              K.push(z.call(p, Y));
             return K;
-          }(E = v.isBuffer(E) ? E : new v(E), g), 8 * E.length), R = g, x = new v(T), M = R ? x.writeInt32BE : x.writeInt32LE, d = 0; d < A.length; d++)
-            M.call(x, A[d], 4 * d, !0);
-          return x;
+          }(v = y.isBuffer(v) ? v : new y(v), w), 8 * v.length), M = w, T = new y(_), E = M ? T.writeInt32BE : T.writeInt32LE, m = 0; m < P.length; m++)
+            E.call(T, P[m], 4 * m, !0);
+          return T;
         } };
       }).call(this, t("lYpoI2"), typeof self < "u" ? self : typeof window < "u" ? window : {}, t("buffer").Buffer, arguments[3], arguments[4], arguments[5], arguments[6], "/node_modules/gulp-browserify/node_modules/crypto-browserify/helpers.js", "/node_modules/gulp-browserify/node_modules/crypto-browserify");
     }, { buffer: 3, lYpoI2: 11 }], 5: [function(t, n, s) {
-      (function(i, r, v, l, c, u, h, m, p) {
-        var v = t("buffer").Buffer, _ = t("./sha"), y = t("./sha256"), E = t("./rng"), R = { sha1: _, sha256: y, md5: t("./md5") }, T = 64, g = new v(T);
-        function A(f, P) {
-          var I = R[f = f || "sha1"], K = [];
-          return I || x("algorithm:", f, "is not yet supported"), { update: function(N) {
-            return v.isBuffer(N) || (N = new v(N)), K.push(N), N.length, this;
-          }, digest: function(N) {
-            var Z = v.concat(K), Z = P ? function(W, X, V) {
-              v.isBuffer(X) || (X = new v(X)), v.isBuffer(V) || (V = new v(V)), X.length > T ? X = W(X) : X.length < T && (X = v.concat([X, g], T));
-              for (var ne = new v(T), se = new v(T), he = 0; he < T; he++)
-                ne[he] = 54 ^ X[he], se[he] = 92 ^ X[he];
-              return V = W(v.concat([ne, V])), W(v.concat([se, V]));
-            }(I, P, Z) : I(Z);
-            return K = null, N ? Z.toString(N) : Z;
+      (function(i, r, y, l, c, u, h, f, d) {
+        var y = t("buffer").Buffer, x = t("./sha"), g = t("./sha256"), v = t("./rng"), M = { sha1: x, sha256: g, md5: t("./md5") }, _ = 64, w = new y(_);
+        function P(p, C) {
+          var I = M[p = p || "sha1"], K = [];
+          return I || T("algorithm:", p, "is not yet supported"), { update: function(z) {
+            return y.isBuffer(z) || (z = new y(z)), K.push(z), z.length, this;
+          }, digest: function(z) {
+            var Y = y.concat(K), Y = C ? function(W, X, V) {
+              y.isBuffer(X) || (X = new y(X)), y.isBuffer(V) || (V = new y(V)), X.length > _ ? X = W(X) : X.length < _ && (X = y.concat([X, w], _));
+              for (var te = new y(_), se = new y(_), fe = 0; fe < _; fe++)
+                te[fe] = 54 ^ X[fe], se[fe] = 92 ^ X[fe];
+              return V = W(y.concat([te, V])), W(y.concat([se, V]));
+            }(I, C, Y) : I(Y);
+            return K = null, z ? Y.toString(z) : Y;
           } };
         }
-        function x() {
-          var f = [].slice.call(arguments).join(" ");
-          throw new Error([f, "we accept pull requests", "http://github.com/dominictarr/crypto-browserify"].join(`
+        function T() {
+          var p = [].slice.call(arguments).join(" ");
+          throw new Error([p, "we accept pull requests", "http://github.com/dominictarr/crypto-browserify"].join(`
 `));
         }
-        g.fill(0), s.createHash = function(f) {
-          return A(f);
-        }, s.createHmac = A, s.randomBytes = function(f, P) {
-          if (!P || !P.call)
-            return new v(E(f));
+        w.fill(0), s.createHash = function(p) {
+          return P(p);
+        }, s.createHmac = P, s.randomBytes = function(p, C) {
+          if (!C || !C.call)
+            return new y(v(p));
           try {
-            P.call(this, void 0, new v(E(f)));
+            C.call(this, void 0, new y(v(p)));
           } catch (I) {
-            P(I);
+            C(I);
           }
         };
-        var M, d = ["createCredentials", "createCipher", "createCipheriv", "createDecipher", "createDecipheriv", "createSign", "createVerify", "createDiffieHellman", "pbkdf2"], w = function(f) {
-          s[f] = function() {
-            x("sorry,", f, "is not implemented yet");
+        var E, m = ["createCredentials", "createCipher", "createCipheriv", "createDecipher", "createDecipheriv", "createSign", "createVerify", "createDiffieHellman", "pbkdf2"], b = function(p) {
+          s[p] = function() {
+            T("sorry,", p, "is not implemented yet");
           };
         };
-        for (M in d)
-          w(d[M]);
+        for (E in m)
+          b(m[E]);
       }).call(this, t("lYpoI2"), typeof self < "u" ? self : typeof window < "u" ? window : {}, t("buffer").Buffer, arguments[3], arguments[4], arguments[5], arguments[6], "/node_modules/gulp-browserify/node_modules/crypto-browserify/index.js", "/node_modules/gulp-browserify/node_modules/crypto-browserify");
     }, { "./md5": 6, "./rng": 7, "./sha": 8, "./sha256": 9, buffer: 3, lYpoI2: 11 }], 6: [function(t, n, s) {
-      (function(i, r, a, l, c, u, h, m, p) {
-        var v = t("./helpers");
-        function _(x, M) {
-          x[M >> 5] |= 128 << M % 32, x[14 + (M + 64 >>> 9 << 4)] = M;
-          for (var d = 1732584193, w = -271733879, f = -1732584194, P = 271733878, I = 0; I < x.length; I += 16) {
-            var K = d, N = w, Z = f, W = P, d = E(d, w, f, P, x[I + 0], 7, -680876936), P = E(P, d, w, f, x[I + 1], 12, -389564586), f = E(f, P, d, w, x[I + 2], 17, 606105819), w = E(w, f, P, d, x[I + 3], 22, -1044525330);
-            d = E(d, w, f, P, x[I + 4], 7, -176418897), P = E(P, d, w, f, x[I + 5], 12, 1200080426), f = E(f, P, d, w, x[I + 6], 17, -1473231341), w = E(w, f, P, d, x[I + 7], 22, -45705983), d = E(d, w, f, P, x[I + 8], 7, 1770035416), P = E(P, d, w, f, x[I + 9], 12, -1958414417), f = E(f, P, d, w, x[I + 10], 17, -42063), w = E(w, f, P, d, x[I + 11], 22, -1990404162), d = E(d, w, f, P, x[I + 12], 7, 1804603682), P = E(P, d, w, f, x[I + 13], 12, -40341101), f = E(f, P, d, w, x[I + 14], 17, -1502002290), d = R(d, w = E(w, f, P, d, x[I + 15], 22, 1236535329), f, P, x[I + 1], 5, -165796510), P = R(P, d, w, f, x[I + 6], 9, -1069501632), f = R(f, P, d, w, x[I + 11], 14, 643717713), w = R(w, f, P, d, x[I + 0], 20, -373897302), d = R(d, w, f, P, x[I + 5], 5, -701558691), P = R(P, d, w, f, x[I + 10], 9, 38016083), f = R(f, P, d, w, x[I + 15], 14, -660478335), w = R(w, f, P, d, x[I + 4], 20, -405537848), d = R(d, w, f, P, x[I + 9], 5, 568446438), P = R(P, d, w, f, x[I + 14], 9, -1019803690), f = R(f, P, d, w, x[I + 3], 14, -187363961), w = R(w, f, P, d, x[I + 8], 20, 1163531501), d = R(d, w, f, P, x[I + 13], 5, -1444681467), P = R(P, d, w, f, x[I + 2], 9, -51403784), f = R(f, P, d, w, x[I + 7], 14, 1735328473), d = T(d, w = R(w, f, P, d, x[I + 12], 20, -1926607734), f, P, x[I + 5], 4, -378558), P = T(P, d, w, f, x[I + 8], 11, -2022574463), f = T(f, P, d, w, x[I + 11], 16, 1839030562), w = T(w, f, P, d, x[I + 14], 23, -35309556), d = T(d, w, f, P, x[I + 1], 4, -1530992060), P = T(P, d, w, f, x[I + 4], 11, 1272893353), f = T(f, P, d, w, x[I + 7], 16, -155497632), w = T(w, f, P, d, x[I + 10], 23, -1094730640), d = T(d, w, f, P, x[I + 13], 4, 681279174), P = T(P, d, w, f, x[I + 0], 11, -358537222), f = T(f, P, d, w, x[I + 3], 16, -722521979), w = T(w, f, P, d, x[I + 6], 23, 76029189), d = T(d, w, f, P, x[I + 9], 4, -640364487), P = T(P, d, w, f, x[I + 12], 11, -421815835), f = T(f, P, d, w, x[I + 15], 16, 530742520), d = g(d, w = T(w, f, P, d, x[I + 2], 23, -995338651), f, P, x[I + 0], 6, -198630844), P = g(P, d, w, f, x[I + 7], 10, 1126891415), f = g(f, P, d, w, x[I + 14], 15, -1416354905), w = g(w, f, P, d, x[I + 5], 21, -57434055), d = g(d, w, f, P, x[I + 12], 6, 1700485571), P = g(P, d, w, f, x[I + 3], 10, -1894986606), f = g(f, P, d, w, x[I + 10], 15, -1051523), w = g(w, f, P, d, x[I + 1], 21, -2054922799), d = g(d, w, f, P, x[I + 8], 6, 1873313359), P = g(P, d, w, f, x[I + 15], 10, -30611744), f = g(f, P, d, w, x[I + 6], 15, -1560198380), w = g(w, f, P, d, x[I + 13], 21, 1309151649), d = g(d, w, f, P, x[I + 4], 6, -145523070), P = g(P, d, w, f, x[I + 11], 10, -1120210379), f = g(f, P, d, w, x[I + 2], 15, 718787259), w = g(w, f, P, d, x[I + 9], 21, -343485551), d = A(d, K), w = A(w, N), f = A(f, Z), P = A(P, W);
+      (function(i, r, a, l, c, u, h, f, d) {
+        var y = t("./helpers");
+        function x(T, E) {
+          T[E >> 5] |= 128 << E % 32, T[14 + (E + 64 >>> 9 << 4)] = E;
+          for (var m = 1732584193, b = -271733879, p = -1732584194, C = 271733878, I = 0; I < T.length; I += 16) {
+            var K = m, z = b, Y = p, W = C, m = v(m, b, p, C, T[I + 0], 7, -680876936), C = v(C, m, b, p, T[I + 1], 12, -389564586), p = v(p, C, m, b, T[I + 2], 17, 606105819), b = v(b, p, C, m, T[I + 3], 22, -1044525330);
+            m = v(m, b, p, C, T[I + 4], 7, -176418897), C = v(C, m, b, p, T[I + 5], 12, 1200080426), p = v(p, C, m, b, T[I + 6], 17, -1473231341), b = v(b, p, C, m, T[I + 7], 22, -45705983), m = v(m, b, p, C, T[I + 8], 7, 1770035416), C = v(C, m, b, p, T[I + 9], 12, -1958414417), p = v(p, C, m, b, T[I + 10], 17, -42063), b = v(b, p, C, m, T[I + 11], 22, -1990404162), m = v(m, b, p, C, T[I + 12], 7, 1804603682), C = v(C, m, b, p, T[I + 13], 12, -40341101), p = v(p, C, m, b, T[I + 14], 17, -1502002290), m = M(m, b = v(b, p, C, m, T[I + 15], 22, 1236535329), p, C, T[I + 1], 5, -165796510), C = M(C, m, b, p, T[I + 6], 9, -1069501632), p = M(p, C, m, b, T[I + 11], 14, 643717713), b = M(b, p, C, m, T[I + 0], 20, -373897302), m = M(m, b, p, C, T[I + 5], 5, -701558691), C = M(C, m, b, p, T[I + 10], 9, 38016083), p = M(p, C, m, b, T[I + 15], 14, -660478335), b = M(b, p, C, m, T[I + 4], 20, -405537848), m = M(m, b, p, C, T[I + 9], 5, 568446438), C = M(C, m, b, p, T[I + 14], 9, -1019803690), p = M(p, C, m, b, T[I + 3], 14, -187363961), b = M(b, p, C, m, T[I + 8], 20, 1163531501), m = M(m, b, p, C, T[I + 13], 5, -1444681467), C = M(C, m, b, p, T[I + 2], 9, -51403784), p = M(p, C, m, b, T[I + 7], 14, 1735328473), m = _(m, b = M(b, p, C, m, T[I + 12], 20, -1926607734), p, C, T[I + 5], 4, -378558), C = _(C, m, b, p, T[I + 8], 11, -2022574463), p = _(p, C, m, b, T[I + 11], 16, 1839030562), b = _(b, p, C, m, T[I + 14], 23, -35309556), m = _(m, b, p, C, T[I + 1], 4, -1530992060), C = _(C, m, b, p, T[I + 4], 11, 1272893353), p = _(p, C, m, b, T[I + 7], 16, -155497632), b = _(b, p, C, m, T[I + 10], 23, -1094730640), m = _(m, b, p, C, T[I + 13], 4, 681279174), C = _(C, m, b, p, T[I + 0], 11, -358537222), p = _(p, C, m, b, T[I + 3], 16, -722521979), b = _(b, p, C, m, T[I + 6], 23, 76029189), m = _(m, b, p, C, T[I + 9], 4, -640364487), C = _(C, m, b, p, T[I + 12], 11, -421815835), p = _(p, C, m, b, T[I + 15], 16, 530742520), m = w(m, b = _(b, p, C, m, T[I + 2], 23, -995338651), p, C, T[I + 0], 6, -198630844), C = w(C, m, b, p, T[I + 7], 10, 1126891415), p = w(p, C, m, b, T[I + 14], 15, -1416354905), b = w(b, p, C, m, T[I + 5], 21, -57434055), m = w(m, b, p, C, T[I + 12], 6, 1700485571), C = w(C, m, b, p, T[I + 3], 10, -1894986606), p = w(p, C, m, b, T[I + 10], 15, -1051523), b = w(b, p, C, m, T[I + 1], 21, -2054922799), m = w(m, b, p, C, T[I + 8], 6, 1873313359), C = w(C, m, b, p, T[I + 15], 10, -30611744), p = w(p, C, m, b, T[I + 6], 15, -1560198380), b = w(b, p, C, m, T[I + 13], 21, 1309151649), m = w(m, b, p, C, T[I + 4], 6, -145523070), C = w(C, m, b, p, T[I + 11], 10, -1120210379), p = w(p, C, m, b, T[I + 2], 15, 718787259), b = w(b, p, C, m, T[I + 9], 21, -343485551), m = P(m, K), b = P(b, z), p = P(p, Y), C = P(C, W);
           }
-          return Array(d, w, f, P);
+          return Array(m, b, p, C);
         }
-        function y(x, M, d, w, f, P) {
-          return A((M = A(A(M, x), A(w, P))) << f | M >>> 32 - f, d);
+        function g(T, E, m, b, p, C) {
+          return P((E = P(P(E, T), P(b, C))) << p | E >>> 32 - p, m);
         }
-        function E(x, M, d, w, f, P, I) {
-          return y(M & d | ~M & w, x, M, f, P, I);
+        function v(T, E, m, b, p, C, I) {
+          return g(E & m | ~E & b, T, E, p, C, I);
         }
-        function R(x, M, d, w, f, P, I) {
-          return y(M & w | d & ~w, x, M, f, P, I);
+        function M(T, E, m, b, p, C, I) {
+          return g(E & b | m & ~b, T, E, p, C, I);
         }
-        function T(x, M, d, w, f, P, I) {
-          return y(M ^ d ^ w, x, M, f, P, I);
+        function _(T, E, m, b, p, C, I) {
+          return g(E ^ m ^ b, T, E, p, C, I);
         }
-        function g(x, M, d, w, f, P, I) {
-          return y(d ^ (M | ~w), x, M, f, P, I);
+        function w(T, E, m, b, p, C, I) {
+          return g(m ^ (E | ~b), T, E, p, C, I);
         }
-        function A(x, M) {
-          var d = (65535 & x) + (65535 & M);
-          return (x >> 16) + (M >> 16) + (d >> 16) << 16 | 65535 & d;
+        function P(T, E) {
+          var m = (65535 & T) + (65535 & E);
+          return (T >> 16) + (E >> 16) + (m >> 16) << 16 | 65535 & m;
         }
-        n.exports = function(x) {
-          return v.hash(x, _, 16);
+        n.exports = function(T) {
+          return y.hash(T, x, 16);
         };
       }).call(this, t("lYpoI2"), typeof self < "u" ? self : typeof window < "u" ? window : {}, t("buffer").Buffer, arguments[3], arguments[4], arguments[5], arguments[6], "/node_modules/gulp-browserify/node_modules/crypto-browserify/md5.js", "/node_modules/gulp-browserify/node_modules/crypto-browserify");
     }, { "./helpers": 4, buffer: 3, lYpoI2: 11 }], 7: [function(t, n, s) {
-      (function(i, r, a, l, c, u, h, m, p) {
-        n.exports = function(v) {
-          for (var _, y = new Array(v), E = 0; E < v; E++)
-            !(3 & E) && (_ = 4294967296 * Math.random()), y[E] = _ >>> ((3 & E) << 3) & 255;
-          return y;
+      (function(i, r, a, l, c, u, h, f, d) {
+        n.exports = function(y) {
+          for (var x, g = new Array(y), v = 0; v < y; v++)
+            !(3 & v) && (x = 4294967296 * Math.random()), g[v] = x >>> ((3 & v) << 3) & 255;
+          return g;
         };
       }).call(this, t("lYpoI2"), typeof self < "u" ? self : typeof window < "u" ? window : {}, t("buffer").Buffer, arguments[3], arguments[4], arguments[5], arguments[6], "/node_modules/gulp-browserify/node_modules/crypto-browserify/rng.js", "/node_modules/gulp-browserify/node_modules/crypto-browserify");
     }, { buffer: 3, lYpoI2: 11 }], 8: [function(t, n, s) {
-      (function(i, r, a, l, c, u, h, m, p) {
-        var v = t("./helpers");
-        function _(R, T) {
-          R[T >> 5] |= 128 << 24 - T % 32, R[15 + (T + 64 >> 9 << 4)] = T;
-          for (var g, A, x, M = Array(80), d = 1732584193, w = -271733879, f = -1732584194, P = 271733878, I = -1009589776, K = 0; K < R.length; K += 16) {
-            for (var N = d, Z = w, W = f, X = P, V = I, ne = 0; ne < 80; ne++) {
-              M[ne] = ne < 16 ? R[K + ne] : E(M[ne - 3] ^ M[ne - 8] ^ M[ne - 14] ^ M[ne - 16], 1);
-              var se = y(y(E(d, 5), (se = w, A = f, x = P, (g = ne) < 20 ? se & A | ~se & x : !(g < 40) && g < 60 ? se & A | se & x | A & x : se ^ A ^ x)), y(y(I, M[ne]), (g = ne) < 20 ? 1518500249 : g < 40 ? 1859775393 : g < 60 ? -1894007588 : -899497514)), I = P, P = f, f = E(w, 30), w = d, d = se;
+      (function(i, r, a, l, c, u, h, f, d) {
+        var y = t("./helpers");
+        function x(M, _) {
+          M[_ >> 5] |= 128 << 24 - _ % 32, M[15 + (_ + 64 >> 9 << 4)] = _;
+          for (var w, P, T, E = Array(80), m = 1732584193, b = -271733879, p = -1732584194, C = 271733878, I = -1009589776, K = 0; K < M.length; K += 16) {
+            for (var z = m, Y = b, W = p, X = C, V = I, te = 0; te < 80; te++) {
+              E[te] = te < 16 ? M[K + te] : v(E[te - 3] ^ E[te - 8] ^ E[te - 14] ^ E[te - 16], 1);
+              var se = g(g(v(m, 5), (se = b, P = p, T = C, (w = te) < 20 ? se & P | ~se & T : !(w < 40) && w < 60 ? se & P | se & T | P & T : se ^ P ^ T)), g(g(I, E[te]), (w = te) < 20 ? 1518500249 : w < 40 ? 1859775393 : w < 60 ? -1894007588 : -899497514)), I = C, C = p, p = v(b, 30), b = m, m = se;
             }
-            d = y(d, N), w = y(w, Z), f = y(f, W), P = y(P, X), I = y(I, V);
+            m = g(m, z), b = g(b, Y), p = g(p, W), C = g(C, X), I = g(I, V);
           }
-          return Array(d, w, f, P, I);
+          return Array(m, b, p, C, I);
         }
-        function y(R, T) {
-          var g = (65535 & R) + (65535 & T);
-          return (R >> 16) + (T >> 16) + (g >> 16) << 16 | 65535 & g;
+        function g(M, _) {
+          var w = (65535 & M) + (65535 & _);
+          return (M >> 16) + (_ >> 16) + (w >> 16) << 16 | 65535 & w;
         }
-        function E(R, T) {
-          return R << T | R >>> 32 - T;
+        function v(M, _) {
+          return M << _ | M >>> 32 - _;
         }
-        n.exports = function(R) {
-          return v.hash(R, _, 20, !0);
+        n.exports = function(M) {
+          return y.hash(M, x, 20, !0);
         };
       }).call(this, t("lYpoI2"), typeof self < "u" ? self : typeof window < "u" ? window : {}, t("buffer").Buffer, arguments[3], arguments[4], arguments[5], arguments[6], "/node_modules/gulp-browserify/node_modules/crypto-browserify/sha.js", "/node_modules/gulp-browserify/node_modules/crypto-browserify");
     }, { "./helpers": 4, buffer: 3, lYpoI2: 11 }], 9: [function(t, n, s) {
-      (function(i, r, a, l, c, u, h, m, p) {
-        function v(T, g) {
-          var A = (65535 & T) + (65535 & g);
-          return (T >> 16) + (g >> 16) + (A >> 16) << 16 | 65535 & A;
+      (function(i, r, a, l, c, u, h, f, d) {
+        function y(_, w) {
+          var P = (65535 & _) + (65535 & w);
+          return (_ >> 16) + (w >> 16) + (P >> 16) << 16 | 65535 & P;
         }
-        function _(T, g) {
-          var A, x = new Array(1116352408, 1899447441, 3049323471, 3921009573, 961987163, 1508970993, 2453635748, 2870763221, 3624381080, 310598401, 607225278, 1426881987, 1925078388, 2162078206, 2614888103, 3248222580, 3835390401, 4022224774, 264347078, 604807628, 770255983, 1249150122, 1555081692, 1996064986, 2554220882, 2821834349, 2952996808, 3210313671, 3336571891, 3584528711, 113926993, 338241895, 666307205, 773529912, 1294757372, 1396182291, 1695183700, 1986661051, 2177026350, 2456956037, 2730485921, 2820302411, 3259730800, 3345764771, 3516065817, 3600352804, 4094571909, 275423344, 430227734, 506948616, 659060556, 883997877, 958139571, 1322822218, 1537002063, 1747873779, 1955562222, 2024104815, 2227730452, 2361852424, 2428436474, 2756734187, 3204031479, 3329325298), M = new Array(1779033703, 3144134277, 1013904242, 2773480762, 1359893119, 2600822924, 528734635, 1541459225), d = new Array(64);
-          T[g >> 5] |= 128 << 24 - g % 32, T[15 + (g + 64 >> 9 << 4)] = g;
-          for (var w, f, P = 0; P < T.length; P += 16) {
-            for (var I = M[0], K = M[1], N = M[2], Z = M[3], W = M[4], X = M[5], V = M[6], ne = M[7], se = 0; se < 64; se++)
-              d[se] = se < 16 ? T[se + P] : v(v(v((f = d[se - 2], E(f, 17) ^ E(f, 19) ^ R(f, 10)), d[se - 7]), (f = d[se - 15], E(f, 7) ^ E(f, 18) ^ R(f, 3))), d[se - 16]), A = v(v(v(v(ne, E(f = W, 6) ^ E(f, 11) ^ E(f, 25)), W & X ^ ~W & V), x[se]), d[se]), w = v(E(w = I, 2) ^ E(w, 13) ^ E(w, 22), I & K ^ I & N ^ K & N), ne = V, V = X, X = W, W = v(Z, A), Z = N, N = K, K = I, I = v(A, w);
-            M[0] = v(I, M[0]), M[1] = v(K, M[1]), M[2] = v(N, M[2]), M[3] = v(Z, M[3]), M[4] = v(W, M[4]), M[5] = v(X, M[5]), M[6] = v(V, M[6]), M[7] = v(ne, M[7]);
+        function x(_, w) {
+          var P, T = new Array(1116352408, 1899447441, 3049323471, 3921009573, 961987163, 1508970993, 2453635748, 2870763221, 3624381080, 310598401, 607225278, 1426881987, 1925078388, 2162078206, 2614888103, 3248222580, 3835390401, 4022224774, 264347078, 604807628, 770255983, 1249150122, 1555081692, 1996064986, 2554220882, 2821834349, 2952996808, 3210313671, 3336571891, 3584528711, 113926993, 338241895, 666307205, 773529912, 1294757372, 1396182291, 1695183700, 1986661051, 2177026350, 2456956037, 2730485921, 2820302411, 3259730800, 3345764771, 3516065817, 3600352804, 4094571909, 275423344, 430227734, 506948616, 659060556, 883997877, 958139571, 1322822218, 1537002063, 1747873779, 1955562222, 2024104815, 2227730452, 2361852424, 2428436474, 2756734187, 3204031479, 3329325298), E = new Array(1779033703, 3144134277, 1013904242, 2773480762, 1359893119, 2600822924, 528734635, 1541459225), m = new Array(64);
+          _[w >> 5] |= 128 << 24 - w % 32, _[15 + (w + 64 >> 9 << 4)] = w;
+          for (var b, p, C = 0; C < _.length; C += 16) {
+            for (var I = E[0], K = E[1], z = E[2], Y = E[3], W = E[4], X = E[5], V = E[6], te = E[7], se = 0; se < 64; se++)
+              m[se] = se < 16 ? _[se + C] : y(y(y((p = m[se - 2], v(p, 17) ^ v(p, 19) ^ M(p, 10)), m[se - 7]), (p = m[se - 15], v(p, 7) ^ v(p, 18) ^ M(p, 3))), m[se - 16]), P = y(y(y(y(te, v(p = W, 6) ^ v(p, 11) ^ v(p, 25)), W & X ^ ~W & V), T[se]), m[se]), b = y(v(b = I, 2) ^ v(b, 13) ^ v(b, 22), I & K ^ I & z ^ K & z), te = V, V = X, X = W, W = y(Y, P), Y = z, z = K, K = I, I = y(P, b);
+            E[0] = y(I, E[0]), E[1] = y(K, E[1]), E[2] = y(z, E[2]), E[3] = y(Y, E[3]), E[4] = y(W, E[4]), E[5] = y(X, E[5]), E[6] = y(V, E[6]), E[7] = y(te, E[7]);
           }
-          return M;
+          return E;
         }
-        var y = t("./helpers"), E = function(T, g) {
-          return T >>> g | T << 32 - g;
-        }, R = function(T, g) {
-          return T >>> g;
+        var g = t("./helpers"), v = function(_, w) {
+          return _ >>> w | _ << 32 - w;
+        }, M = function(_, w) {
+          return _ >>> w;
         };
-        n.exports = function(T) {
-          return y.hash(T, _, 32, !0);
+        n.exports = function(_) {
+          return g.hash(_, x, 32, !0);
         };
       }).call(this, t("lYpoI2"), typeof self < "u" ? self : typeof window < "u" ? window : {}, t("buffer").Buffer, arguments[3], arguments[4], arguments[5], arguments[6], "/node_modules/gulp-browserify/node_modules/crypto-browserify/sha256.js", "/node_modules/gulp-browserify/node_modules/crypto-browserify");
     }, { "./helpers": 4, buffer: 3, lYpoI2: 11 }], 10: [function(t, n, s) {
-      (function(i, r, a, l, c, u, h, m, p) {
-        s.read = function(v, _, y, E, P) {
-          var T, g, A = 8 * P - E - 1, x = (1 << A) - 1, M = x >> 1, d = -7, w = y ? P - 1 : 0, f = y ? -1 : 1, P = v[_ + w];
-          for (w += f, T = P & (1 << -d) - 1, P >>= -d, d += A; 0 < d; T = 256 * T + v[_ + w], w += f, d -= 8)
+      (function(i, r, a, l, c, u, h, f, d) {
+        s.read = function(y, x, g, v, C) {
+          var _, w, P = 8 * C - v - 1, T = (1 << P) - 1, E = T >> 1, m = -7, b = g ? C - 1 : 0, p = g ? -1 : 1, C = y[x + b];
+          for (b += p, _ = C & (1 << -m) - 1, C >>= -m, m += P; 0 < m; _ = 256 * _ + y[x + b], b += p, m -= 8)
             ;
-          for (g = T & (1 << -d) - 1, T >>= -d, d += E; 0 < d; g = 256 * g + v[_ + w], w += f, d -= 8)
+          for (w = _ & (1 << -m) - 1, _ >>= -m, m += v; 0 < m; w = 256 * w + y[x + b], b += p, m -= 8)
             ;
-          if (T === 0)
-            T = 1 - M;
+          if (_ === 0)
+            _ = 1 - E;
           else {
-            if (T === x)
-              return g ? NaN : 1 / 0 * (P ? -1 : 1);
-            g += Math.pow(2, E), T -= M;
+            if (_ === T)
+              return w ? NaN : 1 / 0 * (C ? -1 : 1);
+            w += Math.pow(2, v), _ -= E;
           }
-          return (P ? -1 : 1) * g * Math.pow(2, T - E);
-        }, s.write = function(v, _, y, E, R, I) {
-          var g, A, x = 8 * I - R - 1, M = (1 << x) - 1, d = M >> 1, w = R === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0, f = E ? 0 : I - 1, P = E ? 1 : -1, I = _ < 0 || _ === 0 && 1 / _ < 0 ? 1 : 0;
-          for (_ = Math.abs(_), isNaN(_) || _ === 1 / 0 ? (A = isNaN(_) ? 1 : 0, g = M) : (g = Math.floor(Math.log(_) / Math.LN2), _ * (E = Math.pow(2, -g)) < 1 && (g--, E *= 2), 2 <= (_ += 1 <= g + d ? w / E : w * Math.pow(2, 1 - d)) * E && (g++, E /= 2), M <= g + d ? (A = 0, g = M) : 1 <= g + d ? (A = (_ * E - 1) * Math.pow(2, R), g += d) : (A = _ * Math.pow(2, d - 1) * Math.pow(2, R), g = 0)); 8 <= R; v[y + f] = 255 & A, f += P, A /= 256, R -= 8)
+          return (C ? -1 : 1) * w * Math.pow(2, _ - v);
+        }, s.write = function(y, x, g, v, M, I) {
+          var w, P, T = 8 * I - M - 1, E = (1 << T) - 1, m = E >> 1, b = M === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0, p = v ? 0 : I - 1, C = v ? 1 : -1, I = x < 0 || x === 0 && 1 / x < 0 ? 1 : 0;
+          for (x = Math.abs(x), isNaN(x) || x === 1 / 0 ? (P = isNaN(x) ? 1 : 0, w = E) : (w = Math.floor(Math.log(x) / Math.LN2), x * (v = Math.pow(2, -w)) < 1 && (w--, v *= 2), 2 <= (x += 1 <= w + m ? b / v : b * Math.pow(2, 1 - m)) * v && (w++, v /= 2), E <= w + m ? (P = 0, w = E) : 1 <= w + m ? (P = (x * v - 1) * Math.pow(2, M), w += m) : (P = x * Math.pow(2, m - 1) * Math.pow(2, M), w = 0)); 8 <= M; y[g + p] = 255 & P, p += C, P /= 256, M -= 8)
             ;
-          for (g = g << R | A, x += R; 0 < x; v[y + f] = 255 & g, f += P, g /= 256, x -= 8)
+          for (w = w << M | P, T += M; 0 < T; y[g + p] = 255 & w, p += C, w /= 256, T -= 8)
             ;
-          v[y + f - P] |= 128 * I;
+          y[g + p - C] |= 128 * I;
         };
       }).call(this, t("lYpoI2"), typeof self < "u" ? self : typeof window < "u" ? window : {}, t("buffer").Buffer, arguments[3], arguments[4], arguments[5], arguments[6], "/node_modules/gulp-browserify/node_modules/ieee754/index.js", "/node_modules/gulp-browserify/node_modules/ieee754");
     }, { buffer: 3, lYpoI2: 11 }], 11: [function(t, n, s) {
-      (function(i, r, a, l, c, u, h, m, p) {
-        var v, _, y;
-        function E() {
+      (function(i, r, a, l, c, u, h, f, d) {
+        var y, x, g;
+        function v() {
         }
-        (i = n.exports = {}).nextTick = (_ = typeof window < "u" && window.setImmediate, y = typeof window < "u" && window.postMessage && window.addEventListener, _ ? function(R) {
-          return window.setImmediate(R);
-        } : y ? (v = [], window.addEventListener("message", function(R) {
-          var T = R.source;
-          T !== window && T !== null || R.data !== "process-tick" || (R.stopPropagation(), 0 < v.length && v.shift()());
-        }, !0), function(R) {
-          v.push(R), window.postMessage("process-tick", "*");
-        }) : function(R) {
-          setTimeout(R, 0);
-        }), i.title = "browser", i.browser = !0, i.env = {}, i.argv = [], i.on = E, i.addListener = E, i.once = E, i.off = E, i.removeListener = E, i.removeAllListeners = E, i.emit = E, i.binding = function(R) {
+        (i = n.exports = {}).nextTick = (x = typeof window < "u" && window.setImmediate, g = typeof window < "u" && window.postMessage && window.addEventListener, x ? function(M) {
+          return window.setImmediate(M);
+        } : g ? (y = [], window.addEventListener("message", function(M) {
+          var _ = M.source;
+          _ !== window && _ !== null || M.data !== "process-tick" || (M.stopPropagation(), 0 < y.length && y.shift()());
+        }, !0), function(M) {
+          y.push(M), window.postMessage("process-tick", "*");
+        }) : function(M) {
+          setTimeout(M, 0);
+        }), i.title = "browser", i.browser = !0, i.env = {}, i.argv = [], i.on = v, i.addListener = v, i.once = v, i.off = v, i.removeListener = v, i.removeAllListeners = v, i.emit = v, i.binding = function(M) {
           throw new Error("process.binding is not supported");
         }, i.cwd = function() {
           return "/";
-        }, i.chdir = function(R) {
+        }, i.chdir = function(M) {
           throw new Error("process.chdir is not supported");
         };
       }).call(this, t("lYpoI2"), typeof self < "u" ? self : typeof window < "u" ? window : {}, t("buffer").Buffer, arguments[3], arguments[4], arguments[5], arguments[6], "/node_modules/gulp-browserify/node_modules/process/browser.js", "/node_modules/gulp-browserify/node_modules/process");
     }, { buffer: 3, lYpoI2: 11 }] }, {}, [1])(1);
   });
-})(ja);
-var Df = ja.exports;
-const Lf = /* @__PURE__ */ ys(Df);
-var Va = [
+})(Ka);
+var Nf = Ka.exports;
+const zf = /* @__PURE__ */ Es(Nf);
+var qa = [
   // current
   "precision",
   "highp",
@@ -12435,7 +12463,7 @@ var Va = [
   "cast",
   "namespace",
   "using"
-], Of = [
+], Hf = [
   "<<=",
   ">>=",
   "++",
@@ -12481,7 +12509,7 @@ var Va = [
   ";",
   "{",
   "}"
-], Ya = [
+], Qa = [
   // Keep this list sorted
   "abs",
   "acos",
@@ -12630,7 +12658,7 @@ var Va = [
   "texture2DGradEXT",
   "texture2DProjGradEXT",
   "textureCubeGradEXT"
-], Ff = Va, kf = Ff.slice().concat([
+], jf = qa, Gf = jf.slice().concat([
   "layout",
   "centroid",
   "smooth",
@@ -12714,11 +12742,11 @@ var Va = [
   "sampler2DMSArray",
   "isampler2DMSArray",
   "usampler2DMSArray"
-]), nr = Ya;
-nr = nr.slice().filter(function(o) {
+]), ar = Qa;
+ar = ar.slice().filter(function(o) {
   return !/^(gl\_|texture)/.test(o);
 });
-var Uf = nr.concat([
+var Vf = ar.concat([
   // the updated gl_ constants
   "gl_VertexID",
   "gl_InstanceID",
@@ -12775,7 +12803,7 @@ var Uf = nr.concat([
   "textureGradOffset",
   "textureProjGrad",
   "textureProjGradOffset"
-]), Bf = $f, Nf = Va, yo = Of, zf = Ya, Hf = kf, Gf = Uf, bt = 999, vo = 9999, Li = 0, Oi = 1, _o = 2, xo = 3, wo = 4, Jn = 5, jf = 6, Vf = 7, Yf = 8, To = 9, Xf = 10, bo = 11, Wf = [
+]), Wf = td, Yf = qa, bo = Hf, Xf = Qa, $f = Gf, Zf = Vf, Mt = 999, Eo = 9999, zi = 0, Hi = 1, So = 2, Mo = 3, Ao = 4, os = 5, Kf = 6, qf = 7, Qf = 8, Po = 9, Jf = 10, Co = 11, ed = [
   "block-comment",
   "line-comment",
   "preprocessor",
@@ -12789,65 +12817,65 @@ var Uf = nr.concat([
   "eof",
   "integer"
 ];
-function $f(o) {
-  var e = 0, t = 0, n = bt, s, i, r = [], a = [], l = 1, c = 0, u = 0, h = !1, m = !1, p = "", v;
+function td(o) {
+  var e = 0, t = 0, n = Mt, s, i, r = [], a = [], l = 1, c = 0, u = 0, h = !1, f = !1, d = "", y;
   o = o || {};
-  var _ = zf, y = Nf;
-  o.version === "300 es" && (_ = Gf, y = Hf);
-  for (var E = {}, R = {}, e = 0; e < _.length; e++)
-    E[_[e]] = !0;
-  for (var e = 0; e < y.length; e++)
-    R[y[e]] = !0;
+  var x = Xf, g = Yf;
+  o.version === "300 es" && (x = Zf, g = $f);
+  for (var v = {}, M = {}, e = 0; e < x.length; e++)
+    v[x[e]] = !0;
+  for (var e = 0; e < g.length; e++)
+    M[g[e]] = !0;
   return function(X) {
-    return a = [], X !== null ? g(X) : A();
+    return a = [], X !== null ? w(X) : P();
   };
-  function T(X) {
+  function _(X) {
     X.length && a.push({
-      type: Wf[n],
+      type: ed[n],
       data: X,
       position: u,
       line: l,
       column: c
     });
   }
-  function g(X) {
-    e = 0, X.toString && (X = X.toString()), p += X.replace(/\r\n/g, `
-`), v = p.length;
-    for (var V; s = p[e], e < v; ) {
+  function w(X) {
+    e = 0, X.toString && (X = X.toString()), d += X.replace(/\r\n/g, `
+`), y = d.length;
+    for (var V; s = d[e], e < y; ) {
       switch (V = e, n) {
-        case Li:
-          e = f();
+        case zi:
+          e = p();
           break;
-        case Oi:
-          e = w();
+        case Hi:
+          e = b();
           break;
-        case _o:
-          e = d();
+        case So:
+          e = m();
           break;
-        case xo:
-          e = P();
+        case Mo:
+          e = C();
           break;
-        case wo:
-          e = N();
+        case Ao:
+          e = z();
           break;
-        case bo:
+        case Co:
           e = K();
           break;
-        case Jn:
-          e = Z();
+        case os:
+          e = Y();
           break;
-        case vo:
+        case Eo:
           e = W();
           break;
-        case To:
-          e = M();
+        case Po:
+          e = E();
           break;
-        case bt:
-          e = x();
+        case Mt:
+          e = T();
           break;
       }
       if (V !== e)
-        switch (p[V]) {
+        switch (d[V]) {
           case `
 `:
             c = 0, ++l;
@@ -12857,108 +12885,108 @@ function $f(o) {
             break;
         }
     }
-    return t += e, p = p.slice(e), a;
+    return t += e, d = d.slice(e), a;
   }
-  function A(X) {
-    return r.length && T(r.join("")), n = Xf, T("(eof)"), a;
+  function P(X) {
+    return r.length && _(r.join("")), n = Jf, _("(eof)"), a;
   }
-  function x() {
-    return r = r.length ? [] : r, i === "/" && s === "*" ? (u = t + e - 1, n = Li, i = s, e + 1) : i === "/" && s === "/" ? (u = t + e - 1, n = Oi, i = s, e + 1) : s === "#" ? (n = _o, u = t + e, e) : /\s/.test(s) ? (n = To, u = t + e, e) : (h = /\d/.test(s), m = /[^\w_]/.test(s), u = t + e, n = h ? wo : m ? xo : vo, e);
+  function T() {
+    return r = r.length ? [] : r, i === "/" && s === "*" ? (u = t + e - 1, n = zi, i = s, e + 1) : i === "/" && s === "/" ? (u = t + e - 1, n = Hi, i = s, e + 1) : s === "#" ? (n = So, u = t + e, e) : /\s/.test(s) ? (n = Po, u = t + e, e) : (h = /\d/.test(s), f = /[^\w_]/.test(s), u = t + e, n = h ? Ao : f ? Mo : Eo, e);
   }
-  function M() {
-    return /[^\s]/g.test(s) ? (T(r.join("")), n = bt, e) : (r.push(s), i = s, e + 1);
+  function E() {
+    return /[^\s]/g.test(s) ? (_(r.join("")), n = Mt, e) : (r.push(s), i = s, e + 1);
   }
-  function d() {
+  function m() {
     return (s === "\r" || s === `
-`) && i !== "\\" ? (T(r.join("")), n = bt, e) : (r.push(s), i = s, e + 1);
+`) && i !== "\\" ? (_(r.join("")), n = Mt, e) : (r.push(s), i = s, e + 1);
   }
-  function w() {
-    return d();
+  function b() {
+    return m();
   }
-  function f() {
-    return s === "/" && i === "*" ? (r.push(s), T(r.join("")), n = bt, e + 1) : (r.push(s), i = s, e + 1);
+  function p() {
+    return s === "/" && i === "*" ? (r.push(s), _(r.join("")), n = Mt, e + 1) : (r.push(s), i = s, e + 1);
   }
-  function P() {
+  function C() {
     if (i === "." && /\d/.test(s))
-      return n = Jn, e;
+      return n = os, e;
     if (i === "/" && s === "*")
-      return n = Li, e;
+      return n = zi, e;
     if (i === "/" && s === "/")
-      return n = Oi, e;
+      return n = Hi, e;
     if (s === "." && r.length) {
       for (; I(r); )
         ;
-      return n = Jn, e;
+      return n = os, e;
     }
     if (s === ";" || s === ")" || s === "(") {
       if (r.length)
         for (; I(r); )
           ;
-      return T(s), n = bt, e + 1;
+      return _(s), n = Mt, e + 1;
     }
     var X = r.length === 2 && s !== "=";
     if (/[\w_\d\s]/.test(s) || X) {
       for (; I(r); )
         ;
-      return n = bt, e;
+      return n = Mt, e;
     }
     return r.push(s), i = s, e + 1;
   }
   function I(X) {
-    var V = 0, ne, se;
+    var V = 0, te, se;
     do {
-      if (ne = yo.indexOf(X.slice(0, X.length + V).join("")), se = yo[ne], ne === -1) {
+      if (te = bo.indexOf(X.slice(0, X.length + V).join("")), se = bo[te], te === -1) {
         if (V-- + X.length > 0)
           continue;
         se = X.slice(0, 1).join("");
       }
-      return T(se), u += se.length, r = r.slice(se.length), r.length;
+      return _(se), u += se.length, r = r.slice(se.length), r.length;
     } while (!0);
   }
   function K() {
-    return /[^a-fA-F0-9]/.test(s) ? (T(r.join("")), n = bt, e) : (r.push(s), i = s, e + 1);
+    return /[^a-fA-F0-9]/.test(s) ? (_(r.join("")), n = Mt, e) : (r.push(s), i = s, e + 1);
   }
-  function N() {
-    return s === "." || /[eE]/.test(s) ? (r.push(s), n = Jn, i = s, e + 1) : s === "x" && r.length === 1 && r[0] === "0" ? (n = bo, r.push(s), i = s, e + 1) : /[^\d]/.test(s) ? (T(r.join("")), n = bt, e) : (r.push(s), i = s, e + 1);
+  function z() {
+    return s === "." || /[eE]/.test(s) ? (r.push(s), n = os, i = s, e + 1) : s === "x" && r.length === 1 && r[0] === "0" ? (n = Co, r.push(s), i = s, e + 1) : /[^\d]/.test(s) ? (_(r.join("")), n = Mt, e) : (r.push(s), i = s, e + 1);
   }
-  function Z() {
-    return s === "f" && (r.push(s), i = s, e += 1), /[eE]/.test(s) || (s === "-" || s === "+") && /[eE]/.test(i) ? (r.push(s), i = s, e + 1) : /[^\d]/.test(s) ? (T(r.join("")), n = bt, e) : (r.push(s), i = s, e + 1);
+  function Y() {
+    return s === "f" && (r.push(s), i = s, e += 1), /[eE]/.test(s) || (s === "-" || s === "+") && /[eE]/.test(i) ? (r.push(s), i = s, e + 1) : /[^\d]/.test(s) ? (_(r.join("")), n = Mt, e) : (r.push(s), i = s, e + 1);
   }
   function W() {
     if (/[^\d\w_]/.test(s)) {
       var X = r.join("");
-      return R[X] ? n = Yf : E[X] ? n = Vf : n = jf, T(r.join("")), n = bt, e;
+      return M[X] ? n = Qf : v[X] ? n = qf : n = Kf, _(r.join("")), n = Mt, e;
     }
     return r.push(s), i = s, e + 1;
   }
 }
-var Zf = Bf, Kf = qf;
-function qf(o, e) {
-  var t = Zf(e), n = [];
+var nd = Wf, sd = id;
+function id(o, e) {
+  var t = nd(e), n = [];
   return n = n.concat(t(o)), n = n.concat(t(null)), n;
 }
-const Qf = /* @__PURE__ */ ys(Kf);
-var Jf = ed;
-function ed(o) {
+const rd = /* @__PURE__ */ Es(sd);
+var od = ad;
+function ad(o) {
   for (var e = [], t = 0; t < o.length; t++)
     o[t].type !== "eof" && e.push(o[t].data);
   return e.join("");
 }
-const Eo = /* @__PURE__ */ ys(Jf);
-var td = nd;
-function nd(o) {
+const Ro = /* @__PURE__ */ Es(od);
+var ld = cd;
+function cd(o) {
   var e = null, t = null, n = 0, s = 0, i = 0, r = 0, a = 0, l = [], c, u, h;
   for (c = 0, u; c < o.length; c++)
     if (h = o[c], h.data === "{") {
-      if (n && n++ || (u = p(c, en(")"), en()), u < 0) || (r = u, u = p(u, en("("), en(")")), u < 0) || (a = u, u = p(u, es), u < 0) || o[u].type !== "ident" || (t = o[u].data, u = p(u, es), u < 0))
+      if (n && n++ || (u = d(c, sn(")"), sn()), u < 0) || (r = u, u = d(u, sn("("), sn(")")), u < 0) || (a = u, u = d(u, as), u < 0) || o[u].type !== "ident" || (t = o[u].data, u = d(u, as), u < 0))
         continue;
       n = 1, s = c, e = o[u].data, i = u;
-      var m = p(u, es);
-      switch (o[m] && o[m].data) {
+      var f = d(u, as);
+      switch (o[f] && o[f].data) {
         case "lowp":
         case "highp":
         case "mediump":
-          i = m;
+          i = f;
       }
     } else if (n && h.data === "}") {
       if (--n)
@@ -12973,7 +13001,7 @@ function nd(o) {
     }
   for (c = 0; c < o.length; c++)
     if (h = o[c], h.data === ";") {
-      if (u = p(c, en(")"), en()), u < 0 || (r = u, u = p(u, en("("), en(")")), u < 0) || (a = u, u = p(u, es), u < 0) || o[u].type !== "ident" || (t = o[u].data, u = p(u, es), u < 0) || o[u].type === "operator" || o[u].data === "return")
+      if (u = d(c, sn(")"), sn()), u < 0 || (r = u, u = d(u, sn("("), sn(")")), u < 0) || (a = u, u = d(u, as), u < 0) || o[u].type !== "ident" || (t = o[u].data, u = d(u, as), u < 0) || o[u].type === "operator" || o[u].data === "return")
         continue;
       e = o[u].data, l.push({
         name: t,
@@ -12983,29 +13011,29 @@ function nd(o) {
         outer: [u, c + 1]
       });
     }
-  return l.sort(function(v, _) {
-    return v.outer[0] - _.outer[0];
+  return l.sort(function(y, x) {
+    return y.outer[0] - x.outer[0];
   });
-  function p(v, _, y) {
-    for (var E = v - 1; E >= 0; E--) {
-      if (_(o[E]))
-        return E;
-      if (y && y(o[E]))
+  function d(y, x, g) {
+    for (var v = y - 1; v >= 0; v--) {
+      if (x(o[v]))
+        return v;
+      if (g && g(o[v]))
         return -1;
     }
     return -1;
   }
 }
-function en(o) {
+function sn(o) {
   return function(e) {
     return e.type === "operator" && (!o || e.data === o);
   };
 }
-function es(o) {
+function as(o) {
   return o.type !== "whitespace";
 }
-const sd = /* @__PURE__ */ ys(td);
-function id(o, e) {
+const ud = /* @__PURE__ */ Es(ld);
+function hd(o, e) {
   if (typeof o != "object" || o === null)
     return o;
   var t = o[Symbol.toPrimitive];
@@ -13017,19 +13045,19 @@ function id(o, e) {
   }
   return (e === "string" ? String : Number)(o);
 }
-function Xa(o) {
-  var e = id(o, "string");
+function Ja(o) {
+  var e = hd(o, "string");
   return typeof e == "symbol" ? e : String(e);
 }
-function Ue(o, e, t) {
-  return e = Xa(e), e in o ? Object.defineProperty(o, e, {
+function Be(o, e, t) {
+  return e = Ja(e), e in o ? Object.defineProperty(o, e, {
     value: t,
     enumerable: !0,
     configurable: !0,
     writable: !0
   }) : o[e] = t, o;
 }
-function Mo(o, e) {
+function Io(o, e) {
   var t = Object.keys(o);
   if (Object.getOwnPropertySymbols) {
     var n = Object.getOwnPropertySymbols(o);
@@ -13039,18 +13067,18 @@ function Mo(o, e) {
   }
   return t;
 }
-function kn(o) {
+function Un(o) {
   for (var e = 1; e < arguments.length; e++) {
     var t = arguments[e] != null ? arguments[e] : {};
-    e % 2 ? Mo(Object(t), !0).forEach(function(n) {
-      Ue(o, n, t[n]);
-    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(o, Object.getOwnPropertyDescriptors(t)) : Mo(Object(t)).forEach(function(n) {
+    e % 2 ? Io(Object(t), !0).forEach(function(n) {
+      Be(o, n, t[n]);
+    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(o, Object.getOwnPropertyDescriptors(t)) : Io(Object(t)).forEach(function(n) {
       Object.defineProperty(o, n, Object.getOwnPropertyDescriptor(t, n));
     });
   }
   return o;
 }
-function rd(o, e) {
+function fd(o, e) {
   if (o == null)
     return {};
   var t = {}, n = Object.keys(o), s, i;
@@ -13058,10 +13086,10 @@ function rd(o, e) {
     s = n[i], !(e.indexOf(s) >= 0) && (t[s] = o[s]);
   return t;
 }
-function od(o, e) {
+function dd(o, e) {
   if (o == null)
     return {};
-  var t = rd(o, e), n, s;
+  var t = fd(o, e), n, s;
   if (Object.getOwnPropertySymbols) {
     var i = Object.getOwnPropertySymbols(o);
     for (s = 0; s < i.length; s++)
@@ -13069,32 +13097,32 @@ function od(o, e) {
   }
   return t;
 }
-function ad(o, e) {
+function pd(o, e) {
   if (!(o instanceof e))
     throw new TypeError("Cannot call a class as a function");
 }
-function So(o, e) {
+function Do(o, e) {
   for (var t = 0; t < e.length; t++) {
     var n = e[t];
-    n.enumerable = n.enumerable || !1, n.configurable = !0, "value" in n && (n.writable = !0), Object.defineProperty(o, Xa(n.key), n);
+    n.enumerable = n.enumerable || !1, n.configurable = !0, "value" in n && (n.writable = !0), Object.defineProperty(o, Ja(n.key), n);
   }
 }
-function ld(o, e, t) {
-  return e && So(o.prototype, e), t && So(o, t), Object.defineProperty(o, "prototype", {
+function md(o, e, t) {
+  return e && Do(o.prototype, e), t && Do(o, t), Object.defineProperty(o, "prototype", {
     writable: !1
   }), o;
 }
-function Wa(o) {
+function el(o) {
   if (o === void 0)
     throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
   return o;
 }
-function sr(o, e) {
-  return sr = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(n, s) {
+function lr(o, e) {
+  return lr = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(n, s) {
     return n.__proto__ = s, n;
-  }, sr(o, e);
+  }, lr(o, e);
 }
-function cd(o, e) {
+function gd(o, e) {
   if (typeof e != "function" && e !== null)
     throw new TypeError("Super expression must either be null or a function");
   o.prototype = Object.create(e && e.prototype, {
@@ -13105,14 +13133,14 @@ function cd(o, e) {
     }
   }), Object.defineProperty(o, "prototype", {
     writable: !1
-  }), e && sr(o, e);
+  }), e && lr(o, e);
 }
-function Ks(o) {
-  return Ks = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(t) {
+function ni(o) {
+  return ni = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(t) {
     return t.__proto__ || Object.getPrototypeOf(t);
-  }, Ks(o);
+  }, ni(o);
 }
-function ud() {
+function vd() {
   if (typeof Reflect > "u" || !Reflect.construct || Reflect.construct.sham)
     return !1;
   if (typeof Proxy == "function")
@@ -13124,26 +13152,26 @@ function ud() {
     return !1;
   }
 }
-function hd(o, e) {
+function yd(o, e) {
   if (e && (typeof e == "object" || typeof e == "function"))
     return e;
   if (e !== void 0)
     throw new TypeError("Derived constructors may only return object or undefined");
-  return Wa(o);
+  return el(o);
 }
-function fd(o) {
-  var e = ud();
+function _d(o) {
+  var e = vd();
   return function() {
-    var n = Ks(o), s;
+    var n = ni(o), s;
     if (e) {
-      var i = Ks(this).constructor;
+      var i = ni(this).constructor;
       s = Reflect.construct(n, arguments, i);
     } else
       s = n.apply(this, arguments);
-    return hd(this, s);
+    return yd(this, s);
   };
 }
-var _e = {
+var xe = {
   position: "csm_Position",
   positionRaw: "csm_PositionRaw",
   pointSize: "csm_PointSize",
@@ -13165,20 +13193,20 @@ var _e = {
   // Bump
   depthAlpha: "csm_DepthAlpha"
   // Depth
-}, lt, Un, dd = (lt = {}, Ue(lt, "".concat(_e.normal), {
+}, ut, Nn, xd = (ut = {}, Be(ut, "".concat(xe.normal), {
   "#include <beginnormal_vertex>": `
-    vec3 objectNormal = `.concat(_e.normal, `;
+    vec3 objectNormal = `.concat(xe.normal, `;
     #ifdef USE_TANGENT
 	    vec3 objectTangent = vec3( tangent.xyz );
     #endif
     `)
-}), Ue(lt, "".concat(_e.position), {
+}), Be(ut, "".concat(xe.position), {
   "#include <begin_vertex>": `
-    vec3 transformed = `.concat(_e.position, `;
+    vec3 transformed = `.concat(xe.position, `;
   `)
-}), Ue(lt, "".concat(_e.positionRaw), {
+}), Be(ut, "".concat(xe.positionRaw), {
   "#include <begin_vertex>": `
-    vec4 csm_internal_positionUnprojected = `.concat(_e.positionRaw, `;
+    vec4 csm_internal_positionUnprojected = `.concat(xe.positionRaw, `;
     mat4x4 csm_internal_unprojectMatrix = projectionMatrix * modelViewMatrix;
     #ifdef USE_INSTANCING
       csm_internal_unprojectMatrix = csm_internal_unprojectMatrix * instanceMatrix;
@@ -13186,72 +13214,72 @@ var _e = {
     csm_internal_positionUnprojected = inverse(csm_internal_unprojectMatrix) * csm_internal_positionUnprojected;
     vec3 transformed = csm_internal_positionUnprojected.xyz;
   `)
-}), Ue(lt, "".concat(_e.pointSize), {
+}), Be(ut, "".concat(xe.pointSize), {
   "gl_PointSize = size;": `
-    gl_PointSize = `.concat(_e.pointSize, `;
+    gl_PointSize = `.concat(xe.pointSize, `;
     `)
-}), Ue(lt, "".concat(_e.diffuseColor), {
+}), Be(ut, "".concat(xe.diffuseColor), {
   "#include <color_fragment>": `
     #include <color_fragment>
-    diffuseColor = `.concat(_e.diffuseColor, `;
+    diffuseColor = `.concat(xe.diffuseColor, `;
   `)
-}), Ue(lt, "".concat(_e.fragColor), {
+}), Be(ut, "".concat(xe.fragColor), {
   "#include <dithering_fragment>": `
     #include <dithering_fragment>
-    gl_FragColor  = `.concat(_e.fragColor, `;
+    gl_FragColor  = `.concat(xe.fragColor, `;
   `)
-}), Ue(lt, "".concat(_e.emissive), {
+}), Be(ut, "".concat(xe.emissive), {
   "vec3 totalEmissiveRadiance = emissive;": `
-    vec3 totalEmissiveRadiance = `.concat(_e.emissive, `;
+    vec3 totalEmissiveRadiance = `.concat(xe.emissive, `;
     `)
-}), Ue(lt, "".concat(_e.roughness), {
+}), Be(ut, "".concat(xe.roughness), {
   "#include <roughnessmap_fragment>": `
     #include <roughnessmap_fragment>
-    roughnessFactor = `.concat(_e.roughness, `;
+    roughnessFactor = `.concat(xe.roughness, `;
     `)
-}), Ue(lt, "".concat(_e.metalness), {
+}), Be(ut, "".concat(xe.metalness), {
   "#include <metalnessmap_fragment>": `
     #include <metalnessmap_fragment>
-    metalnessFactor = `.concat(_e.metalness, `;
+    metalnessFactor = `.concat(xe.metalness, `;
     `)
-}), Ue(lt, "".concat(_e.ao), {
+}), Be(ut, "".concat(xe.ao), {
   "#include <aomap_fragment>": `
     #include <aomap_fragment>
-    reflectedLight.indirectDiffuse *= 1. - `.concat(_e.ao, `;
+    reflectedLight.indirectDiffuse *= 1. - `.concat(xe.ao, `;
     `)
-}), Ue(lt, "".concat(_e.bump), {
+}), Be(ut, "".concat(xe.bump), {
   "#include <normal_fragment_maps>": `
     #include <normal_fragment_maps>
 
-    vec3 csm_internal_orthogonal = `.concat(_e.bump, " - (dot(").concat(_e.bump, `, normal) * normal);
+    vec3 csm_internal_orthogonal = `.concat(xe.bump, " - (dot(").concat(xe.bump, `, normal) * normal);
     vec3 csm_internal_projectedbump = mat3(csm_internal_vModelViewMatrix) * csm_internal_orthogonal;
     normal = normalize(normal - csm_internal_projectedbump);
     `)
-}), Ue(lt, "".concat(_e.depthAlpha), {
+}), Be(ut, "".concat(xe.depthAlpha), {
   "gl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );": `
-      gl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity * `.concat(_e.depthAlpha, ` );
+      gl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity * `.concat(xe.depthAlpha, ` );
     `),
   "gl_FragColor = packDepthToRGBA( fragCoordZ );": `
       gl_FragColor = packDepthToRGBA( fragCoordZ );
-      gl_FragColor.a *= `.concat(_e.depthAlpha, `;
+      gl_FragColor.a *= `.concat(xe.depthAlpha, `;
     `)
-}), lt), pd = (Un = {}, Ue(Un, "".concat(_e.position), {
+}), ut), wd = (Nn = {}, Be(Nn, "".concat(xe.position), {
   "gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );": `
-    gl_Position = projectionMatrix * modelViewMatrix * vec4( `.concat(_e.position, `, 1.0 );
+    gl_Position = projectionMatrix * modelViewMatrix * vec4( `.concat(xe.position, `, 1.0 );
   `)
-}), Ue(Un, "".concat(_e.positionRaw), {
+}), Be(Nn, "".concat(xe.positionRaw), {
   "gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );": `
-    gl_Position = `.concat(_e.position, `;
+    gl_Position = `.concat(xe.position, `;
   `)
-}), Ue(Un, "".concat(_e.diffuseColor), {
+}), Be(Nn, "".concat(xe.diffuseColor), {
   "gl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );": `
-    gl_FragColor = `.concat(_e.diffuseColor, `;
+    gl_FragColor = `.concat(xe.diffuseColor, `;
   `)
-}), Ue(Un, "".concat(_e.fragColor), {
+}), Be(Nn, "".concat(xe.fragColor), {
   "gl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );": `
-    gl_FragColor = `.concat(_e.fragColor, `;
+    gl_FragColor = `.concat(xe.fragColor, `;
   `)
-}), Un), md = (
+}), Nn), Td = (
   /* glsl */
   `
 
@@ -13313,34 +13341,34 @@ var _e = {
     float csm_DepthAlpha = 1.0;
 #endif
 `
-), gd = (
+), bd = (
   /* glsl */
   `
     varying mat4 csm_internal_vModelViewMatrix;
 `
-), yd = (
+), Ed = (
   /* glsl */
   `
     csm_internal_vModelViewMatrix = modelViewMatrix;
 `
-), vd = (
+), Sd = (
   /* glsl */
   `
     varying mat4 csm_internal_vModelViewMatrix;
 `
-), _d = (
+), Md = (
   /* glsl */
   `
     
 `
-), ct, xd = (ct = {}, Ue(ct, "".concat(_e.position), "*"), Ue(ct, "".concat(_e.positionRaw), "*"), Ue(ct, "".concat(_e.normal), "*"), Ue(ct, "".concat(_e.pointSize), ["PointsMaterial"]), Ue(ct, "".concat(_e.diffuseColor), "*"), Ue(ct, "".concat(_e.fragColor), "*"), Ue(ct, "".concat(_e.emissive), ["MeshStandardMaterial", "MeshPhysicalMaterial"]), Ue(ct, "".concat(_e.roughness), ["MeshStandardMaterial", "MeshPhysicalMaterial"]), Ue(ct, "".concat(_e.metalness), ["MeshStandardMaterial", "MeshPhysicalMaterial"]), Ue(ct, "".concat(_e.ao), ["MeshStandardMaterial", "MeshPhysicalMaterial", "MeshBasicMaterial", "MeshLambertMaterial", "MeshPhongMaterial", "MeshToonMaterial"]), Ue(ct, "".concat(_e.bump), ["MeshLambertMaterial", "MeshMatcapMaterial", "MeshNormalMaterial", "MeshPhongMaterial", "MeshPhysicalMaterial", "MeshStandardMaterial", "MeshToonMaterial", "ShadowMaterial"]), Ue(ct, "".concat(_e.depthAlpha), "*"), ct), wd = ["baseMaterial", "fragmentShader", "vertexShader", "uniforms", "patchMap", "cacheKey", "silent"], Td = function(e, t, n) {
+), ht, Ad = (ht = {}, Be(ht, "".concat(xe.position), "*"), Be(ht, "".concat(xe.positionRaw), "*"), Be(ht, "".concat(xe.normal), "*"), Be(ht, "".concat(xe.pointSize), ["PointsMaterial"]), Be(ht, "".concat(xe.diffuseColor), "*"), Be(ht, "".concat(xe.fragColor), "*"), Be(ht, "".concat(xe.emissive), ["MeshStandardMaterial", "MeshPhysicalMaterial"]), Be(ht, "".concat(xe.roughness), ["MeshStandardMaterial", "MeshPhysicalMaterial"]), Be(ht, "".concat(xe.metalness), ["MeshStandardMaterial", "MeshPhysicalMaterial"]), Be(ht, "".concat(xe.ao), ["MeshStandardMaterial", "MeshPhysicalMaterial", "MeshBasicMaterial", "MeshLambertMaterial", "MeshPhongMaterial", "MeshToonMaterial"]), Be(ht, "".concat(xe.bump), ["MeshLambertMaterial", "MeshMatcapMaterial", "MeshNormalMaterial", "MeshPhongMaterial", "MeshPhysicalMaterial", "MeshStandardMaterial", "MeshToonMaterial", "ShadowMaterial"]), Be(ht, "".concat(xe.depthAlpha), "*"), ht), Pd = ["baseMaterial", "fragmentShader", "vertexShader", "uniforms", "patchMap", "cacheKey", "silent"], Cd = function(e, t, n) {
   return e.split(t).join(n);
-}, bd = function(e) {
+}, Rd = function(e) {
   return e.replace(/[-\/\\^$*+?.()|[\]{}]/g, "\\$&");
-}, Ed = function(e, t) {
-  return new RegExp("\\b".concat(bd(t), "\\b")).test(e);
+}, Id = function(e, t) {
+  return new RegExp("\\b".concat(Rd(t), "\\b")).test(e);
 };
-function Md(o) {
+function Dd(o) {
   try {
     new o();
   } catch (e) {
@@ -13349,7 +13377,7 @@ function Md(o) {
   }
   return !0;
 }
-function Sd(o, e) {
+function Od(o, e) {
   var t = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : !1;
   Object.assign(o, e);
   var n = Object.getPrototypeOf(e);
@@ -13366,45 +13394,45 @@ function Sd(o, e) {
     Object.defineProperty(o, s[0], s[1]);
   });
 }
-function Ad(o) {
+function Ld(o) {
   var e = o.toString().trim(), t = e.substring(e.indexOf("{") + 1, e.lastIndexOf("}"));
   return t.trim().length === 0;
 }
-function Ao(o) {
+function Oo(o) {
   return o.replace(/\s/g, "");
 }
-function Pd(o, e, t) {
+function Fd(o, e, t) {
   var n = o.lastIndexOf(e);
   return n === -1 ? o : o.substring(0, n) + t + o.substring(n + e.length);
 }
-var Rd = /* @__PURE__ */ function(o) {
-  cd(t, o);
-  var e = fd(t);
+var kd = /* @__PURE__ */ function(o) {
+  gd(t, o);
+  var e = _d(t);
   function t(n) {
-    var s, i = n.baseMaterial, r = n.fragmentShader, a = n.vertexShader, l = n.uniforms, c = n.patchMap, u = n.cacheKey, h = n.silent, m = od(n, wd);
-    ad(this, t);
-    var p;
-    if (Md(i) ? p = new i(m) : (p = i, Object.assign(p, m)), p.type === "RawShaderMaterial")
+    var s, i = n.baseMaterial, r = n.fragmentShader, a = n.vertexShader, l = n.uniforms, c = n.patchMap, u = n.cacheKey, h = n.silent, f = dd(n, Pd);
+    pd(this, t);
+    var d;
+    if (Dd(i) ? d = new i(f) : (d = i, Object.assign(d, f)), d.type === "RawShaderMaterial")
       throw new Error("CustomShaderMaterial does not support RawShaderMaterial");
-    s = e.call(this), Sd(Wa(s), p, h), s.__csm = {
+    s = e.call(this), Od(el(s), d, h), s.__csm = {
       patchMap: c || {},
       fragmentShader: r || "",
       vertexShader: a || "",
       cacheKey: u,
       baseMaterial: i,
-      instanceID: Ar.MathUtils.generateUUID(),
-      type: p.type,
-      isAlreadyExtended: !Ad(p.onBeforeCompile),
+      instanceID: Or.MathUtils.generateUUID(),
+      type: d.type,
+      isAlreadyExtended: !Ld(d.onBeforeCompile),
       cacheHash: "",
       silent: h
-    }, s.uniforms = kn(kn({}, s.uniforms || {}), l || {});
+    }, s.uniforms = Un(Un({}, s.uniforms || {}), l || {});
     {
-      var v = s.__csm, _ = v.fragmentShader, y = v.vertexShader, E = s.uniforms;
-      s.__csm.cacheHash = s.getCacheHash(), s.generateMaterial(_, y, E);
+      var y = s.__csm, x = y.fragmentShader, g = y.vertexShader, v = s.uniforms;
+      s.__csm.cacheHash = s.getCacheHash(), s.generateMaterial(x, g, v);
     }
     return s;
   }
-  return ld(t, [{
+  return md(t, [{
     key: "update",
     value: function() {
       var s = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
@@ -13448,10 +13476,10 @@ var Rd = /* @__PURE__ */ function(o) {
     key: "getCacheHash",
     value: function() {
       var s = this.__csm, i = s.fragmentShader, r = s.vertexShader, a = this.uniforms, l = Object.values(a).reduce(function(u, h) {
-        var m = h.value;
-        return u + JSON.stringify(m);
-      }, ""), c = Ao(i) + Ao(r) + l;
-      return c.trim().length > 0 ? Lf(c) : this.customProgramCacheKey();
+        var f = h.value;
+        return u + JSON.stringify(f);
+      }, ""), c = Oo(i) + Oo(r) + l;
+      return c.trim().length > 0 ? zf(c) : this.customProgramCacheKey();
     }
     /**
      * Does the internal shader generation. Not meant to be called directly.
@@ -13467,26 +13495,26 @@ var Rd = /* @__PURE__ */ function(o) {
       this.uniforms = r || {}, this.customProgramCacheKey = function() {
         return a.__csm.cacheHash;
       };
-      var u = function(p) {
+      var u = function(d) {
         try {
           if (l) {
-            var v = a.patchShader(l, p.fragmentShader, !0);
-            p.fragmentShader = a.getMaterialDefine() + v;
+            var y = a.patchShader(l, d.fragmentShader, !0);
+            d.fragmentShader = a.getMaterialDefine() + y;
           }
           if (c) {
-            var _ = a.patchShader(c, p.vertexShader);
-            p.vertexShader = `#define IS_VERTEX;
-` + _, p.vertexShader = a.getMaterialDefine() + p.vertexShader;
+            var x = a.patchShader(c, d.vertexShader);
+            d.vertexShader = `#define IS_VERTEX;
+` + x, d.vertexShader = a.getMaterialDefine() + d.vertexShader;
           }
-          p.uniforms = kn(kn({}, p.uniforms), a.uniforms), a.uniforms = p.uniforms;
-        } catch (y) {
-          console.error(y);
+          d.uniforms = Un(Un({}, d.uniforms), a.uniforms), a.uniforms = d.uniforms;
+        } catch (g) {
+          console.error(g);
         }
       };
       if (this.__csm.isAlreadyExtended) {
         var h = this.onBeforeCompile;
-        this.onBeforeCompile = function(m, p) {
-          h(m, p), u(m);
+        this.onBeforeCompile = function(f, d) {
+          h(f, d), u(f);
         };
       } else
         this.onBeforeCompile = u;
@@ -13502,19 +13530,19 @@ var Rd = /* @__PURE__ */ function(o) {
   }, {
     key: "patchShader",
     value: function(s, i, r) {
-      var a = this, l = i, c = kn(kn({}, this.getPatchMapForMaterial()), this.__csm.patchMap);
-      Object.keys(c).forEach(function(m) {
-        Object.keys(c[m]).forEach(function(p) {
-          var v = xd[m], _ = a.__csm.type;
-          if (m === "*" || Ed(s.main, m))
-            if (!v || Array.isArray(v) && v.includes(_) || v === "*")
-              l = Td(l, p, c[m][p]);
+      var a = this, l = i, c = Un(Un({}, this.getPatchMapForMaterial()), this.__csm.patchMap);
+      Object.keys(c).forEach(function(f) {
+        Object.keys(c[f]).forEach(function(d) {
+          var y = Ad[f], x = a.__csm.type;
+          if (f === "*" || Id(s.main, f))
+            if (!y || Array.isArray(y) && y.includes(x) || y === "*")
+              l = Cd(l, d, c[f][d]);
             else
-              throw new Error("CSM: ".concat(m, " is not available in ").concat(_, ". Shader cannot compile."));
+              throw new Error("CSM: ".concat(f, " is not available in ").concat(x, ". Shader cannot compile."));
         });
       }), l = l.replace("void main() {", `
         #ifndef CSM_IS_HEAD_DEFAULTS_DEFINED
-          `.concat(r ? vd : gd, `
+          `.concat(r ? Sd : bd, `
           #define CSM_IS_HEAD_DEFAULTS_DEFINED 1
         #endif
 
@@ -13522,19 +13550,19 @@ var Rd = /* @__PURE__ */ function(o) {
         
         void main() {
           #ifndef CSM_IS_DEFAULTS_DEFINED
-            `).concat(md, `
+            `).concat(Td, `
             #define CSM_IS_DEFAULTS_DEFINED 1
           #endif
           
           #ifndef CSM_IS_MAIN_DEFAULTS_DEFINED
-            `).concat(r ? _d : yd, `
+            `).concat(r ? Md : Ed, `
             #define CSM_IS_MAIN_DEFAULTS_DEFINED 1
           #endif
 
           // CSM_START
       `));
       var u = this.__csm.isAlreadyExtended, h = l.includes("// CSM_END");
-      return u && h ? l = Pd(l, "// CSM_END", `
+      return u && h ? l = Fd(l, "// CSM_END", `
           // CSM_END
           `.concat(s.main, `
           // CSM_END
@@ -13557,9 +13585,9 @@ var Rd = /* @__PURE__ */ function(o) {
     key: "parseShader",
     value: function(s) {
       if (s) {
-        var i = s.replace(/\/\*\*(.*?)\*\/|\/\/(.*?)\n/gm, ""), r = Qf(i), a = sd(r), l = a.map(function(h) {
+        var i = s.replace(/\/\*\*(.*?)\*\/|\/\/(.*?)\n/gm, ""), r = rd(i), a = ud(r), l = a.map(function(h) {
           return h.name;
-        }).indexOf("main"), c = Eo(r.slice(0, l >= 0 ? a[l].outer[0] : void 0)), u = l >= 0 ? this.getShaderFromIndex(r, a[l].body) : "";
+        }).indexOf("main"), c = Ro(r.slice(0, l >= 0 ? a[l].outer[0] : void 0)), u = l >= 0 ? this.getShaderFromIndex(r, a[l].body) : "";
         return {
           defines: "",
           header: c,
@@ -13588,9 +13616,9 @@ var Rd = /* @__PURE__ */ function(o) {
     value: function() {
       switch (this.__csm.type) {
         case "ShaderMaterial":
-          return pd;
+          return wd;
         default:
-          return dd;
+          return xd;
       }
     }
     /**
@@ -13602,11 +13630,11 @@ var Rd = /* @__PURE__ */ function(o) {
   }, {
     key: "getShaderFromIndex",
     value: function(s, i) {
-      return Eo(s.slice(i[0], i[1]));
+      return Ro(s.slice(i[0], i[1]));
     }
   }]), t;
-}(Ar.Material);
-const Cd = ["args"], ng = /* @__PURE__ */ pe({
+}(Or.Material);
+const Bd = ["args"], Tg = /* @__PURE__ */ pe({
   __name: "index",
   props: {
     baseMaterial: { type: Function },
@@ -13616,31 +13644,31 @@ const Cd = ["args"], ng = /* @__PURE__ */ pe({
     uniforms: {}
   },
   setup(o, { expose: e }) {
-    const t = o, n = xe(null), { extend: s } = je();
-    return s({ CustomShaderMaterial: Rd }), e({ value: n }), (i, r) => (fe(), de("TresCustomShaderMaterial", {
+    const t = o, n = me(null), { extend: s } = Ue();
+    return s({ CustomShaderMaterial: kd }), e({ value: n }), (i, r) => (le(), ce("TresCustomShaderMaterial", {
       ref_key: "customShaderMaterialClass",
       ref: n,
       args: [t]
-    }, null, 8, Cd));
+    }, null, 8, Bd));
   }
-}), Id = () => parseInt(rr.replace(/\D+/g, "")), Dd = /* @__PURE__ */ Id();
-class Ld extends Xt {
-  constructor(t = new le()) {
+}), Ud = () => parseInt(ur.replace(/\D+/g, "")), Nd = /* @__PURE__ */ Ud();
+class zd extends Pt {
+  constructor(t = new he()) {
     super({
       uniforms: {
-        inputBuffer: new Re(null),
-        depthBuffer: new Re(null),
-        resolution: new Re(new le()),
-        texelSize: new Re(new le()),
-        halfTexelSize: new Re(new le()),
-        kernel: new Re(0),
-        scale: new Re(1),
-        cameraNear: new Re(0),
-        cameraFar: new Re(1),
-        minDepthThreshold: new Re(0),
-        maxDepthThreshold: new Re(1),
-        depthScale: new Re(0),
-        depthToBlurRatioBias: new Re(0.25)
+        inputBuffer: new we(null),
+        depthBuffer: new we(null),
+        resolution: new we(new he()),
+        texelSize: new we(new he()),
+        halfTexelSize: new we(new he()),
+        kernel: new we(0),
+        scale: new we(1),
+        cameraNear: new we(0),
+        cameraFar: new we(1),
+        minDepthThreshold: new we(0),
+        maxDepthThreshold: new we(1),
+        depthScale: new we(0),
+        depthToBlurRatioBias: new we(0.25)
       },
       fragmentShader: `#include <common>
         #include <dithering_pars_fragment>      
@@ -13676,7 +13704,7 @@ class Ld extends Xt {
 
           #include <dithering_fragment>
           #include <tonemapping_fragment>
-          #include <${Dd >= 154 ? "colorspace_fragment" : "encodings_fragment"}>
+          #include <${Nd >= 154 ? "colorspace_fragment" : "encodings_fragment"}>
         }`,
       vertexShader: `uniform vec2 texelSize;
         uniform vec2 halfTexelSize;
@@ -13700,7 +13728,7 @@ class Ld extends Xt {
 
           gl_Position = vec4(position.xy, 1.0, 1.0);
         }`,
-      blending: Fl,
+      blending: Hl,
       depthWrite: !1,
       depthTest: !1
     });
@@ -13714,7 +13742,7 @@ class Ld extends Xt {
     this.uniforms.resolution.value.copy(t);
   }
 }
-class Od {
+class Hd {
   constructor({
     resolution: e,
     width: t = 500,
@@ -13731,27 +13759,27 @@ class Od {
     oe(this, "camera");
     oe(this, "screen");
     oe(this, "renderToScreen", !1);
-    this.renderTargetA = new bn(e, e, {
-      minFilter: At,
-      magFilter: At,
+    this.renderTargetA = new pn(e, e, {
+      minFilter: Ct,
+      magFilter: Ct,
       stencilBuffer: !1,
       depthBuffer: !1,
-      type: un
-    }), this.renderTargetB = this.renderTargetA.clone(), this.convolutionMaterial = new Ld(), this.convolutionMaterial.setTexelSize(1 / t, 1 / n), this.convolutionMaterial.setResolution(new le(t, n)), this.scene = new Xs(), this.camera = new kl(), this.convolutionMaterial.uniforms.minDepthThreshold.value = s, this.convolutionMaterial.uniforms.maxDepthThreshold.value = i, this.convolutionMaterial.uniforms.depthScale.value = r, this.convolutionMaterial.uniforms.depthToBlurRatioBias.value = a, this.convolutionMaterial.defines.USE_DEPTH = r > 0;
-    const l = new Float32Array([-1, -1, 0, 3, -1, 0, -1, 3, 0]), c = new Float32Array([0, 0, 2, 0, 0, 2]), u = new rt();
+      type: Zt
+    }), this.renderTargetB = this.renderTargetA.clone(), this.convolutionMaterial = new zd(), this.convolutionMaterial.setTexelSize(1 / t, 1 / n), this.convolutionMaterial.setResolution(new he(t, n)), this.scene = new fs(), this.camera = new jl(), this.convolutionMaterial.uniforms.minDepthThreshold.value = s, this.convolutionMaterial.uniforms.maxDepthThreshold.value = i, this.convolutionMaterial.uniforms.depthScale.value = r, this.convolutionMaterial.uniforms.depthToBlurRatioBias.value = a, this.convolutionMaterial.defines.USE_DEPTH = r > 0;
+    const l = new Float32Array([-1, -1, 0, 3, -1, 0, -1, 3, 0]), c = new Float32Array([0, 0, 2, 0, 0, 2]), u = new at();
     u.setAttribute("position", new pt(l, 3)), u.setAttribute("uv", new pt(c, 2)), this.screen = new ae(u, this.convolutionMaterial), this.screen.frustumCulled = !1, this.scene.add(this.screen);
   }
   render(e, t, n) {
     const s = this.scene, i = this.camera, r = this.renderTargetA, a = this.renderTargetB, l = this.convolutionMaterial, c = l.uniforms;
     c.depthBuffer.value = t.depthTexture;
     const u = l.kernel;
-    let h = t, m, p, v;
-    for (p = 0, v = u.length - 1; p < v; ++p)
-      m = p & 1 ? a : r, c.kernel.value = u[p], c.inputBuffer.value = h.texture, e.setRenderTarget(m), e.render(s, i), h = m;
-    c.kernel.value = u[p], c.inputBuffer.value = h.texture, e.setRenderTarget(this.renderToScreen ? null : n), e.render(s, i);
+    let h = t, f, d, y;
+    for (d = 0, y = u.length - 1; d < y; ++d)
+      f = d & 1 ? a : r, c.kernel.value = u[d], c.inputBuffer.value = h.texture, e.setRenderTarget(f), e.render(s, i), h = f;
+    c.kernel.value = u[d], c.inputBuffer.value = h.texture, e.setRenderTarget(this.renderToScreen ? null : n), e.render(s, i);
   }
 }
-class Fd extends us {
+class jd extends ys {
   constructor(t = {}) {
     super(t);
     oe(this, "_tDepth", { value: null });
@@ -13958,7 +13986,7 @@ class Fd extends us {
     this._mixContrast.value = t;
   }
 }
-const kd = ["texture-matrix", "mirror", "t-diffuse", "t-depth", "t-diffuse-blur", "has-blur", "mix-strength", "min-depth-threshold", "max-depth-threshold", "depth-scale", "depth-to-blur-ratio-bias", "distortion", "distortionMap", "mix-contrast", "defines-USE_BLUR", "defines-USE_DEPTH", "defines-USE_DISTORTION"], sg = /* @__PURE__ */ pe({
+const Gd = ["texture-matrix", "mirror", "t-diffuse", "t-depth", "t-diffuse-blur", "has-blur", "mix-strength", "min-depth-threshold", "max-depth-threshold", "depth-scale", "depth-to-blur-ratio-bias", "distortion", "distortionMap", "mix-contrast", "defines-USE_BLUR", "defines-USE_DEPTH", "defines-USE_DISTORTION"], bg = /* @__PURE__ */ pe({
   __name: "index",
   props: {
     resolution: { default: 256 },
@@ -13977,24 +14005,24 @@ const kd = ["texture-matrix", "mirror", "t-diffuse", "t-depth", "t-diffuse-blur"
   },
   setup(o) {
     const e = o;
-    function t(Z, W) {
+    function t(Y, W) {
       let X;
-      return Z.traverse((V) => {
+      return Y.traverse((V) => {
         V.isMesh && V.material && V.material.uuid === W && (X = V);
       }), X;
     }
-    function n(Z) {
+    function n(Y) {
       var X, V;
-      if (f.reflectorWorldPosition.setFromMatrixPosition(Z.matrixWorld), f.cameraWorldPosition.setFromMatrixPosition((X = y.value) == null ? void 0 : X.matrixWorld), f.rotationMatrix.extractRotation(Z.matrixWorld), f.normal.set(0, 0, 1), f.normal.applyMatrix4(f.rotationMatrix), f.reflectorWorldPosition.addScaledVector(f.normal, e.reflectorOffset), f.view.subVectors(f.reflectorWorldPosition, f.cameraWorldPosition), f.view.dot(f.normal) > 0)
+      if (p.reflectorWorldPosition.setFromMatrixPosition(Y.matrixWorld), p.cameraWorldPosition.setFromMatrixPosition((X = g.value) == null ? void 0 : X.matrixWorld), p.rotationMatrix.extractRotation(Y.matrixWorld), p.normal.set(0, 0, 1), p.normal.applyMatrix4(p.rotationMatrix), p.reflectorWorldPosition.addScaledVector(p.normal, e.reflectorOffset), p.view.subVectors(p.reflectorWorldPosition, p.cameraWorldPosition), p.view.dot(p.normal) > 0)
         return;
-      f.view.reflect(f.normal).negate(), f.view.add(f.reflectorWorldPosition), f.rotationMatrix.extractRotation((V = y.value) == null ? void 0 : V.matrixWorld), f.lookAtPosition.set(0, 0, -1), f.lookAtPosition.applyMatrix4(f.rotationMatrix), f.lookAtPosition.add(f.cameraWorldPosition), f.target.subVectors(f.reflectorWorldPosition, f.lookAtPosition), f.target.reflect(f.normal).negate(), f.target.add(f.reflectorWorldPosition), f.virtualCamera.position.copy(f.view), f.virtualCamera.up.set(0, 1, 0), f.virtualCamera.up.applyMatrix4(f.rotationMatrix), f.virtualCamera.up.reflect(f.normal), f.virtualCamera.lookAt(f.target), f.virtualCamera.far = (y == null ? void 0 : y.value).far, f.virtualCamera.updateMatrixWorld(), f.virtualCamera.projectionMatrix.copy((y == null ? void 0 : y.value).projectionMatrix), f.textureMatrix.set(0.5, 0, 0, 0.5, 0, 0.5, 0, 0.5, 0, 0, 0.5, 0.5, 0, 0, 0, 1), f.textureMatrix.multiply(f.virtualCamera.projectionMatrix), f.textureMatrix.multiply(f.virtualCamera.matrixWorldInverse), f.textureMatrix.multiply(Z.matrixWorld), f.reflectorPlane.setFromNormalAndCoplanarPoint(f.normal, f.reflectorWorldPosition), f.reflectorPlane.applyMatrix4(f.virtualCamera.matrixWorldInverse), f.clipPlane.set(
-        f.reflectorPlane.normal.x,
-        f.reflectorPlane.normal.y,
-        f.reflectorPlane.normal.z,
-        f.reflectorPlane.constant
+      p.view.reflect(p.normal).negate(), p.view.add(p.reflectorWorldPosition), p.rotationMatrix.extractRotation((V = g.value) == null ? void 0 : V.matrixWorld), p.lookAtPosition.set(0, 0, -1), p.lookAtPosition.applyMatrix4(p.rotationMatrix), p.lookAtPosition.add(p.cameraWorldPosition), p.target.subVectors(p.reflectorWorldPosition, p.lookAtPosition), p.target.reflect(p.normal).negate(), p.target.add(p.reflectorWorldPosition), p.virtualCamera.position.copy(p.view), p.virtualCamera.up.set(0, 1, 0), p.virtualCamera.up.applyMatrix4(p.rotationMatrix), p.virtualCamera.up.reflect(p.normal), p.virtualCamera.lookAt(p.target), p.virtualCamera.far = (g == null ? void 0 : g.value).far, p.virtualCamera.updateMatrixWorld(), p.virtualCamera.projectionMatrix.copy((g == null ? void 0 : g.value).projectionMatrix), p.textureMatrix.set(0.5, 0, 0, 0.5, 0, 0.5, 0, 0.5, 0, 0, 0.5, 0.5, 0, 0, 0, 1), p.textureMatrix.multiply(p.virtualCamera.projectionMatrix), p.textureMatrix.multiply(p.virtualCamera.matrixWorldInverse), p.textureMatrix.multiply(Y.matrixWorld), p.reflectorPlane.setFromNormalAndCoplanarPoint(p.normal, p.reflectorWorldPosition), p.reflectorPlane.applyMatrix4(p.virtualCamera.matrixWorldInverse), p.clipPlane.set(
+        p.reflectorPlane.normal.x,
+        p.reflectorPlane.normal.y,
+        p.reflectorPlane.normal.z,
+        p.reflectorPlane.constant
       );
-      const W = f.virtualCamera.projectionMatrix;
-      f.q.x = (Math.sign(f.clipPlane.x) + W.elements[8]) / W.elements[0], f.q.y = (Math.sign(f.clipPlane.y) + W.elements[9]) / W.elements[5], f.q.z = -1, f.q.w = (1 + W.elements[10]) / W.elements[14], f.clipPlane.multiplyScalar(2 / f.clipPlane.dot(f.q)), W.elements[2] = f.clipPlane.x, W.elements[6] = f.clipPlane.y, W.elements[10] = f.clipPlane.z + 1, W.elements[14] = f.clipPlane.w;
+      const W = p.virtualCamera.projectionMatrix;
+      p.q.x = (Math.sign(p.clipPlane.x) + W.elements[8]) / W.elements[0], p.q.y = (Math.sign(p.clipPlane.y) + W.elements[9]) / W.elements[5], p.q.z = -1, p.q.w = (1 + W.elements[10]) / W.elements[14], p.clipPlane.multiplyScalar(2 / p.clipPlane.dot(p.q)), W.elements[2] = p.clipPlane.x, W.elements[6] = p.clipPlane.y, W.elements[10] = p.clipPlane.z + 1, W.elements[14] = p.clipPlane.w;
     }
     const {
       resolution: s,
@@ -14005,148 +14033,398 @@ const kd = ["texture-matrix", "mirror", "t-diffuse", "t-depth", "t-diffuse-blur"
       blur: c,
       mirror: u,
       mixBlur: h,
-      mixStrength: m,
-      distortion: p,
-      distortionMap: v,
-      mixContrast: _
-    } = Fe(e), { camera: y, scene: E, renderer: R, extend: T } = je();
-    T({ MeshReflectorMaterial: Fd });
-    const g = xe(), A = xe(), x = xe(), M = xe(), d = Ne(() => typeof c.value == "number" ? [c.value, c.value] : c.value), w = Ne(() => d.value[0] > 0 || d.value[1] > 0), f = {
-      reflectorPlane: new lr(),
-      normal: new ee(),
-      reflectorWorldPosition: new ee(),
-      cameraWorldPosition: new ee(),
-      rotationMatrix: new De(),
-      lookAtPosition: new ee(0, 0, -1),
-      clipPlane: new ht(),
-      view: new ee(),
-      target: new ee(),
-      q: new ht(),
-      virtualCamera: new Mt(),
-      textureMatrix: new De()
+      mixStrength: f,
+      distortion: d,
+      distortionMap: y,
+      mixContrast: x
+    } = Oe(e), { camera: g, scene: v, renderer: M, extend: _ } = Ue();
+    _({ MeshReflectorMaterial: jd });
+    const w = me(), P = me(), T = me(), E = me(), m = Ne(() => typeof c.value == "number" ? [c.value, c.value] : c.value), b = Ne(() => m.value[0] > 0 || m.value[1] > 0), p = {
+      reflectorPlane: new ii(),
+      normal: new q(),
+      reflectorWorldPosition: new q(),
+      cameraWorldPosition: new q(),
+      rotationMatrix: new Pe(),
+      lookAtPosition: new q(0, 0, -1),
+      clipPlane: new rt(),
+      view: new q(),
+      target: new q(),
+      q: new rt(),
+      virtualCamera: new wt(),
+      textureMatrix: new Pe()
     };
-    ft(() => {
+    lt(() => {
       var W;
-      (W = g.value) == null || W.texture.dispose();
-      const Z = {
-        minFilter: At,
-        magFilter: At,
-        type: un
+      (W = w.value) == null || W.texture.dispose();
+      const Y = {
+        minFilter: Ct,
+        magFilter: Ct,
+        type: Zt
       };
-      g.value = new bn(
+      w.value = new pn(
         s.value,
         s.value,
         {
-          ...Z,
+          ...Y,
           depthBuffer: !0,
-          depthTexture: new sa(
+          depthTexture: new ca(
             s.value,
             s.value,
-            Ul,
-            Bl
+            Gl,
+            Vl
           )
         }
-      ), A.value = new bn(
+      ), P.value = new pn(
         s.value,
         s.value,
-        Z
-      ), x.value = new Od({
+        Y
+      ), T.value = new Hd({
         resolution: s.value,
-        width: d.value[0],
-        height: d.value[1],
+        width: m.value[0],
+        height: m.value[1],
         minDepthThreshold: i.value,
         maxDepthThreshold: r.value,
         depthScale: a.value,
         depthToBlurRatioBias: l.value
-      }), M.value = {
+      }), E.value = {
         mirror: u,
-        textureMatrix: f.textureMatrix,
+        textureMatrix: p.textureMatrix,
         mixBlur: h,
-        tDiffuse: g.value.texture,
-        tDepth: g.value.depthTexture,
-        tDiffuseBlur: g.value.texture,
-        hasBlur: w,
-        mixStrength: m,
+        tDiffuse: w.value.texture,
+        tDepth: w.value.depthTexture,
+        tDiffuseBlur: w.value.texture,
+        hasBlur: b,
+        mixStrength: f,
         minDepthThreshold: i,
         maxDepthThreshold: r,
         depthScale: a,
         depthToBlurRatioBias: l,
-        distortion: p,
-        distortionMap: v.value,
-        mixContrast: _,
-        "defines-USE_BLUR": w.value ? "" : void 0,
+        distortion: d,
+        distortionMap: y.value,
+        mixContrast: x,
+        "defines-USE_BLUR": b.value ? "" : void 0,
         "defines-USE_DEPTH": a.value > 0 ? "" : void 0,
-        "defines-USE_DISTORTION": v.value ? "" : void 0
+        "defines-USE_DISTORTION": y.value ? "" : void 0
       };
     });
-    const P = xe(), { onLoop: I } = Ke();
+    const C = me(), { onLoop: I } = Xe();
     I(() => {
       var V;
-      if (!P.value || !R.value || !g.value || !y.value)
+      if (!C.value || !M.value || !w.value || !g.value)
         return;
-      const Z = t(E.value, P.value.uuid);
-      if (!Z)
+      const Y = t(v.value, C.value.uuid);
+      if (!Y)
         return;
-      Z.visible = !1;
-      const W = R.value.xr.enabled, X = R.value.shadowMap.autoUpdate;
-      n(Z), R.value.shadowMap.autoUpdate = !1, R.value.setRenderTarget(g.value), R.value.autoClear || R.value.clear(), R.value.render(E.value, f.virtualCamera), (V = x == null ? void 0 : x.value) == null || V.render(R.value, g.value, A.value), R.value.xr.enabled = W, R.value.shadowMap.autoUpdate = X, Z.visible = !0, R.value.setRenderTarget(null);
+      Y.visible = !1;
+      const W = M.value.xr.enabled, X = M.value.shadowMap.autoUpdate;
+      n(Y), M.value.shadowMap.autoUpdate = !1, M.value.setRenderTarget(w.value), M.value.autoClear || M.value.clear(), M.value.render(v.value, p.virtualCamera), (V = T == null ? void 0 : T.value) == null || V.render(M.value, w.value, P.value), M.value.xr.enabled = W, M.value.shadowMap.autoUpdate = X, Y.visible = !0, M.value.setRenderTarget(null);
     });
-    const K = fa(), N = Ne(() => {
-      const Z = {};
-      return Object.assign(Z, e), Object.assign(Z, K.value), Z;
+    const K = ya(), z = Ne(() => {
+      const Y = {};
+      return Object.assign(Y, e), Object.assign(Y, K.value), Y;
     });
-    return aa(() => {
-      var Z, W;
-      (Z = g == null ? void 0 : g.value) == null || Z.dispose(), (W = A == null ? void 0 : A.value) == null || W.dispose();
-    }), (Z, W) => {
-      var X, V, ne;
-      return fe(), de("TresMeshReflectorMaterial", Ye({
-        key: `key${M.value["defines-USE_BLUR"]}${M.value["defines-USE_DEPTH"]}${M.value["defines-USE_DISTORTION"]}`,
+    return da(() => {
+      var Y, W;
+      (Y = w == null ? void 0 : w.value) == null || Y.dispose(), (W = P == null ? void 0 : P.value) == null || W.dispose();
+    }), (Y, W) => {
+      var X, V, te;
+      return le(), ce("TresMeshReflectorMaterial", Ye({
+        key: `key${E.value["defines-USE_BLUR"]}${E.value["defines-USE_DEPTH"]}${E.value["defines-USE_DISTORTION"]}`,
         ref_key: "materialRef",
-        ref: P
-      }, N.value, {
-        "texture-matrix": f.textureMatrix,
-        mirror: z(u),
-        "t-diffuse": (X = g.value) == null ? void 0 : X.texture,
-        "t-depth": (V = g.value) == null ? void 0 : V.depthTexture,
-        "t-diffuse-blur": (ne = A.value) == null ? void 0 : ne.texture,
-        "has-blur": w.value,
-        "mix-strength": z(m),
-        "min-depth-threshold": z(i),
-        "max-depth-threshold": z(r),
-        "depth-scale": z(a),
-        "depth-to-blur-ratio-bias": z(l),
-        distortion: z(p),
-        distortionMap: z(v),
-        "mix-contrast": z(_),
-        "defines-USE_BLUR": w.value ? "" : void 0,
-        "defines-USE_DEPTH": z(a) > 0 ? "" : void 0,
-        "defines-USE_DISTORTION": z(v) ? "" : void 0
-      }), null, 16, kd);
+        ref: C
+      }, z.value, {
+        "texture-matrix": p.textureMatrix,
+        mirror: B(u),
+        "t-diffuse": (X = w.value) == null ? void 0 : X.texture,
+        "t-depth": (V = w.value) == null ? void 0 : V.depthTexture,
+        "t-diffuse-blur": (te = P.value) == null ? void 0 : te.texture,
+        "has-blur": b.value,
+        "mix-strength": B(f),
+        "min-depth-threshold": B(i),
+        "max-depth-threshold": B(r),
+        "depth-scale": B(a),
+        "depth-to-blur-ratio-bias": B(l),
+        distortion: B(d),
+        distortionMap: B(y),
+        "mix-contrast": B(x),
+        "defines-USE_BLUR": b.value ? "" : void 0,
+        "defines-USE_DEPTH": B(a) > 0 ? "" : void 0,
+        "defines-USE_DISTORTION": B(y) ? "" : void 0
+      }), null, 16, Gd);
     };
   }
-}), Ud = ["args"], Bd = ["color"], ig = /* @__PURE__ */ pe({
+});
+class Vd extends Pt {
+  /**
+   * Create a HolographicMaterial.
+   *
+   * @param {Object} parameters - The parameters to configure the material.
+   * @param {number} [parameters.time=0.0] - The time uniform representing animation time.
+   * @param {number} [parameters.fresnelOpacity=1.0] - The opacity for the fresnel effect.
+   * @param {number} [parameters.fresnelAmount=1.0] - The strength of the fresnel effect.
+   * @param {number} [parameters.scanlineSize=15.0] - The size of the scanline effect.
+   * @param {number} [parameters.hologramBrightness=1.0] - The brightness of the hologram.
+   * @param {number} [parameters.signalSpeed=1.0] - The speed of the signal effect.
+   * @param {Color} [parameters.hologramColor=new Color('#00d5ff')] - The color of the hologram.
+   * @param {boolean} [parameters.enableBlinking=true] - Enable/disable blinking effect.
+   * @param {boolean} [parameters.blinkFresnelOnly=false] - Enable blinking only on the fresnel effect.
+   * @param {number} [parameters.hologramOpacity=1.0] - The opacity of the hologram.
+   * @param {number} [parameters.blendMode=NormalBlending] - The blending mode. Use `THREE.NormalBlending` or `THREE.AdditiveBlending`.
+   * @param {number} [parameters.side=FrontSide] - The rendering side. Use `THREE.FrontSide`,
+   *  `THREE.BackSide`, or `THREE.DoubleSide`.
+   * @param {Boolean} [parameters.depthTest=true] - Enable or disable depthTest.
+   */
+  constructor(e = {}) {
+    super(), this.vertexShader = `
+      #define STANDARD
+      varying vec3 vViewPosition;
+      #ifdef USE_TRANSMISSION
+      varying vec3 vWorldPosition;
+      #endif
+    
+      varying vec2 vUv;
+      varying vec4 vPos;
+      varying vec3 vNormalW;
+      varying vec3 vPositionW;
+
+      #include <common>
+      #include <uv_pars_vertex>
+      #include <envmap_pars_vertex>
+      #include <color_pars_vertex>
+      #include <fog_pars_vertex>
+      #include <morphtarget_pars_vertex>
+      #include <skinning_pars_vertex>
+      #include <logdepthbuf_pars_vertex>
+      #include <clipping_planes_pars_vertex>
+
+      void main() {
+        
+        #include <uv_vertex>
+        #include <color_vertex>
+        #include <morphcolor_vertex>
+      
+        #if defined ( USE_ENVMAP ) || defined ( USE_SKINNING )
+      
+          #include <beginnormal_vertex>
+          #include <morphnormal_vertex>
+          #include <skinbase_vertex>
+          #include <skinnormal_vertex>
+          #include <defaultnormal_vertex>
+      
+        #endif
+      
+        #include <begin_vertex>
+        #include <morphtarget_vertex>
+        #include <skinning_vertex>
+        #include <project_vertex>
+        #include <logdepthbuf_vertex>
+        #include <clipping_planes_vertex>
+      
+        #include <worldpos_vertex>
+        #include <envmap_vertex>
+        #include <fog_vertex>
+
+        mat4 modelViewProjectionMatrix = projectionMatrix * modelViewMatrix;
+
+        vUv = uv;
+        vPos = projectionMatrix * modelViewMatrix * vec4( transformed, 1.0 );
+        vPositionW = vec3( vec4( transformed, 1.0 ) * modelMatrix);
+        vNormalW = normalize( vec3( vec4( normal, 0.0 ) * modelMatrix ) );
+        
+        gl_Position = modelViewProjectionMatrix * vec4( transformed, 1.0 );
+
+      }`, this.fragmentShader = ` 
+      varying vec2 vUv;
+      varying vec3 vPositionW;
+      varying vec4 vPos;
+      varying vec3 vNormalW;
+      
+      uniform float time;
+      uniform float fresnelOpacity;
+      uniform float scanlineSize;
+      uniform float fresnelAmount;
+      uniform float signalSpeed;
+      uniform float hologramBrightness;
+      uniform float hologramOpacity;
+      uniform bool blinkFresnelOnly;
+      uniform bool enableBlinking;
+      uniform vec3 hologramColor;
+
+      float flicker( float amt, float time ) {return clamp( fract( cos( time ) * 43758.5453123 ), amt, 1.0 );}
+      float random(in float a, in float b) { return fract((cos(dot(vec2(a,b) ,vec2(12.9898,78.233))) * 43758.5453)); }
+
+      void main() {
+        vec2 vCoords = vPos.xy;
+        vCoords /= vPos.w;
+        vCoords = vCoords * 0.5 + 0.5;
+        vec2 myUV = fract( vCoords );
+
+        // Defines hologram main color
+        vec4 hologramColor = vec4(hologramColor, mix(hologramBrightness, vUv.y, 0.5));
+
+        // Add scanlines
+        float scanlines = 10.;
+        scanlines += 20. * sin(time *signalSpeed * 20.8 - myUV.y * 60. * scanlineSize);
+        scanlines *= smoothstep(1.3 * cos(time *signalSpeed + myUV.y * scanlineSize), 0.78, 0.9);
+        scanlines *= max(0.25, sin(time *signalSpeed) * 1.0);
+
+        // Scanlines offsets
+        float r = random(vUv.x, vUv.y);
+        float g = random(vUv.y * 20.2, 	vUv.y * .2);
+        float b = random(vUv.y * .9, 	vUv.y * .2);
+
+        // Scanline composition
+        hologramColor += vec4(r*scanlines, b*scanlines, r, 1.0) / 84.;
+        vec4 scanlineMix = mix(vec4(0.0), hologramColor, hologramColor.a);
+
+        // Calculates fresnel
+        vec3 viewDirectionW = normalize(cameraPosition - vPositionW);
+        float fresnelEffect = dot(viewDirectionW, vNormalW) * (1.6 - fresnelOpacity/2.);
+        fresnelEffect = clamp(fresnelAmount - fresnelEffect, 0., fresnelOpacity);
+
+        // Blinkin effect
+        //Suggested by Octano - https://x.com/OtanoDesign?s=20
+        float blinkValue = enableBlinking ? 0.6 - signalSpeed : 1.0;
+        float blink = flicker(blinkValue, time * signalSpeed * .02);
+
+        // Final shader composition
+        vec3 finalColor;
+
+        if(blinkFresnelOnly){
+          finalColor = scanlineMix.rgb + fresnelEffect * blink;
+        }else{
+          finalColor = scanlineMix.rgb * blink + fresnelEffect;
+        }
+
+        gl_FragColor = vec4( finalColor, hologramOpacity);
+
+      }`, this.uniforms = {
+      /**
+         * The time uniform representing animation time.
+         * @type {Uniform<number>}
+         * @default 0.0
+         */
+      time: new we(0),
+      /**
+         * The opacity for the fresnel effect.
+         * @type {Uniform<number>}
+         * @default 1.0
+         */
+      fresnelOpacity: new we(e.fresnelOpacity !== void 0 ? e.fresnelOpacity : 1),
+      /**
+         * The strength of the fresnel effect.
+         * @type {Uniform<number>}
+         * @default 1.0
+         */
+      fresnelAmount: new we(e.fresnelAmount !== void 0 ? e.fresnelAmount : 0.45),
+      /**
+         * The size of the scanline effect.
+         * @type {Uniform<number>}
+         * @default 1.0
+         */
+      scanlineSize: new we(e.scanlineSize !== void 0 ? e.scanlineSize : 8),
+      /**
+         * The brightness of the hologram.
+         * @type {Uniform<number>}
+         * @default 1.0
+         */
+      hologramBrightness: new we(e.hologramBrightness !== void 0 ? e.hologramBrightness : 1),
+      /**
+         * The speed of the signal effect.
+         * @type {Uniform<number>}
+         * @default 1.0
+         */
+      signalSpeed: new we(e.signalSpeed !== void 0 ? e.signalSpeed : 1),
+      /**
+         * The color of the hologram.
+         * @type {Uniform<Color>}
+         * @default new Color(0xFFFFFF)
+         */
+      hologramColor: new we(e.hologramColor !== void 0 ? new Re(e.hologramColor) : new Re("#00d5ff")),
+      /**
+         * Enable/disable blinking effect.
+         * @type {Uniform<boolean>}
+         * @default true
+         */
+      enableBlinking: new we(e.enableBlinking !== void 0 ? e.enableBlinking : !0),
+      /**
+         * Enable blinking only on the fresnel effect.
+         * @type {Uniform<boolean>}
+         * @default false
+         */
+      blinkFresnelOnly: new we(e.blinkFresnelOnly !== void 0 ? e.blinkFresnelOnly : !0),
+      /**
+         * The opacity of the hologram.
+         * @type {Uniform<number>}
+         * @default 1.0
+         */
+      hologramOpacity: new we(e.hologramOpacity !== void 0 ? e.hologramOpacity : 1)
+    }, this.clock = new Wl(), this.setValues(e), this.depthTest = e.depthTest !== void 0 ? e.depthTest : !1, this.blending = e.blendMode !== void 0 ? e.blendMode : mr, this.transparent = !0, this.side = e.side !== void 0 ? e.side : _s;
+  }
+  update() {
+    this.uniforms.time.value = this.clock.getElapsedTime();
+  }
+}
+const Lo = Vd, Wd = ["uniforms-fresnelAmount-value", "uniforms-enableBlinking-value", "uniforms-fresnelOpacity-value", "uniforms-hologramBrightness-value", "uniforms-scanlineSize-value", "uniforms-signalSpeed-value", "uniforms-hologramColor-value", "uniforms-hologramOpacity-value", "uniforms-blinkFresnelOnly-value", "enableAdditive", "side"], Eg = /* @__PURE__ */ pe({
+  __name: "index",
+  props: {
+    fresnelAmount: { default: 0.45 },
+    fresnelOpacity: { default: 1 },
+    blinkFresnelOnly: { type: Boolean, default: !0 },
+    enableBlinking: { type: Boolean, default: !0 },
+    enableAdditive: { type: Boolean, default: !0 },
+    hologramBrightness: { default: 0.7 },
+    scanlineSize: { default: 8 },
+    signalSpeed: { default: 0.45 },
+    hologramOpacity: { default: 1 },
+    hologramColor: { default: "#00d5ff" },
+    side: { default: _s }
+  },
+  setup(o, { expose: e }) {
+    const t = o, n = me(), { extend: s } = Ue();
+    s({ HolographicMaterial: Lo }), e({ root: n, constructor: Lo });
+    const { onLoop: i } = Xe();
+    return i(() => {
+      var r;
+      (r = n.value) == null || r.update();
+    }), (r, a) => (le(), ce("TresHolographicMaterial", {
+      ref_key: "MeshHolographicMaterialClass",
+      ref: n,
+      "uniforms-fresnelAmount-value": t.fresnelAmount,
+      "uniforms-enableBlinking-value": t.enableBlinking,
+      "uniforms-fresnelOpacity-value": t.fresnelOpacity,
+      "uniforms-hologramBrightness-value": t.hologramBrightness,
+      "uniforms-scanlineSize-value": t.scanlineSize,
+      "uniforms-signalSpeed-value": t.signalSpeed,
+      "uniforms-hologramColor-value": t.hologramColor,
+      "uniforms-hologramOpacity-value": t.hologramOpacity,
+      "uniforms-blinkFresnelOnly-value": t.blinkFresnelOnly,
+      enableAdditive: t.enableAdditive,
+      side: t.side
+    }, null, 8, Wd));
+  }
+}), Yd = ["args"], Xd = ["color"], Sg = /* @__PURE__ */ pe({
   __name: "Box",
   props: {
     args: { default: () => [1, 1, 1] },
     color: { default: "#ffffff" }
   },
   setup(o, { expose: e }) {
-    const t = o, { args: n, color: s } = Fe(t), i = xe();
+    const t = o, { args: n, color: s } = Oe(t), i = me();
     return e({
       value: i
-    }), (r, a) => (fe(), de("TresMesh", Ye({
+    }), (r, a) => (le(), ce("TresMesh", Ye({
       ref_key: "boxRef",
       ref: i
     }, r.$attrs), [
-      Te("TresBoxGeometry", { args: z(n) }, null, 8, Ud),
-      $e(r.$slots, "default", {}, () => [
-        Te("TresMeshBasicMaterial", { color: z(s) }, null, 8, Bd)
+      ye("TresBoxGeometry", { args: B(n) }, null, 8, Yd),
+      Ve(r.$slots, "default", {}, () => [
+        ye("TresMeshBasicMaterial", { color: B(s) }, null, 8, Xd)
       ])
     ], 16));
   }
-}), Po = new hs(), Bs = new ee();
-class $a extends Nl {
+}), Fo = new xs(), Ws = new q();
+class tl extends Yl {
   constructor() {
     super(), this.isLineSegmentsGeometry = !0, this.type = "LineSegmentsGeometry";
     const e = [-1, 2, 0, 1, 2, 0, -1, 1, 0, 1, 1, 0, -1, 0, 0, 1, 0, 0, -1, -1, 0, 1, -1, 0], t = [-1, 2, 1, 2, -1, 1, 1, 1, -1, -1, 1, -1, -1, -2, 1, -2], n = [0, 2, 1, 2, 3, 1, 2, 4, 3, 4, 5, 3, 4, 6, 5, 6, 7, 5];
@@ -14159,14 +14437,14 @@ class $a extends Nl {
   setPositions(e) {
     let t;
     e instanceof Float32Array ? t = e : Array.isArray(e) && (t = new Float32Array(e));
-    const n = new Yi(t, 6, 1);
-    return this.setAttribute("instanceStart", new Vt(n, 3, 0)), this.setAttribute("instanceEnd", new Vt(n, 3, 3)), this.computeBoundingBox(), this.computeBoundingSphere(), this;
+    const n = new Qi(t, 6, 1);
+    return this.setAttribute("instanceStart", new $t(n, 3, 0)), this.setAttribute("instanceEnd", new $t(n, 3, 3)), this.computeBoundingBox(), this.computeBoundingSphere(), this;
   }
   setColors(e) {
     let t;
     e instanceof Float32Array ? t = e : Array.isArray(e) && (t = new Float32Array(e));
-    const n = new Yi(t, 6, 1);
-    return this.setAttribute("instanceColorStart", new Vt(n, 3, 0)), this.setAttribute("instanceColorEnd", new Vt(n, 3, 3)), this;
+    const n = new Qi(t, 6, 1);
+    return this.setAttribute("instanceColorStart", new $t(n, 3, 0)), this.setAttribute("instanceColorEnd", new $t(n, 3, 3)), this;
   }
   fromWireframeGeometry(e) {
     return this.setPositions(e.attributes.position.array), this;
@@ -14175,26 +14453,26 @@ class $a extends Nl {
     return this.setPositions(e.attributes.position.array), this;
   }
   fromMesh(e) {
-    return this.fromWireframeGeometry(new zl(e.geometry)), this;
+    return this.fromWireframeGeometry(new Xl(e.geometry)), this;
   }
   fromLineSegments(e) {
     const t = e.geometry;
     return this.setPositions(t.attributes.position.array), this;
   }
   computeBoundingBox() {
-    this.boundingBox === null && (this.boundingBox = new hs());
+    this.boundingBox === null && (this.boundingBox = new xs());
     const e = this.attributes.instanceStart, t = this.attributes.instanceEnd;
-    e !== void 0 && t !== void 0 && (this.boundingBox.setFromBufferAttribute(e), Po.setFromBufferAttribute(t), this.boundingBox.union(Po));
+    e !== void 0 && t !== void 0 && (this.boundingBox.setFromBufferAttribute(e), Fo.setFromBufferAttribute(t), this.boundingBox.union(Fo));
   }
   computeBoundingSphere() {
-    this.boundingSphere === null && (this.boundingSphere = new Qs()), this.boundingBox === null && this.computeBoundingBox();
+    this.boundingSphere === null && (this.boundingSphere = new ri()), this.boundingBox === null && this.computeBoundingBox();
     const e = this.attributes.instanceStart, t = this.attributes.instanceEnd;
     if (e !== void 0 && t !== void 0) {
       const n = this.boundingSphere.center;
       this.boundingBox.getCenter(n);
       let s = 0;
       for (let i = 0, r = e.count; i < r; i++)
-        Bs.fromBufferAttribute(e, i), s = Math.max(s, n.distanceToSquared(Bs)), Bs.fromBufferAttribute(t, i), s = Math.max(s, n.distanceToSquared(Bs));
+        Ws.fromBufferAttribute(e, i), s = Math.max(s, n.distanceToSquared(Ws)), Ws.fromBufferAttribute(t, i), s = Math.max(s, n.distanceToSquared(Ws));
       this.boundingSphere.radius = Math.sqrt(s), isNaN(this.boundingSphere.radius) && console.error("THREE.LineSegmentsGeometry.computeBoundingSphere(): Computed radius is NaN. The instanced position data is likely to have NaN values.", this);
     }
   }
@@ -14204,21 +14482,21 @@ class $a extends Nl {
     return console.warn("THREE.LineSegmentsGeometry: applyMatrix() has been renamed to applyMatrix4()."), this.applyMatrix4(e);
   }
 }
-js.line = {
+jn.line = {
   worldUnits: { value: 1 },
   linewidth: { value: 1 },
-  resolution: { value: new le(1, 1) },
+  resolution: { value: new he(1, 1) },
   dashOffset: { value: 0 },
   dashScale: { value: 1 },
   dashSize: { value: 1 },
   gapSize: { value: 1 }
   // todo FIX - maybe change to totalSize
 };
-Vs.line = {
-  uniforms: Js.merge([
-    js.common,
-    js.fog,
-    js.line
+Ks.line = {
+  uniforms: Yn.merge([
+    jn.common,
+    jn.fog,
+    jn.line
   ]),
   vertexShader: (
     /* glsl */
@@ -14599,13 +14877,13 @@ Vs.line = {
 		`
   )
 };
-class _r extends Xt {
+class Sr extends Pt {
   constructor(e) {
     super({
       type: "LineMaterial",
-      uniforms: Js.clone(Vs.line.uniforms),
-      vertexShader: Vs.line.vertexShader,
-      fragmentShader: Vs.line.fragmentShader,
+      uniforms: Yn.clone(Ks.line.uniforms),
+      vertexShader: Ks.line.vertexShader,
+      fragmentShader: Ks.line.fragmentShader,
       clipping: !0
       // required for clipping support
     }), this.isLineMaterial = !0, this.setValues(e);
@@ -14677,20 +14955,20 @@ class _r extends Xt {
     this.defines && (e === !0 !== this.alphaToCoverage && (this.needsUpdate = !0), e === !0 ? (this.defines.USE_ALPHA_TO_COVERAGE = "", this.extensions.derivatives = !0) : (delete this.defines.USE_ALPHA_TO_COVERAGE, this.extensions.derivatives = !1));
   }
 }
-const Ro = new ee(), Co = new ee(), et = new ht(), tt = new ht(), Ct = new ht(), Fi = new ee(), ki = new De(), nt = new Hl(), Io = new ee(), Ns = new hs(), zs = new Qs(), It = new ht();
-let Ot, xn;
-function Do(o, e, t) {
-  return It.set(0, 0, -e, 1).applyMatrix4(o.projectionMatrix), It.multiplyScalar(1 / It.w), It.x = xn / t.width, It.y = xn / t.height, It.applyMatrix4(o.projectionMatrixInverse), It.multiplyScalar(1 / It.w), Math.abs(Math.max(It.x, It.y));
+const ko = new q(), Bo = new q(), et = new rt(), tt = new rt(), Dt = new rt(), ji = new q(), Gi = new Pe(), nt = new $l(), Uo = new q(), Ys = new xs(), Xs = new ri(), Ot = new rt();
+let kt, bn;
+function No(o, e, t) {
+  return Ot.set(0, 0, -e, 1).applyMatrix4(o.projectionMatrix), Ot.multiplyScalar(1 / Ot.w), Ot.x = bn / t.width, Ot.y = bn / t.height, Ot.applyMatrix4(o.projectionMatrixInverse), Ot.multiplyScalar(1 / Ot.w), Math.abs(Math.max(Ot.x, Ot.y));
 }
-function Nd(o, e) {
+function $d(o, e) {
   const t = o.matrixWorld, n = o.geometry, s = n.attributes.instanceStart, i = n.attributes.instanceEnd, r = Math.min(n.instanceCount, s.count);
   for (let a = 0, l = r; a < l; a++) {
     nt.start.fromBufferAttribute(s, a), nt.end.fromBufferAttribute(i, a), nt.applyMatrix4(t);
-    const c = new ee(), u = new ee();
-    Ot.distanceSqToSegment(nt.start, nt.end, u, c), u.distanceTo(c) < xn * 0.5 && e.push({
+    const c = new q(), u = new q();
+    kt.distanceSqToSegment(nt.start, nt.end, u, c), u.distanceTo(c) < bn * 0.5 && e.push({
       point: u,
       pointOnLine: c,
-      distance: Ot.origin.distanceTo(u),
+      distance: kt.origin.distanceTo(u),
       object: o,
       face: null,
       faceIndex: a,
@@ -14699,79 +14977,79 @@ function Nd(o, e) {
     });
   }
 }
-function zd(o, e, t) {
+function Zd(o, e, t) {
   const n = e.projectionMatrix, i = o.material.resolution, r = o.matrixWorld, a = o.geometry, l = a.attributes.instanceStart, c = a.attributes.instanceEnd, u = Math.min(a.instanceCount, l.count), h = -e.near;
-  Ot.at(1, Ct), Ct.w = 1, Ct.applyMatrix4(e.matrixWorldInverse), Ct.applyMatrix4(n), Ct.multiplyScalar(1 / Ct.w), Ct.x *= i.x / 2, Ct.y *= i.y / 2, Ct.z = 0, Fi.copy(Ct), ki.multiplyMatrices(e.matrixWorldInverse, r);
-  for (let m = 0, p = u; m < p; m++) {
-    if (et.fromBufferAttribute(l, m), tt.fromBufferAttribute(c, m), et.w = 1, tt.w = 1, et.applyMatrix4(ki), tt.applyMatrix4(ki), et.z > h && tt.z > h)
+  kt.at(1, Dt), Dt.w = 1, Dt.applyMatrix4(e.matrixWorldInverse), Dt.applyMatrix4(n), Dt.multiplyScalar(1 / Dt.w), Dt.x *= i.x / 2, Dt.y *= i.y / 2, Dt.z = 0, ji.copy(Dt), Gi.multiplyMatrices(e.matrixWorldInverse, r);
+  for (let f = 0, d = u; f < d; f++) {
+    if (et.fromBufferAttribute(l, f), tt.fromBufferAttribute(c, f), et.w = 1, tt.w = 1, et.applyMatrix4(Gi), tt.applyMatrix4(Gi), et.z > h && tt.z > h)
       continue;
     if (et.z > h) {
-      const T = et.z - tt.z, g = (et.z - h) / T;
-      et.lerp(tt, g);
+      const _ = et.z - tt.z, w = (et.z - h) / _;
+      et.lerp(tt, w);
     } else if (tt.z > h) {
-      const T = tt.z - et.z, g = (tt.z - h) / T;
-      tt.lerp(et, g);
+      const _ = tt.z - et.z, w = (tt.z - h) / _;
+      tt.lerp(et, w);
     }
     et.applyMatrix4(n), tt.applyMatrix4(n), et.multiplyScalar(1 / et.w), tt.multiplyScalar(1 / tt.w), et.x *= i.x / 2, et.y *= i.y / 2, tt.x *= i.x / 2, tt.y *= i.y / 2, nt.start.copy(et), nt.start.z = 0, nt.end.copy(tt), nt.end.z = 0;
-    const _ = nt.closestPointToPointParameter(Fi, !0);
-    nt.at(_, Io);
-    const y = We.lerp(et.z, tt.z, _), E = y >= -1 && y <= 1, R = Fi.distanceTo(Io) < xn * 0.5;
-    if (E && R) {
-      nt.start.fromBufferAttribute(l, m), nt.end.fromBufferAttribute(c, m), nt.start.applyMatrix4(r), nt.end.applyMatrix4(r);
-      const T = new ee(), g = new ee();
-      Ot.distanceSqToSegment(nt.start, nt.end, g, T), t.push({
-        point: g,
-        pointOnLine: T,
-        distance: Ot.origin.distanceTo(g),
+    const x = nt.closestPointToPointParameter(ji, !0);
+    nt.at(x, Uo);
+    const g = Ze.lerp(et.z, tt.z, x), v = g >= -1 && g <= 1, M = ji.distanceTo(Uo) < bn * 0.5;
+    if (v && M) {
+      nt.start.fromBufferAttribute(l, f), nt.end.fromBufferAttribute(c, f), nt.start.applyMatrix4(r), nt.end.applyMatrix4(r);
+      const _ = new q(), w = new q();
+      kt.distanceSqToSegment(nt.start, nt.end, w, _), t.push({
+        point: w,
+        pointOnLine: _,
+        distance: kt.origin.distanceTo(w),
         object: o,
         face: null,
-        faceIndex: m,
+        faceIndex: f,
         uv: null,
         uv1: null
       });
     }
   }
 }
-class Hd extends ae {
-  constructor(e = new $a(), t = new _r({ color: Math.random() * 16777215 })) {
+class Kd extends ae {
+  constructor(e = new tl(), t = new Sr({ color: Math.random() * 16777215 })) {
     super(e, t), this.isLineSegments2 = !0, this.type = "LineSegments2";
   }
   // for backwards-compatibility, but could be a method of LineSegmentsGeometry...
   computeLineDistances() {
     const e = this.geometry, t = e.attributes.instanceStart, n = e.attributes.instanceEnd, s = new Float32Array(2 * t.count);
     for (let r = 0, a = 0, l = t.count; r < l; r++, a += 2)
-      Ro.fromBufferAttribute(t, r), Co.fromBufferAttribute(n, r), s[a] = a === 0 ? 0 : s[a - 1], s[a + 1] = s[a] + Ro.distanceTo(Co);
-    const i = new Yi(s, 2, 1);
-    return e.setAttribute("instanceDistanceStart", new Vt(i, 1, 0)), e.setAttribute("instanceDistanceEnd", new Vt(i, 1, 1)), this;
+      ko.fromBufferAttribute(t, r), Bo.fromBufferAttribute(n, r), s[a] = a === 0 ? 0 : s[a - 1], s[a + 1] = s[a] + ko.distanceTo(Bo);
+    const i = new Qi(s, 2, 1);
+    return e.setAttribute("instanceDistanceStart", new $t(i, 1, 0)), e.setAttribute("instanceDistanceEnd", new $t(i, 1, 1)), this;
   }
   raycast(e, t) {
     const n = this.material.worldUnits, s = e.camera;
     s === null && !n && console.error('LineSegments2: "Raycaster.camera" needs to be set in order to raycast against LineSegments2 while worldUnits is set to false.');
     const i = e.params.Line2 !== void 0 && e.params.Line2.threshold || 0;
-    Ot = e.ray;
+    kt = e.ray;
     const r = this.matrixWorld, a = this.geometry, l = this.material;
-    xn = l.linewidth + i, a.boundingSphere === null && a.computeBoundingSphere(), zs.copy(a.boundingSphere).applyMatrix4(r);
+    bn = l.linewidth + i, a.boundingSphere === null && a.computeBoundingSphere(), Xs.copy(a.boundingSphere).applyMatrix4(r);
     let c;
     if (n)
-      c = xn * 0.5;
+      c = bn * 0.5;
     else {
-      const h = Math.max(s.near, zs.distanceToPoint(Ot.origin));
-      c = Do(s, h, l.resolution);
+      const h = Math.max(s.near, Xs.distanceToPoint(kt.origin));
+      c = No(s, h, l.resolution);
     }
-    if (zs.radius += c, Ot.intersectsSphere(zs) === !1)
+    if (Xs.radius += c, kt.intersectsSphere(Xs) === !1)
       return;
-    a.boundingBox === null && a.computeBoundingBox(), Ns.copy(a.boundingBox).applyMatrix4(r);
+    a.boundingBox === null && a.computeBoundingBox(), Ys.copy(a.boundingBox).applyMatrix4(r);
     let u;
     if (n)
-      u = xn * 0.5;
+      u = bn * 0.5;
     else {
-      const h = Math.max(s.near, Ns.distanceToPoint(Ot.origin));
-      u = Do(s, h, l.resolution);
+      const h = Math.max(s.near, Ys.distanceToPoint(kt.origin));
+      u = No(s, h, l.resolution);
     }
-    Ns.expandByScalar(u), Ot.intersectsBox(Ns) !== !1 && (n ? Nd(this, t) : zd(this, s, t));
+    Ys.expandByScalar(u), kt.intersectsBox(Ys) !== !1 && (n ? $d(this, t) : Zd(this, s, t));
   }
 }
-class Za extends $a {
+class nl extends tl {
   constructor() {
     super(), this.isLineGeometry = !0, this.type = "LineGeometry";
   }
@@ -14792,12 +15070,12 @@ class Za extends $a {
     return this.setPositions(t.attributes.position.array), this;
   }
 }
-class Gd extends Hd {
-  constructor(e = new Za(), t = new _r({ color: Math.random() * 16777215 })) {
+class qd extends Kd {
+  constructor(e = new nl(), t = new Sr({ color: Math.random() * 16777215 })) {
     super(e, t), this.isLine2 = !0, this.type = "Line2";
   }
 }
-const jd = ["object"], Vd = /* @__PURE__ */ pe({
+const Qd = ["object"], Jd = /* @__PURE__ */ pe({
   __name: "Line2",
   props: {
     points: {},
@@ -14816,31 +15094,31 @@ const jd = ["object"], Vd = /* @__PURE__ */ pe({
     const e = o;
     function t(u, h) {
       if (!u || u.length === 0)
-        return new Array(h).fill(ln(e.color));
+        return new Array(h).fill(un(e.color));
       if (u.length === 1)
-        return new Array(h).fill(ln(u[0]));
+        return new Array(h).fill(un(u[0]));
       if (u.length === h)
-        return u.map(ln);
-      const m = h - 1, p = u.map(ln);
-      closed && p.push(p[0].clone());
-      const v = [p[0]], _ = m / (p.length - 1);
-      for (let y = 1; y < m; y++) {
-        const E = y % _ / _, R = Math.floor(y / _);
-        v.push(p[R].clone().lerp(p[R + 1], E));
+        return u.map(un);
+      const f = h - 1, d = u.map(un);
+      closed && d.push(d[0].clone());
+      const y = [d[0]], x = f / (d.length - 1);
+      for (let g = 1; g < f; g++) {
+        const v = g % x / x, M = Math.floor(g / x);
+        y.push(d[M].clone().lerp(d[M + 1], v));
       }
-      return v.push(p[p.length - 1]), v;
+      return y.push(d[d.length - 1]), y;
     }
-    function n(u, h, m) {
-      const p = h.map((_) => _ instanceof ee ? [_.x, _.y, _.z] : _ instanceof le ? [_.x, _.y, 0] : Array.isArray(_) && _.length === 2 ? [_[0], _[1], 0] : _).flat();
-      u.setPositions(p.flat());
-      const v = t(m, h.length).map((_) => _.toArray()).flat();
-      u.setColors(v), a.computeLineDistances();
+    function n(u, h, f) {
+      const d = h.map((x) => x instanceof q ? [x.x, x.y, x.z] : x instanceof he ? [x.x, x.y, 0] : Array.isArray(x) && x.length === 2 ? [x[0], x[1], 0] : x).flat();
+      u.setPositions(d.flat());
+      const y = t(f, h.length).map((x) => x.toArray()).flat();
+      u.setColors(y), a.computeLineDistances();
     }
     function s(u, h) {
-      u.color = ln(h.color), u.linewidth = h.lineWidth, u.alphaToCoverage = h.alphaToCoverage, u.worldUnits = h.worldUnits, u.vertexColors = Array.isArray(h.vertexColors), u.dashed = h.dashed, u.dashScale = h.dashScale, u.dashSize = h.dashSize, u.dashOffset = h.dashOffset, u.gapSize = h.gapSize, u.needsUpdate = !0;
+      u.color = un(h.color), u.linewidth = h.lineWidth, u.alphaToCoverage = h.alphaToCoverage, u.worldUnits = h.worldUnits, u.vertexColors = Array.isArray(h.vertexColors), u.dashed = h.dashed, u.dashScale = h.dashScale, u.dashSize = h.dashSize, u.dashOffset = h.dashOffset, u.gapSize = h.gapSize, u.needsUpdate = !0;
     }
-    const i = new _r(), r = new Za(), a = new Gd(r, i), l = je().sizes, c = Ne(() => Array.isArray(e.vertexColors));
-    return s(i, e), n(r, e.points, e.vertexColors), a.computeLineDistances(), we(() => [
+    const i = new Sr(), r = new nl(), a = new qd(r, i), l = Ue().sizes, c = Ne(() => Array.isArray(e.vertexColors));
+    return s(i, e), n(r, e.points, e.vertexColors), a.computeLineDistances(), Te(() => [
       e.color,
       e.lineWidth,
       e.alphaToCoverage,
@@ -14850,11 +15128,11 @@ const jd = ["object"], Vd = /* @__PURE__ */ pe({
       e.dashScale,
       e.dashSize,
       e.dashOffset
-    ], () => s(i, e)), we([e.points, e.vertexColors], () => n(r, e.points, e.vertexColors)), we(() => e.vertexColors, () => n(r, e.points, e.vertexColors)), we(() => e.points, () => n(r, e.points, e.vertexColors)), we([l.height, l.width], () => i.resolution = new le(l.width.value, l.height.value)), ot(() => {
+    ], () => s(i, e)), Te([e.points, e.vertexColors], () => n(r, e.points, e.vertexColors)), Te(() => e.vertexColors, () => n(r, e.points, e.vertexColors)), Te(() => e.points, () => n(r, e.points, e.vertexColors)), Te([l.height, l.width], () => i.resolution = new he(l.width.value, l.height.value)), ot(() => {
       r.dispose(), i.dispose();
-    }), (u, h) => (fe(), de("primitive", { object: z(a) }, null, 8, jd));
+    }), (u, h) => (le(), ce("primitive", { object: B(a) }, null, 8, Qd));
   }
-}), rg = /* @__PURE__ */ pe({
+}), Mg = /* @__PURE__ */ pe({
   __name: "CatmullRomCurve3",
   props: {
     segments: { default: 20 },
@@ -14877,15 +15155,15 @@ const jd = ["object"], Vd = /* @__PURE__ */ pe({
     const e = o;
     function t(r, a, l, c) {
       const u = r.map(
-        (h) => h instanceof ee ? h : new ee(...h)
+        (h) => h instanceof q ? h : new q(...h)
       );
-      return new Gl(u, a, l, c);
+      return new Zl(u, a, l, c);
     }
     function n(r, a) {
       return r.getPoints(a);
     }
     const s = Ne(() => t(e.points, e.closed, e.curveType, e.tension)), i = Ne(() => n(s.value, e.segments));
-    return (r, a) => (fe(), sc(Vd, {
+    return (r, a) => (le(), _a(Jd, {
       points: i.value,
       "vertex-colors": e.vertexColors,
       color: e.color,
@@ -14899,168 +15177,188 @@ const jd = ["object"], Vd = /* @__PURE__ */ pe({
       worldUnits: e.worldUnits
     }, null, 8, ["points", "vertex-colors", "color", "lineWidth", "alphaToCoverage", "dashed", "dashSize", "dashScale", "dashOffset", "gapSize", "worldUnits"]));
   }
-}), Yd = ["args"], Xd = ["color"], og = /* @__PURE__ */ pe({
+}), ep = ["args"], tp = ["color"], Ag = /* @__PURE__ */ pe({
   __name: "Circle",
   props: {
     args: { default: () => [1, 32, 0, Math.PI * 2] },
     color: { default: "#ffffff" }
   },
   setup(o, { expose: e }) {
-    const t = o, { args: n, color: s } = Fe(t), i = xe();
+    const t = o, { args: n, color: s } = Oe(t), i = me();
     return e({
       value: i
-    }), (r, a) => (fe(), de("TresMesh", Ye({
+    }), (r, a) => (le(), ce("TresMesh", Ye({
       ref_key: "circleRef",
       ref: i
     }, r.$attrs), [
-      Te("TresCircleGeometry", { args: z(n) }, null, 8, Yd),
-      $e(r.$slots, "default", {}, () => [
-        Te("TresMeshBasicMaterial", { color: z(s) }, null, 8, Xd)
+      ye("TresCircleGeometry", { args: B(n) }, null, 8, ep),
+      Ve(r.$slots, "default", {}, () => [
+        ye("TresMeshBasicMaterial", { color: B(s) }, null, 8, tp)
       ])
     ], 16));
   }
-}), Wd = ["args"], $d = ["color"], ag = /* @__PURE__ */ pe({
+}), np = ["args"], sp = ["color"], Pg = /* @__PURE__ */ pe({
   __name: "Cone",
   props: {
     args: { default: () => [1, 1, 12, 12, !1, 0, Math.PI * 2] },
     color: { default: "#ffffff" }
   },
   setup(o, { expose: e }) {
-    const t = o, { args: n, color: s } = Fe(t), i = xe();
+    const t = o, { args: n, color: s } = Oe(t), i = me();
     return e({
       value: i
-    }), (r, a) => (fe(), de("TresMesh", Ye({
+    }), (r, a) => (le(), ce("TresMesh", Ye({
       ref_key: "coneRef",
       ref: i
     }, r.$attrs), [
-      Te("TresConeGeometry", { args: z(n) }, null, 8, Wd),
-      $e(r.$slots, "default", {}, () => [
-        Te("TresMeshBasicMaterial", { color: z(s) }, null, 8, $d)
+      ye("TresConeGeometry", { args: B(n) }, null, 8, np),
+      Ve(r.$slots, "default", {}, () => [
+        ye("TresMeshBasicMaterial", { color: B(s) }, null, 8, sp)
       ])
     ], 16));
   }
-}), Zd = ["args"], Kd = ["color"], lg = /* @__PURE__ */ pe({
+}), ip = ["args"], rp = ["color"], Cg = /* @__PURE__ */ pe({
   __name: "Dodecahedron",
   props: {
     args: { default: () => [1, 0] },
     color: { default: "#ffffff" }
   },
   setup(o, { expose: e }) {
-    const t = o, { args: n, color: s } = Fe(t), i = xe();
+    const t = o, { args: n, color: s } = Oe(t), i = me();
     return e({
       value: i
-    }), (r, a) => (fe(), de("TresMesh", Ye({
+    }), (r, a) => (le(), ce("TresMesh", Ye({
       ref_key: "dodecahedronRef",
       ref: i
     }, r.$attrs), [
-      Te("TresDodecahedronGeometry", { args: z(n) }, null, 8, Zd),
-      $e(r.$slots, "default", {}, () => [
-        Te("TresMeshBasicMaterial", { color: z(s) }, null, 8, Kd)
+      ye("TresDodecahedronGeometry", { args: B(n) }, null, 8, ip),
+      Ve(r.$slots, "default", {}, () => [
+        ye("TresMeshBasicMaterial", { color: B(s) }, null, 8, rp)
       ])
     ], 16));
   }
-}), qd = ["args"], Qd = ["color"], cg = /* @__PURE__ */ pe({
+}), op = ["args"], ap = ["color"], Rg = /* @__PURE__ */ pe({
   __name: "Icosahedron",
   props: {
     args: { default: () => [1, 0] },
     color: { default: "#ffffff" }
   },
   setup(o, { expose: e }) {
-    const t = o, { args: n, color: s } = Fe(t), i = xe();
+    const t = o, { args: n, color: s } = Oe(t), i = me();
     return e({
       value: i
-    }), (r, a) => (fe(), de("TresMesh", Ye({
+    }), (r, a) => (le(), ce("TresMesh", Ye({
       ref_key: "icosahedronRef",
       ref: i
     }, r.$attrs), [
-      Te("TresIcosahedronGeometry", { args: z(n) }, null, 8, qd),
-      $e(r.$slots, "default", {}, () => [
-        Te("TresMeshBasicMaterial", { color: z(s) }, null, 8, Qd)
+      ye("TresIcosahedronGeometry", { args: B(n) }, null, 8, op),
+      Ve(r.$slots, "default", {}, () => [
+        ye("TresMeshBasicMaterial", { color: B(s) }, null, 8, ap)
       ])
     ], 16));
   }
-}), Jd = ["args"], ep = ["color"], ug = /* @__PURE__ */ pe({
+}), lp = ["args"], cp = ["color"], Ig = /* @__PURE__ */ pe({
   __name: "Octahedron",
   props: {
     args: { default: () => [1, 0] },
     color: { default: "#ffffff" }
   },
   setup(o, { expose: e }) {
-    const t = o, { args: n, color: s } = Fe(t), i = xe();
+    const t = o, { args: n, color: s } = Oe(t), i = me();
     return e({
       value: i
-    }), (r, a) => (fe(), de("TresMesh", Ye({
+    }), (r, a) => (le(), ce("TresMesh", Ye({
       ref_key: "octahedronRef",
       ref: i
     }, r.$attrs), [
-      Te("TresOctahedronGeometry", { args: z(n) }, null, 8, Jd),
-      $e(r.$slots, "default", {}, () => [
-        Te("TresMeshBasicMaterial", { color: z(s) }, null, 8, ep)
+      ye("TresOctahedronGeometry", { args: B(n) }, null, 8, lp),
+      Ve(r.$slots, "default", {}, () => [
+        ye("TresMeshBasicMaterial", { color: B(s) }, null, 8, cp)
       ])
     ], 16));
   }
-}), tp = ["rotation"], np = ["args"], sp = ["color"], hg = /* @__PURE__ */ pe({
+}), up = ["rotation"], hp = ["args"], fp = ["color"], Dg = /* @__PURE__ */ pe({
   __name: "Plane",
   props: {
     args: { default: () => [1, 1] },
     color: { default: "#ffffff" }
   },
   setup(o, { expose: e }) {
-    const t = o, { args: n, color: s } = Fe(t), i = xe();
+    const t = o, { args: n, color: s } = Oe(t), i = me();
     return e({
       value: i
-    }), (r, a) => (fe(), de("TresMesh", Ye({
+    }), (r, a) => (le(), ce("TresMesh", Ye({
       ref_key: "planeRef",
       ref: i,
       rotation: [-Math.PI / 2, 0, 0]
     }, r.$attrs), [
-      Te("TresPlaneGeometry", { args: z(n) }, null, 8, np),
-      $e(r.$slots, "default", {}, () => [
-        Te("TresMeshBasicMaterial", { color: z(s) }, null, 8, sp)
+      ye("TresPlaneGeometry", { args: B(n) }, null, 8, hp),
+      Ve(r.$slots, "default", {}, () => [
+        ye("TresMeshBasicMaterial", { color: B(s) }, null, 8, fp)
       ])
-    ], 16, tp));
+    ], 16, up));
   }
-}), ip = ["args"], rp = ["color"], fg = /* @__PURE__ */ pe({
+}), dp = ["args"], pp = ["color"], Og = /* @__PURE__ */ pe({
   __name: "Ring",
   props: {
     args: { default: () => [0.5, 1, 32] },
     color: { default: "#ffffff" }
   },
   setup(o, { expose: e }) {
-    const t = o, { args: n, color: s } = Fe(t), i = xe();
+    const t = o, { args: n, color: s } = Oe(t), i = me();
     return e({
       value: i
-    }), (r, a) => (fe(), de("TresMesh", Ye({
+    }), (r, a) => (le(), ce("TresMesh", Ye({
       ref_key: "ringRef",
       ref: i
     }, r.$attrs), [
-      Te("TresRingGeometry", { args: z(n) }, null, 8, ip),
-      $e(r.$slots, "default", {}, () => [
-        Te("TresMeshBasicMaterial", { color: z(s) }, null, 8, rp)
+      ye("TresRingGeometry", { args: B(n) }, null, 8, dp),
+      Ve(r.$slots, "default", {}, () => [
+        ye("TresMeshBasicMaterial", { color: B(s) }, null, 8, pp)
       ])
     ], 16));
   }
-}), op = ["args"], ap = ["color"], dg = /* @__PURE__ */ pe({
+}), mp = ["args"], gp = ["color"], Lg = /* @__PURE__ */ pe({
+  __name: "RoundedBox",
+  props: {
+    args: { default: () => [1, 1, 1, 2, 0.1] },
+    color: { default: "#ffffff" }
+  },
+  setup(o, { expose: e }) {
+    const t = o, { args: n, color: s } = Oe(t), { extend: i } = Ue();
+    i({ RoundedBoxGeometry: Xu });
+    const r = me();
+    return e({ value: r }), (a, l) => (le(), ce("TresMesh", {
+      ref_key: "roundedBoxRef",
+      ref: r
+    }, [
+      ye("TresRoundedBoxGeometry", { args: B(n) }, null, 8, mp),
+      Ve(a.$slots, "default", {}, () => [
+        ye("TresMeshBasicMaterial", { color: B(s) }, null, 8, gp)
+      ])
+    ], 512));
+  }
+}), vp = ["args"], yp = ["color"], Fg = /* @__PURE__ */ pe({
   __name: "Sphere",
   props: {
     args: { default: () => [2, 32, 16] },
     color: { default: "#ffffff" }
   },
   setup(o, { expose: e }) {
-    const t = o, { args: n, color: s } = Fe(t), i = xe();
+    const t = o, { args: n, color: s } = Oe(t), i = me();
     return e({
       value: i
-    }), (r, a) => (fe(), de("TresMesh", Ye({
+    }), (r, a) => (le(), ce("TresMesh", Ye({
       ref_key: "sphereRef",
       ref: i
     }, r.$attrs), [
-      Te("TresSphereGeometry", { args: z(n) }, null, 8, op),
-      $e(r.$slots, "default", {}, () => [
-        Te("TresMeshBasicMaterial", { color: z(s) }, null, 8, ap)
+      ye("TresSphereGeometry", { args: B(n) }, null, 8, vp),
+      Ve(r.$slots, "default", {}, () => [
+        ye("TresMeshBasicMaterial", { color: B(s) }, null, 8, yp)
       ])
     ], 16));
   }
-}), lp = ["geometry"], cp = ["color"], pg = /* @__PURE__ */ pe({
+}), _p = ["geometry"], xp = ["color"], kg = /* @__PURE__ */ pe({
   __name: "Superformula",
   props: {
     widthSegments: { default: 32 },
@@ -15072,43 +15370,43 @@ const jd = ["object"], Vd = /* @__PURE__ */ pe({
     color: { default: "white" }
   },
   setup(o, { expose: e }) {
-    const t = o, { cos: n, sin: s, abs: i } = Math, r = xe(), a = xe(t.color);
-    function l(m, p) {
-      const v = new rt(), _ = m * p, y = new Float32Array(new Array(3 * _).fill(0)), E = new Float32Array(new Array(3 * _).fill(0)), R = [];
-      for (let T = 0; T < p - 1; T++) {
-        for (let d = 0; d < m - 1; d++) {
-          const w = T * m + d, f = w + 1, P = w + m, I = f + m;
-          R.push(w, P, f), R.push(P, I, f);
+    const t = o, { cos: n, sin: s, abs: i } = Math, r = me(), a = me(t.color);
+    function l(f, d) {
+      const y = new at(), x = f * d, g = new Float32Array(new Array(3 * x).fill(0)), v = new Float32Array(new Array(3 * x).fill(0)), M = [];
+      for (let _ = 0; _ < d - 1; _++) {
+        for (let m = 0; m < f - 1; m++) {
+          const b = _ * f + m, p = b + 1, C = b + f, I = p + f;
+          M.push(b, C, p), M.push(C, I, p);
         }
-        const g = T * m + m - 1, A = T * m, x = g + m, M = A + m;
-        R.push(g, x, A), R.push(x, M, A);
+        const w = _ * f + f - 1, P = _ * f, T = w + f, E = P + f;
+        M.push(w, T, P), M.push(T, E, P);
       }
-      return v.setIndex(R), v.setAttribute("position", new pt(y, 3)), v.setAttribute("normal", new pt(E, 3)), v;
-    }
-    function c(m, p, v, _, y) {
-      return (i(n(p * m * 0.25)) ** _ + i(s(p * m * 0.25)) ** y) ** (-1 / v);
-    }
-    function u(m, p, v, _, y, E, R, T, g, A, x) {
-      const M = 2 * Math.PI / A, d = -Math.PI, w = Math.PI / (x - 1), f = -0.5 * Math.PI, P = m.getAttribute("position");
-      let I = 0, K = 0, N = f;
-      for (let Z = 0; Z < x; Z++) {
-        K = d;
-        for (let W = 0; W < A; W++) {
-          const X = c(K, p, v, _, y), V = c(N, E, R, T, g);
-          P.setXYZ(
+      return y.setIndex(M), y.setAttribute("position", new pt(g, 3)), y.setAttribute("normal", new pt(v, 3)), y;
+    }
+    function c(f, d, y, x, g) {
+      return (i(n(d * f * 0.25)) ** x + i(s(d * f * 0.25)) ** g) ** (-1 / y);
+    }
+    function u(f, d, y, x, g, v, M, _, w, P, T) {
+      const E = 2 * Math.PI / P, m = -Math.PI, b = Math.PI / (T - 1), p = -0.5 * Math.PI, C = f.getAttribute("position");
+      let I = 0, K = 0, z = p;
+      for (let Y = 0; Y < T; Y++) {
+        K = m;
+        for (let W = 0; W < P; W++) {
+          const X = c(K, d, y, x, g), V = c(z, v, M, _, w);
+          C.setXYZ(
             I,
-            X * n(K) * V * n(N),
-            V * s(N),
-            X * s(K) * V * n(N)
-          ), I++, K += M;
+            X * n(K) * V * n(z),
+            V * s(z),
+            X * s(K) * V * n(z)
+          ), I++, K += E;
         }
-        N += w;
+        z += b;
       }
-      P.needsUpdate = !0, m.computeVertexNormals();
+      C.needsUpdate = !0, f.computeVertexNormals();
     }
-    we(() => t.color, () => a.value = t.color), we(() => [t.widthSegments, t.heightSegments], () => {
+    Te(() => t.color, () => a.value = t.color), Te(() => [t.widthSegments, t.heightSegments], () => {
       r.value && r.value.dispose(), r.value = l(t.widthSegments, t.heightSegments);
-    }, { immediate: !0 }), we(
+    }, { immediate: !0 }), Te(
       () => [
         t.numArmsA,
         t.expA[0],
@@ -15136,84 +15434,84 @@ const jd = ["object"], Vd = /* @__PURE__ */ pe({
     ), ot(() => {
       r.value && r.value.dispose();
     });
-    const h = xe();
+    const h = me();
     return e({
       value: h
-    }), (m, p) => (fe(), de("TresMesh", Ye({
+    }), (f, d) => (le(), ce("TresMesh", Ye({
       ref_key: "superformulaRef",
       ref: h
-    }, m.$attrs, { geometry: r.value }), [
-      $e(m.$slots, "default", {}, () => [
-        Te("TresMeshBasicMaterial", { color: a.value }, null, 8, cp)
+    }, f.$attrs, { geometry: r.value }), [
+      Ve(f.$slots, "default", {}, () => [
+        ye("TresMeshBasicMaterial", { color: a.value }, null, 8, xp)
       ])
-    ], 16, lp));
+    ], 16, _p));
   }
-}), up = ["rotation"], hp = ["args"], fp = ["color"], mg = /* @__PURE__ */ pe({
+}), wp = ["rotation"], Tp = ["args"], bp = ["color"], Bg = /* @__PURE__ */ pe({
   __name: "Tetrahedron",
   props: {
     args: { default: () => [1, 0] },
     color: { default: "#ffffff" }
   },
   setup(o, { expose: e }) {
-    const t = o, { args: n, color: s } = Fe(t), i = xe();
+    const t = o, { args: n, color: s } = Oe(t), i = me();
     return e({
       value: i
-    }), (r, a) => (fe(), de("TresMesh", Ye({
+    }), (r, a) => (le(), ce("TresMesh", Ye({
       ref_key: "tetrahedronRef",
       ref: i,
       rotation: [-Math.PI / 2, 0, 0]
     }, r.$attrs), [
-      Te("TresTetrahedronGeometry", { args: z(n) }, null, 8, hp),
-      $e(r.$slots, "default", {}, () => [
-        Te("TresMeshBasicMaterial", { color: z(s) }, null, 8, fp)
+      ye("TresTetrahedronGeometry", { args: B(n) }, null, 8, Tp),
+      Ve(r.$slots, "default", {}, () => [
+        ye("TresMeshBasicMaterial", { color: B(s) }, null, 8, bp)
       ])
-    ], 16, up));
+    ], 16, wp));
   }
-}), dp = ["args"], pp = ["color"], gg = /* @__PURE__ */ pe({
+}), Ep = ["args"], Sp = ["color"], Ug = /* @__PURE__ */ pe({
   __name: "Torus",
   props: {
     args: { default: () => [1, 1, 16, 80] },
     color: { default: "#ffffff" }
   },
   setup(o, { expose: e }) {
-    const t = o, { args: n, color: s } = Fe(t), i = xe();
+    const t = o, { args: n, color: s } = Oe(t), i = me();
     return e({
       value: i
-    }), (r, a) => (fe(), de("TresMesh", Ye({
+    }), (r, a) => (le(), ce("TresMesh", Ye({
       ref_key: "torusRef",
       ref: i
     }, r.$attrs), [
-      Te("TresTorusGeometry", { args: z(n) }, null, 8, dp),
-      $e(r.$slots, "default", {}, () => [
-        Te("TresMeshBasicMaterial", { color: z(s) }, null, 8, pp)
+      ye("TresTorusGeometry", { args: B(n) }, null, 8, Ep),
+      Ve(r.$slots, "default", {}, () => [
+        ye("TresMeshBasicMaterial", { color: B(s) }, null, 8, Sp)
       ])
     ], 16));
   }
-}), mp = ["args"], gp = ["color"], yg = /* @__PURE__ */ pe({
+}), Mp = ["args"], Ap = ["color"], Ng = /* @__PURE__ */ pe({
   __name: "TorusKnot",
   props: {
     args: { default: () => [1, 0.4, 64, 8] },
     color: { default: "#ffffff" }
   },
   setup(o, { expose: e }) {
-    const t = o, { args: n, color: s } = Fe(t), i = xe();
+    const t = o, { args: n, color: s } = Oe(t), i = me();
     return e({
       value: i
-    }), (r, a) => (fe(), de("TresMesh", Ye({
+    }), (r, a) => (le(), ce("TresMesh", Ye({
       ref_key: "torusKnotRef",
       ref: i
     }, r.$attrs), [
-      Te("TresTorusKnotGeometry", { args: z(n) }, null, 8, mp),
-      $e(r.$slots, "default", {}, () => [
-        Te("TresMeshBasicMaterial", { color: z(s) }, null, 8, gp)
+      ye("TresTorusKnotGeometry", { args: B(n) }, null, 8, Mp),
+      Ve(r.$slots, "default", {}, () => [
+        ye("TresMeshBasicMaterial", { color: B(s) }, null, 8, Ap)
       ])
     ], 16));
   }
-}), yp = ["args"], vp = ["color"], vg = /* @__PURE__ */ pe({
+}), Pp = ["args"], Cp = ["color"], zg = /* @__PURE__ */ pe({
   __name: "Tube",
   props: {
     args: { default: () => [
-      new jl(new ee(-1, 0, 0), new ee(0, 1, 0), new ee(1, 0, 0)),
+      new Kl(new q(-1, 0, 0), new q(0, 1, 0), new q(1, 0, 0)),
       20,
       0.2,
       8,
@@ -15222,38 +15520,123 @@ const jd = ["object"], Vd = /* @__PURE__ */ pe({
     color: { default: "#ffffff" }
   },
   setup(o, { expose: e }) {
-    const t = o, { args: n, color: s } = Fe(t), i = xe();
+    const t = o, { args: n, color: s } = Oe(t), i = me();
     return e({
       value: i
-    }), (r, a) => (fe(), de("TresMesh", Ye({
+    }), (r, a) => (le(), ce("TresMesh", Ye({
       ref_key: "tubeRef",
       ref: i
     }, r.$attrs), [
-      Te("TresTubeGeometry", { args: z(n) }, null, 8, yp),
-      $e(r.$slots, "default", {}, () => [
-        Te("TresMeshBasicMaterial", { color: z(s) }, null, 8, vp)
+      ye("TresTubeGeometry", { args: B(n) }, null, 8, Pp),
+      Ve(r.$slots, "default", {}, () => [
+        ye("TresMeshBasicMaterial", { color: B(s) }, null, 8, Cp)
       ])
     ], 16));
   }
-}), _g = /* @__PURE__ */ pe({
+});
+class Rp extends Tt {
+  constructor() {
+    super();
+    oe(this, "virtualScene", null);
+    this.virtualScene = new fs();
+  }
+  add(...t) {
+    return this.virtualScene.add(...t), this;
+  }
+  destructor() {
+    this.virtualScene.traverse((t) => {
+      t instanceof ae && (t.geometry.dispose(), t.material.dispose(), t.material.map && t.material.map.dispose(), this.virtualScene.remove(t));
+    }), this.virtualScene = null;
+  }
+}
+const Ip = Rp, Hg = /* @__PURE__ */ pe({
   __name: "component",
   props: {
     background: { type: [Boolean, String], default: !1 },
     blur: { default: 0 },
     files: { default: [] },
     path: { default: "" },
-    preset: { default: void 0 }
+    preset: { default: void 0 },
+    resolution: { default: 256 },
+    near: { default: 1 },
+    far: { default: 1e3 },
+    frames: { default: 1 / 0 }
   },
   async setup(o, { expose: e }) {
     let t, n;
     const s = o, i = ue(null);
-    return e(i), i.value = ([t, n] = fs(() => nf(s).texture), t = await t, n(), t), () => {
+    e({ texture: i });
+    const { extend: r, renderer: a, scene: l } = Ue();
+    let c = null, u = ue(null), h = null;
+    const f = ue(null);
+    ot(() => {
+      var v, M;
+      (v = f.value) == null || v.destructor(), (M = u.value) == null || M.dispose();
+    });
+    const { onBeforeLoop: d } = Xe();
+    let y = 1;
+    d(() => {
+      h && f.value && u.value && (s.frames === 1 / 0 || y < s.frames) && (h.update(a.value, hc(f.value.virtualScene)), y++);
+    });
+    const x = ([t, n] = Xn(() => hf(s, u)), t = await t, n(), t).texture, g = (v) => {
+      v ? (l.value.environment = v.texture, s.background && (l.value.background = v.texture)) : (l.value.environment = x.value, s.background && (l.value.background = x.value));
     };
+    return Te(x, (v) => {
+      u.value && g(u.value);
+    }, { immediate: !0, deep: !0 }), Te(gr().default, (v) => {
+      var M, _;
+      if (v && (c = v, Array.isArray(c) && c.length > 0 && typeof ((M = c[0]) == null ? void 0 : M.type) != "symbol")) {
+        r({ EnvSence: Ip }), u.value = new ql(s.resolution), u.value.texture.type = Zt, h = new Ql(s.near, s.far, u.value), g(u.value);
+        return;
+      }
+      (_ = u.value) == null || _.dispose(), u.value = null, g();
+    }, { immediate: !0, deep: !0 }), i.value = x, (v, M) => B(u) ? (le(), ce("TresEnvSence", {
+      key: 0,
+      ref_key: "envSence",
+      ref: f
+    }, [
+      Ve(v.$slots, "default")
+    ], 512)) : Ut("", !0);
+  }
+}), Dp = {
+  key: 0,
+  args: [0, 1, 64]
+}, Op = {
+  key: 1,
+  args: [0.5, 1, 64]
+}, Lp = { key: 2 }, Fp = ["toneMapped", "map", "side", "color"], jg = /* @__PURE__ */ pe({
+  __name: "index",
+  props: {
+    args: { default: null },
+    from: { default: "rect" },
+    toneMapped: { type: Boolean, default: !1 },
+    map: { default: null },
+    intensity: { default: 1 },
+    color: { default: new Re(16777215) }
+  },
+  setup(o) {
+    const e = o, t = ue();
+    return lt(() => {
+      t.value && (t.value.color.multiplyScalar(e.intensity), t.value.needsUpdate = !0);
+    }), (n, s) => (le(), ce("TresMesh", null, [
+      e.from === "circle" ? (le(), ce("TresRingGeometry", Dp)) : e.from === "ring" ? (le(), ce("TresRingGeometry", Op)) : e.from === "rect" ? (le(), ce("TresPlaneGeometry", Lp)) : (le(), _a(e.from, {
+        key: 3,
+        args: e
+      })),
+      ye("TresMeshBasicMaterial", {
+        ref_key: "material",
+        ref: t,
+        toneMapped: n.toneMapped,
+        map: n.map,
+        side: B(dn),
+        color: n.color
+      }, null, 8, Fp)
+    ]));
   }
-}), _p = ["receive-shadow", "rotation"], xp = ["args"], wp = /* @__PURE__ */ Te("TresMeshStandardMaterial", {
+}), kp = ["receive-shadow", "rotation"], Bp = ["args"], Up = /* @__PURE__ */ ye("TresMeshStandardMaterial", {
   color: 8421504,
   side: 2
-}, null, -1), xg = /* @__PURE__ */ pe({
+}, null, -1), Gg = /* @__PURE__ */ pe({
   __name: "Backdrop",
   props: {
     floor: { default: 0.25 },
@@ -15261,41 +15644,41 @@ const jd = ["object"], Vd = /* @__PURE__ */ pe({
     receiveShadow: { type: Boolean, default: !1 }
   },
   setup(o) {
-    const e = o, t = (a) => a === 0 ? 0 : 2 ** (10 * a - 10), { floor: n, segments: s, receiveShadow: i } = Fe(e), r = ue(null);
-    return we(
+    const e = o, t = (a) => a === 0 ? 0 : 2 ** (10 * a - 10), { floor: n, segments: s, receiveShadow: i } = Oe(e), r = ue(null);
+    return Te(
       () => [s.value, n.value, r.value],
       ([a, l, c]) => {
         if (!c || a === null)
           return;
         let u = 0;
-        const h = a / a / 2, m = c.attributes.position;
-        for (let p = 0; p < a + 1; p++)
-          for (let v = 0; v < a + 1; v++)
-            m.setXYZ(
+        const h = a / a / 2, f = c.attributes.position;
+        for (let d = 0; d < a + 1; d++)
+          for (let y = 0; y < a + 1; y++)
+            f.setXYZ(
               u++,
-              p / a - h + (p === 0 ? -l : 0),
-              v / a - h,
-              t(p / a)
+              d / a - h + (d === 0 ? -l : 0),
+              y / a - h,
+              t(d / a)
             );
-        m.needsUpdate = !0, c.computeVertexNormals();
+        f.needsUpdate = !0, c.computeVertexNormals();
       }
-    ), (a, l) => (fe(), de("TresGroup", ua(ha(a.$attrs)), [
-      Te("TresMesh", {
-        "receive-shadow": z(i),
+    ), (a, l) => (le(), ce("TresGroup", ga(va(a.$attrs)), [
+      ye("TresMesh", {
+        "receive-shadow": B(i),
         rotation: [-Math.PI / 2, 0, Math.PI / 2]
       }, [
-        Te("TresPlaneGeometry", {
+        ye("TresPlaneGeometry", {
           ref_key: "planeRef",
           ref: r,
-          args: [1, 1, z(s), z(s)]
-        }, null, 8, xp),
-        $e(a.$slots, "default", {}, () => [
-          wp
+          args: [1, 1, B(s), B(s)]
+        }, null, 8, Bp),
+        Ve(a.$slots, "default", {}, () => [
+          Up
         ])
-      ], 8, _p)
+      ], 8, kp)
     ], 16));
   }
-}), Tp = ["geometry"], bp = ["map", "opacity", "depth-write"], Ep = ["object"], Mp = ["args"], Sp = ["rotation", "args"], wg = /* @__PURE__ */ pe({
+}), Np = ["geometry"], zp = ["map", "opacity", "depth-write"], Hp = ["object"], jp = ["args"], Gp = ["rotation", "args"], Vg = /* @__PURE__ */ pe({
   __name: "ContactShadows",
   props: {
     opacity: { default: 1 },
@@ -15312,76 +15695,76 @@ const jd = ["object"], Vd = /* @__PURE__ */ pe({
     helper: { type: Boolean, default: !1 }
   },
   setup(o, { expose: e }) {
-    const t = o, n = xe(), s = xe();
+    const t = o, n = me(), s = me();
     e(n);
     let i, r, a, l, c;
-    const { renderer: u, scene: h } = je(), m = Ne(() => t.width * (Array.isArray(t.scale) ? t.scale[0] : t.scale || 1)), p = Ne(() => t.height * (Array.isArray(t.scale) ? t.scale[1] : t.scale || 1));
-    ft(() => {
-      i && i.dispose(), r && r.dispose(), a && a.dispose(), l && l.geometry.dispose(), i = new bn(t.resolution, t.resolution), r = new bn(t.resolution, t.resolution), r.texture.generateMipmaps = i.texture.generateMipmaps = !1, s.value = new jt(
-        -m.value / 2,
-        m.value / 2,
-        p.value / 2,
-        -p.value / 2,
+    const { renderer: u, scene: h } = Ue(), f = Ne(() => t.width * (Array.isArray(t.scale) ? t.scale[0] : t.scale || 1)), d = Ne(() => t.height * (Array.isArray(t.scale) ? t.scale[1] : t.scale || 1));
+    lt(() => {
+      i && i.dispose(), r && r.dispose(), a && a.dispose(), l && l.geometry.dispose(), i = new pn(t.resolution, t.resolution), r = new pn(t.resolution, t.resolution), r.texture.generateMipmaps = i.texture.generateMipmaps = !1, s.value = new Xt(
+        -f.value / 2,
+        f.value / 2,
+        d.value / 2,
+        -d.value / 2,
         0,
         t.far
-      ), a = new Dt(m.value, p.value).rotateX(Math.PI / 2), l = new ae(a), l.visible = !1;
-    }), ft(() => {
-      t.color && (c && c.dispose(), c = new Vl(), c.depthTest = c.depthWrite = !1, c.onBeforeCompile = (A) => {
-        A.uniforms = {
-          ...A.uniforms,
-          ucolor: { value: t.color ? new Be(t.color) : new Be() }
-        }, A.fragmentShader = A.fragmentShader.replace(
+      ), a = new Lt(f.value, d.value).rotateX(Math.PI / 2), l = new ae(a), l.visible = !1;
+    }), lt(() => {
+      t.color && (c && c.dispose(), c = new Jl(), c.depthTest = c.depthWrite = !1, c.onBeforeCompile = (P) => {
+        P.uniforms = {
+          ...P.uniforms,
+          ucolor: { value: t.color ? new Re(t.color) : new Re() }
+        }, P.fragmentShader = P.fragmentShader.replace(
           "void main() {",
           //
           `uniform vec3 ucolor;
              void main() {
             `
-        ), A.fragmentShader = A.fragmentShader.replace(
+        ), P.fragmentShader = P.fragmentShader.replace(
           "vec4( vec3( 1.0 - fragCoordZ ), opacity );",
           // Colorize the shadow, multiply by the falloff so that the center can remain darker
           "vec4( ucolor * fragCoordZ * 2.0, ( 1.0 - fragCoordZ ) * 1.0 );"
         );
       });
     });
-    const v = new Xt(Nu), _ = new Xt(zu);
-    _.depthTest = v.depthTest = !1;
-    function y(A) {
-      !u.value || !s.value || (l.visible = !0, l.material = v, v.uniforms.tDiffuse.value = i.texture, v.uniforms.h.value = A / 256, u.value.setRenderTarget(r), u.value.render(l, s.value), l.material = _, _.uniforms.tDiffuse.value = r.texture, _.uniforms.v.value = A / 256, u.value.setRenderTarget(i), u.value.render(l, s.value), l.visible = !1);
-    }
-    const { onLoop: E } = Ke();
-    let R = 0, T, g;
-    return E(() => {
-      !s.value || h.value === void 0 || u.value === void 0 || (t.frames === 1 / 0 || R < t.frames) && (R++, T = h.value.background, g = h.value.overrideMaterial, n.value.visible = !1, h.value.background = null, h.value.overrideMaterial = c, u.value.setRenderTarget(i), u.value.render(h.value, s.value), y(t.blur), t.smooth && y(t.blur * 0.4), u.value.setRenderTarget(null), n.value.visible = !0, h.value.background = T, h.value.overrideMaterial = g);
-    }), (A, x) => (fe(), de("TresGroup", Ye({
+    const y = new Pt($u), x = new Pt(Zu);
+    x.depthTest = y.depthTest = !1;
+    function g(P) {
+      !u.value || !s.value || (l.visible = !0, l.material = y, y.uniforms.tDiffuse.value = i.texture, y.uniforms.h.value = P / 256, u.value.setRenderTarget(r), u.value.render(l, s.value), l.material = x, x.uniforms.tDiffuse.value = r.texture, x.uniforms.v.value = P / 256, u.value.setRenderTarget(i), u.value.render(l, s.value), l.visible = !1);
+    }
+    const { onLoop: v } = Xe();
+    let M = 0, _, w;
+    return v(() => {
+      !s.value || h.value === void 0 || u.value === void 0 || (t.frames === 1 / 0 || M < t.frames) && (M++, _ = h.value.background, w = h.value.overrideMaterial, n.value.visible = !1, h.value.background = null, h.value.overrideMaterial = c, u.value.setRenderTarget(i), u.value.render(h.value, s.value), g(t.blur), t.smooth && g(t.blur * 0.4), u.value.setRenderTarget(null), n.value.visible = !0, h.value.background = _, h.value.overrideMaterial = w);
+    }), (P, T) => (le(), ce("TresGroup", Ye({
       ref_key: "groupRef",
       ref: n
-    }, A.$attrs), [
-      Te("TresMesh", {
+    }, P.$attrs), [
+      ye("TresMesh", {
         scale: [1, -1, 1],
-        geometry: z(a)
+        geometry: B(a)
       }, [
-        Te("TresMeshBasicMaterial", {
-          map: z(i).texture,
-          opacity: A.opacity,
-          "depth-write": A.depthWrite,
+        ye("TresMeshBasicMaterial", {
+          map: B(i).texture,
+          opacity: P.opacity,
+          "depth-write": P.depthWrite,
           transparent: !0
-        }, null, 8, bp)
-      ], 8, Tp),
-      Te("primitive", { object: z(l) }, null, 8, Ep),
-      s.value && A.helper ? (fe(), de("TresCameraHelper", {
+        }, null, 8, zp)
+      ], 8, Np),
+      ye("primitive", { object: B(l) }, null, 8, Hp),
+      s.value && P.helper ? (le(), ce("TresCameraHelper", {
         key: 0,
         args: [s.value]
-      }, null, 8, Mp)) : Wt("", !0),
-      Te("TresOrthographicCamera", {
+      }, null, 8, jp)) : Ut("", !0),
+      ye("TresOrthographicCamera", {
         ref_key: "shadowCamera",
         ref: s,
         position: [0, 0, 0],
         rotation: [Math.PI / 2, 0, 0],
-        args: [-m.value / 2, m.value / 2, p.value / 2, -p.value / 2, 0, A.far]
-      }, null, 8, Sp)
+        args: [-f.value / 2, f.value / 2, d.value / 2, -d.value / 2, 0, P.far]
+      }, null, 8, Gp)
     ], 16));
   }
-}), Ap = ["size", "color", "alpha-map", "map", "opacity", "alpha-test", "depth-write", "transparent", "size-attenuation"], Pp = ["position", "velocity"], Tg = /* @__PURE__ */ pe({
+}), Vp = ["size", "color", "alpha-map", "map", "opacity", "alpha-test", "depth-write", "transparent", "size-attenuation"], Wp = ["position", "velocity"], Wg = /* @__PURE__ */ pe({
   __name: "Precipitation",
   props: {
     size: { default: 0.1 },
@@ -15410,79 +15793,79 @@ const jd = ["object"], Vd = /* @__PURE__ */ pe({
       depthWrite: c,
       transparent: u,
       sizeAttenuation: h,
-      count: m,
-      speed: p,
-      randomness: v
-    } = Fe(e), _ = xe();
-    let y = [], E = [];
-    const R = () => {
-      y = new Float32Array(m.value * 3);
-      for (let A = 0; A < m.value; A++) {
-        const x = A * 3;
-        y[x] = (Math.random() - 0.5) * n.value[0], y[x + 1] = (Math.random() - 0.5) * n.value[1], y[x + 2] = (Math.random() - 0.5) * n.value[2];
+      count: f,
+      speed: d,
+      randomness: y
+    } = Oe(e), x = me();
+    let g = [], v = [];
+    const M = () => {
+      g = new Float32Array(f.value * 3);
+      for (let P = 0; P < f.value; P++) {
+        const T = P * 3;
+        g[T] = (Math.random() - 0.5) * n.value[0], g[T + 1] = (Math.random() - 0.5) * n.value[1], g[T + 2] = (Math.random() - 0.5) * n.value[2];
       }
-    }, T = () => {
-      E = new Float32Array(m.value * 2);
-      for (let A = 0; A < m.value * 2; A += 2)
-        E[A] = (Math.random() - 0.5) / 5 * p.value * v.value, E[A + 1] = Math.random() / 5 * p.value + 0.01;
+    }, _ = () => {
+      v = new Float32Array(f.value * 2);
+      for (let P = 0; P < f.value * 2; P += 2)
+        v[P] = (Math.random() - 0.5) / 5 * d.value * y.value, v[P + 1] = Math.random() / 5 * d.value + 0.01;
     };
-    T(), R(), ft(() => {
-      T(), R();
+    _(), M(), lt(() => {
+      _(), M();
     });
-    const { onLoop: g } = Ke();
-    return g(() => {
-      var A, x;
-      if ((A = _.value) != null && A.attributes.position.array && ((x = _.value) != null && x.attributes.position.count)) {
-        const M = _.value.attributes.position.array;
-        for (let d = 0; d < _.value.attributes.position.count; d++) {
-          const w = E[d * 2], f = E[d * 2 + 1];
-          M[d * 3] += w, M[d * 3 + 1] -= f, (M[d * 3] <= -n.value[0] / 2 || M[d * 3] >= n.value[0] / 2) && (M[d * 3] = M[d * 3] * -1), (M[d * 3 + 1] <= -n.value[1] / 2 || M[d * 3 + 1] >= n.value[1] / 2) && (M[d * 3 + 1] = M[d * 3 + 1] * -1);
+    const { onLoop: w } = Xe();
+    return w(() => {
+      var P, T;
+      if ((P = x.value) != null && P.attributes.position.array && ((T = x.value) != null && T.attributes.position.count)) {
+        const E = x.value.attributes.position.array;
+        for (let m = 0; m < x.value.attributes.position.count; m++) {
+          const b = v[m * 2], p = v[m * 2 + 1];
+          E[m * 3] += b, E[m * 3 + 1] -= p, (E[m * 3] <= -n.value[0] / 2 || E[m * 3] >= n.value[0] / 2) && (E[m * 3] = E[m * 3] * -1), (E[m * 3 + 1] <= -n.value[1] / 2 || E[m * 3 + 1] >= n.value[1] / 2) && (E[m * 3 + 1] = E[m * 3 + 1] * -1);
         }
-        _.value.attributes.position.needsUpdate = !0;
+        x.value.attributes.position.needsUpdate = !0;
       }
-    }), (A, x) => (fe(), de("TresPoints", null, [
-      Te("TresPointsMaterial", {
-        size: z(t),
-        color: z(s),
-        "alpha-map": z(i),
-        map: z(r),
-        opacity: z(a),
-        "alpha-test": z(l),
-        "depth-write": z(c),
-        transparent: z(u),
-        "size-attenuation": z(h)
-      }, null, 8, Ap),
-      Te("TresBufferGeometry", {
+    }), (P, T) => (le(), ce("TresPoints", null, [
+      ye("TresPointsMaterial", {
+        size: B(t),
+        color: B(s),
+        "alpha-map": B(i),
+        map: B(r),
+        opacity: B(a),
+        "alpha-test": B(l),
+        "depth-write": B(c),
+        transparent: B(u),
+        "size-attenuation": B(h)
+      }, null, 8, Vp),
+      ye("TresBufferGeometry", {
         ref_key: "geometryRef",
-        ref: _,
-        position: [z(y), 3],
-        velocity: [z(E)]
-      }, null, 8, Pp)
+        ref: x,
+        position: [B(g), 3],
+        velocity: [B(v)]
+      }, null, 8, Wp)
     ]));
   }
 });
-class ni extends ae {
+class li extends ae {
   constructor() {
-    const e = ni.SkyShader, t = new Xt({
+    const e = li.SkyShader, t = new Pt({
       name: e.name,
-      uniforms: Js.clone(e.uniforms),
+      uniforms: Yn.clone(e.uniforms),
       vertexShader: e.vertexShader,
       fragmentShader: e.fragmentShader,
-      side: ta,
+      side: la,
       depthWrite: !1
     });
-    super(new tn(1, 1, 1), t), this.isSky = !0;
+    super(new Wt(1, 1, 1), t), this.isSky = !0;
   }
 }
-ni.SkyShader = {
+li.SkyShader = {
   name: "SkyShader",
   uniforms: {
     turbidity: { value: 2 },
     rayleigh: { value: 1 },
     mieCoefficient: { value: 5e-3 },
     mieDirectionalG: { value: 0.8 },
-    sunPosition: { value: new ee() },
-    up: { value: new ee(0, 1, 0) }
+    sunPosition: { value: new q() },
+    up: { value: new q(0, 1, 0) }
   },
   vertexShader: (
     /* glsl */
@@ -15646,7 +16029,7 @@ ni.SkyShader = {
 		}`
   )
 };
-const Rp = ["object", "material-uniforms-turbidity-value", "material-uniforms-rayleigh-value", "material-uniforms-mieCoefficient-value", "material-uniforms-mieDirectionalG-value", "material-uniforms-sunPosition-value", "scale"], bg = /* @__PURE__ */ pe({
+const Yp = ["object", "material-uniforms-turbidity-value", "material-uniforms-rayleigh-value", "material-uniforms-mieCoefficient-value", "material-uniforms-mieDirectionalG-value", "material-uniforms-sunPosition-value", "scale"], Yg = /* @__PURE__ */ pe({
   __name: "Sky",
   props: {
     turbidity: { default: 3.4 },
@@ -15657,25 +16040,30 @@ const Rp = ["object", "material-uniforms-turbidity-value", "material-uniforms-ra
     azimuth: { default: 180 },
     distance: { default: 45e4 }
   },
-  setup(o) {
-    const e = o, t = new ni(), n = Ne(
-      () => s(e.azimuth, e.elevation)
+  setup(o, { expose: e }) {
+    const t = o, n = me(), s = new li(), i = Ne(
+      () => r(t.azimuth, t.elevation)
     );
-    function s(i, r) {
-      const a = We.degToRad(90 - r), l = We.degToRad(i);
-      return new ee().setFromSphericalCoords(1, a, l);
-    }
-    return (i, r) => (fe(), de("primitive", {
-      object: z(t),
-      "material-uniforms-turbidity-value": e.turbidity,
-      "material-uniforms-rayleigh-value": e.rayleigh,
-      "material-uniforms-mieCoefficient-value": e.mieCoefficient,
-      "material-uniforms-mieDirectionalG-value": e.mieDirectionalG,
-      "material-uniforms-sunPosition-value": n.value,
-      scale: e.distance
-    }, null, 8, Rp));
-  }
-}), Cp = ["position"], Ip = ["position"], Dp = ["scale"], Lp = ["map", "depth-test", "color-space", "color", "opacity"], Eg = /* @__PURE__ */ pe({
+    function r(a, l) {
+      const c = Ze.degToRad(90 - l), u = Ze.degToRad(a);
+      return new q().setFromSphericalCoords(1, c, u);
+    }
+    return e({
+      root: n,
+      sunPosition: i.value
+    }), (a, l) => (le(), ce("primitive", {
+      ref_key: "skyRef",
+      ref: n,
+      object: B(s),
+      "material-uniforms-turbidity-value": t.turbidity,
+      "material-uniforms-rayleigh-value": t.rayleigh,
+      "material-uniforms-mieCoefficient-value": t.mieCoefficient,
+      "material-uniforms-mieDirectionalG-value": t.mieDirectionalG,
+      "material-uniforms-sunPosition-value": i.value,
+      scale: t.distance
+    }, null, 8, Yp));
+  }
+}), Xp = ["position"], $p = ["position"], Zp = ["scale"], Kp = ["map", "depth-test", "color-space", "color", "opacity"], Xg = /* @__PURE__ */ pe({
   __name: "Smoke",
   props: {
     color: { default: "#ffffff" },
@@ -15689,81 +16077,81 @@ const Rp = ["object", "material-uniforms-turbidity-value", "material-uniforms-ra
   },
   async setup(o, { expose: e }) {
     let t, n;
-    const s = o, { width: i, depth: r, segments: a, texture: l, color: c, depthTest: u, opacity: h, speed: m } = Fe(s), p = xe(), v = xe();
+    const s = o, { width: i, depth: r, segments: a, texture: l, color: c, depthTest: u, opacity: h, speed: f } = Oe(s), d = me(), y = me();
     e({
-      value: p
+      value: d
     });
-    const _ = [...new Array(a)].map((x, M) => ({
+    const x = [...new Array(a)].map((T, E) => ({
       x: i.value / 2 - Math.random() * i.value,
       y: i.value / 2 - Math.random() * i.value,
-      scale: 0.4 + Math.sin((M + 1) / a.value * Math.PI) * ((0.2 + Math.random()) * 10),
+      scale: 0.4 + Math.sin((E + 1) / a.value * Math.PI) * ((0.2 + Math.random()) * 10),
       density: Math.max(0.2, Math.random()),
-      rotation: Math.max(2e-3, 5e-3 * Math.random()) * m.value
-    })), y = (x, M) => x / 6 * M * h.value, { map: E } = ([t, n] = fs(() => $i({ map: l.value })), t = await t, n(), t), { renderer: R, camera: T } = je(), g = Ne(() => {
-      var x;
-      return (x = R.value) == null ? void 0 : x.outputColorSpace;
-    }), { onLoop: A } = Ke();
-    return A(() => {
-      var x, M;
-      p.value && T.value && v.value && ((x = v.value) == null || x.children.forEach((d, w) => {
-        d.rotation.z += _[w].rotation;
-      }), p.value.lookAt((M = T.value) == null ? void 0 : M.position));
-    }), (x, M) => (fe(), de("TresGroup", Ye({
+      rotation: Math.max(2e-3, 5e-3 * Math.random()) * f.value
+    })), g = (T, E) => T / 6 * E * h.value, { map: v } = ([t, n] = Xn(() => Js({ map: l.value })), t = await t, n(), t), { renderer: M, camera: _ } = Ue(), w = Ne(() => {
+      var T;
+      return (T = M.value) == null ? void 0 : T.outputColorSpace;
+    }), { onLoop: P } = Xe();
+    return P(() => {
+      var T, E;
+      d.value && _.value && y.value && ((T = y.value) == null || T.children.forEach((m, b) => {
+        m.rotation.z += x[b].rotation;
+      }), d.value.lookAt((E = _.value) == null ? void 0 : E.position));
+    }), (T, E) => (le(), ce("TresGroup", Ye({
       ref_key: "smokeRef",
-      ref: p
-    }, x.$attrs), [
-      Te("TresGroup", {
+      ref: d
+    }, T.$attrs), [
+      ye("TresGroup", {
         ref_key: "groupRef",
-        ref: v,
-        position: [0, 0, z(a) / 2 * z(r)]
+        ref: y,
+        position: [0, 0, B(a) / 2 * B(r)]
       }, [
-        (fe(!0), de(la, null, ca(z(_), ({ scale: d, x: w, y: f, density: P }, I) => (fe(), de("TresMesh", {
+        (le(!0), ce(pa, null, ma(B(x), ({ scale: m, x: b, y: p, density: C }, I) => (le(), ce("TresMesh", {
           key: `${I}`,
-          position: [w, f, -I * z(r)]
+          position: [b, p, -I * B(r)]
         }, [
-          Te("TresPlaneGeometry", {
-            scale: [d, d, d],
+          ye("TresPlaneGeometry", {
+            scale: [m, m, m],
             rotation: [0, 0, 0]
-          }, null, 8, Dp),
-          Te("TresMeshStandardMaterial", {
-            map: z(E),
-            "depth-test": z(u),
-            "color-space": g.value,
-            color: z(c),
+          }, null, 8, Zp),
+          ye("TresMeshStandardMaterial", {
+            map: B(v),
+            "depth-test": B(u),
+            "color-space": w.value,
+            color: B(c),
             "depth-write": !1,
             transparent: "",
-            opacity: y(d, P)
-          }, null, 8, Lp)
-        ], 8, Ip))), 128))
-      ], 8, Cp)
+            opacity: g(m, C)
+          }, null, 8, Kp)
+        ], 8, $p))), 128))
+      ], 8, Xp)
     ], 16));
   }
 });
-function Op(o) {
-  return xr(o, {
-    normalizeValue: (e) => ln(e),
-    getDefaultValue: () => new Be(0, 0, 0),
+function qp(o) {
+  return Mr(o, {
+    normalizeValue: (e) => un(e),
+    getDefaultValue: () => new Re(0, 0, 0),
     isSingleValue: (e) => !Array.isArray(e),
     isMultipleValues: (e) => Array.isArray(e) && (e.length === 0 || !Array.isArray(e[0])),
     isMultipleValuesWithStops: (e) => Array.isArray(e) && e.length > 0 && Array.isArray(e[0]),
     isEmpty: (e) => Array.isArray(e) && e.length === 0
   });
 }
-function Ui(o) {
+function Vi(o) {
   return "isVector3" in o || Array.isArray(o) && o.length > 0 && o.every((e) => typeof e == "number");
 }
-function Fp(o) {
-  return xr(o, {
-    normalizeValue: (e) => oc(e),
+function Qp(o) {
+  return Mr(o, {
+    normalizeValue: (e) => pc(e),
     getDefaultValue: () => [0, 0, 0],
-    isSingleValue: (e) => Ui(e),
-    isMultipleValues: (e) => Array.isArray(e) && e.length > 0 && Ui(e[0]),
-    isMultipleValuesWithStops: (e) => Array.isArray(e) && e.length > 0 && Array.isArray(e[0]) && e[0].length === 2 && Ui(e[0][1]),
+    isSingleValue: (e) => Vi(e),
+    isMultipleValues: (e) => Array.isArray(e) && e.length > 0 && Vi(e[0]),
+    isMultipleValuesWithStops: (e) => Array.isArray(e) && e.length > 0 && Array.isArray(e[0]) && e[0].length === 2 && Vi(e[0][1]),
     isEmpty: (e) => Array.isArray(e) && e.length === 0
   });
 }
-function kp(o) {
-  return xr(o, {
+function Jp(o) {
+  return Mr(o, {
     normalizeValue: (e) => e,
     getDefaultValue: () => 1,
     isSingleValue: (e) => !Array.isArray(e) && typeof e < "u",
@@ -15772,7 +16160,7 @@ function kp(o) {
     isEmpty: (e) => Array.isArray(e) && e.length === 0
   });
 }
-function xr(o, e) {
+function Mr(o, e) {
   const { normalizeValue: t, getDefaultValue: n, isEmpty: s } = e, i = (l) => e.isSingleValue(l), r = (l) => e.isMultipleValues(l), a = (l) => e.isMultipleValuesWithStops(l);
   if (s(o))
     return [[0, n()]];
@@ -15785,17 +16173,17 @@ function xr(o, e) {
     return o.map(([l, c], u) => [l, t(c)]);
   return [[0, n()]];
 }
-class Up {
+class em {
   constructor(e, t) {
     oe(this, "entries");
     oe(this, "resolution");
     this.entries = e, this.resolution = t;
   }
   useTexture() {
-    return new zp(this.entries, this.resolution).use();
+    return new sm(this.entries, this.resolution).use();
   }
 }
-class wr {
+class Ar {
   constructor(e, t, n, s, i, r) {
     oe(this, "data");
     oe(this, "ref");
@@ -15804,42 +16192,42 @@ class wr {
     oe(this, "valueMax");
     oe(this, "suffix");
     oe(this, "renderToCanvasGradient");
-    this.data = Wi(e) ? e.value : e, this.ref = Wi(e) ? e : null, this.name = t, this.valueMin = n, this.valueMax = s, this.suffix = i, this.renderToCanvasGradient = r;
+    this.data = Qs(e) ? e.value : e, this.ref = Qs(e) ? e : null, this.name = t, this.valueMin = n, this.valueMax = s, this.suffix = i, this.renderToCanvasGradient = r;
   }
 }
-class Bp extends wr {
-  constructor(e, t = "color", n = 0, s = 1, i = "rgba", r = Hp) {
+class tm extends Ar {
+  constructor(e, t = "color", n = 0, s = 1, i = "rgba", r = im) {
     super(e, t, n, s, i, r);
   }
 }
-class Lo extends wr {
-  constructor(e, t = "scalar", n = 0, s = 1, i = "x", r = Gp) {
+class zo extends Ar {
+  constructor(e, t = "scalar", n = 0, s = 1, i = "x", r = rm) {
     super(e, t, n, s, i, r);
   }
 }
-class Np extends wr {
-  constructor(e, t = "scalar3", n = 0, s = 1, i = "xyz", r = jp) {
+class nm extends Ar {
+  constructor(e, t = "scalar3", n = 0, s = 1, i = "xyz", r = om) {
     super(e, t, n, s, i, r);
   }
 }
-class zp {
+class sm {
   constructor(e, t) {
     oe(this, "entries");
     oe(this, "size");
-    oe(this, "dirty", xe(0));
+    oe(this, "dirty", me(0));
     oe(this, "context");
     this.entries = e, this.size = Math.max(t, e.length);
     const n = document.createElement("canvas");
     n.height = this.size, n.width = this.size, this.context = n.getContext("2d");
   }
   use() {
-    const e = this.build(), t = xe(e);
+    const e = this.build(), t = me(e);
     for (const n of this.entries)
-      n.ref && we(n.ref, () => {
+      n.ref && Te(n.ref, () => {
         var s;
-        n.data = (s = n.ref) == null ? void 0 : s.value, ic(this.dirty);
+        n.data = (s = n.ref) == null ? void 0 : s.value, fc(this.dirty);
       });
-    return Mh(
+    return Lh(
       this.dirty,
       () => {
         this.build(e), t.value = e;
@@ -15861,35 +16249,35 @@ class zp {
       this.size,
       this.size
     ));
-    const t = e ?? new ia(
+    const t = e ?? new ua(
       this.context.getImageData(0, 0, this.size, this.size).data,
       this.size,
       this.size,
-      Uo,
-      Vi,
-      Yl,
-      Hn,
-      Hn
+      Vo,
+      qi,
+      ec,
+      Wn,
+      Wn
     );
     return t.needsUpdate = !0, t;
   }
 }
-function Ka(o, e, t, n, s) {
-  return Mf(cn(o, e, t), e, t, n, s);
+function sl(o, e, t, n, s) {
+  return Df(hn(o, e, t), e, t, n, s);
 }
-function Hp(o, e) {
-  return Op(e.data).forEach(
+function im(o, e) {
+  return qp(e.data).forEach(
     ([t, n]) => o.addColorStop(
       t,
       `rgb(${n.r * 255}, ${n.g * 255}, ${n.b * 255})`
     )
   );
 }
-function Gp(o, e) {
-  return kp(e.data).forEach(([t, n]) => {
+function rm(o, e) {
+  return Jp(e.data).forEach(([t, n]) => {
     o.addColorStop(
       t,
-      `rgb(${Ka(
+      `rgb(${sl(
         n,
         e.valueMin,
         e.valueMax,
@@ -15899,17 +16287,17 @@ function Gp(o, e) {
     );
   });
 }
-function jp(o, e) {
-  return Fp(e.data).forEach(
+function om(o, e) {
+  return Qp(e.data).forEach(
     ([t, n]) => o.addColorStop(
       t,
       `rgb(${n.map(
-        (s) => Ka(s, e.valueMin, e.valueMax, 0, 255)
+        (s) => sl(s, e.valueMin, e.valueMax, 0, 255)
       )})`
     )
   );
 }
-class Vp {
+class am {
   constructor(e = 256) {
     oe(this, "entries");
     oe(this, "resolution");
@@ -15919,18 +16307,18 @@ class Vp {
     return this.resolution = e, this;
   }
   get add() {
-    return new Xp(
+    return new cm(
       (e) => this.onAdd(e)
     );
   }
   build() {
-    return new Up(this.entries, this.resolution);
+    return new em(this.entries, this.resolution);
   }
   onAdd(e) {
-    return this.entries.push(e), new Yp(e, this);
+    return this.entries.push(e), new lm(e, this);
   }
 }
-class Yp {
+class lm {
   constructor(e, t) {
     oe(this, "entry");
     oe(this, "parent");
@@ -15962,33 +16350,33 @@ class Yp {
     return this.parent.build();
   }
 }
-class Xp {
+class cm {
   constructor(e) {
     oe(this, "onAdd");
     this.onAdd = e;
   }
   GradientTresColor(e) {
-    return this.onAdd(new Bp(e));
+    return this.onAdd(new tm(e));
   }
   Gradient01(e) {
-    return this.onAdd(new Lo(e, "zeroOne", 0, 1));
+    return this.onAdd(new zo(e, "zeroOne", 0, 1));
   }
   GradientScalar(e, t, n) {
     return this.onAdd(
-      new Lo(e, "scalar", t, n)
+      new zo(e, "scalar", t, n)
     );
   }
   GradientXyz(e, t, n) {
     return this.onAdd(
-      new Np(e, "position", t, n)
+      new nm(e, "position", t, n)
     );
   }
 }
-let Bi = null;
-function Wp() {
-  return Bi === null && (Bi = new ia(new Uint8Array([0, 0, 0, 0]), 1, 1)), Bi;
+let Wi = null;
+function um() {
+  return Wi === null && (Wi = new ua(new Uint8Array([0, 0, 0, 0]), 1, 1)), Wi;
 }
-const $p = ["object"], Mg = /* @__PURE__ */ pe({
+const hm = ["object"], $g = /* @__PURE__ */ pe({
   __name: "component",
   props: {
     map: { default: "https://raw.githubusercontent.com/Tresjs/assets/e41a93c56ec7cb5ac2d241f309e23582a5fe1fc6/textures/sparkles/particle.png" },
@@ -16017,37 +16405,37 @@ const $p = ["object"], Mg = /* @__PURE__ */ pe({
     mixSize: { default: 0 },
     mixSurfaceDistance: { default: 1 },
     mixNoise: { default: 1 },
-    blending: { default: na },
+    blending: { default: mr },
     transparent: { type: Boolean, default: !0 },
     depthWrite: { type: Boolean, default: !1 }
   },
   setup(o) {
-    const e = o, t = parseInt(rr.replace(/\D+/g, "")), n = Fe(e), s = typeof e.map == "string" ? Wp() : e.map, { texture: i, yFor: r } = new Vp(256).add.GradientTresColor(n.sequenceColor).id("sequenceColor").add.Gradient01(n.sequenceAlpha).id("sequenceAlpha").add.Gradient01(n.sequenceSurfaceDistance).id("sequenceSurfaceDistance").add.Gradient01(n.sequenceSize).id("sequenceSize").add.GradientXyz(n.sequenceOffset, -1, 1).id("sequenceOffset").add.GradientXyz(n.sequenceNoise, 0, 1).id("sequenceNoise").build().useTexture(), a = {
+    const e = o, t = parseInt(ur.replace(/\D+/g, "")), n = Oe(e), s = typeof e.map == "string" ? um() : e.map, { texture: i, yFor: r } = new am(256).add.GradientTresColor(n.sequenceColor).id("sequenceColor").add.Gradient01(n.sequenceAlpha).id("sequenceAlpha").add.Gradient01(n.sequenceSurfaceDistance).id("sequenceSurfaceDistance").add.Gradient01(n.sequenceSize).id("sequenceSize").add.GradientXyz(n.sequenceOffset, -1, 1).id("sequenceOffset").add.GradientXyz(n.sequenceNoise, 0, 1).id("sequenceNoise").build().useTexture(), a = {
       blending: e.blending,
       transparent: e.transparent,
       depthWrite: e.depthWrite,
       uniforms: {
-        uMap: new Re(s),
-        uPixelRatio: new Re(1),
-        uNormal: new Re(St.DEFAULT_UP),
-        uNormalThreshold: new Re(e.normalThreshold),
-        uTime: new Re(0),
-        uCooldownRatio: new Re(1),
-        uSize: new Re(e.size),
-        uAlpha: new Re(e.alpha),
-        uOffset: new Re(e.offset),
-        uSurfaceDistance: new Re(e.surfaceDistance),
-        uNoiseScale: new Re(e.noiseScale),
-        uScaleNoise: new Re(e.scaleNoise),
-        uOffsetNoise: new Re(e.offsetNoise),
-        uLifetimeNoise: new Re(e.lifetimeNoise),
-        uMixColor: new Re(e.mixColor),
-        uMixAlpha: new Re(e.mixAlpha),
-        uMixOffset: new Re(e.mixOffset),
-        uMixSize: new Re(e.mixSize),
-        uMixSurfaceDistance: new Re(e.mixSurfaceDistance),
-        uMixNoise: new Re(e.mixNoise),
-        uInfoTexture: new Re(i.value)
+        uMap: new we(s),
+        uPixelRatio: new we(1),
+        uNormal: new we(Tt.DEFAULT_UP),
+        uNormalThreshold: new we(e.normalThreshold),
+        uTime: new we(0),
+        uCooldownRatio: new we(1),
+        uSize: new we(e.size),
+        uAlpha: new we(e.alpha),
+        uOffset: new we(e.offset),
+        uSurfaceDistance: new we(e.surfaceDistance),
+        uNoiseScale: new we(e.noiseScale),
+        uScaleNoise: new we(e.scaleNoise),
+        uOffsetNoise: new we(e.offsetNoise),
+        uLifetimeNoise: new we(e.lifetimeNoise),
+        uMixColor: new we(e.mixColor),
+        uMixAlpha: new we(e.mixAlpha),
+        uMixOffset: new we(e.mixOffset),
+        uMixSize: new we(e.mixSize),
+        uMixSurfaceDistance: new we(e.mixSurfaceDistance),
+        uMixNoise: new we(e.mixNoise),
+        uInfoTexture: new we(i.value)
       },
       vertexShader: `
     uniform float uPixelRatio;
@@ -16122,9 +16510,9 @@ const $p = ["object"], Mg = /* @__PURE__ */ pe({
       #include <tonemapping_fragment>
       #include <${t >= 154 ? "colorspace_fragment" : "encodings_fragment"}>
     }`
-    }, l = new Xt(a), c = new Zo(void 0, l), u = l.uniforms, h = { immediate: !0 };
+    }, l = new Pt(a), c = new na(void 0, l), u = l.uniforms, h = { immediate: !0 };
     [
-      [u.uPixelRatio, je().sizes.aspectRatio],
+      [u.uPixelRatio, Ue().sizes.aspectRatio],
       [u.uSize, n.size],
       [u.uNormalThreshold, n.normalThreshold],
       [u.uAlpha, n.alpha],
@@ -16138,52 +16526,52 @@ const $p = ["object"], Mg = /* @__PURE__ */ pe({
       [u.uMixNoise, n.mixNoise],
       [u.uInfoTexture, i]
     ].forEach(
-      ([R, T]) => we(
-        T,
+      ([M, _]) => Te(
+        _,
         () => {
-          R.value = T.value;
+          M.value = _.value;
         },
         h
       )
-    ), we(
+    ), Te(
       [n.noiseScale, n.lifetimeSec],
       () => {
         u.uNoiseScale.value = n.noiseScale.value * n.lifetimeSec.value;
       },
       h
-    ), we(
+    ), Te(
       [n.lifetimeSec, n.cooldownSec],
       () => {
         u.uCooldownRatio.value = n.cooldownSec.value / n.lifetimeSec.value;
       },
       h
-    ), we(n.map, () => {
-      typeof n.map.value == "string" ? $i([n.map.value]).then((R) => l.uniforms.uMap.value = R) : l.uniforms.uMap.value = n.map.value;
+    ), Te(n.map, () => {
+      typeof n.map.value == "string" ? Js([n.map.value]).then((M) => l.uniforms.uMap.value = M) : l.uniforms.uMap.value = n.map.value;
     });
-    const p = new He(), v = new ee();
-    Ke().onLoop(({ elapsed: R }) => {
-      c.getWorldQuaternion(p), v.copy(e.directionalLight ? e.directionalLight.position : St.DEFAULT_UP).normalize(), v.applyQuaternion(p.invert()), l.uniforms.uNormal.value = v, l.uniforms.uTime.value = R / (e.cooldownSec + e.lifetimeSec);
+    const d = new He(), y = new q();
+    Xe().onLoop(({ elapsed: M }) => {
+      c.getWorldQuaternion(d), y.copy(e.directionalLight ? e.directionalLight.position : Tt.DEFAULT_UP).normalize(), y.applyQuaternion(d.invert()), l.uniforms.uNormal.value = y, l.uniforms.uTime.value = M / (e.cooldownSec + e.lifetimeSec);
     });
-    function _(R) {
-      return R && "isObject3D" in R;
+    function x(M) {
+      return M && "isObject3D" in M;
     }
-    function y(R) {
-      return R && "isBufferGeometry" in R;
+    function g(M) {
+      return M && "isBufferGeometry" in M;
     }
-    ds(() => {
-      e.geometry ? y(e.geometry) ? c.geometry.copy(e.geometry) : _(e.geometry) && "geometry" in e.geometry && y(e.geometry.geometry) && c.geometry.copy(e.geometry.geometry) : _(c.parent) && "geometry" in c.parent && y(c.parent.geometry) ? c.geometry.copy(c.parent.geometry) : c.geometry = new Xl(1, 16), typeof e.map == "string" && $i([e.map]).then((R) => l.uniforms.uMap.value = R);
+    $n(() => {
+      e.geometry ? g(e.geometry) ? c.geometry.copy(e.geometry) : x(e.geometry) && "geometry" in e.geometry && g(e.geometry.geometry) && c.geometry.copy(e.geometry.geometry) : x(c.parent) && "geometry" in c.parent && g(c.parent.geometry) ? c.geometry.copy(c.parent.geometry) : c.geometry = new tc(1, 16), typeof e.map == "string" && Js([e.map]).then((M) => l.uniforms.uMap.value = M);
     }), ot(() => {
-      var R;
-      (R = l.uniforms.uMap.value) == null || R.dispose(), i.value.dispose(), l.dispose();
+      var M;
+      (M = l.uniforms.uMap.value) == null || M.dispose(), i.value.dispose(), l.dispose();
     });
-    const E = xe();
-    return (R, T) => (fe(), de("primitive", {
+    const v = me();
+    return (M, _) => (le(), ce("primitive", {
       ref_key: "sparkleRef",
-      ref: E,
-      object: z(c)
-    }, null, 8, $p));
+      ref: v,
+      object: B(c)
+    }, null, 8, hm));
   }
-}), Zp = ["position", "a-scale"], Kp = ["size", "size-attenuation", "transparent", "alpha-test", "alpha-map"], Sg = /* @__PURE__ */ pe({
+}), fm = ["position", "a-scale"], dm = ["size", "size-attenuation", "transparent", "alpha-test", "alpha-map"], Zg = /* @__PURE__ */ pe({
   __name: "Stars",
   props: {
     size: { default: 0.1 },
@@ -16196,104 +16584,341 @@ const $p = ["object"], Mg = /* @__PURE__ */ pe({
     alphaMap: { default: null }
   },
   setup(o, { expose: e }) {
-    const t = o, n = ue(), s = ue(), { radius: i, depth: r, count: a, size: l, sizeAttenuation: c, transparent: u, alphaMap: h, alphaTest: m } = Fe(t), p = () => {
-      let _ = i.value + r.value;
-      const y = Ne(() => r.value / a.value), E = [], R = Array.from(
+    const t = o, n = ue(), s = ue(), { radius: i, depth: r, count: a, size: l, sizeAttenuation: c, transparent: u, alphaMap: h, alphaTest: f } = Oe(t), d = () => {
+      let x = i.value + r.value;
+      const g = Ne(() => r.value / a.value), v = [], M = Array.from(
         { length: a.value },
         () => (0.5 + 0.5 * Math.random()) * 4
-      ), T = (g) => new ee().setFromSpherical(new Ws(g, Math.acos(1 - Math.random() * 2), Math.random() * 2 * Math.PI)).toArray();
-      for (let g = 0; g < a.value; g++)
-        _ -= y.value * Math.random(), E.push(...T(_));
-      n.value = new Float32Array(E), s.value = new Float32Array(R);
+      ), _ = (w) => new q().setFromSpherical(new qs(w, Math.acos(1 - Math.random() * 2), Math.random() * 2 * Math.PI)).toArray();
+      for (let w = 0; w < a.value; w++)
+        x -= g.value * Math.random(), v.push(..._(x));
+      n.value = new Float32Array(v), s.value = new Float32Array(M);
     };
-    ft(() => {
-      p();
+    lt(() => {
+      d();
     });
-    const v = xe();
+    const y = me();
     return e({
-      value: v
-    }), (_, y) => (fe(), de("TresPoints", {
+      value: y
+    }), (x, g) => (le(), ce("TresPoints", {
       ref_key: "starsRef",
-      ref: v
+      ref: y
     }, [
-      Te("TresBufferGeometry", {
+      ye("TresBufferGeometry", {
         position: [n.value, 3],
         "a-scale": [s.value, 1]
-      }, null, 8, Zp),
-      Te("TresPointsMaterial", {
-        size: z(l),
-        "size-attenuation": z(c),
-        transparent: z(u),
-        "alpha-test": z(m),
-        "alpha-map": z(h)
-      }, null, 8, Kp)
+      }, null, 8, fm),
+      ye("TresPointsMaterial", {
+        size: B(l),
+        "size-attenuation": B(c),
+        transparent: B(u),
+        "alpha-test": B(f),
+        "alpha-map": B(h)
+      }, null, 8, dm)
     ], 512));
   }
 });
-let zt;
-const Ag = (o = "body") => {
-  zt || (zt = new ac({
+class pm extends ae {
+  constructor(e, t = {}) {
+    super(e), this.isWater = !0;
+    const n = this, s = t.textureWidth !== void 0 ? t.textureWidth : 512, i = t.textureHeight !== void 0 ? t.textureHeight : 512, r = t.clipBias !== void 0 ? t.clipBias : 0, a = t.alpha !== void 0 ? t.alpha : 1, l = t.time !== void 0 ? t.time : 0, c = t.waterNormals !== void 0 ? t.waterNormals : null, u = t.sunDirection !== void 0 ? t.sunDirection : new q(0.70707, 0.70707, 0), h = new Re(t.sunColor !== void 0 ? t.sunColor : 16777215), f = new Re(t.waterColor !== void 0 ? t.waterColor : 8355711), d = t.eye !== void 0 ? t.eye : new q(0, 0, 0), y = t.distortionScale !== void 0 ? t.distortionScale : 20, x = t.side !== void 0 ? t.side : _s, g = t.fog !== void 0 ? t.fog : !1, v = new ii(), M = new q(), _ = new q(), w = new q(), P = new Pe(), T = new q(0, 0, -1), E = new rt(), m = new q(), b = new q(), p = new rt(), C = new Pe(), I = new wt(), K = new pn(s, i), z = {
+      name: "MirrorShader",
+      uniforms: Yn.merge([
+        jn.fog,
+        jn.lights,
+        {
+          normalSampler: { value: null },
+          mirrorSampler: { value: null },
+          alpha: { value: 1 },
+          time: { value: 0 },
+          size: { value: 1 },
+          distortionScale: { value: 20 },
+          textureMatrix: { value: new Pe() },
+          sunColor: { value: new Re(8355711) },
+          sunDirection: { value: new q(0.70707, 0.70707, 0) },
+          eye: { value: new q() },
+          waterColor: { value: new Re(5592405) }
+        }
+      ]),
+      vertexShader: (
+        /* glsl */
+        `
+				uniform mat4 textureMatrix;
+				uniform float time;
+
+				varying vec4 mirrorCoord;
+				varying vec4 worldPosition;
+
+				#include <common>
+				#include <fog_pars_vertex>
+				#include <shadowmap_pars_vertex>
+				#include <logdepthbuf_pars_vertex>
+
+				void main() {
+					mirrorCoord = modelMatrix * vec4( position, 1.0 );
+					worldPosition = mirrorCoord.xyzw;
+					mirrorCoord = textureMatrix * mirrorCoord;
+					vec4 mvPosition =  modelViewMatrix * vec4( position, 1.0 );
+					gl_Position = projectionMatrix * mvPosition;
+
+				#include <beginnormal_vertex>
+				#include <defaultnormal_vertex>
+				#include <logdepthbuf_vertex>
+				#include <fog_vertex>
+				#include <shadowmap_vertex>
+			}`
+      ),
+      fragmentShader: (
+        /* glsl */
+        `
+				uniform sampler2D mirrorSampler;
+				uniform float alpha;
+				uniform float time;
+				uniform float size;
+				uniform float distortionScale;
+				uniform sampler2D normalSampler;
+				uniform vec3 sunColor;
+				uniform vec3 sunDirection;
+				uniform vec3 eye;
+				uniform vec3 waterColor;
+
+				varying vec4 mirrorCoord;
+				varying vec4 worldPosition;
+
+				vec4 getNoise( vec2 uv ) {
+					vec2 uv0 = ( uv / 103.0 ) + vec2(time / 17.0, time / 29.0);
+					vec2 uv1 = uv / 107.0-vec2( time / -19.0, time / 31.0 );
+					vec2 uv2 = uv / vec2( 8907.0, 9803.0 ) + vec2( time / 101.0, time / 97.0 );
+					vec2 uv3 = uv / vec2( 1091.0, 1027.0 ) - vec2( time / 109.0, time / -113.0 );
+					vec4 noise = texture2D( normalSampler, uv0 ) +
+						texture2D( normalSampler, uv1 ) +
+						texture2D( normalSampler, uv2 ) +
+						texture2D( normalSampler, uv3 );
+					return noise * 0.5 - 1.0;
+				}
+
+				void sunLight( const vec3 surfaceNormal, const vec3 eyeDirection, float shiny, float spec, float diffuse, inout vec3 diffuseColor, inout vec3 specularColor ) {
+					vec3 reflection = normalize( reflect( -sunDirection, surfaceNormal ) );
+					float direction = max( 0.0, dot( eyeDirection, reflection ) );
+					specularColor += pow( direction, shiny ) * sunColor * spec;
+					diffuseColor += max( dot( sunDirection, surfaceNormal ), 0.0 ) * sunColor * diffuse;
+				}
+
+				#include <common>
+				#include <packing>
+				#include <bsdfs>
+				#include <fog_pars_fragment>
+				#include <logdepthbuf_pars_fragment>
+				#include <lights_pars_begin>
+				#include <shadowmap_pars_fragment>
+				#include <shadowmask_pars_fragment>
+
+				void main() {
+
+					#include <logdepthbuf_fragment>
+					vec4 noise = getNoise( worldPosition.xz * size );
+					vec3 surfaceNormal = normalize( noise.xzy * vec3( 1.5, 1.0, 1.5 ) );
+
+					vec3 diffuseLight = vec3(0.0);
+					vec3 specularLight = vec3(0.0);
+
+					vec3 worldToEye = eye-worldPosition.xyz;
+					vec3 eyeDirection = normalize( worldToEye );
+					sunLight( surfaceNormal, eyeDirection, 100.0, 2.0, 0.5, diffuseLight, specularLight );
+
+					float distance = length(worldToEye);
+
+					vec2 distortion = surfaceNormal.xz * ( 0.001 + 1.0 / distance ) * distortionScale;
+					vec3 reflectionSample = vec3( texture2D( mirrorSampler, mirrorCoord.xy / mirrorCoord.w + distortion ) );
+
+					float theta = max( dot( eyeDirection, surfaceNormal ), 0.0 );
+					float rf0 = 0.3;
+					float reflectance = rf0 + ( 1.0 - rf0 ) * pow( ( 1.0 - theta ), 5.0 );
+					vec3 scatter = max( 0.0, dot( surfaceNormal, eyeDirection ) ) * waterColor;
+					vec3 albedo = mix( ( sunColor * diffuseLight * 0.3 + scatter ) * getShadowMask(), ( vec3( 0.1 ) + reflectionSample * 0.9 + reflectionSample * specularLight ), reflectance);
+					vec3 outgoingLight = albedo;
+					gl_FragColor = vec4( outgoingLight, alpha );
+
+					#include <tonemapping_fragment>
+					#include <colorspace_fragment>
+					#include <fog_fragment>	
+				}`
+      )
+    }, Y = new Pt({
+      name: z.name,
+      uniforms: Yn.clone(z.uniforms),
+      vertexShader: z.vertexShader,
+      fragmentShader: z.fragmentShader,
+      lights: !0,
+      side: x,
+      fog: g
+    });
+    Y.uniforms.mirrorSampler.value = K.texture, Y.uniforms.textureMatrix.value = C, Y.uniforms.alpha.value = a, Y.uniforms.time.value = l, Y.uniforms.normalSampler.value = c, Y.uniforms.sunColor.value = h, Y.uniforms.waterColor.value = f, Y.uniforms.sunDirection.value = u, Y.uniforms.distortionScale.value = y, Y.uniforms.eye.value = d, n.material = Y, n.onBeforeRender = function(W, X, V) {
+      if (_.setFromMatrixPosition(n.matrixWorld), w.setFromMatrixPosition(V.matrixWorld), P.extractRotation(n.matrixWorld), M.set(0, 0, 1), M.applyMatrix4(P), m.subVectors(_, w), m.dot(M) > 0)
+        return;
+      m.reflect(M).negate(), m.add(_), P.extractRotation(V.matrixWorld), T.set(0, 0, -1), T.applyMatrix4(P), T.add(w), b.subVectors(_, T), b.reflect(M).negate(), b.add(_), I.position.copy(m), I.up.set(0, 1, 0), I.up.applyMatrix4(P), I.up.reflect(M), I.lookAt(b), I.far = V.far, I.updateMatrixWorld(), I.projectionMatrix.copy(V.projectionMatrix), C.set(
+        0.5,
+        0,
+        0,
+        0.5,
+        0,
+        0.5,
+        0,
+        0.5,
+        0,
+        0,
+        0.5,
+        0.5,
+        0,
+        0,
+        0,
+        1
+      ), C.multiply(I.projectionMatrix), C.multiply(I.matrixWorldInverse), v.setFromNormalAndCoplanarPoint(M, _), v.applyMatrix4(I.matrixWorldInverse), E.set(v.normal.x, v.normal.y, v.normal.z, v.constant);
+      const te = I.projectionMatrix;
+      p.x = (Math.sign(E.x) + te.elements[8]) / te.elements[0], p.y = (Math.sign(E.y) + te.elements[9]) / te.elements[5], p.z = -1, p.w = (1 + te.elements[10]) / te.elements[14], E.multiplyScalar(2 / E.dot(p)), te.elements[2] = E.x, te.elements[6] = E.y, te.elements[10] = E.z + 1 - r, te.elements[14] = E.w, d.setFromMatrixPosition(V.matrixWorld);
+      const se = W.getRenderTarget(), fe = W.xr.enabled, H = W.shadowMap.autoUpdate;
+      n.visible = !1, W.xr.enabled = !1, W.shadowMap.autoUpdate = !1, W.setRenderTarget(K), W.state.buffers.depth.setMask(!0), W.autoClear === !1 && W.clear(), W.render(X, I), n.visible = !0, W.xr.enabled = fe, W.shadowMap.autoUpdate = H, W.setRenderTarget(se);
+      const k = V.viewport;
+      k !== void 0 && W.state.viewport(k);
+    };
+  }
+}
+const mm = ["rotation-x", "args"], gm = /* @__PURE__ */ ye("TresPlaneGeometry", { args: [1e4, 1e4] }, null, -1), Kg = /* @__PURE__ */ pe({
+  __name: "Ocean",
+  props: {
+    textureWidth: { default: 512 },
+    textureHeight: { default: 512 },
+    waterNormals: { default: "https://raw.githubusercontent.com/Tresjs/assets/main/textures/water-normals/Water_1_M_Normal.jpg" },
+    sunDirection: { default: () => new q() },
+    sunColor: { default: 16777215 },
+    waterColor: { default: 7695 },
+    distortionScale: { default: 3.7 },
+    size: { default: 1 },
+    clipBias: { default: 0 },
+    alpha: { default: 1 },
+    side: { default: _s }
+  },
+  async setup(o, { expose: e }) {
+    let t, n;
+    const s = o, {
+      textureWidth: i,
+      textureHeight: r,
+      waterNormals: a,
+      sunDirection: l,
+      sunColor: c,
+      waterColor: u,
+      distortionScale: h,
+      size: f,
+      clipBias: d,
+      alpha: y,
+      side: x
+    } = Oe(s), { extend: g, scene: v } = Ue();
+    g({ Water: pm });
+    const M = me(), _ = me(), w = v.value.fog !== void 0;
+    e({
+      root: M
+    }), v.value.traverse((E) => {
+      E.hasOwnProperty("isSky") && (_.value = E);
+    }), $n(async () => {
+      if (await ha(), _.value) {
+        const E = _.value.material.uniforms.sunPosition.value;
+        M.value.material.uniforms.sunDirection.value.copy(E);
+      }
+    });
+    const { normalMap: P } = ([t, n] = Xn(() => Js({ normalMap: a.value })), t = await t, n(), t);
+    P.wrapS = P.wrapT = En;
+    const { onLoop: T } = Xe();
+    return T(({ delta: E }) => {
+      M.value.material.uniforms.time.value += E;
+    }), (E, m) => (le(), ce("TresWater", {
+      ref_key: "waterRef",
+      ref: M,
+      "rotation-x": -Math.PI / 2,
+      args: [void 0, {
+        textureWidth: B(i),
+        textureHeight: B(r),
+        waterNormals: B(P),
+        sunDirection: B(l),
+        sunColor: B(c),
+        waterColor: B(u),
+        distortionScale: B(h),
+        fog: w,
+        size: B(f),
+        clipBias: B(d),
+        alpha: B(y),
+        side: B(x)
+      }]
+    }, [
+      Ve(E.$slots, "default", {}, () => [
+        gm
+      ])
+    ], 8, mm));
+  }
+});
+let Gt;
+const qg = (o = "body") => {
+  Gt || (Gt = new mc({
     container: document.querySelector(o)
-  }), zt.element.style.position = "absolute", zt.element.style.top = "1rem", zt.element.style.right = "1rem", zt.element.style.zIndex = "9999");
-  const { logWarning: e } = gr();
+  }), Gt.element.style.position = "absolute", Gt.element.style.top = "1rem", Gt.element.style.right = "1rem", Gt.element.style.zIndex = "9999");
+  const { logWarning: e } = Tr();
   e("useTweakPane is deprecated as of Cientos v3.7.0 and will no longer be part of this package. Please migrate to @tresjs/leches package https://github.com/Tresjs/leches or v-tweakpane https://github.com/vinayakkulkarni/v-tweakpane instead.");
   function t() {
-    zt && zt.dispose();
+    Gt && Gt.dispose();
   }
-  return ds(() => {
-    const { resume: n } = Ke();
+  return $n(() => {
+    const { resume: n } = Xe();
     n();
   }), ot(() => {
     t();
-  }), { pane: zt, disposeTweakPane: t };
+  }), { pane: Gt, disposeTweakPane: t };
 };
-var qa = { exports: {} };
+var il = { exports: {} };
 (function(o, e) {
   (function(t, n) {
     o.exports = n();
-  })(If, function() {
+  })(Uf, function() {
     var t = function() {
-      function n(p) {
-        return r.appendChild(p.dom), p;
+      function n(d) {
+        return r.appendChild(d.dom), d;
       }
-      function s(p) {
-        for (var v = 0; v < r.children.length; v++)
-          r.children[v].style.display = v === p ? "block" : "none";
-        i = p;
+      function s(d) {
+        for (var y = 0; y < r.children.length; y++)
+          r.children[y].style.display = y === d ? "block" : "none";
+        i = d;
       }
       var i = 0, r = document.createElement("div");
-      r.style.cssText = "position:fixed;top:0;left:0;cursor:pointer;opacity:0.9;z-index:10000", r.addEventListener("click", function(p) {
-        p.preventDefault(), s(++i % r.children.length);
+      r.style.cssText = "position:fixed;top:0;left:0;cursor:pointer;opacity:0.9;z-index:10000", r.addEventListener("click", function(d) {
+        d.preventDefault(), s(++i % r.children.length);
       }, !1);
       var a = (performance || Date).now(), l = a, c = 0, u = n(new t.Panel("FPS", "#0ff", "#002")), h = n(new t.Panel("MS", "#0f0", "#020"));
       if (self.performance && self.performance.memory)
-        var m = n(new t.Panel("MB", "#f08", "#201"));
+        var f = n(new t.Panel("MB", "#f08", "#201"));
       return s(0), { REVISION: 16, dom: r, addPanel: n, showPanel: s, begin: function() {
         a = (performance || Date).now();
       }, end: function() {
         c++;
-        var p = (performance || Date).now();
-        if (h.update(p - a, 200), p > l + 1e3 && (u.update(1e3 * c / (p - l), 100), l = p, c = 0, m)) {
-          var v = performance.memory;
-          m.update(v.usedJSHeapSize / 1048576, v.jsHeapSizeLimit / 1048576);
+        var d = (performance || Date).now();
+        if (h.update(d - a, 200), d > l + 1e3 && (u.update(1e3 * c / (d - l), 100), l = d, c = 0, f)) {
+          var y = performance.memory;
+          f.update(y.usedJSHeapSize / 1048576, y.jsHeapSizeLimit / 1048576);
         }
-        return p;
+        return d;
       }, update: function() {
         a = this.end();
       }, domElement: r, setMode: s };
     };
     return t.Panel = function(n, s, i) {
-      var r = 1 / 0, a = 0, l = Math.round, c = l(window.devicePixelRatio || 1), u = 80 * c, h = 48 * c, m = 3 * c, p = 2 * c, v = 3 * c, _ = 15 * c, y = 74 * c, E = 30 * c, R = document.createElement("canvas");
-      R.width = u, R.height = h, R.style.cssText = "width:80px;height:48px";
-      var T = R.getContext("2d");
-      return T.font = "bold " + 9 * c + "px Helvetica,Arial,sans-serif", T.textBaseline = "top", T.fillStyle = i, T.fillRect(0, 0, u, h), T.fillStyle = s, T.fillText(n, m, p), T.fillRect(v, _, y, E), T.fillStyle = i, T.globalAlpha = 0.9, T.fillRect(v, _, y, E), { dom: R, update: function(g, A) {
-        r = Math.min(r, g), a = Math.max(a, g), T.fillStyle = i, T.globalAlpha = 1, T.fillRect(0, 0, u, _), T.fillStyle = s, T.fillText(l(g) + " " + n + " (" + l(r) + "-" + l(a) + ")", m, p), T.drawImage(R, v + c, _, y - c, E, v, _, y - c, E), T.fillRect(v + y - c, _, c, E), T.fillStyle = i, T.globalAlpha = 0.9, T.fillRect(v + y - c, _, c, l((1 - g / A) * E));
+      var r = 1 / 0, a = 0, l = Math.round, c = l(window.devicePixelRatio || 1), u = 80 * c, h = 48 * c, f = 3 * c, d = 2 * c, y = 3 * c, x = 15 * c, g = 74 * c, v = 30 * c, M = document.createElement("canvas");
+      M.width = u, M.height = h, M.style.cssText = "width:80px;height:48px";
+      var _ = M.getContext("2d");
+      return _.font = "bold " + 9 * c + "px Helvetica,Arial,sans-serif", _.textBaseline = "top", _.fillStyle = i, _.fillRect(0, 0, u, h), _.fillStyle = s, _.fillText(n, f, d), _.fillRect(y, x, g, v), _.fillStyle = i, _.globalAlpha = 0.9, _.fillRect(y, x, g, v), { dom: M, update: function(w, P) {
+        r = Math.min(r, w), a = Math.max(a, w), _.fillStyle = i, _.globalAlpha = 1, _.fillRect(0, 0, u, x), _.fillStyle = s, _.fillText(l(w) + " " + n + " (" + l(r) + "-" + l(a) + ")", f, d), _.drawImage(M, y + c, x, g - c, v, y, x, g - c, v), _.fillRect(y + g - c, x, c, v), _.fillStyle = i, _.globalAlpha = 0.9, _.fillRect(y + g - c, x, c, l((1 - w / P) * v));
       } };
     }, t;
   });
-})(qa);
-var qp = qa.exports;
-const Qp = /* @__PURE__ */ ys(qp), Pg = pe({
+})(il);
+var vm = il.exports;
+const ym = /* @__PURE__ */ Es(vm), Qg = pe({
   name: "Stats",
   props: {
     showPanel: {
@@ -16302,17 +16927,17 @@ const Qp = /* @__PURE__ */ ys(qp), Pg = pe({
     }
   },
   setup(o, { expose: e }) {
-    const t = new Qp();
+    const t = new ym();
     e({ stats: t });
     const n = document.body;
     t.showPanel(o.showPanel || 0), n == null || n.appendChild(t.dom);
-    const { onBeforeLoop: s, onAfterLoop: i, resume: r } = Ke();
+    const { onBeforeLoop: s, onAfterLoop: i, resume: r } = Xe();
     r(), s(() => t.begin()), i(() => t.end()), ot(() => {
       n == null || n.removeChild(t.dom);
     });
   }
 });
-class Jp {
+class _m {
   constructor(e, t, n) {
     this.name = e, this.fg = t, this.bg = n, this.PR = Math.round(window.devicePixelRatio || 1), this.WIDTH = 90 * this.PR, this.HEIGHT = 48 * this.PR, this.TEXT_X = 3 * this.PR, this.TEXT_Y = 2 * this.PR, this.GRAPH_X = 3 * this.PR, this.GRAPH_Y = 15 * this.PR, this.GRAPH_WIDTH = 84 * this.PR, this.GRAPH_HEIGHT = 30 * this.PR, this.canvas = document.createElement("canvas"), this.canvas.width = 90 * this.PR, this.canvas.height = 48 * this.PR, this.canvas.style.width = "90px", this.canvas.style.position = "absolute", this.canvas.style.height = "48px", this.canvas.style.cssText = "width:90px;height:48px", this.context = this.canvas.getContext("2d"), this.context && (this.context.font = "bold " + 9 * this.PR + "px Helvetica,Arial,sans-serif", this.context.textBaseline = "top", this.context.fillStyle = this.bg, this.context.fillRect(0, 0, this.WIDTH, this.HEIGHT), this.context.fillStyle = this.fg, this.context.fillText(this.name, this.TEXT_X, this.TEXT_Y), this.context.fillRect(this.GRAPH_X, this.GRAPH_Y, this.GRAPH_WIDTH, this.GRAPH_HEIGHT), this.context.fillStyle = this.bg, this.context.globalAlpha = 0.9, this.context.fillRect(this.GRAPH_X, this.GRAPH_Y, this.GRAPH_WIDTH, this.GRAPH_HEIGHT));
   }
@@ -16321,18 +16946,21 @@ class Jp {
     this.context && (r = Math.min(r, e), a = Math.max(n, e), s = Math.max(s, t), this.context.fillStyle = this.bg, this.context.globalAlpha = 1, this.context.fillRect(0, 0, this.WIDTH, this.GRAPH_Y), this.context.fillStyle = this.fg, this.context.fillText(e.toFixed(i) + " " + this.name + " (" + r.toFixed(i) + "-" + parseFloat(a.toFixed(i)) + ")", this.TEXT_X, this.TEXT_Y), this.context.drawImage(this.canvas, this.GRAPH_X + this.PR, this.GRAPH_Y, this.GRAPH_WIDTH - this.PR, this.GRAPH_HEIGHT, this.GRAPH_X, this.GRAPH_Y, this.GRAPH_WIDTH - this.PR, this.GRAPH_HEIGHT), this.context.fillRect(this.GRAPH_X + this.GRAPH_WIDTH - this.PR, this.GRAPH_Y, this.PR, this.GRAPH_HEIGHT), this.context.fillStyle = this.bg, this.context.globalAlpha = 0.9, this.context.fillRect(this.GRAPH_X + this.GRAPH_WIDTH - this.PR, this.GRAPH_Y, this.PR, (1 - t / s) * this.GRAPH_HEIGHT));
   }
 }
-const Qa = class Ys {
+const rl = class Hn {
   constructor({ logsPerSecond: e = 20, samplesLog: t = 100, samplesGraph: n = 10, precision: s = 2, minimal: i = !1, horizontal: r = !0, mode: a = 0 } = {}) {
-    this.totalCpuDuration = 0, this.totalGpuDuration = 0, this.totalFps = 0, this.activeQuery = null, this.gpuQueries = [], this.renderCount = 0, this.mode = a, this.horizontal = r, this.dom = document.createElement("div"), this.dom.style.cssText = "position:fixed;top:0;left:0;opacity:0.9;z-index:10000;", i && (this.dom.style.cssText += "cursor:pointer"), this.gl = null, this.query = null, this.isRunningCPUProfiling = !1, this.minimal = i, this.beginTime = (performance || Date).now(), this.prevTime = this.beginTime, this.prevCpuTime = this.beginTime, this.frames = 0, this.renderCount = 0, this.threeRendererPatched = !1, this.averageCpu = {
+    this.totalCpuDuration = 0, this.totalGpuDuration = 0, this.totalGpuDurationCompute = 0, this.totalFps = 0, this.activeQuery = null, this.gpuQueries = [], this.renderCount = 0, this.mode = a, this.horizontal = r, this.dom = document.createElement("div"), this.dom.style.cssText = "position:fixed;top:0;left:0;opacity:0.9;z-index:10000;", i && (this.dom.style.cssText += "cursor:pointer"), this.gl = null, this.query = null, this.isRunningCPUProfiling = !1, this.minimal = i, this.beginTime = (performance || Date).now(), this.prevTime = this.beginTime, this.prevCpuTime = this.beginTime, this.frames = 0, this.renderCount = 0, this.threeRendererPatched = !1, this.averageCpu = {
       logs: [],
       graph: []
     }, this.averageGpu = {
       logs: [],
       graph: []
-    }, this.queryCreated = !1, this.fpsPanel = this.addPanel(new Ys.Panel("FPS", "#0ff", "#002"), 0), this.msPanel = this.addPanel(new Ys.Panel("CPU", "#0f0", "#020"), 1), this.gpuPanel = null, this.samplesLog = t, this.samplesGraph = n, this.precision = s, this.logsPerSecond = e, this.minimal ? (this.dom.addEventListener("click", (l) => {
+    }, this.averageGpuCompute = {
+      logs: [],
+      graph: []
+    }, this.queryCreated = !1, this.fpsPanel = this.addPanel(new Hn.Panel("FPS", "#0ff", "#002"), 0), this.msPanel = this.addPanel(new Hn.Panel("CPU", "#0f0", "#020"), 1), this.gpuPanel = null, this.gpuPanelCompute = null, this.samplesLog = t, this.samplesGraph = n, this.precision = s, this.logsPerSecond = e, this.minimal ? (this.dom.addEventListener("click", (l) => {
       l.preventDefault(), this.showPanel(++this.mode % this.dom.children.length);
     }, !1), this.mode = a, this.showPanel(this.mode)) : window.addEventListener("resize", () => {
-      this.resizePanel(this.fpsPanel, 0), this.resizePanel(this.msPanel, 1), this.gpuPanel && this.resizePanel(this.gpuPanel, 2);
+      this.resizePanel(this.fpsPanel, 0), this.resizePanel(this.msPanel, 1), this.gpuPanel && this.resizePanel(this.gpuPanel, 2), this.gpuPanelCompute && this.resizePanel(this.gpuPanelCompute, 3);
     });
   }
   patchThreeRenderer(e) {
@@ -16354,7 +16982,7 @@ const Qa = class Ys {
     }
     this.mode = e;
   }
-  init(e) {
+  async init(e) {
     if (!e) {
       console.error('Stats: The "canvas" parameter is undefined.');
       return;
@@ -16362,10 +16990,12 @@ const Qa = class Ys {
     if (e.isWebGLRenderer && !this.threeRendererPatched) {
       const t = e;
       this.patchThreeRenderer(t), this.gl = t.getContext();
-    }
-    if (!this.gl && e instanceof WebGL2RenderingContext)
-      this.gl = e;
-    else if (!this.gl && e instanceof HTMLCanvasElement || e instanceof OffscreenCanvas) {
+    } else
+      !this.gl && e instanceof WebGL2RenderingContext && (this.gl = e);
+    if (e.isWebGPURenderer) {
+      e.backend.trackTimestamp = !0, await e.hasFeatureAsync("timestamp-query") && (this.gpuPanel = this.addPanel(new Hn.Panel("GPU", "#ff0", "#220"), 2), this.gpuPanelCompute = this.addPanel(new Hn.Panel("CPT", "#e1e1e1", "#212121"), 3), this.info = e.info);
+      return;
+    } else if (!this.gl && e instanceof HTMLCanvasElement || e instanceof OffscreenCanvas) {
       if (this.gl = e.getContext("webgl2"), !this.gl) {
         console.error("Stats: Unable to obtain WebGL2 context.");
         return;
@@ -16374,7 +17004,7 @@ const Qa = class Ys {
       console.error("Stats: Invalid input type. Expected WebGL2RenderingContext, HTMLCanvasElement, or OffscreenCanvas.");
       return;
     }
-    this.ext = this.gl.getExtension("EXT_disjoint_timer_query_webgl2"), this.ext && (this.gpuPanel = this.addPanel(new Ys.Panel("GPU", "#ff0", "#220"), 2));
+    this.ext = this.gl.getExtension("EXT_disjoint_timer_query_webgl2"), this.ext && (this.gpuPanel = this.addPanel(new Hn.Panel("GPU", "#ff0", "#220"), 2));
   }
   begin() {
     this.isRunningCPUProfiling || this.beginProfiling("cpu-started"), !(!this.gl || !this.ext) && this.gl && this.ext && (this.activeQuery && this.gl.endQuery(this.ext.TIME_ELAPSED_EXT), this.activeQuery = this.gl.createQuery(), this.activeQuery !== null && this.gl.beginQuery(this.ext.TIME_ELAPSED_EXT, this.activeQuery));
@@ -16394,12 +17024,12 @@ const Qa = class Ys {
     }));
   }
   update() {
-    this.processGpuQueries(), this.endProfiling("cpu-started", "cpu-finished", "cpu-duration"), this.addToAverage(this.totalCpuDuration, this.averageCpu), this.addToAverage(this.totalGpuDuration, this.averageGpu), this.renderCount = 0, this.totalCpuDuration = 0, this.totalGpuDuration = 0, this.totalFps = 0, this.beginTime = this.endInternal();
+    this.info === void 0 ? this.processGpuQueries() : (this.totalGpuDuration = this.info.render.timestamp, this.totalGpuDurationCompute = this.info.compute.timestamp, this.addToAverage(this.totalGpuDurationCompute, this.averageGpuCompute)), this.endProfiling("cpu-started", "cpu-finished", "cpu-duration"), this.addToAverage(this.totalCpuDuration, this.averageCpu), this.addToAverage(this.totalGpuDuration, this.averageGpu), this.renderCount = 0, this.totalCpuDuration === 0 && this.beginProfiling("cpu-started"), this.totalCpuDuration = 0, this.totalFps = 0, this.beginTime = this.endInternal();
   }
   endInternal() {
     this.frames++;
     const e = (performance || Date).now();
-    if (e >= this.prevCpuTime + 1e3 / this.logsPerSecond && (this.updatePanel(this.msPanel, this.averageCpu), this.updatePanel(this.gpuPanel, this.averageGpu), this.prevCpuTime = e), e >= this.prevTime + 1e3) {
+    if (e >= this.prevCpuTime + 1e3 / this.logsPerSecond && (this.updatePanel(this.msPanel, this.averageCpu), this.updatePanel(this.gpuPanel, this.averageGpu), this.gpuPanelCompute && this.updatePanel(this.gpuPanelCompute, this.averageGpuCompute), this.prevCpuTime = e), e >= this.prevTime + 1e3) {
       const t = this.frames * 1e3 / (e - this.prevTime);
       this.fpsPanel.update(t, t, 100, 100, 0), this.prevTime = e, this.frames = 0;
     }
@@ -16436,9 +17066,9 @@ const Qa = class Ys {
     return console.warn("Stats: Deprecated! this.container as been replaced to this.dom "), this.dom;
   }
 };
-Qa.Panel = Jp;
-let em = Qa;
-const Rg = pe({
+rl.Panel = _m;
+let xm = rl;
+const Jg = pe({
   name: "StatsGl",
   props: [
     "logsPerSecond",
@@ -16450,7 +17080,7 @@ const Rg = pe({
     "mode"
   ],
   async setup(o, { expose: e }) {
-    const t = new em({
+    const t = new xm({
       logsPerSecond: o.logsPerSecond,
       samplesLog: o.samplesLog,
       samplesGraph: o.samplesGraph,
@@ -16462,23 +17092,23 @@ const Rg = pe({
     e({ statsGl: t });
     const n = document.body, s = t.dom || t.container;
     n == null || n.appendChild(s);
-    const { renderer: i } = je(), { onAfterLoop: r, resume: a } = Ke();
+    const { renderer: i } = Ue(), { onAfterLoop: r, resume: a } = Xe();
     t.init(i.value), a(), r(() => {
       t.update();
     }), ot(() => {
       n == null || n.removeChild(s);
     });
   }
-}), Cg = pe({
+}), e0 = pe({
   name: "BakeShadows",
   setup() {
-    const { renderer: o } = je();
-    ft(() => {
+    const { renderer: o } = Ue();
+    lt(() => {
       o.value.shadowMap.autoUpdate = !1, o.value.shadowMap.needsUpdate = !0;
     });
   }
 });
-var tm = `#include <common>
+var wm = `#include <common>
 
 void main() {
   vec2 center = vec2(0., 1.);
@@ -16503,12 +17133,12 @@ void main() {
   mvPosition.xy += rotatedPosition;
 
   gl_Position = projectionMatrix * mvPosition;
-}`, nm = `void main() {
+}`, Tm = `void main() {
   gl_FragColor = vec4(0.0, 0.0, 0.0, 0.0);
 }`;
-const vs = new ee(0, 0, 0), Tr = new ee(0, 0, 0), sm = new ee(0, 0, 0);
-function Oo(o, e, t) {
-  const n = vs.setFromMatrixPosition(o.matrixWorld);
+const Ss = new q(0, 0, 0), Pr = new q(0, 0, 0), bm = new q(0, 0, 0);
+function Ho(o, e, t) {
+  const n = Ss.setFromMatrixPosition(o.matrixWorld);
   n.project(e);
   const s = t.width / 2, i = t.height / 2;
   return [
@@ -16516,13 +17146,13 @@ function Oo(o, e, t) {
     -(n.y * i) + i
   ];
 }
-function im(o, e) {
-  const t = vs.setFromMatrixPosition(o.matrixWorld), n = Tr.setFromMatrixPosition(e.matrixWorld), s = t.sub(n), i = e.getWorldDirection(sm);
+function Em(o, e) {
+  const t = Ss.setFromMatrixPosition(o.matrixWorld), n = Pr.setFromMatrixPosition(e.matrixWorld), s = t.sub(n), i = e.getWorldDirection(bm);
   return s.angleTo(i) > Math.PI / 2;
 }
-function rm(o, e, t, n) {
-  const s = vs.setFromMatrixPosition(o.matrixWorld), i = s.clone();
-  i.project(e), t.setFromCamera(new le(i.x, i.y), e);
+function Sm(o, e, t, n) {
+  const s = Ss.setFromMatrixPosition(o.matrixWorld), i = s.clone();
+  i.project(e), t.setFromCamera(new he(i.x, i.y), e);
   const r = t.intersectObjects(n, !0);
   if (r.length > 0) {
     const a = r[0].distance;
@@ -16530,32 +17160,32 @@ function rm(o, e, t, n) {
   }
   return !0;
 }
-function om(o, e) {
-  if (e instanceof jt)
+function Mm(o, e) {
+  if (e instanceof Xt)
     return e.zoom;
-  if (e instanceof Mt) {
-    const t = vs.setFromMatrixPosition(o.matrixWorld), n = Tr.setFromMatrixPosition(e.matrixWorld), s = e.fov * Math.PI / 180, i = t.distanceTo(n);
+  if (e instanceof wt) {
+    const t = Ss.setFromMatrixPosition(o.matrixWorld), n = Pr.setFromMatrixPosition(e.matrixWorld), s = e.fov * Math.PI / 180, i = t.distanceTo(n);
     return 1 / (2 * Math.tan(s / 2) * i);
   } else
     return 1;
 }
-function am(o, e, t) {
-  if (e instanceof Mt || e instanceof jt) {
-    const n = vs.setFromMatrixPosition(o.matrixWorld), s = Tr.setFromMatrixPosition(e.matrixWorld), i = n.distanceTo(s), r = (t[1] - t[0]) / (e.far - e.near), a = t[1] - r * e.far;
+function Am(o, e, t) {
+  if (e instanceof wt || e instanceof Xt) {
+    const n = Ss.setFromMatrixPosition(o.matrixWorld), s = Pr.setFromMatrixPosition(e.matrixWorld), i = n.distanceTo(s), r = (t[1] - t[0]) / (e.far - e.near), a = t[1] - r * e.far;
     return Math.round(r * i + a);
   }
 }
-const ir = (o) => Math.abs(o) < 1e-10 ? 0 : o;
-function Ja(o, e, t = "") {
+const cr = (o) => Math.abs(o) < 1e-10 ? 0 : o;
+function ol(o, e, t = "") {
   let n = "matrix3d(";
   for (let s = 0; s !== 16; s++)
-    n += ir(e[s] * o.elements[s]) + (s !== 15 ? "," : ")");
+    n += cr(e[s] * o.elements[s]) + (s !== 15 ? "," : ")");
   return t + n;
 }
-const lm = /* @__PURE__ */ ((o) => (e) => Ja(e, o))([1, -1, 1, 1, 1, -1, 1, 1, 1, -1, 1, 1, 1, -1, 1, 1]), cm = /* @__PURE__ */ ((o) => (e, t) => Ja(e, o(t), "translate(-50%,-50%)"))((o) => [1 / o, 1 / o, 1 / o, 1, -1 / o, -1 / o, -1 / o, -1, 1 / o, 1 / o, 1 / o, 1, 1, 1, 1, 1]), um = ["geometry", "material"], Ig = /* @__PURE__ */ pe({
+const Pm = /* @__PURE__ */ ((o) => (e) => ol(e, o))([1, -1, 1, 1, 1, -1, 1, 1, 1, -1, 1, 1, 1, -1, 1, 1]), Cm = /* @__PURE__ */ ((o) => (e, t) => ol(e, o(t), "translate(-50%,-50%)"))((o) => [1 / o, 1 / o, 1 / o, 1, -1 / o, -1 / o, -1 / o, -1, 1 / o, 1 / o, 1 / o, 1, 1, 1, 1, 1]), Rm = ["geometry", "material"], t0 = /* @__PURE__ */ pe({
   __name: "HTML",
   props: {
-    geometry: { default: new Dt() },
+    geometry: { default: new Lt() },
     material: {},
     as: { default: "div" },
     transform: { type: Boolean, default: !1 },
@@ -16572,218 +17202,218 @@ const lm = /* @__PURE__ */ ((o) => (e) => Ja(e, o))([1, -1, 1, 1, 1, -1, 1, 1, 1
   },
   emits: ["onOcclude"],
   setup(o, { emit: e }) {
-    const t = o, n = e, s = fa(), i = ra(), r = ue(), a = ue(), {
+    const t = o, n = e, s = ya(), i = gr(), r = ue(), a = ue(), {
       geometry: l,
       material: c,
       as: u,
       transform: h,
-      portal: m,
-      wrapperClass: p,
-      eps: v,
-      distanceFactor: _,
-      fullscreen: y,
-      center: E,
-      pointerEvents: R,
-      sprite: T,
-      occlude: g,
-      zIndexRange: A
-    } = Fe(t), { renderer: x, scene: M, camera: d, raycaster: w, sizes: f } = je(), P = Ne(() => document.createElement(u.value)), I = ue([0, 0]), K = ue(0), N = ue(), Z = Ne(() => h.value ? {
+      portal: f,
+      wrapperClass: d,
+      eps: y,
+      distanceFactor: x,
+      fullscreen: g,
+      center: v,
+      pointerEvents: M,
+      sprite: _,
+      occlude: w,
+      zIndexRange: P
+    } = Oe(t), { renderer: T, scene: E, camera: m, raycaster: b, sizes: p } = Ue(), C = Ne(() => document.createElement(u.value)), I = ue([0, 0]), K = ue(0), z = ue(), Y = Ne(() => h.value ? {
       position: "absolute",
       top: 0,
       left: 0,
-      width: `${f.width.value}px`,
-      height: `${f.height.value}px`,
+      width: `${p.width.value}px`,
+      height: `${p.height.value}px`,
       transformStyle: "preserve-3d",
       pointerEvents: "none",
       zIndex: 2,
       willChange: "transform"
     } : {
       position: "absolute",
-      transform: E.value ? "translate3d(-50%,-50%,0)" : "none",
-      ...y.value && {
-        top: -f.height.value / 2,
-        left: -f.width.value / 2,
-        width: `${f.width.value}px`,
-        height: `${f.height.value}px`
+      transform: v.value ? "translate3d(-50%,-50%,0)" : "none",
+      ...g.value && {
+        top: -p.height.value / 2,
+        left: -p.width.value / 2,
+        width: `${p.width.value}px`,
+        height: `${p.height.value}px`
       },
       zIndex: 2,
       ...s.style,
       willChange: "transform"
     }), W = Ne(() => ({
       position: "absolute",
-      pointerEvents: R.value
-    })), X = ue(null), V = ue(!1), ne = Ne(
-      () => (g == null ? void 0 : g.value) && (g == null ? void 0 : g.value) !== "blending" || Array.isArray(g == null ? void 0 : g.value) && (g == null ? void 0 : g.value.length) && Wi(g.value[0])
+      pointerEvents: M.value
+    })), X = ue(null), V = ue(!1), te = Ne(
+      () => (w == null ? void 0 : w.value) && (w == null ? void 0 : w.value) !== "blending" || Array.isArray(w == null ? void 0 : w.value) && (w == null ? void 0 : w.value.length) && Qs(w.value[0])
     );
-    we(
-      () => g,
-      (b) => {
-        b && b === "blending" ? (P.value.style.zIndex = `${Math.floor(A.value[0] / 2)}`, P.value.style.position = "absolute", P.value.style.pointerEvents = "none") : (P.value.style.zIndex = null, P.value.style.position = null, P.value.style.pointerEvents = null);
+    Te(
+      () => w,
+      (S) => {
+        S && S === "blending" ? (C.value.style.zIndex = `${Math.floor(P.value[0] / 2)}`, C.value.style.position = "absolute", C.value.style.pointerEvents = "none") : (C.value.style.zIndex = null, C.value.style.position = null, C.value.style.pointerEvents = null);
       }
-    ), we(
+    ), Te(
       () => {
-        var b;
-        return [r.value, x.value, f.width.value, f.height.value, (b = i.default) == null ? void 0 : b.call(i)];
+        var S;
+        return [r.value, T.value, p.width.value, p.height.value, (S = i.default) == null ? void 0 : S.call(i)];
       },
-      ([b, U]) => {
-        var J, F, B, S, C, D;
-        if (b && U) {
-          const G = (m == null ? void 0 : m.value) || U.domElement;
-          if ((J = M.value) == null || J.updateMatrixWorld(), h.value)
-            P.value.style.cssText = "position:absolute;top:0;left:0;pointer-events:none;overflow:hidden;";
+      ([S, U]) => {
+        var ee, F, N, A, R, D;
+        if (S && U) {
+          const j = (f == null ? void 0 : f.value) || U.domElement;
+          if ((ee = E.value) == null || ee.updateMatrixWorld(), h.value)
+            C.value.style.cssText = "position:absolute;top:0;left:0;pointer-events:none;overflow:hidden;";
           else {
-            const $ = Oo(b, d.value, {
-              width: f.width.value,
-              height: f.height.value
+            const Z = Ho(S, m.value, {
+              width: p.width.value,
+              height: p.height.value
             });
-            P.value.style.cssText = `position:absolute;top:0;left:0;transform:translate3d(${$[0]}px,${$[1]}px,0);transform-origin:0 0;`;
+            C.value.style.cssText = `position:absolute;top:0;left:0;transform:translate3d(${Z[0]}px,${Z[1]}px,0);transform-origin:0 0;`;
           }
-          G && !P.value.parentNode && ((F = G.parentNode) == null || F.appendChild(P.value)), h.value ? N.value = bs("div", { id: "outer", style: Z.value }, [
-            bs("div", { id: "inner", style: W.value }, [
-              bs("div", {
-                key: (B = a.value) == null ? void 0 : B.uuid,
-                id: M == null ? void 0 : M.value.uuid,
+          j && !C.value.parentNode && ((F = j.parentNode) == null || F.appendChild(C.value)), h.value ? z.value = Rs("div", { id: "outer", style: Y.value }, [
+            Rs("div", { id: "inner", style: W.value }, [
+              Rs("div", {
+                key: (N = a.value) == null ? void 0 : N.uuid,
+                id: E == null ? void 0 : E.value.uuid,
                 class: s.class,
                 style: s.style
-              }, (S = i.default) == null ? void 0 : S.call(i))
+              }, (A = i.default) == null ? void 0 : A.call(i))
             ])
-          ]) : N.value = bs(
+          ]) : z.value = Rs(
             "div",
             {
-              key: (C = a.value) == null ? void 0 : C.uuid,
-              id: M == null ? void 0 : M.value.uuid,
-              style: Z.value
+              key: (R = a.value) == null ? void 0 : R.uuid,
+              id: E == null ? void 0 : E.value.uuid,
+              style: Y.value
             },
             (D = i.default) == null ? void 0 : D.call(i)
-          ), rc(N.value, P.value);
+          ), dc(z.value, C.value);
         }
       }
-    ), ft(() => {
-      p != null && p.value && (P.value.className = p.value);
+    ), lt(() => {
+      d != null && d.value && (C.value.className = d.value);
     });
-    const se = ue(!0), { onLoop: he } = Ke();
-    he(() => {
-      var b, U, J, F, B, S, C;
-      if (r.value && d.value && x.value) {
-        (b = d.value) == null || b.updateMatrixWorld(), r.value.updateWorldMatrix(!0, !1);
-        const D = h.value ? I.value : Oo(r.value, d.value, {
-          width: f.width.value || 0,
-          height: f.height.value || 0
+    const se = ue(!0), { onLoop: fe } = Xe();
+    fe(() => {
+      var S, U, ee, F, N, A, R;
+      if (r.value && m.value && T.value) {
+        (S = m.value) == null || S.updateMatrixWorld(), r.value.updateWorldMatrix(!0, !1);
+        const D = h.value ? I.value : Ho(r.value, m.value, {
+          width: p.width.value || 0,
+          height: p.height.value || 0
         });
-        if (h.value || Math.abs(K.value - d.value.zoom) > v.value || Math.abs(I.value[0] - D[0]) > v.value || Math.abs(I.value[1] - D[1]) > v.value) {
-          const G = im(r.value, d.value);
-          let $ = !1;
-          ne.value && (Array.isArray(g == null ? void 0 : g.value) ? $ = g == null ? void 0 : g.value : (g == null ? void 0 : g.value) !== "blending" && ($ = [M.value]));
-          const Y = se.value;
-          if ($) {
-            const L = rm(
+        if (h.value || Math.abs(K.value - m.value.zoom) > y.value || Math.abs(I.value[0] - D[0]) > y.value || Math.abs(I.value[1] - D[1]) > y.value) {
+          const j = Em(r.value, m.value);
+          let Z = !1;
+          te.value && (Array.isArray(w == null ? void 0 : w.value) ? Z = w == null ? void 0 : w.value : (w == null ? void 0 : w.value) !== "blending" && (Z = [E.value]));
+          const $ = se.value;
+          if (Z) {
+            const O = Sm(
               r.value,
-              d.value,
-              w.value,
-              $
+              m.value,
+              b.value,
+              Z
             );
-            se.value = L && !G;
+            se.value = O && !j;
           } else
-            se.value = !G;
-          Y !== se.value && (n("onOcclude", !se.value), P.value.style.display = se.value ? "block" : "none");
-          const te = Math.floor(A.value[0] / 2), O = g != null && g.value ? ne.value ? [A.value[0], te] : [te - 1, 0] : A.value;
-          if (P.value.style.zIndex = `${am(r.value, d.value, O)}`, P.value.style.willChange = "transform", h.value) {
-            const [L, re] = [
-              f.width.value / 2,
-              f.height.value / 2
-            ], ce = d.value.projectionMatrix.elements[5] * re, { isOrthographicCamera: be, top: Me, left: Se, bottom: qe, right: kt } = d.value, jn = lm(d.value.matrixWorldInverse), Sn = be ? `scale(${ce})translate(${ir(-(kt + Se) / 2)}px,${ir((Me + qe) / 2)}px)` : `translateZ(${ce}px)`;
+            se.value = !j;
+          $ !== se.value && (n("onOcclude", !se.value), C.value.style.display = se.value ? "block" : "none");
+          const ne = Math.floor(P.value[0] / 2), L = w != null && w.value ? te.value ? [P.value[0], ne] : [ne - 1, 0] : P.value;
+          if (C.value.style.zIndex = `${Am(r.value, m.value, L)}`, C.value.style.willChange = "transform", h.value) {
+            const [O, re] = [
+              p.width.value / 2,
+              p.height.value / 2
+            ], de = m.value.projectionMatrix.elements[5] * re, { isOrthographicCamera: be, top: Se, left: Me, bottom: qe, right: Nt } = m.value, Zn = Pm(m.value.matrixWorldInverse), Pn = be ? `scale(${de})translate(${cr(-(Nt + Me) / 2)}px,${cr((Se + qe) / 2)}px)` : `translateZ(${de}px)`;
             let gt = r.value.matrixWorld;
-            T.value && (gt = d.value.matrixWorldInverse.clone().transpose().copyPosition(gt).scale(r.value.scale), gt.elements[3] = gt.elements[7] = gt.elements[11] = 0, gt.elements[15] = 1), P.value.style.width = `${f.width.value}px`, P.value.style.height = `${f.height.value}px`, P.value.style.perspective = be ? "" : `${ce}px`, (U = N.value) != null && U.el && ((J = N.value) != null && J.children) && (N.value.el.style.willChange = "transform", N.value.el.style.transform = `${Sn}${jn}translate(${L}px,${re}px)`, N.value.children[0].willChange = "transform", N.value.children[0].el.style.transform = cm(
+            _.value && (gt = m.value.matrixWorldInverse.clone().transpose().copyPosition(gt).scale(r.value.scale), gt.elements[3] = gt.elements[7] = gt.elements[11] = 0, gt.elements[15] = 1), C.value.style.width = `${p.width.value}px`, C.value.style.height = `${p.height.value}px`, C.value.style.perspective = be ? "" : `${de}px`, (U = z.value) != null && U.el && ((ee = z.value) != null && ee.children) && (z.value.el.style.willChange = "transform", z.value.el.style.transform = `${Pn}${Zn}translate(${O}px,${re}px)`, z.value.children[0].willChange = "transform", z.value.children[0].el.style.transform = Cm(
               gt,
-              1 / (((_ == null ? void 0 : _.value) || 10) / 400)
+              1 / (((x == null ? void 0 : x.value) || 10) / 400)
             ));
           } else {
-            const L = (_ == null ? void 0 : _.value) === void 0 ? 1 : om(r.value, d.value) * (_ == null ? void 0 : _.value);
-            P.value.style.transform = `translate3d(${D[0]}px,${D[1]}px,0) scale(${L})`;
+            const O = (x == null ? void 0 : x.value) === void 0 ? 1 : Mm(r.value, m.value) * (x == null ? void 0 : x.value);
+            C.value.style.transform = `translate3d(${D[0]}px,${D[1]}px,0) scale(${O})`;
           }
         }
-        I.value = D, K.value = d.value.zoom;
+        I.value = D, K.value = m.value.zoom;
       }
-      if (!ne.value && a.value && !V.value)
+      if (!te.value && a.value && !V.value)
         if (h.value) {
-          if ((F = N.value) != null && F.el && ((B = N.value) != null && B.children)) {
-            const D = (S = N.value) == null ? void 0 : S.children[0];
+          if ((F = z.value) != null && F.el && ((N = z.value) != null && N.children)) {
+            const D = (A = z.value) == null ? void 0 : A.children[0];
             if (D != null && D.clientWidth && (D != null && D.clientHeight)) {
-              const { isOrthographicCamera: G } = d.value;
-              if (G || l)
-                s.scale && (Array.isArray(s.scale) ? s.scale instanceof ee ? a.value.scale.copy(s.scale.clone().divideScalar(1)) : a.value.scale.set(1 / s.scale[0], 1 / s.scale[1], 1 / s.scale[2]) : a.value.scale.setScalar(1 / s.scale));
+              const { isOrthographicCamera: j } = m.value;
+              if (j || l)
+                s.scale && (Array.isArray(s.scale) ? s.scale instanceof q ? a.value.scale.copy(s.scale.clone().divideScalar(1)) : a.value.scale.set(1 / s.scale[0], 1 / s.scale[1], 1 / s.scale[2]) : a.value.scale.setScalar(1 / s.scale));
               else {
-                const $ = ((_ == null ? void 0 : _.value) || 10) / 400, Y = D.clientWidth * $, te = D.clientHeight * $;
-                a.value.scale.set(Y, te, 1);
+                const Z = ((x == null ? void 0 : x.value) || 10) / 400, $ = D.clientWidth * Z, ne = D.clientHeight * Z;
+                a.value.scale.set($, ne, 1);
               }
               V.value = !0;
             }
           }
         } else {
-          const D = P.value.children[0];
+          const D = C.value.children[0];
           if (D != null && D.clientWidth && (D != null && D.clientHeight)) {
-            const $ = D.clientWidth * 1, Y = D.clientHeight * 1;
-            a.value.scale.set($, Y, 1), V.value = !0;
+            const Z = D.clientWidth * 1, $ = D.clientHeight * 1;
+            a.value.scale.set(Z, $, 1), V.value = !0;
           }
-          X.value.lookAt((C = d.value) == null ? void 0 : C.position);
+          X.value.lookAt((R = m.value) == null ? void 0 : R.position);
         }
     });
     const H = Ne(() => ({
-      vertexShader: h.value ? void 0 : tm,
-      fragmentShader: nm
+      vertexShader: h.value ? void 0 : wm,
+      fragmentShader: Tm
     })), k = Ne(() => {
-      const b = H.value;
-      return c.value || new Xt({
-        vertexShader: b.vertexShader,
-        fragmentShader: b.fragmentShader,
-        side: wn
+      const S = H.value;
+      return c.value || new Pt({
+        vertexShader: S.vertexShader,
+        fragmentShader: S.fragmentShader,
+        side: dn
       });
     });
     return ot(() => {
-      k.value && k.value.dispose(), P.value.remove();
-    }), (b, U) => (fe(), de("TresGroup", {
+      k.value && k.value.dispose(), C.value.remove();
+    }), (S, U) => (le(), ce("TresGroup", {
       ref_key: "groupRef",
       ref: r
     }, [
-      z(g) && !ne.value ? (fe(), de("TresMesh", {
+      B(w) && !te.value ? (le(), ce("TresMesh", {
         key: 0,
         ref_key: "meshRef",
         ref: a,
-        geometry: z(l),
+        geometry: B(l),
         material: k.value
-      }, null, 8, um)) : Wt("", !0)
+      }, null, 8, Rm)) : Ut("", !0)
     ], 512));
   }
-}), { logError: hm } = ps();
-async function Dg(o, e) {
-  const t = new hr(), n = (e == null ? void 0 : e.fileName) || "scene";
+}), { logError: Im } = ws();
+async function n0(o, e) {
+  const t = new vr(), n = (e == null ? void 0 : e.fileName) || "scene";
   t.parse(
     o,
     (s) => {
       if (s instanceof ArrayBuffer)
-        dm(s, `${n}.glb`);
+        Om(s, `${n}.glb`);
       else {
         const i = JSON.stringify(s, null, 2);
-        fm(i, `${n}.gltf`);
+        Dm(i, `${n}.gltf`);
       }
     },
     (s) => {
-      hm("An error happened while exporting the GLTF", s);
+      Im("An error happened while exporting the GLTF", s);
     },
     e
   );
 }
-function fm(o, e) {
-  el(new Blob([o], { type: "text/plain" }), e);
+function Dm(o, e) {
+  al(new Blob([o], { type: "text/plain" }), e);
 }
-function dm(o, e) {
-  el(new Blob([o], { type: "application/octet-stream" }), e);
+function Om(o, e) {
+  al(new Blob([o], { type: "application/octet-stream" }), e);
 }
-function el(o, e) {
+function al(o, e) {
   const t = document.createElement("a");
   t.style.display = "none", document.body.appendChild(t), t.href = URL.createObjectURL(o), t.download = e, t.click(), t.remove();
 }
-const Lg = {
+const s0 = {
   mounted: (o, e) => {
     if (e.arg) {
       console.log(`v-log:${e.arg}`, o[e.arg]);
@@ -16791,71 +17421,71 @@ const Lg = {
     }
     console.log("v-log", o);
   }
-}, { logWarning: Fo } = ps(), Og = {
+}, { logWarning: jo } = ws(), i0 = {
   mounted: (o) => {
     if (!o.isLight) {
-      Fo(`${o.type} is not a light`);
+      jo(`${o.type} is not a light`);
       return;
     }
-    Hs = pm[o.type], o.parent.add(new Hs(o));
+    $s = Lm[o.type], o.parent.add(new $s(o));
   },
   updated: (o) => {
-    Bn = o.parent.children.find((e) => e instanceof Hs), !(Bn instanceof Ra) && Bn.update();
+    zn = o.parent.children.find((e) => e instanceof $s), !(zn instanceof ka) && zn.update();
   },
   unmounted: (o) => {
     if (!o.isLight) {
-      Fo(`${o.type} is not a light`);
+      jo(`${o.type} is not a light`);
       return;
     }
-    Bn = o.parent.children.find((e) => e instanceof Hs), Bn.dispose(), o.parent.remove(Bn);
+    zn = o.parent.children.find((e) => e instanceof $s), zn.dispose(), o.parent.remove(zn);
   }
 };
-let Hs, Bn;
-const pm = {
-  DirectionalLight: Wl,
-  PointLight: $l,
-  SpotLight: Zl,
-  HemisphereLight: Kl,
-  RectAreaLight: Ra
+let $s, zn;
+const Lm = {
+  DirectionalLight: nc,
+  PointLight: sc,
+  SpotLight: ic,
+  HemisphereLight: rc,
+  RectAreaLight: ka
 };
-function Fg(o, e) {
+function r0(o, e) {
   const t = {};
   for (const n of e)
     Object.prototype.hasOwnProperty.call(o, n) && (t[n] = o[n]);
   return t;
 }
-function kg(o, e) {
+function o0(o, e) {
   const t = `set${e[0].toUpperCase()}${e.slice(1)}`;
   return o[t] !== void 0;
 }
-function tl(o) {
+function ll(o) {
   var t, n;
   let e = o.value;
-  return o.value && ((n = (t = o.value) == null ? void 0 : t.value) != null && n.isMesh) && (e = o.value.value.position), Array.isArray(o.value) && (e = new ee(...e)), e;
+  return o.value && ((n = (t = o.value) == null ? void 0 : t.value) != null && n.isMesh) && (e = o.value.value.position), Array.isArray(o.value) && (e = new q(...e)), e;
 }
-const { logWarning: mm } = ps(), Ug = {
+const { logWarning: Fm } = ws(), a0 = {
   updated: (o, e) => {
-    const t = tl(e);
+    const t = ll(e);
     if (!t) {
-      mm(`v-always-look-at: problem with binding value: ${e.value}`);
+      Fm(`v-always-look-at: problem with binding value: ${e.value}`);
       return;
     }
-    const { onLoop: n } = Ke();
+    const { onLoop: n } = Xe();
     n(() => {
       o.lookAt(t);
     });
   }
-}, { logWarning: gm } = ps(), Bg = {
+}, { logWarning: km } = ws(), l0 = {
   updated: (o, e) => {
     var s;
-    const t = tl(e);
+    const t = ll(e);
     if (!t) {
-      gm(`v-distance-to: problem with binding value: ${e.value}`);
+      km(`v-distance-to: problem with binding value: ${e.value}`);
       return;
     }
-    Ht && (Ht.dispose(), o.parent.remove(Ht));
+    Vt && (Vt.dispose(), o.parent.remove(Vt));
     const n = t.clone().sub(o.position);
-    n.normalize(), Ht = new ql(n, o.position, o.position.distanceTo(t) / 1.5, 16776960), o.parent.add(Ht), console.table(
+    n.normalize(), Vt = new oc(n, o.position, o.position.distanceTo(t) / 1.5, 16776960), o.parent.add(Vt), console.table(
       [
         ["Distance:", o.position.distanceTo(t)],
         [`origin: ${o.name || o.type}`, `x:${o.position.x}, y:${o.position.y}, z:${(s = o.position) == null ? void 0 : s.z}`],
@@ -16864,76 +17494,80 @@ const { logWarning: mm } = ps(), Ug = {
     );
   },
   unmounted: (o) => {
-    Ht == null || Ht.dispose(), o.parent.remove(Ht);
+    Vt == null || Vt.dispose(), o.parent.remove(Vt);
   }
 };
-let Ht = null;
+let Vt = null;
 export {
-  xg as Backdrop,
-  Cg as BakeShadows,
-  ig as Box,
-  Jm as CameraControls,
-  rg as CatmullRomCurve3,
-  og as Circle,
-  ag as Cone,
-  wg as ContactShadows,
-  ng as CustomShaderMaterial,
-  lg as Dodecahedron,
-  _g as Environment,
-  jm as FBXModel,
-  zm as Fbo,
-  Gm as GLTFModel,
-  Bm as GlobalAudio,
-  Ig as Html,
-  cg as Icosahedron,
-  $m as KeyboardControls,
-  Nm as Lensflare,
-  Fm as Levioso,
-  Vd as Line2,
-  qm as MapControls,
-  tg as MeshGlassMaterial,
-  sg as MeshReflectionMaterial,
-  eg as MeshWobbleMaterial,
-  Um as MouseParallax,
-  ug as Octahedron,
-  Wm as OrbitControls,
-  hg as Plane,
-  Km as PointerLockControls,
-  Tg as Precipitation,
-  km as Reflector,
-  fg as Ring,
-  Vm as SVG,
-  Hm as Sampler,
-  Qm as ScrollControls,
-  bg as Sky,
-  Eg as Smoke,
-  Mg as Sparkles,
-  dg as Sphere,
-  Sg as Stars,
-  Pg as Stats,
-  Rg as StatsGl,
-  pg as Superformula,
-  mg as Tetrahedron,
-  Lm as Text3D,
-  gg as Torus,
-  yg as TorusKnot,
-  Zm as TransformControls,
-  vg as Tube,
-  tl as extractBindingPosition,
-  kg as hasSetter,
-  Fg as pick,
-  Om as useAnimations,
-  nf as useEnvironment,
-  Jh as useFBO,
-  af as useFBX,
-  rf as useGLTF,
-  Dg as useGLTFExporter,
-  Ym as useProgress,
-  ef as useSurfaceSampler,
-  Ag as useTweakPane,
-  Xm as useVideoTexture,
-  Ug as vAlwaysLookAt,
-  Bg as vDistanceTo,
-  Og as vLightHelper,
-  Lg as vLog
+  Gg as Backdrop,
+  e0 as BakeShadows,
+  Sg as Box,
+  _g as CameraControls,
+  Mg as CatmullRomCurve3,
+  Ag as Circle,
+  Pg as Cone,
+  Vg as ContactShadows,
+  Tg as CustomShaderMaterial,
+  Cg as Dodecahedron,
+  Hg as Environment,
+  cg as FBXModel,
+  og as Fbo,
+  lg as GLTFModel,
+  ig as GlobalAudio,
+  Eg as HolographicMaterial,
+  t0 as Html,
+  Rg as Icosahedron,
+  pg as KeyboardControls,
+  rg as Lensflare,
+  tg as Levioso,
+  jg as Lightformer,
+  Jd as Line2,
+  vg as MapControls,
+  wg as MeshGlassMaterial,
+  bg as MeshReflectionMaterial,
+  xg as MeshWobbleMaterial,
+  sg as MouseParallax,
+  Kg as Ocean,
+  Ig as Octahedron,
+  dg as OrbitControls,
+  Dg as Plane,
+  gg as PointerLockControls,
+  Wg as Precipitation,
+  ng as Reflector,
+  Og as Ring,
+  Lg as RoundedBox,
+  ug as SVG,
+  ag as Sampler,
+  yg as ScrollControls,
+  Yg as Sky,
+  Xg as Smoke,
+  $g as Sparkles,
+  Fg as Sphere,
+  Zg as Stars,
+  Qg as Stats,
+  Jg as StatsGl,
+  kg as Superformula,
+  Bg as Tetrahedron,
+  Jm as Text3D,
+  Ug as Torus,
+  Ng as TorusKnot,
+  mg as TransformControls,
+  zg as Tube,
+  ll as extractBindingPosition,
+  o0 as hasSetter,
+  r0 as pick,
+  eg as useAnimations,
+  hf as useEnvironment,
+  lf as useFBO,
+  mf as useFBX,
+  df as useGLTF,
+  n0 as useGLTFExporter,
+  hg as useProgress,
+  cf as useSurfaceSampler,
+  qg as useTweakPane,
+  fg as useVideoTexture,
+  a0 as vAlwaysLookAt,
+  l0 as vDistanceTo,
+  i0 as vLightHelper,
+  s0 as vLog
 };
diff --git a/node_modules/@tresjs/cientos/dist/trescientos.umd.cjs b/node_modules/@tresjs/cientos/dist/trescientos.umd.cjs
index b22b8b4..4db1b4a 100644
--- a/node_modules/@tresjs/cientos/dist/trescientos.umd.cjs
+++ b/node_modules/@tresjs/cientos/dist/trescientos.umd.cjs
@@ -5,7 +5,7 @@
  * description: Collection of useful helpers and fully functional, ready-made abstractions for Tres
  * author: Alvaro Saburido <hola@alvarosaburido.dev> (https://github.com/alvarosabu/)
  */
-(function(re,c){typeof exports=="object"&&typeof module<"u"?c(exports,require("three"),require("vue"),require("@tresjs/core"),require("tweakpane")):typeof define=="function"&&define.amd?define(["exports","three","vue","@tresjs/core","tweakpane"],c):(re=typeof globalThis<"u"?globalThis:re||self,c(re.trescientos={},re.Three,re.Vue,re.TresjsCore,re.tweakpane))})(this,function(re,c,f,ae,ji){"use strict";var ed=Object.defineProperty;var td=(re,c,f)=>c in re?ed(re,c,{enumerable:!0,configurable:!0,writable:!0,value:f}):re[c]=f;var le=(re,c,f)=>(td(re,typeof c!="symbol"?c+"":c,f),f);function Ei(o){const e=Object.create(null,{[Symbol.toStringTag]:{value:"Module"}});if(o){for(const t in o)if(t!=="default"){const n=Object.getOwnPropertyDescriptor(o,t);Object.defineProperty(e,t,n.get?n:{enumerable:!0,get:()=>o[t]})}}return e.default=o,Object.freeze(e)}const Ns=Ei(c);function zs(o,e){if(e===c.TrianglesDrawMode)return console.warn("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Geometry already defined as triangles."),o;if(e===c.TriangleFanDrawMode||e===c.TriangleStripDrawMode){let t=o.getIndex();if(t===null){const i=[],a=o.getAttribute("position");if(a!==void 0){for(let l=0;l<a.count;l++)i.push(l);o.setIndex(i),t=o.getIndex()}else return console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Undefined position attribute. Processing not possible."),o}const n=t.count-2,s=[];if(t)if(e===c.TriangleFanDrawMode)for(let i=1;i<=n;i++)s.push(t.getX(0)),s.push(t.getX(i)),s.push(t.getX(i+1));else for(let i=0;i<n;i++)i%2===0?(s.push(t.getX(i)),s.push(t.getX(i+1)),s.push(t.getX(i+2))):(s.push(t.getX(i+2)),s.push(t.getX(i+1)),s.push(t.getX(i)));s.length/3!==n&&console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unable to generate correct amount of triangles.");const r=o.clone();return r.setIndex(s),r.clearGroups(),r}else return console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unknown draw mode:",e),o}const Vs=parseInt(c.REVISION.replace(/\D+/g,""));var Yi=Object.defineProperty,Xi=(o,e,t)=>e in o?Yi(o,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):o[e]=t,Wi=(o,e,t)=>(Xi(o,typeof e!="symbol"?e+"":e,t),t);async function Rs(o){const e=await o.arrayBuffer(),t=btoa(String.fromCharCode(...new Uint8Array(e)));return`data:${o.type||""};base64,${t}`}let hn,Nn,Tt,fn;function zn(o,e=1/0,t=null){Nn||(Nn=new c.PlaneGeometry(2,2,1,1)),Tt||(Tt=new c.ShaderMaterial({uniforms:{blitTexture:new c.Uniform(o)},vertexShader:`
+(function(ie,l){typeof exports=="object"&&typeof module<"u"?l(exports,require("three"),require("vue"),require("@tresjs/core"),require("tweakpane")):typeof define=="function"&&define.amd?define(["exports","three","vue","@tresjs/core","tweakpane"],l):(ie=typeof globalThis<"u"?globalThis:ie||self,l(ie.trescientos={},ie.Three,ie.Vue,ie.TresjsCore,ie.tweakpane))})(this,function(ie,l,u,oe,Xs){"use strict";var xd=Object.defineProperty;var wd=(ie,l,u)=>l in ie?xd(ie,l,{enumerable:!0,configurable:!0,writable:!0,value:u}):ie[l]=u;var le=(ie,l,u)=>(wd(ie,typeof l!="symbol"?l+"":l,u),u);function Zs(o){const e=Object.create(null,{[Symbol.toStringTag]:{value:"Module"}});if(o){for(const t in o)if(t!=="default"){const n=Object.getOwnPropertyDescriptor(o,t);Object.defineProperty(e,t,n.get?n:{enumerable:!0,get:()=>o[t]})}}return e.default=o,Object.freeze(e)}const Rr=Zs(l);function Gr(o,e){if(e===l.TrianglesDrawMode)return console.warn("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Geometry already defined as triangles."),o;if(e===l.TriangleFanDrawMode||e===l.TriangleStripDrawMode){let t=o.getIndex();if(t===null){const s=[],a=o.getAttribute("position");if(a!==void 0){for(let c=0;c<a.count;c++)s.push(c);o.setIndex(s),t=o.getIndex()}else return console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Undefined position attribute. Processing not possible."),o}const n=t.count-2,r=[];if(t)if(e===l.TriangleFanDrawMode)for(let s=1;s<=n;s++)r.push(t.getX(0)),r.push(t.getX(s)),r.push(t.getX(s+1));else for(let s=0;s<n;s++)s%2===0?(r.push(t.getX(s)),r.push(t.getX(s+1)),r.push(t.getX(s+2))):(r.push(t.getX(s+2)),r.push(t.getX(s+1)),r.push(t.getX(s)));r.length/3!==n&&console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unable to generate correct amount of triangles.");const i=o.clone();return i.setIndex(r),i.clearGroups(),i}else return console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unknown draw mode:",e),o}const jr=parseInt(l.REVISION.replace(/\D+/g,""));var Ks=Object.defineProperty,qs=(o,e,t)=>e in o?Ks(o,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):o[e]=t,Qs=(o,e,t)=>(qs(o,typeof e!="symbol"?e+"":e,t),t);async function Er(o){const e=await o.arrayBuffer(),t=btoa(String.fromCharCode(...new Uint8Array(e)));return`data:${o.type||""};base64,${t}`}let pn,Vn,Lt,mn;function Rn(o,e=1/0,t=null){Vn||(Vn=new l.PlaneGeometry(2,2,1,1)),Lt||(Lt=new l.ShaderMaterial({uniforms:{blitTexture:new l.Uniform(o)},vertexShader:`
         varying vec2 vUv;
         void main(){
             vUv = uv;
@@ -24,7 +24,7 @@
               gl_FragColor = texture2D( blitTexture, vUv);
               #endif
           }
-      `})),Tt.uniforms.blitTexture.value=o,Tt.defines.IS_SRGB="colorSpace"in o?o.colorSpace==="srgb":o.encoding===3001,Tt.needsUpdate=!0,fn||(fn=new c.Mesh(Nn,Tt),fn.frustrumCulled=!1);const n=new c.PerspectiveCamera,s=new c.Scene;s.add(fn),t||(t=hn=new c.WebGLRenderer({antialias:!1})),t.setSize(Math.min(o.image.width,e),Math.min(o.image.height,e)),t.clear(),t.render(s,n);const r=new c.Texture(t.domElement);return r.minFilter=o.minFilter,r.magFilter=o.magFilter,r.wrapS=o.wrapS,r.wrapT=o.wrapT,r.name=o.name,hn&&(hn.dispose(),hn=null),r}const Gs={POSITION:["byte","byte normalized","unsigned byte","unsigned byte normalized","short","short normalized","unsigned short","unsigned short normalized"],NORMAL:["byte normalized","short normalized"],TANGENT:["byte normalized","short normalized"],TEXCOORD:["byte","byte normalized","unsigned byte","short","short normalized","unsigned short"]};class Vn{constructor(){this.pluginCallbacks=[],this.register(function(e){return new no(e)}),this.register(function(e){return new so(e)}),this.register(function(e){return new oo(e)}),this.register(function(e){return new ao(e)}),this.register(function(e){return new lo(e)}),this.register(function(e){return new co(e)}),this.register(function(e){return new ro(e)}),this.register(function(e){return new io(e)}),this.register(function(e){return new uo(e)}),this.register(function(e){return new ho(e)}),this.register(function(e){return new fo(e)})}register(e){return this.pluginCallbacks.indexOf(e)===-1&&this.pluginCallbacks.push(e),this}unregister(e){return this.pluginCallbacks.indexOf(e)!==-1&&this.pluginCallbacks.splice(this.pluginCallbacks.indexOf(e),1),this}parse(e,t,n,s){const r=new to,i=[];for(let a=0,l=this.pluginCallbacks.length;a<l;a++)i.push(this.pluginCallbacks[a](r));r.setPlugins(i),r.write(e,t,s).catch(n)}parseAsync(e,t){const n=this;return new Promise(function(s,r){n.parse(e,s,r,t)})}}Wi(Vn,"Utils",{insertKeyframe:function(o,e){const n=o.getValueSize(),s=new o.TimeBufferType(o.times.length+1),r=new o.ValueBufferType(o.values.length+n),i=o.createInterpolant(new o.ValueBufferType(n));let a;if(o.times.length===0){s[0]=e;for(let l=0;l<n;l++)r[l]=0;a=0}else if(e<o.times[0]){if(Math.abs(o.times[0]-e)<.001)return 0;s[0]=e,s.set(o.times,1),r.set(i.evaluate(e),0),r.set(o.values,n),a=0}else if(e>o.times[o.times.length-1]){if(Math.abs(o.times[o.times.length-1]-e)<.001)return o.times.length-1;s[s.length-1]=e,s.set(o.times,0),r.set(o.values,0),r.set(i.evaluate(e),o.values.length),a=s.length-1}else for(let l=0;l<o.times.length;l++){if(Math.abs(o.times[l]-e)<.001)return l;if(o.times[l]<e&&o.times[l+1]>e){s.set(o.times.slice(0,l+1),0),s[l+1]=e,s.set(o.times.slice(l+1),l+2),r.set(o.values.slice(0,(l+1)*n),0),r.set(i.evaluate(e),(l+1)*n),r.set(o.values.slice((l+1)*n),(l+2)*n),a=l+1;break}}return o.times=s,o.values=r,a},mergeMorphTargetTracks:function(o,e){const t=[],n={},s=o.tracks;for(let r=0;r<s.length;++r){let i=s[r];const a=c.PropertyBinding.parseTrackName(i.name),l=c.PropertyBinding.findNode(e,a.nodeName);if(a.propertyName!=="morphTargetInfluences"||a.propertyIndex===void 0){t.push(i);continue}if(i.createInterpolant!==i.InterpolantFactoryMethodDiscrete&&i.createInterpolant!==i.InterpolantFactoryMethodLinear){if(i.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline)throw new Error("THREE.GLTFExporter: Cannot merge tracks with glTF CUBICSPLINE interpolation.");console.warn("THREE.GLTFExporter: Morph target interpolation mode not yet supported. Using LINEAR instead."),i=i.clone(),i.setInterpolation(c.InterpolateLinear)}const u=l.morphTargetInfluences.length,h=l.morphTargetDictionary[a.propertyIndex];if(h===void 0)throw new Error("THREE.GLTFExporter: Morph target name not found: "+a.propertyIndex);let d;if(n[l.uuid]===void 0){d=i.clone();const g=new d.ValueBufferType(u*d.times.length);for(let x=0;x<d.times.length;x++)g[x*u+h]=d.values[x];d.name=(a.nodeName||"")+".morphTargetInfluences",d.values=g,n[l.uuid]=d,t.push(d);continue}const y=i.createInterpolant(new i.ValueBufferType(1));d=n[l.uuid];for(let g=0;g<d.times.length;g++)d.values[g*u+h]=y.evaluate(d.times[g]);for(let g=0;g<i.times.length;g++){const x=this.insertKeyframe(d,i.times[g]);d.values[x*u+h]=i.values[g]}}return o.tracks=t,o}});const we={POINTS:0,LINES:1,LINE_LOOP:2,LINE_STRIP:3,TRIANGLES:4,TRIANGLE_STRIP:5,TRIANGLE_FAN:6,BYTE:5120,UNSIGNED_BYTE:5121,SHORT:5122,UNSIGNED_SHORT:5123,INT:5124,UNSIGNED_INT:5125,FLOAT:5126,ARRAY_BUFFER:34962,ELEMENT_ARRAY_BUFFER:34963,NEAREST:9728,LINEAR:9729,NEAREST_MIPMAP_NEAREST:9984,LINEAR_MIPMAP_NEAREST:9985,NEAREST_MIPMAP_LINEAR:9986,LINEAR_MIPMAP_LINEAR:9987,CLAMP_TO_EDGE:33071,MIRRORED_REPEAT:33648,REPEAT:10497},Rn="KHR_mesh_quantization",Ee={};Ee[c.NearestFilter]=we.NEAREST,Ee[c.NearestMipmapNearestFilter]=we.NEAREST_MIPMAP_NEAREST,Ee[c.NearestMipmapLinearFilter]=we.NEAREST_MIPMAP_LINEAR,Ee[c.LinearFilter]=we.LINEAR,Ee[c.LinearMipmapNearestFilter]=we.LINEAR_MIPMAP_NEAREST,Ee[c.LinearMipmapLinearFilter]=we.LINEAR_MIPMAP_LINEAR,Ee[c.ClampToEdgeWrapping]=we.CLAMP_TO_EDGE,Ee[c.RepeatWrapping]=we.REPEAT,Ee[c.MirroredRepeatWrapping]=we.MIRRORED_REPEAT;const js={scale:"scale",position:"translation",quaternion:"rotation",morphTargetInfluences:"weights"},Zi=new c.Color,Es=12,Ki=1179937895,qi=2,Ys=8,Qi=1313821514,Ji=5130562;function jt(o,e){return o.length===e.length&&o.every(function(t,n){return t===e[n]})}function Hi(o){return new TextEncoder().encode(o).buffer}function $i(o){return jt(o.elements,[1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1])}function eo(o,e,t){const n={min:new Array(o.itemSize).fill(Number.POSITIVE_INFINITY),max:new Array(o.itemSize).fill(Number.NEGATIVE_INFINITY)};for(let s=e;s<e+t;s++)for(let r=0;r<o.itemSize;r++){let i;o.itemSize>4?i=o.array[s*o.itemSize+r]:(r===0?i=o.getX(s):r===1?i=o.getY(s):r===2?i=o.getZ(s):r===3&&(i=o.getW(s)),o.normalized===!0&&(i=c.MathUtils.normalize(i,o.array))),n.min[r]=Math.min(n.min[r],i),n.max[r]=Math.max(n.max[r],i)}return n}function Xs(o){return Math.ceil(o/4)*4}function Gn(o,e=0){const t=Xs(o.byteLength);if(t!==o.byteLength){const n=new Uint8Array(t);if(n.set(new Uint8Array(o)),e!==0)for(let s=o.byteLength;s<t;s++)n[s]=e;return n.buffer}return o}function Ws(){return typeof document>"u"&&typeof OffscreenCanvas<"u"?new OffscreenCanvas(1,1):document.createElement("canvas")}function Zs(o,e){if(o.toBlob!==void 0)return new Promise(n=>o.toBlob(n,e));let t;return e==="image/jpeg"?t=.92:e==="image/webp"&&(t=.8),o.convertToBlob({type:e,quality:t})}class to{constructor(){this.plugins=[],this.options={},this.pending=[],this.buffers=[],this.byteOffset=0,this.buffers=[],this.nodeMap=new Map,this.skins=[],this.extensionsUsed={},this.extensionsRequired={},this.uids=new Map,this.uid=0,this.json={asset:{version:"2.0",generator:"THREE.GLTFExporter"}},this.cache={meshes:new Map,attributes:new Map,attributesNormalized:new Map,materials:new Map,textures:new Map,images:new Map}}setPlugins(e){this.plugins=e}async write(e,t,n={}){this.options=Object.assign({binary:!1,trs:!1,onlyVisible:!0,maxTextureSize:1/0,animations:[],includeCustomExtensions:!1},n),this.options.animations.length>0&&(this.options.trs=!0),this.processInput(e),await Promise.all(this.pending);const s=this,r=s.buffers,i=s.json;n=s.options;const a=s.extensionsUsed,l=s.extensionsRequired,u=new Blob(r,{type:"application/octet-stream"}),h=Object.keys(a),d=Object.keys(l);h.length>0&&(i.extensionsUsed=h),d.length>0&&(i.extensionsRequired=d),i.buffers&&i.buffers.length>0&&(i.buffers[0].byteLength=u.size),n.binary===!0?u.arrayBuffer().then(y=>{const g=Gn(y),x=new DataView(new ArrayBuffer(Ys));x.setUint32(0,g.byteLength,!0),x.setUint32(4,Ji,!0);const w=Gn(Hi(JSON.stringify(i)),32),v=new DataView(new ArrayBuffer(Ys));v.setUint32(0,w.byteLength,!0),v.setUint32(4,Qi,!0);const P=new ArrayBuffer(Es),D=new DataView(P);D.setUint32(0,Ki,!0),D.setUint32(4,qi,!0);const S=Es+v.byteLength+w.byteLength+x.byteLength+g.byteLength;D.setUint32(8,S,!0),new Blob([P,v,w,x,g],{type:"application/octet-stream"}).arrayBuffer().then(t)}):i.buffers&&i.buffers.length>0?Rs(u).then(y=>{i.buffers[0].uri=y,t(i)}):t(i)}serializeUserData(e,t){if(Object.keys(e.userData).length===0)return;const n=this.options,s=this.extensionsUsed;try{const r=JSON.parse(JSON.stringify(e.userData));if(n.includeCustomExtensions&&r.gltfExtensions){t.extensions===void 0&&(t.extensions={});for(const i in r.gltfExtensions)t.extensions[i]=r.gltfExtensions[i],s[i]=!0;delete r.gltfExtensions}Object.keys(r).length>0&&(t.extras=r)}catch(r){console.warn("THREE.GLTFExporter: userData of '"+e.name+"' won't be serialized because of JSON.stringify error - "+r.message)}}getUID(e,t=!1){if(this.uids.has(e)===!1){const s=new Map;s.set(!0,this.uid++),s.set(!1,this.uid++),this.uids.set(e,s)}return this.uids.get(e).get(t)}isNormalizedNormalAttribute(e){if(this.cache.attributesNormalized.has(e))return!1;const n=new c.Vector3;for(let s=0,r=e.count;s<r;s++)if(Math.abs(n.fromBufferAttribute(e,s).length()-1)>5e-4)return!1;return!0}createNormalizedNormalAttribute(e){const t=this.cache;if(t.attributesNormalized.has(e))return t.attributesNormalized.get(e);const n=e.clone(),s=new c.Vector3;for(let r=0,i=n.count;r<i;r++)s.fromBufferAttribute(n,r),s.x===0&&s.y===0&&s.z===0?s.setX(1):s.normalize(),n.setXYZ(r,s.x,s.y,s.z);return t.attributesNormalized.set(e,n),n}applyTextureTransform(e,t){let n=!1;const s={};(t.offset.x!==0||t.offset.y!==0)&&(s.offset=t.offset.toArray(),n=!0),t.rotation!==0&&(s.rotation=t.rotation,n=!0),(t.repeat.x!==1||t.repeat.y!==1)&&(s.scale=t.repeat.toArray(),n=!0),n&&(e.extensions=e.extensions||{},e.extensions.KHR_texture_transform=s,this.extensionsUsed.KHR_texture_transform=!0)}buildMetalRoughTexture(e,t){if(e===t)return e;function n(g){return("colorSpace"in g?g.colorSpace==="srgb":g.encoding===3001)?function(w){return w<.04045?w*.0773993808:Math.pow(w*.9478672986+.0521327014,2.4)}:function(w){return w}}console.warn("THREE.GLTFExporter: Merged metalnessMap and roughnessMap textures."),e instanceof c.CompressedTexture&&(e=zn(e)),t instanceof c.CompressedTexture&&(t=zn(t));const s=e?e.image:null,r=t?t.image:null,i=Math.max(s?s.width:0,r?r.width:0),a=Math.max(s?s.height:0,r?r.height:0),l=Ws();l.width=i,l.height=a;const u=l.getContext("2d");u.fillStyle="#00ffff",u.fillRect(0,0,i,a);const h=u.getImageData(0,0,i,a);if(s){u.drawImage(s,0,0,i,a);const g=n(e),x=u.getImageData(0,0,i,a).data;for(let w=2;w<x.length;w+=4)h.data[w]=g(x[w]/256)*256}if(r){u.drawImage(r,0,0,i,a);const g=n(t),x=u.getImageData(0,0,i,a).data;for(let w=1;w<x.length;w+=4)h.data[w]=g(x[w]/256)*256}u.putImageData(h,0,0);const y=(e||t).clone();return y.source=new c.Texture(l).source,"colorSpace"in y?y.colorSpace="":y.encoding=3e3,y.channel=(e||t).channel,e&&t&&e.channel!==t.channel&&console.warn("THREE.GLTFExporter: UV channels for metalnessMap and roughnessMap textures must match."),y}processBuffer(e){const t=this.json,n=this.buffers;return t.buffers||(t.buffers=[{byteLength:0}]),n.push(e),0}processBufferView(e,t,n,s,r){const i=this.json;i.bufferViews||(i.bufferViews=[]);let a;switch(t){case we.BYTE:case we.UNSIGNED_BYTE:a=1;break;case we.SHORT:case we.UNSIGNED_SHORT:a=2;break;default:a=4}const l=Xs(s*e.itemSize*a),u=new DataView(new ArrayBuffer(l));let h=0;for(let g=n;g<n+s;g++)for(let x=0;x<e.itemSize;x++){let w;e.itemSize>4?w=e.array[g*e.itemSize+x]:(x===0?w=e.getX(g):x===1?w=e.getY(g):x===2?w=e.getZ(g):x===3&&(w=e.getW(g)),e.normalized===!0&&(w=c.MathUtils.normalize(w,e.array))),t===we.FLOAT?u.setFloat32(h,w,!0):t===we.INT?u.setInt32(h,w,!0):t===we.UNSIGNED_INT?u.setUint32(h,w,!0):t===we.SHORT?u.setInt16(h,w,!0):t===we.UNSIGNED_SHORT?u.setUint16(h,w,!0):t===we.BYTE?u.setInt8(h,w):t===we.UNSIGNED_BYTE&&u.setUint8(h,w),h+=a}const d={buffer:this.processBuffer(u.buffer),byteOffset:this.byteOffset,byteLength:l};return r!==void 0&&(d.target=r),r===we.ARRAY_BUFFER&&(d.byteStride=e.itemSize*a),this.byteOffset+=l,i.bufferViews.push(d),{id:i.bufferViews.length-1,byteLength:0}}processBufferViewImage(e){const t=this,n=t.json;return n.bufferViews||(n.bufferViews=[]),e.arrayBuffer().then(s=>{const r=Gn(s),i={buffer:t.processBuffer(r),byteOffset:t.byteOffset,byteLength:r.byteLength};return t.byteOffset+=r.byteLength,n.bufferViews.push(i)-1})}processAccessor(e,t,n,s){const r=this.json,i={1:"SCALAR",2:"VEC2",3:"VEC3",4:"VEC4",9:"MAT3",16:"MAT4"};let a;if(e.array.constructor===Float32Array)a=we.FLOAT;else if(e.array.constructor===Int32Array)a=we.INT;else if(e.array.constructor===Uint32Array)a=we.UNSIGNED_INT;else if(e.array.constructor===Int16Array)a=we.SHORT;else if(e.array.constructor===Uint16Array)a=we.UNSIGNED_SHORT;else if(e.array.constructor===Int8Array)a=we.BYTE;else if(e.array.constructor===Uint8Array)a=we.UNSIGNED_BYTE;else throw new Error("THREE.GLTFExporter: Unsupported bufferAttribute component type: "+e.array.constructor.name);if(n===void 0&&(n=0),s===void 0&&(s=e.count),s===0)return null;const l=eo(e,n,s);let u;t!==void 0&&(u=e===t.index?we.ELEMENT_ARRAY_BUFFER:we.ARRAY_BUFFER);const h=this.processBufferView(e,a,n,s,u),d={bufferView:h.id,byteOffset:h.byteOffset,componentType:a,count:s,max:l.max,min:l.min,type:i[e.itemSize]};return e.normalized===!0&&(d.normalized=!0),r.accessors||(r.accessors=[]),r.accessors.push(d)-1}processImage(e,t,n,s="image/png"){if(e!==null){const r=this,i=r.cache,a=r.json,l=r.options,u=r.pending;i.images.has(e)||i.images.set(e,{});const h=i.images.get(e),d=s+":flipY/"+n.toString();if(h[d]!==void 0)return h[d];a.images||(a.images=[]);const y={mimeType:s},g=Ws();g.width=Math.min(e.width,l.maxTextureSize),g.height=Math.min(e.height,l.maxTextureSize);const x=g.getContext("2d");if(n===!0&&(x.translate(0,g.height),x.scale(1,-1)),e.data!==void 0){t!==c.RGBAFormat&&console.error("GLTFExporter: Only RGBAFormat is supported.",t),(e.width>l.maxTextureSize||e.height>l.maxTextureSize)&&console.warn("GLTFExporter: Image size is bigger than maxTextureSize",e);const v=new Uint8ClampedArray(e.height*e.width*4);for(let P=0;P<v.length;P+=4)v[P+0]=e.data[P+0],v[P+1]=e.data[P+1],v[P+2]=e.data[P+2],v[P+3]=e.data[P+3];x.putImageData(new ImageData(v,e.width,e.height),0,0)}else x.drawImage(e,0,0,g.width,g.height);l.binary===!0?u.push(Zs(g,s).then(v=>r.processBufferViewImage(v)).then(v=>{y.bufferView=v})):g.toDataURL!==void 0?y.uri=g.toDataURL(s):u.push(Zs(g,s).then(Rs).then(v=>{y.uri=v}));const w=a.images.push(y)-1;return h[d]=w,w}else throw new Error("THREE.GLTFExporter: No valid image data found. Unable to process texture.")}processSampler(e){const t=this.json;t.samplers||(t.samplers=[]);const n={magFilter:Ee[e.magFilter],minFilter:Ee[e.minFilter],wrapS:Ee[e.wrapS],wrapT:Ee[e.wrapT]};return t.samplers.push(n)-1}processTexture(e){const n=this.options,s=this.cache,r=this.json;if(s.textures.has(e))return s.textures.get(e);r.textures||(r.textures=[]),e instanceof c.CompressedTexture&&(e=zn(e,n.maxTextureSize));let i=e.userData.mimeType;i==="image/webp"&&(i="image/png");const a={sampler:this.processSampler(e),source:this.processImage(e.image,e.format,e.flipY,i)};e.name&&(a.name=e.name),this._invokeAll(function(u){u.writeTexture&&u.writeTexture(e,a)});const l=r.textures.push(a)-1;return s.textures.set(e,l),l}processMaterial(e){const t=this.cache,n=this.json;if(t.materials.has(e))return t.materials.get(e);if(e.isShaderMaterial)return console.warn("GLTFExporter: THREE.ShaderMaterial not supported."),null;n.materials||(n.materials=[]);const s={pbrMetallicRoughness:{}};e.isMeshStandardMaterial!==!0&&e.isMeshBasicMaterial!==!0&&console.warn("GLTFExporter: Use MeshStandardMaterial or MeshBasicMaterial for best results.");const r=e.color.toArray().concat([e.opacity]);if(jt(r,[1,1,1,1])||(s.pbrMetallicRoughness.baseColorFactor=r),e.isMeshStandardMaterial?(s.pbrMetallicRoughness.metallicFactor=e.metalness,s.pbrMetallicRoughness.roughnessFactor=e.roughness):(s.pbrMetallicRoughness.metallicFactor=.5,s.pbrMetallicRoughness.roughnessFactor=.5),e.metalnessMap||e.roughnessMap){const a=this.buildMetalRoughTexture(e.metalnessMap,e.roughnessMap),l={index:this.processTexture(a),channel:a.channel};this.applyTextureTransform(l,a),s.pbrMetallicRoughness.metallicRoughnessTexture=l}if(e.map){const a={index:this.processTexture(e.map),texCoord:e.map.channel};this.applyTextureTransform(a,e.map),s.pbrMetallicRoughness.baseColorTexture=a}if(e.emissive){const a=e.emissive;if(Math.max(a.r,a.g,a.b)>0&&(s.emissiveFactor=e.emissive.toArray()),e.emissiveMap){const u={index:this.processTexture(e.emissiveMap),texCoord:e.emissiveMap.channel};this.applyTextureTransform(u,e.emissiveMap),s.emissiveTexture=u}}if(e.normalMap){const a={index:this.processTexture(e.normalMap),texCoord:e.normalMap.channel};e.normalScale&&e.normalScale.x!==1&&(a.scale=e.normalScale.x),this.applyTextureTransform(a,e.normalMap),s.normalTexture=a}if(e.aoMap){const a={index:this.processTexture(e.aoMap),texCoord:e.aoMap.channel};e.aoMapIntensity!==1&&(a.strength=e.aoMapIntensity),this.applyTextureTransform(a,e.aoMap),s.occlusionTexture=a}e.transparent?s.alphaMode="BLEND":e.alphaTest>0&&(s.alphaMode="MASK",s.alphaCutoff=e.alphaTest),e.side===c.DoubleSide&&(s.doubleSided=!0),e.name!==""&&(s.name=e.name),this.serializeUserData(e,s),this._invokeAll(function(a){a.writeMaterial&&a.writeMaterial(e,s)});const i=n.materials.push(s)-1;return t.materials.set(e,i),i}processMesh(e){const t=this.cache,n=this.json,s=[e.geometry.uuid];if(Array.isArray(e.material))for(let S=0,_=e.material.length;S<_;S++)s.push(e.material[S].uuid);else s.push(e.material.uuid);const r=s.join(":");if(t.meshes.has(r))return t.meshes.get(r);const i=e.geometry;let a;e.isLineSegments?a=we.LINES:e.isLineLoop?a=we.LINE_LOOP:e.isLine?a=we.LINE_STRIP:e.isPoints?a=we.POINTS:a=e.material.wireframe?we.LINES:we.TRIANGLES;const l={},u={},h=[],d=[],y={...Vs>=152?{uv:"TEXCOORD_0",uv1:"TEXCOORD_1",uv2:"TEXCOORD_2",uv3:"TEXCOORD_3"}:{uv:"TEXCOORD_0",uv2:"TEXCOORD_1"},color:"COLOR_0",skinWeight:"WEIGHTS_0",skinIndex:"JOINTS_0"},g=i.getAttribute("normal");g!==void 0&&!this.isNormalizedNormalAttribute(g)&&(console.warn("THREE.GLTFExporter: Creating normalized normal attribute from the non-normalized one."),i.setAttribute("normal",this.createNormalizedNormalAttribute(g)));let x=null;for(let S in i.attributes){if(S.slice(0,5)==="morph")continue;const _=i.attributes[S];if(S=y[S]||S.toUpperCase(),/^(POSITION|NORMAL|TANGENT|TEXCOORD_\d+|COLOR_\d+|JOINTS_\d+|WEIGHTS_\d+)$/.test(S)||(S="_"+S),t.attributes.has(this.getUID(_))){u[S]=t.attributes.get(this.getUID(_));continue}x=null;const b=_.array;S==="JOINTS_0"&&!(b instanceof Uint16Array)&&!(b instanceof Uint8Array)&&(console.warn('GLTFExporter: Attribute "skinIndex" converted to type UNSIGNED_SHORT.'),x=new c.BufferAttribute(new Uint16Array(b),_.itemSize,_.normalized));const C=this.processAccessor(x||_,i);C!==null&&(S.startsWith("_")||this.detectMeshQuantization(S,_),u[S]=C,t.attributes.set(this.getUID(_),C))}if(g!==void 0&&i.setAttribute("normal",g),Object.keys(u).length===0)return null;if(e.morphTargetInfluences!==void 0&&e.morphTargetInfluences.length>0){const S=[],_=[],L={};if(e.morphTargetDictionary!==void 0)for(const b in e.morphTargetDictionary)L[e.morphTargetDictionary[b]]=b;for(let b=0;b<e.morphTargetInfluences.length;++b){const C={};let m=!1;for(const M in i.morphAttributes){if(M!=="position"&&M!=="normal"){m||(console.warn("GLTFExporter: Only POSITION and NORMAL morph are supported."),m=!0);continue}const p=i.morphAttributes[M][b],I=M.toUpperCase(),F=i.attributes[M];if(t.attributes.has(this.getUID(p,!0))){C[I]=t.attributes.get(this.getUID(p,!0));continue}const J=p.clone();if(!i.morphTargetsRelative)for(let G=0,Q=p.count;G<Q;G++)for(let K=0;K<p.itemSize;K++)K===0&&J.setX(G,p.getX(G)-F.getX(G)),K===1&&J.setY(G,p.getY(G)-F.getY(G)),K===2&&J.setZ(G,p.getZ(G)-F.getZ(G)),K===3&&J.setW(G,p.getW(G)-F.getW(G));C[I]=this.processAccessor(J,i),t.attributes.set(this.getUID(F,!0),C[I])}d.push(C),S.push(e.morphTargetInfluences[b]),e.morphTargetDictionary!==void 0&&_.push(L[b])}l.weights=S,_.length>0&&(l.extras={},l.extras.targetNames=_)}const w=Array.isArray(e.material);if(w&&i.groups.length===0)return null;const v=w?e.material:[e.material],P=w?i.groups:[{materialIndex:0,start:void 0,count:void 0}];for(let S=0,_=P.length;S<_;S++){const L={mode:a,attributes:u};if(this.serializeUserData(i,L),d.length>0&&(L.targets=d),i.index!==null){let C=this.getUID(i.index);(P[S].start!==void 0||P[S].count!==void 0)&&(C+=":"+P[S].start+":"+P[S].count),t.attributes.has(C)?L.indices=t.attributes.get(C):(L.indices=this.processAccessor(i.index,i,P[S].start,P[S].count),t.attributes.set(C,L.indices)),L.indices===null&&delete L.indices}const b=this.processMaterial(v[P[S].materialIndex]);b!==null&&(L.material=b),h.push(L)}l.primitives=h,n.meshes||(n.meshes=[]),this._invokeAll(function(S){S.writeMesh&&S.writeMesh(e,l)});const D=n.meshes.push(l)-1;return t.meshes.set(r,D),D}detectMeshQuantization(e,t){if(this.extensionsUsed[Rn])return;let n;switch(t.array.constructor){case Int8Array:n="byte";break;case Uint8Array:n="unsigned byte";break;case Int16Array:n="short";break;case Uint16Array:n="unsigned short";break;default:return}t.normalized&&(n+=" normalized");const s=e.split("_",1)[0];Gs[s]&&Gs[s].includes(n)&&(this.extensionsUsed[Rn]=!0,this.extensionsRequired[Rn]=!0)}processCamera(e){const t=this.json;t.cameras||(t.cameras=[]);const n=e.isOrthographicCamera,s={type:n?"orthographic":"perspective"};return n?s.orthographic={xmag:e.right*2,ymag:e.top*2,zfar:e.far<=0?.001:e.far,znear:e.near<0?0:e.near}:s.perspective={aspectRatio:e.aspect,yfov:c.MathUtils.degToRad(e.fov),zfar:e.far<=0?.001:e.far,znear:e.near<0?0:e.near},e.name!==""&&(s.name=e.type),t.cameras.push(s)-1}processAnimation(e,t){const n=this.json,s=this.nodeMap;n.animations||(n.animations=[]),e=Vn.Utils.mergeMorphTargetTracks(e.clone(),t);const r=e.tracks,i=[],a=[];for(let l=0;l<r.length;++l){const u=r[l],h=c.PropertyBinding.parseTrackName(u.name);let d=c.PropertyBinding.findNode(t,h.nodeName);const y=js[h.propertyName];if(h.objectName==="bones"&&(d.isSkinnedMesh===!0?d=d.skeleton.getBoneByName(h.objectIndex):d=void 0),!d||!y)return console.warn('THREE.GLTFExporter: Could not export animation track "%s".',u.name),null;const g=1;let x=u.values.length/u.times.length;y===js.morphTargetInfluences&&(x/=d.morphTargetInfluences.length);let w;u.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline===!0?(w="CUBICSPLINE",x/=3):u.getInterpolation()===c.InterpolateDiscrete?w="STEP":w="LINEAR",a.push({input:this.processAccessor(new c.BufferAttribute(u.times,g)),output:this.processAccessor(new c.BufferAttribute(u.values,x)),interpolation:w}),i.push({sampler:a.length-1,target:{node:s.get(d),path:y}})}return n.animations.push({name:e.name||"clip_"+n.animations.length,samplers:a,channels:i}),n.animations.length-1}processSkin(e){const t=this.json,n=this.nodeMap,s=t.nodes[n.get(e)],r=e.skeleton;if(r===void 0)return null;const i=e.skeleton.bones[0];if(i===void 0)return null;const a=[],l=new Float32Array(r.bones.length*16),u=new c.Matrix4;for(let d=0;d<r.bones.length;++d)a.push(n.get(r.bones[d])),u.copy(r.boneInverses[d]),u.multiply(e.bindMatrix).toArray(l,d*16);return t.skins===void 0&&(t.skins=[]),t.skins.push({inverseBindMatrices:this.processAccessor(new c.BufferAttribute(l,16)),joints:a,skeleton:n.get(i)}),s.skin=t.skins.length-1}processNode(e){const t=this.json,n=this.options,s=this.nodeMap;t.nodes||(t.nodes=[]);const r={};if(n.trs){const a=e.quaternion.toArray(),l=e.position.toArray(),u=e.scale.toArray();jt(a,[0,0,0,1])||(r.rotation=a),jt(l,[0,0,0])||(r.translation=l),jt(u,[1,1,1])||(r.scale=u)}else e.matrixAutoUpdate&&e.updateMatrix(),$i(e.matrix)===!1&&(r.matrix=e.matrix.elements);if(e.name!==""&&(r.name=String(e.name)),this.serializeUserData(e,r),e.isMesh||e.isLine||e.isPoints){const a=this.processMesh(e);a!==null&&(r.mesh=a)}else e.isCamera&&(r.camera=this.processCamera(e));if(e.isSkinnedMesh&&this.skins.push(e),e.children.length>0){const a=[];for(let l=0,u=e.children.length;l<u;l++){const h=e.children[l];if(h.visible||n.onlyVisible===!1){const d=this.processNode(h);d!==null&&a.push(d)}}a.length>0&&(r.children=a)}this._invokeAll(function(a){a.writeNode&&a.writeNode(e,r)});const i=t.nodes.push(r)-1;return s.set(e,i),i}processScene(e){const t=this.json,n=this.options;t.scenes||(t.scenes=[],t.scene=0);const s={};e.name!==""&&(s.name=e.name),t.scenes.push(s);const r=[];for(let i=0,a=e.children.length;i<a;i++){const l=e.children[i];if(l.visible||n.onlyVisible===!1){const u=this.processNode(l);u!==null&&r.push(u)}}r.length>0&&(s.nodes=r),this.serializeUserData(e,s)}processObjects(e){const t=new c.Scene;t.name="AuxScene";for(let n=0;n<e.length;n++)t.children.push(e[n]);this.processScene(t)}processInput(e){const t=this.options;e=e instanceof Array?e:[e],this._invokeAll(function(s){s.beforeParse&&s.beforeParse(e)});const n=[];for(let s=0;s<e.length;s++)e[s]instanceof c.Scene?this.processScene(e[s]):n.push(e[s]);n.length>0&&this.processObjects(n);for(let s=0;s<this.skins.length;++s)this.processSkin(this.skins[s]);for(let s=0;s<t.animations.length;++s)this.processAnimation(t.animations[s],e[0]);this._invokeAll(function(s){s.afterParse&&s.afterParse(e)})}_invokeAll(e){for(let t=0,n=this.plugins.length;t<n;t++)e(this.plugins[t])}}class no{constructor(e){this.writer=e,this.name="KHR_lights_punctual"}writeNode(e,t){if(!e.isLight)return;if(!e.isDirectionalLight&&!e.isPointLight&&!e.isSpotLight){console.warn("THREE.GLTFExporter: Only directional, point, and spot lights are supported.",e);return}const n=this.writer,s=n.json,r=n.extensionsUsed,i={};e.name&&(i.name=e.name),i.color=e.color.toArray(),i.intensity=e.intensity,e.isDirectionalLight?i.type="directional":e.isPointLight?(i.type="point",e.distance>0&&(i.range=e.distance)):e.isSpotLight&&(i.type="spot",e.distance>0&&(i.range=e.distance),i.spot={},i.spot.innerConeAngle=(e.penumbra-1)*e.angle*-1,i.spot.outerConeAngle=e.angle),e.decay!==void 0&&e.decay!==2&&console.warn("THREE.GLTFExporter: Light decay may be lost. glTF is physically-based, and expects light.decay=2."),e.target&&(e.target.parent!==e||e.target.position.x!==0||e.target.position.y!==0||e.target.position.z!==-1)&&console.warn("THREE.GLTFExporter: Light direction may be lost. For best results, make light.target a child of the light with position 0,0,-1."),r[this.name]||(s.extensions=s.extensions||{},s.extensions[this.name]={lights:[]},r[this.name]=!0);const a=s.extensions[this.name].lights;a.push(i),t.extensions=t.extensions||{},t.extensions[this.name]={light:a.length-1}}}let so=class{constructor(e){this.writer=e,this.name="KHR_materials_unlit"}writeMaterial(e,t){if(!e.isMeshBasicMaterial)return;const s=this.writer.extensionsUsed;t.extensions=t.extensions||{},t.extensions[this.name]={},s[this.name]=!0,t.pbrMetallicRoughness.metallicFactor=0,t.pbrMetallicRoughness.roughnessFactor=.9}},ro=class{constructor(e){this.writer=e,this.name="KHR_materials_clearcoat"}writeMaterial(e,t){if(!e.isMeshPhysicalMaterial||e.clearcoat===0)return;const n=this.writer,s=n.extensionsUsed,r={};if(r.clearcoatFactor=e.clearcoat,e.clearcoatMap){const i={index:n.processTexture(e.clearcoatMap),texCoord:e.clearcoatMap.channel};n.applyTextureTransform(i,e.clearcoatMap),r.clearcoatTexture=i}if(r.clearcoatRoughnessFactor=e.clearcoatRoughness,e.clearcoatRoughnessMap){const i={index:n.processTexture(e.clearcoatRoughnessMap),texCoord:e.clearcoatRoughnessMap.channel};n.applyTextureTransform(i,e.clearcoatRoughnessMap),r.clearcoatRoughnessTexture=i}if(e.clearcoatNormalMap){const i={index:n.processTexture(e.clearcoatNormalMap),texCoord:e.clearcoatNormalMap.channel};n.applyTextureTransform(i,e.clearcoatNormalMap),r.clearcoatNormalTexture=i}t.extensions=t.extensions||{},t.extensions[this.name]=r,s[this.name]=!0}},io=class{constructor(e){this.writer=e,this.name="KHR_materials_iridescence"}writeMaterial(e,t){if(!e.isMeshPhysicalMaterial||e.iridescence===0)return;const n=this.writer,s=n.extensionsUsed,r={};if(r.iridescenceFactor=e.iridescence,e.iridescenceMap){const i={index:n.processTexture(e.iridescenceMap),texCoord:e.iridescenceMap.channel};n.applyTextureTransform(i,e.iridescenceMap),r.iridescenceTexture=i}if(r.iridescenceIor=e.iridescenceIOR,r.iridescenceThicknessMinimum=e.iridescenceThicknessRange[0],r.iridescenceThicknessMaximum=e.iridescenceThicknessRange[1],e.iridescenceThicknessMap){const i={index:n.processTexture(e.iridescenceThicknessMap),texCoord:e.iridescenceThicknessMap.channel};n.applyTextureTransform(i,e.iridescenceThicknessMap),r.iridescenceThicknessTexture=i}t.extensions=t.extensions||{},t.extensions[this.name]=r,s[this.name]=!0}},oo=class{constructor(e){this.writer=e,this.name="KHR_materials_transmission"}writeMaterial(e,t){if(!e.isMeshPhysicalMaterial||e.transmission===0)return;const n=this.writer,s=n.extensionsUsed,r={};if(r.transmissionFactor=e.transmission,e.transmissionMap){const i={index:n.processTexture(e.transmissionMap),texCoord:e.transmissionMap.channel};n.applyTextureTransform(i,e.transmissionMap),r.transmissionTexture=i}t.extensions=t.extensions||{},t.extensions[this.name]=r,s[this.name]=!0}},ao=class{constructor(e){this.writer=e,this.name="KHR_materials_volume"}writeMaterial(e,t){if(!e.isMeshPhysicalMaterial||e.transmission===0)return;const n=this.writer,s=n.extensionsUsed,r={};if(r.thicknessFactor=e.thickness,e.thicknessMap){const i={index:n.processTexture(e.thicknessMap),texCoord:e.thicknessMap.channel};n.applyTextureTransform(i,e.thicknessMap),r.thicknessTexture=i}r.attenuationDistance=e.attenuationDistance,r.attenuationColor=e.attenuationColor.toArray(),t.extensions=t.extensions||{},t.extensions[this.name]=r,s[this.name]=!0}},lo=class{constructor(e){this.writer=e,this.name="KHR_materials_ior"}writeMaterial(e,t){if(!e.isMeshPhysicalMaterial||e.ior===1.5)return;const s=this.writer.extensionsUsed,r={};r.ior=e.ior,t.extensions=t.extensions||{},t.extensions[this.name]=r,s[this.name]=!0}},co=class{constructor(e){this.writer=e,this.name="KHR_materials_specular"}writeMaterial(e,t){if(!e.isMeshPhysicalMaterial||e.specularIntensity===1&&e.specularColor.equals(Zi)&&!e.specularIntensityMap&&!e.specularColorTexture)return;const n=this.writer,s=n.extensionsUsed,r={};if(e.specularIntensityMap){const i={index:n.processTexture(e.specularIntensityMap),texCoord:e.specularIntensityMap.channel};n.applyTextureTransform(i,e.specularIntensityMap),r.specularTexture=i}if(e.specularColorMap){const i={index:n.processTexture(e.specularColorMap),texCoord:e.specularColorMap.channel};n.applyTextureTransform(i,e.specularColorMap),r.specularColorTexture=i}r.specularFactor=e.specularIntensity,r.specularColorFactor=e.specularColor.toArray(),t.extensions=t.extensions||{},t.extensions[this.name]=r,s[this.name]=!0}},uo=class{constructor(e){this.writer=e,this.name="KHR_materials_sheen"}writeMaterial(e,t){if(!e.isMeshPhysicalMaterial||e.sheen==0)return;const n=this.writer,s=n.extensionsUsed,r={};if(e.sheenRoughnessMap){const i={index:n.processTexture(e.sheenRoughnessMap),texCoord:e.sheenRoughnessMap.channel};n.applyTextureTransform(i,e.sheenRoughnessMap),r.sheenRoughnessTexture=i}if(e.sheenColorMap){const i={index:n.processTexture(e.sheenColorMap),texCoord:e.sheenColorMap.channel};n.applyTextureTransform(i,e.sheenColorMap),r.sheenColorTexture=i}r.sheenRoughnessFactor=e.sheenRoughness,r.sheenColorFactor=e.sheenColor.toArray(),t.extensions=t.extensions||{},t.extensions[this.name]=r,s[this.name]=!0}},ho=class{constructor(e){this.writer=e,this.name="KHR_materials_anisotropy"}writeMaterial(e,t){if(!e.isMeshPhysicalMaterial||e.anisotropy==0)return;const n=this.writer,s=n.extensionsUsed,r={};if(e.anisotropyMap){const i={index:n.processTexture(e.anisotropyMap)};n.applyTextureTransform(i,e.anisotropyMap),r.anisotropyTexture=i}r.anisotropyStrength=e.anisotropy,r.anisotropyRotation=e.anisotropyRotation,t.extensions=t.extensions||{},t.extensions[this.name]=r,s[this.name]=!0}},fo=class{constructor(e){this.writer=e,this.name="KHR_materials_emissive_strength"}writeMaterial(e,t){if(!e.isMeshStandardMaterial||e.emissiveIntensity===1)return;const s=this.writer.extensionsUsed,r={};r.emissiveStrength=e.emissiveIntensity,t.extensions=t.extensions||{},t.extensions[this.name]=r,s[this.name]=!0}};var Xe=Uint8Array,ht=Uint16Array,jn=Uint32Array,Ks=new Xe([0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0,0,0,0]),qs=new Xe([0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13,0,0]),po=new Xe([16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15]),Qs=function(o,e){for(var t=new ht(31),n=0;n<31;++n)t[n]=e+=1<<o[n-1];for(var s=new jn(t[30]),n=1;n<30;++n)for(var r=t[n];r<t[n+1];++r)s[r]=r-t[n]<<5|n;return[t,s]},Js=Qs(Ks,2),Hs=Js[0],mo=Js[1];Hs[28]=258,mo[258]=28;for(var go=Qs(qs,0),yo=go[0],En=new ht(32768),Te=0;Te<32768;++Te){var ft=(Te&43690)>>>1|(Te&21845)<<1;ft=(ft&52428)>>>2|(ft&13107)<<2,ft=(ft&61680)>>>4|(ft&3855)<<4,En[Te]=((ft&65280)>>>8|(ft&255)<<8)>>>1}for(var Et=function(o,e,t){for(var n=o.length,s=0,r=new ht(e);s<n;++s)++r[o[s]-1];var i=new ht(e);for(s=0;s<e;++s)i[s]=i[s-1]+r[s-1]<<1;var a;if(t){a=new ht(1<<e);var l=15-e;for(s=0;s<n;++s)if(o[s])for(var u=s<<4|o[s],h=e-o[s],d=i[o[s]-1]++<<h,y=d|(1<<h)-1;d<=y;++d)a[En[d]>>>l]=u}else for(a=new ht(n),s=0;s<n;++s)o[s]&&(a[s]=En[i[o[s]-1]++]>>>15-o[s]);return a},Yt=new Xe(288),Te=0;Te<144;++Te)Yt[Te]=8;for(var Te=144;Te<256;++Te)Yt[Te]=9;for(var Te=256;Te<280;++Te)Yt[Te]=7;for(var Te=280;Te<288;++Te)Yt[Te]=8;for(var $s=new Xe(32),Te=0;Te<32;++Te)$s[Te]=5;var _o=Et(Yt,9,1),vo=Et($s,5,1),Yn=function(o){for(var e=o[0],t=1;t<o.length;++t)o[t]>e&&(e=o[t]);return e},qe=function(o,e,t){var n=e/8|0;return(o[n]|o[n+1]<<8)>>(e&7)&t},Xn=function(o,e){var t=e/8|0;return(o[t]|o[t+1]<<8|o[t+2]<<16)>>(e&7)},xo=function(o){return(o/8|0)+(o&7&&1)},wo=function(o,e,t){(e==null||e<0)&&(e=0),(t==null||t>o.length)&&(t=o.length);var n=new(o instanceof ht?ht:o instanceof jn?jn:Xe)(t-e);return n.set(o.subarray(e,t)),n},bo=function(o,e,t){var n=o.length;if(!n||t&&!t.l&&n<5)return e||new Xe(0);var s=!e||t,r=!t||t.i;t||(t={}),e||(e=new Xe(n*3));var i=function(ee){var N=e.length;if(ee>N){var R=new Xe(Math.max(N*2,ee));R.set(e),e=R}},a=t.f||0,l=t.p||0,u=t.b||0,h=t.l,d=t.d,y=t.m,g=t.n,x=n*8;do{if(!h){t.f=a=qe(o,l,1);var w=qe(o,l+1,3);if(l+=3,w)if(w==1)h=_o,d=vo,y=9,g=5;else if(w==2){var S=qe(o,l,31)+257,_=qe(o,l+10,15)+4,L=S+qe(o,l+5,31)+1;l+=14;for(var b=new Xe(L),C=new Xe(19),m=0;m<_;++m)C[po[m]]=qe(o,l+m*3,7);l+=_*3;for(var M=Yn(C),p=(1<<M)-1,I=Et(C,M,1),m=0;m<L;){var F=I[qe(o,l,p)];l+=F&15;var v=F>>>4;if(v<16)b[m++]=v;else{var J=0,G=0;for(v==16?(G=3+qe(o,l,3),l+=2,J=b[m-1]):v==17?(G=3+qe(o,l,7),l+=3):v==18&&(G=11+qe(o,l,127),l+=7);G--;)b[m++]=J}}var Q=b.subarray(0,S),K=b.subarray(S);y=Yn(Q),g=Yn(K),h=Et(Q,y,1),d=Et(K,g,1)}else throw"invalid block type";else{var v=xo(l)+4,P=o[v-4]|o[v-3]<<8,D=v+P;if(D>n){if(r)throw"unexpected EOF";break}s&&i(u+P),e.set(o.subarray(v,D),u),t.b=u+=P,t.p=l=D*8;continue}if(l>x){if(r)throw"unexpected EOF";break}}s&&i(u+131072);for(var Z=(1<<y)-1,X=(1<<g)-1,ne=l;;ne=l){var J=h[Xn(o,l)&Z],se=J>>>4;if(l+=J&15,l>x){if(r)throw"unexpected EOF";break}if(!J)throw"invalid length/literal";if(se<256)e[u++]=se;else if(se==256){ne=l,h=null;break}else{var ue=se-254;if(se>264){var m=se-257,j=Ks[m];ue=qe(o,l,(1<<j)-1)+Hs[m],l+=j}var z=d[Xn(o,l)&X],A=z>>>4;if(!z)throw"invalid distance";l+=z&15;var K=yo[A];if(A>3){var j=qs[A];K+=Xn(o,l)&(1<<j)-1,l+=j}if(l>x){if(r)throw"unexpected EOF";break}s&&i(u+131072);for(var V=u+ue;u<V;u+=4)e[u]=e[u-K],e[u+1]=e[u+1-K],e[u+2]=e[u+2-K],e[u+3]=e[u+3-K];u=V}}t.l=h,t.p=ne,t.b=u,h&&(a=1,t.m=y,t.d=d,t.n=g)}while(!a);return u==e.length?e:wo(e,0,u)},Mo=new Xe(0),So=function(o){if((o[0]&15)!=8||o[0]>>>4>7||(o[0]<<8|o[1])%31)throw"invalid zlib data";if(o[1]&32)throw"invalid zlib data: preset dictionaries not supported"};function Ao(o,e){return bo((So(o),o.subarray(2,-4)),e)}var Po=typeof TextDecoder<"u"&&new TextDecoder,Co=0;try{Po.decode(Mo,{stream:!0}),Co=1}catch{}const ke=new c.Triangle,dn=new c.Vector3;class To{constructor(e){let t=e.geometry;t.index&&(console.warn("THREE.MeshSurfaceSampler: Converting geometry to non-indexed BufferGeometry."),t=t.toNonIndexed()),this.geometry=t,this.randomFunction=Math.random,this.positionAttribute=this.geometry.getAttribute("position"),this.colorAttribute=this.geometry.getAttribute("color"),this.weightAttribute=null,this.distribution=null}setWeightAttribute(e){return this.weightAttribute=e?this.geometry.getAttribute(e):null,this}build(){const e=this.positionAttribute,t=this.weightAttribute,n=new Float32Array(e.count/3);for(let r=0;r<e.count;r+=3){let i=1;t&&(i=t.getX(r)+t.getX(r+1)+t.getX(r+2)),ke.a.fromBufferAttribute(e,r),ke.b.fromBufferAttribute(e,r+1),ke.c.fromBufferAttribute(e,r+2),i*=ke.getArea(),n[r/3]=i}this.distribution=new Float32Array(e.count/3);let s=0;for(let r=0;r<n.length;r++)s+=n[r],this.distribution[r]=s;return this}setRandomGenerator(e){return this.randomFunction=e,this}sample(e,t,n){const s=this.sampleFaceIndex();return this.sampleFace(s,e,t,n)}sampleFaceIndex(){const e=this.distribution[this.distribution.length-1];return this.binarySearch(this.randomFunction()*e)}binarySearch(e){const t=this.distribution;let n=0,s=t.length-1,r=-1;for(;n<=s;){const i=Math.ceil((n+s)/2);if(i===0||t[i-1]<=e&&t[i]>e){r=i;break}else e<t[i]?s=i-1:n=i+1}return r}sampleFace(e,t,n,s){let r=this.randomFunction(),i=this.randomFunction();return r+i>1&&(r=1-r,i=1-i),ke.a.fromBufferAttribute(this.positionAttribute,e*3),ke.b.fromBufferAttribute(this.positionAttribute,e*3+1),ke.c.fromBufferAttribute(this.positionAttribute,e*3+2),t.set(0,0,0).addScaledVector(ke.a,r).addScaledVector(ke.b,i).addScaledVector(ke.c,1-(r+i)),n!==void 0&&ke.getNormal(n),s!==void 0&&this.colorAttribute!==void 0&&(ke.a.fromBufferAttribute(this.colorAttribute,e*3),ke.b.fromBufferAttribute(this.colorAttribute,e*3+1),ke.c.fromBufferAttribute(this.colorAttribute,e*3+2),dn.set(0,0,0).addScaledVector(ke.a,r).addScaledVector(ke.b,i).addScaledVector(ke.c,1-(r+i)),s.r=dn.x,s.g=dn.y,s.b=dn.z),this}}var Lo=Object.defineProperty,Io=(o,e,t)=>e in o?Lo(o,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):o[e]=t,H=(o,e,t)=>(Io(o,typeof e!="symbol"?e+"":e,t),t);class Do extends c.Object3D{constructor(e,t){super(),H(this,"isTransformControls",!0),H(this,"visible",!1),H(this,"domElement"),H(this,"raycaster",new c.Raycaster),H(this,"gizmo"),H(this,"plane"),H(this,"tempVector",new c.Vector3),H(this,"tempVector2",new c.Vector3),H(this,"tempQuaternion",new c.Quaternion),H(this,"unit",{X:new c.Vector3(1,0,0),Y:new c.Vector3(0,1,0),Z:new c.Vector3(0,0,1)}),H(this,"pointStart",new c.Vector3),H(this,"pointEnd",new c.Vector3),H(this,"offset",new c.Vector3),H(this,"rotationAxis",new c.Vector3),H(this,"startNorm",new c.Vector3),H(this,"endNorm",new c.Vector3),H(this,"rotationAngle",0),H(this,"cameraPosition",new c.Vector3),H(this,"cameraQuaternion",new c.Quaternion),H(this,"cameraScale",new c.Vector3),H(this,"parentPosition",new c.Vector3),H(this,"parentQuaternion",new c.Quaternion),H(this,"parentQuaternionInv",new c.Quaternion),H(this,"parentScale",new c.Vector3),H(this,"worldPositionStart",new c.Vector3),H(this,"worldQuaternionStart",new c.Quaternion),H(this,"worldScaleStart",new c.Vector3),H(this,"worldPosition",new c.Vector3),H(this,"worldQuaternion",new c.Quaternion),H(this,"worldQuaternionInv",new c.Quaternion),H(this,"worldScale",new c.Vector3),H(this,"eye",new c.Vector3),H(this,"positionStart",new c.Vector3),H(this,"quaternionStart",new c.Quaternion),H(this,"scaleStart",new c.Vector3),H(this,"camera"),H(this,"object"),H(this,"enabled",!0),H(this,"axis",null),H(this,"mode","translate"),H(this,"translationSnap",null),H(this,"rotationSnap",null),H(this,"scaleSnap",null),H(this,"space","world"),H(this,"size",1),H(this,"dragging",!1),H(this,"showX",!0),H(this,"showY",!0),H(this,"showZ",!0),H(this,"changeEvent",{type:"change"}),H(this,"mouseDownEvent",{type:"mouseDown",mode:this.mode}),H(this,"mouseUpEvent",{type:"mouseUp",mode:this.mode}),H(this,"objectChangeEvent",{type:"objectChange"}),H(this,"intersectObjectWithRay",(s,r,i)=>{const a=r.intersectObject(s,!0);for(let l=0;l<a.length;l++)if(a[l].object.visible||i)return a[l];return!1}),H(this,"attach",s=>(this.object=s,this.visible=!0,this)),H(this,"detach",()=>(this.object=void 0,this.visible=!1,this.axis=null,this)),H(this,"reset",()=>this.enabled?(this.dragging&&this.object!==void 0&&(this.object.position.copy(this.positionStart),this.object.quaternion.copy(this.quaternionStart),this.object.scale.copy(this.scaleStart),this.dispatchEvent(this.changeEvent),this.dispatchEvent(this.objectChangeEvent),this.pointStart.copy(this.pointEnd)),this):this),H(this,"updateMatrixWorld",()=>{this.object!==void 0&&(this.object.updateMatrixWorld(),this.object.parent===null?console.error("TransformControls: The attached 3D object must be a part of the scene graph."):this.object.parent.matrixWorld.decompose(this.parentPosition,this.parentQuaternion,this.parentScale),this.object.matrixWorld.decompose(this.worldPosition,this.worldQuaternion,this.worldScale),this.parentQuaternionInv.copy(this.parentQuaternion).invert(),this.worldQuaternionInv.copy(this.worldQuaternion).invert()),this.camera.updateMatrixWorld(),this.camera.matrixWorld.decompose(this.cameraPosition,this.cameraQuaternion,this.cameraScale),this.eye.copy(this.cameraPosition).sub(this.worldPosition).normalize(),super.updateMatrixWorld()}),H(this,"pointerHover",s=>{if(this.object===void 0||this.dragging===!0)return;this.raycaster.setFromCamera(s,this.camera);const r=this.intersectObjectWithRay(this.gizmo.picker[this.mode],this.raycaster);r?this.axis=r.object.name:this.axis=null}),H(this,"pointerDown",s=>{if(!(this.object===void 0||this.dragging===!0||s.button!==0)&&this.axis!==null){this.raycaster.setFromCamera(s,this.camera);const r=this.intersectObjectWithRay(this.plane,this.raycaster,!0);if(r){let i=this.space;if(this.mode==="scale"?i="local":(this.axis==="E"||this.axis==="XYZE"||this.axis==="XYZ")&&(i="world"),i==="local"&&this.mode==="rotate"){const a=this.rotationSnap;this.axis==="X"&&a&&(this.object.rotation.x=Math.round(this.object.rotation.x/a)*a),this.axis==="Y"&&a&&(this.object.rotation.y=Math.round(this.object.rotation.y/a)*a),this.axis==="Z"&&a&&(this.object.rotation.z=Math.round(this.object.rotation.z/a)*a)}this.object.updateMatrixWorld(),this.object.parent&&this.object.parent.updateMatrixWorld(),this.positionStart.copy(this.object.position),this.quaternionStart.copy(this.object.quaternion),this.scaleStart.copy(this.object.scale),this.object.matrixWorld.decompose(this.worldPositionStart,this.worldQuaternionStart,this.worldScaleStart),this.pointStart.copy(r.point).sub(this.worldPositionStart)}this.dragging=!0,this.mouseDownEvent.mode=this.mode,this.dispatchEvent(this.mouseDownEvent)}}),H(this,"pointerMove",s=>{const r=this.axis,i=this.mode,a=this.object;let l=this.space;if(i==="scale"?l="local":(r==="E"||r==="XYZE"||r==="XYZ")&&(l="world"),a===void 0||r===null||this.dragging===!1||s.button!==-1)return;this.raycaster.setFromCamera(s,this.camera);const u=this.intersectObjectWithRay(this.plane,this.raycaster,!0);if(u){if(this.pointEnd.copy(u.point).sub(this.worldPositionStart),i==="translate")this.offset.copy(this.pointEnd).sub(this.pointStart),l==="local"&&r!=="XYZ"&&this.offset.applyQuaternion(this.worldQuaternionInv),r.indexOf("X")===-1&&(this.offset.x=0),r.indexOf("Y")===-1&&(this.offset.y=0),r.indexOf("Z")===-1&&(this.offset.z=0),l==="local"&&r!=="XYZ"?this.offset.applyQuaternion(this.quaternionStart).divide(this.parentScale):this.offset.applyQuaternion(this.parentQuaternionInv).divide(this.parentScale),a.position.copy(this.offset).add(this.positionStart),this.translationSnap&&(l==="local"&&(a.position.applyQuaternion(this.tempQuaternion.copy(this.quaternionStart).invert()),r.search("X")!==-1&&(a.position.x=Math.round(a.position.x/this.translationSnap)*this.translationSnap),r.search("Y")!==-1&&(a.position.y=Math.round(a.position.y/this.translationSnap)*this.translationSnap),r.search("Z")!==-1&&(a.position.z=Math.round(a.position.z/this.translationSnap)*this.translationSnap),a.position.applyQuaternion(this.quaternionStart)),l==="world"&&(a.parent&&a.position.add(this.tempVector.setFromMatrixPosition(a.parent.matrixWorld)),r.search("X")!==-1&&(a.position.x=Math.round(a.position.x/this.translationSnap)*this.translationSnap),r.search("Y")!==-1&&(a.position.y=Math.round(a.position.y/this.translationSnap)*this.translationSnap),r.search("Z")!==-1&&(a.position.z=Math.round(a.position.z/this.translationSnap)*this.translationSnap),a.parent&&a.position.sub(this.tempVector.setFromMatrixPosition(a.parent.matrixWorld))));else if(i==="scale"){if(r.search("XYZ")!==-1){let h=this.pointEnd.length()/this.pointStart.length();this.pointEnd.dot(this.pointStart)<0&&(h*=-1),this.tempVector2.set(h,h,h)}else this.tempVector.copy(this.pointStart),this.tempVector2.copy(this.pointEnd),this.tempVector.applyQuaternion(this.worldQuaternionInv),this.tempVector2.applyQuaternion(this.worldQuaternionInv),this.tempVector2.divide(this.tempVector),r.search("X")===-1&&(this.tempVector2.x=1),r.search("Y")===-1&&(this.tempVector2.y=1),r.search("Z")===-1&&(this.tempVector2.z=1);a.scale.copy(this.scaleStart).multiply(this.tempVector2),this.scaleSnap&&this.object&&(r.search("X")!==-1&&(this.object.scale.x=Math.round(a.scale.x/this.scaleSnap)*this.scaleSnap||this.scaleSnap),r.search("Y")!==-1&&(a.scale.y=Math.round(a.scale.y/this.scaleSnap)*this.scaleSnap||this.scaleSnap),r.search("Z")!==-1&&(a.scale.z=Math.round(a.scale.z/this.scaleSnap)*this.scaleSnap||this.scaleSnap))}else if(i==="rotate"){this.offset.copy(this.pointEnd).sub(this.pointStart);const h=20/this.worldPosition.distanceTo(this.tempVector.setFromMatrixPosition(this.camera.matrixWorld));r==="E"?(this.rotationAxis.copy(this.eye),this.rotationAngle=this.pointEnd.angleTo(this.pointStart),this.startNorm.copy(this.pointStart).normalize(),this.endNorm.copy(this.pointEnd).normalize(),this.rotationAngle*=this.endNorm.cross(this.startNorm).dot(this.eye)<0?1:-1):r==="XYZE"?(this.rotationAxis.copy(this.offset).cross(this.eye).normalize(),this.rotationAngle=this.offset.dot(this.tempVector.copy(this.rotationAxis).cross(this.eye))*h):(r==="X"||r==="Y"||r==="Z")&&(this.rotationAxis.copy(this.unit[r]),this.tempVector.copy(this.unit[r]),l==="local"&&this.tempVector.applyQuaternion(this.worldQuaternion),this.rotationAngle=this.offset.dot(this.tempVector.cross(this.eye).normalize())*h),this.rotationSnap&&(this.rotationAngle=Math.round(this.rotationAngle/this.rotationSnap)*this.rotationSnap),l==="local"&&r!=="E"&&r!=="XYZE"?(a.quaternion.copy(this.quaternionStart),a.quaternion.multiply(this.tempQuaternion.setFromAxisAngle(this.rotationAxis,this.rotationAngle)).normalize()):(this.rotationAxis.applyQuaternion(this.parentQuaternionInv),a.quaternion.copy(this.tempQuaternion.setFromAxisAngle(this.rotationAxis,this.rotationAngle)),a.quaternion.multiply(this.quaternionStart).normalize())}this.dispatchEvent(this.changeEvent),this.dispatchEvent(this.objectChangeEvent)}}),H(this,"pointerUp",s=>{s.button===0&&(this.dragging&&this.axis!==null&&(this.mouseUpEvent.mode=this.mode,this.dispatchEvent(this.mouseUpEvent)),this.dragging=!1,this.axis=null)}),H(this,"getPointer",s=>{var r;if(this.domElement&&((r=this.domElement.ownerDocument)!=null&&r.pointerLockElement))return{x:0,y:0,button:s.button};{const i=s.changedTouches?s.changedTouches[0]:s,a=this.domElement.getBoundingClientRect();return{x:(i.clientX-a.left)/a.width*2-1,y:-(i.clientY-a.top)/a.height*2+1,button:s.button}}}),H(this,"onPointerHover",s=>{if(this.enabled)switch(s.pointerType){case"mouse":case"pen":this.pointerHover(this.getPointer(s));break}}),H(this,"onPointerDown",s=>{!this.enabled||!this.domElement||(this.domElement.style.touchAction="none",this.domElement.ownerDocument.addEventListener("pointermove",this.onPointerMove),this.pointerHover(this.getPointer(s)),this.pointerDown(this.getPointer(s)))}),H(this,"onPointerMove",s=>{this.enabled&&this.pointerMove(this.getPointer(s))}),H(this,"onPointerUp",s=>{!this.enabled||!this.domElement||(this.domElement.style.touchAction="",this.domElement.ownerDocument.removeEventListener("pointermove",this.onPointerMove),this.pointerUp(this.getPointer(s)))}),H(this,"getMode",()=>this.mode),H(this,"setMode",s=>{this.mode=s}),H(this,"setTranslationSnap",s=>{this.translationSnap=s}),H(this,"setRotationSnap",s=>{this.rotationSnap=s}),H(this,"setScaleSnap",s=>{this.scaleSnap=s}),H(this,"setSize",s=>{this.size=s}),H(this,"setSpace",s=>{this.space=s}),H(this,"update",()=>{console.warn("THREE.TransformControls: update function has no more functionality and therefore has been deprecated.")}),H(this,"connect",s=>{s===document&&console.error('THREE.OrbitControls: "document" should not be used as the target "domElement". Please use "renderer.domElement" instead.'),this.domElement=s,this.domElement.addEventListener("pointerdown",this.onPointerDown),this.domElement.addEventListener("pointermove",this.onPointerHover),this.domElement.ownerDocument.addEventListener("pointerup",this.onPointerUp)}),H(this,"dispose",()=>{var s,r,i,a,l,u;(s=this.domElement)==null||s.removeEventListener("pointerdown",this.onPointerDown),(r=this.domElement)==null||r.removeEventListener("pointermove",this.onPointerHover),(a=(i=this.domElement)==null?void 0:i.ownerDocument)==null||a.removeEventListener("pointermove",this.onPointerMove),(u=(l=this.domElement)==null?void 0:l.ownerDocument)==null||u.removeEventListener("pointerup",this.onPointerUp),this.traverse(h=>{const d=h;d.geometry&&d.geometry.dispose(),d.material&&d.material.dispose()})}),this.domElement=t,this.camera=e,this.gizmo=new Oo,this.add(this.gizmo),this.plane=new Fo,this.add(this.plane);const n=(s,r)=>{let i=r;Object.defineProperty(this,s,{get:function(){return i!==void 0?i:r},set:function(a){i!==a&&(i=a,this.plane[s]=a,this.gizmo[s]=a,this.dispatchEvent({type:s+"-changed",value:a}),this.dispatchEvent(this.changeEvent))}}),this[s]=r,this.plane[s]=r,this.gizmo[s]=r};n("camera",this.camera),n("object",this.object),n("enabled",this.enabled),n("axis",this.axis),n("mode",this.mode),n("translationSnap",this.translationSnap),n("rotationSnap",this.rotationSnap),n("scaleSnap",this.scaleSnap),n("space",this.space),n("size",this.size),n("dragging",this.dragging),n("showX",this.showX),n("showY",this.showY),n("showZ",this.showZ),n("worldPosition",this.worldPosition),n("worldPositionStart",this.worldPositionStart),n("worldQuaternion",this.worldQuaternion),n("worldQuaternionStart",this.worldQuaternionStart),n("cameraPosition",this.cameraPosition),n("cameraQuaternion",this.cameraQuaternion),n("pointStart",this.pointStart),n("pointEnd",this.pointEnd),n("rotationAxis",this.rotationAxis),n("rotationAngle",this.rotationAngle),n("eye",this.eye),t!==void 0&&this.connect(t)}}class Oo extends c.Object3D{constructor(){super(),H(this,"isTransformControlsGizmo",!0),H(this,"type","TransformControlsGizmo"),H(this,"tempVector",new c.Vector3(0,0,0)),H(this,"tempEuler",new c.Euler),H(this,"alignVector",new c.Vector3(0,1,0)),H(this,"zeroVector",new c.Vector3(0,0,0)),H(this,"lookAtMatrix",new c.Matrix4),H(this,"tempQuaternion",new c.Quaternion),H(this,"tempQuaternion2",new c.Quaternion),H(this,"identityQuaternion",new c.Quaternion),H(this,"unitX",new c.Vector3(1,0,0)),H(this,"unitY",new c.Vector3(0,1,0)),H(this,"unitZ",new c.Vector3(0,0,1)),H(this,"gizmo"),H(this,"picker"),H(this,"helper"),H(this,"rotationAxis",new c.Vector3),H(this,"cameraPosition",new c.Vector3),H(this,"worldPositionStart",new c.Vector3),H(this,"worldQuaternionStart",new c.Quaternion),H(this,"worldPosition",new c.Vector3),H(this,"worldQuaternion",new c.Quaternion),H(this,"eye",new c.Vector3),H(this,"camera",null),H(this,"enabled",!0),H(this,"axis",null),H(this,"mode","translate"),H(this,"space","world"),H(this,"size",1),H(this,"dragging",!1),H(this,"showX",!0),H(this,"showY",!0),H(this,"showZ",!0),H(this,"updateMatrixWorld",()=>{let se=this.space;this.mode==="scale"&&(se="local");const ue=se==="local"?this.worldQuaternion:this.identityQuaternion;this.gizmo.translate.visible=this.mode==="translate",this.gizmo.rotate.visible=this.mode==="rotate",this.gizmo.scale.visible=this.mode==="scale",this.helper.translate.visible=this.mode==="translate",this.helper.rotate.visible=this.mode==="rotate",this.helper.scale.visible=this.mode==="scale";let j=[];j=j.concat(this.picker[this.mode].children),j=j.concat(this.gizmo[this.mode].children),j=j.concat(this.helper[this.mode].children);for(let z=0;z<j.length;z++){const A=j[z];A.visible=!0,A.rotation.set(0,0,0),A.position.copy(this.worldPosition);let V;if(this.camera.isOrthographicCamera?V=(this.camera.top-this.camera.bottom)/this.camera.zoom:V=this.worldPosition.distanceTo(this.cameraPosition)*Math.min(1.9*Math.tan(Math.PI*this.camera.fov/360)/this.camera.zoom,7),A.scale.set(1,1,1).multiplyScalar(V*this.size/7),A.tag==="helper"){A.visible=!1,A.name==="AXIS"?(A.position.copy(this.worldPositionStart),A.visible=!!this.axis,this.axis==="X"&&(this.tempQuaternion.setFromEuler(this.tempEuler.set(0,0,0)),A.quaternion.copy(ue).multiply(this.tempQuaternion),Math.abs(this.alignVector.copy(this.unitX).applyQuaternion(ue).dot(this.eye))>.9&&(A.visible=!1)),this.axis==="Y"&&(this.tempQuaternion.setFromEuler(this.tempEuler.set(0,0,Math.PI/2)),A.quaternion.copy(ue).multiply(this.tempQuaternion),Math.abs(this.alignVector.copy(this.unitY).applyQuaternion(ue).dot(this.eye))>.9&&(A.visible=!1)),this.axis==="Z"&&(this.tempQuaternion.setFromEuler(this.tempEuler.set(0,Math.PI/2,0)),A.quaternion.copy(ue).multiply(this.tempQuaternion),Math.abs(this.alignVector.copy(this.unitZ).applyQuaternion(ue).dot(this.eye))>.9&&(A.visible=!1)),this.axis==="XYZE"&&(this.tempQuaternion.setFromEuler(this.tempEuler.set(0,Math.PI/2,0)),this.alignVector.copy(this.rotationAxis),A.quaternion.setFromRotationMatrix(this.lookAtMatrix.lookAt(this.zeroVector,this.alignVector,this.unitY)),A.quaternion.multiply(this.tempQuaternion),A.visible=this.dragging),this.axis==="E"&&(A.visible=!1)):A.name==="START"?(A.position.copy(this.worldPositionStart),A.visible=this.dragging):A.name==="END"?(A.position.copy(this.worldPosition),A.visible=this.dragging):A.name==="DELTA"?(A.position.copy(this.worldPositionStart),A.quaternion.copy(this.worldQuaternionStart),this.tempVector.set(1e-10,1e-10,1e-10).add(this.worldPositionStart).sub(this.worldPosition).multiplyScalar(-1),this.tempVector.applyQuaternion(this.worldQuaternionStart.clone().invert()),A.scale.copy(this.tempVector),A.visible=this.dragging):(A.quaternion.copy(ue),this.dragging?A.position.copy(this.worldPositionStart):A.position.copy(this.worldPosition),this.axis&&(A.visible=this.axis.search(A.name)!==-1));continue}A.quaternion.copy(ue),this.mode==="translate"||this.mode==="scale"?((A.name==="X"||A.name==="XYZX")&&Math.abs(this.alignVector.copy(this.unitX).applyQuaternion(ue).dot(this.eye))>.99&&(A.scale.set(1e-10,1e-10,1e-10),A.visible=!1),(A.name==="Y"||A.name==="XYZY")&&Math.abs(this.alignVector.copy(this.unitY).applyQuaternion(ue).dot(this.eye))>.99&&(A.scale.set(1e-10,1e-10,1e-10),A.visible=!1),(A.name==="Z"||A.name==="XYZZ")&&Math.abs(this.alignVector.copy(this.unitZ).applyQuaternion(ue).dot(this.eye))>.99&&(A.scale.set(1e-10,1e-10,1e-10),A.visible=!1),A.name==="XY"&&Math.abs(this.alignVector.copy(this.unitZ).applyQuaternion(ue).dot(this.eye))<.2&&(A.scale.set(1e-10,1e-10,1e-10),A.visible=!1),A.name==="YZ"&&Math.abs(this.alignVector.copy(this.unitX).applyQuaternion(ue).dot(this.eye))<.2&&(A.scale.set(1e-10,1e-10,1e-10),A.visible=!1),A.name==="XZ"&&Math.abs(this.alignVector.copy(this.unitY).applyQuaternion(ue).dot(this.eye))<.2&&(A.scale.set(1e-10,1e-10,1e-10),A.visible=!1),A.name.search("X")!==-1&&(this.alignVector.copy(this.unitX).applyQuaternion(ue).dot(this.eye)<0?A.tag==="fwd"?A.visible=!1:A.scale.x*=-1:A.tag==="bwd"&&(A.visible=!1)),A.name.search("Y")!==-1&&(this.alignVector.copy(this.unitY).applyQuaternion(ue).dot(this.eye)<0?A.tag==="fwd"?A.visible=!1:A.scale.y*=-1:A.tag==="bwd"&&(A.visible=!1)),A.name.search("Z")!==-1&&(this.alignVector.copy(this.unitZ).applyQuaternion(ue).dot(this.eye)<0?A.tag==="fwd"?A.visible=!1:A.scale.z*=-1:A.tag==="bwd"&&(A.visible=!1))):this.mode==="rotate"&&(this.tempQuaternion2.copy(ue),this.alignVector.copy(this.eye).applyQuaternion(this.tempQuaternion.copy(ue).invert()),A.name.search("E")!==-1&&A.quaternion.setFromRotationMatrix(this.lookAtMatrix.lookAt(this.eye,this.zeroVector,this.unitY)),A.name==="X"&&(this.tempQuaternion.setFromAxisAngle(this.unitX,Math.atan2(-this.alignVector.y,this.alignVector.z)),this.tempQuaternion.multiplyQuaternions(this.tempQuaternion2,this.tempQuaternion),A.quaternion.copy(this.tempQuaternion)),A.name==="Y"&&(this.tempQuaternion.setFromAxisAngle(this.unitY,Math.atan2(this.alignVector.x,this.alignVector.z)),this.tempQuaternion.multiplyQuaternions(this.tempQuaternion2,this.tempQuaternion),A.quaternion.copy(this.tempQuaternion)),A.name==="Z"&&(this.tempQuaternion.setFromAxisAngle(this.unitZ,Math.atan2(this.alignVector.y,this.alignVector.x)),this.tempQuaternion.multiplyQuaternions(this.tempQuaternion2,this.tempQuaternion),A.quaternion.copy(this.tempQuaternion))),A.visible=A.visible&&(A.name.indexOf("X")===-1||this.showX),A.visible=A.visible&&(A.name.indexOf("Y")===-1||this.showY),A.visible=A.visible&&(A.name.indexOf("Z")===-1||this.showZ),A.visible=A.visible&&(A.name.indexOf("E")===-1||this.showX&&this.showY&&this.showZ),A.material.tempOpacity=A.material.tempOpacity||A.material.opacity,A.material.tempColor=A.material.tempColor||A.material.color.clone(),A.material.color.copy(A.material.tempColor),A.material.opacity=A.material.tempOpacity,this.enabled?this.axis&&(A.name===this.axis?(A.material.opacity=1,A.material.color.lerp(new c.Color(1,1,1),.5)):this.axis.split("").some(function(ee){return A.name===ee})?(A.material.opacity=1,A.material.color.lerp(new c.Color(1,1,1),.5)):(A.material.opacity*=.25,A.material.color.lerp(new c.Color(1,1,1),.5))):(A.material.opacity*=.5,A.material.color.lerp(new c.Color(1,1,1),.5))}super.updateMatrixWorld()});const e=new c.MeshBasicMaterial({depthTest:!1,depthWrite:!1,transparent:!0,side:c.DoubleSide,fog:!1,toneMapped:!1}),t=new c.LineBasicMaterial({depthTest:!1,depthWrite:!1,transparent:!0,linewidth:1,fog:!1,toneMapped:!1}),n=e.clone();n.opacity=.15;const s=e.clone();s.opacity=.33;const r=e.clone();r.color.set(16711680);const i=e.clone();i.color.set(65280);const a=e.clone();a.color.set(255);const l=e.clone();l.opacity=.25;const u=l.clone();u.color.set(16776960);const h=l.clone();h.color.set(65535);const d=l.clone();d.color.set(16711935),e.clone().color.set(16776960);const g=t.clone();g.color.set(16711680);const x=t.clone();x.color.set(65280);const w=t.clone();w.color.set(255);const v=t.clone();v.color.set(65535);const P=t.clone();P.color.set(16711935);const D=t.clone();D.color.set(16776960);const S=t.clone();S.color.set(7895160);const _=D.clone();_.opacity=.25;const L=new c.CylinderGeometry(0,.05,.2,12,1,!1),b=new c.BoxGeometry(.125,.125,.125),C=new c.BufferGeometry;C.setAttribute("position",new c.Float32BufferAttribute([0,0,0,1,0,0],3));const m=(se,ue)=>{const j=new c.BufferGeometry,z=[];for(let A=0;A<=64*ue;++A)z.push(0,Math.cos(A/32*Math.PI)*se,Math.sin(A/32*Math.PI)*se);return j.setAttribute("position",new c.Float32BufferAttribute(z,3)),j},M=()=>{const se=new c.BufferGeometry;return se.setAttribute("position",new c.Float32BufferAttribute([0,0,0,1,1,1],3)),se},p={X:[[new c.Mesh(L,r),[1,0,0],[0,0,-Math.PI/2],null,"fwd"],[new c.Mesh(L,r),[1,0,0],[0,0,Math.PI/2],null,"bwd"],[new c.Line(C,g)]],Y:[[new c.Mesh(L,i),[0,1,0],null,null,"fwd"],[new c.Mesh(L,i),[0,1,0],[Math.PI,0,0],null,"bwd"],[new c.Line(C,x),null,[0,0,Math.PI/2]]],Z:[[new c.Mesh(L,a),[0,0,1],[Math.PI/2,0,0],null,"fwd"],[new c.Mesh(L,a),[0,0,1],[-Math.PI/2,0,0],null,"bwd"],[new c.Line(C,w),null,[0,-Math.PI/2,0]]],XYZ:[[new c.Mesh(new c.OctahedronGeometry(.1,0),l.clone()),[0,0,0],[0,0,0]]],XY:[[new c.Mesh(new c.PlaneGeometry(.295,.295),u.clone()),[.15,.15,0]],[new c.Line(C,D),[.18,.3,0],null,[.125,1,1]],[new c.Line(C,D),[.3,.18,0],[0,0,Math.PI/2],[.125,1,1]]],YZ:[[new c.Mesh(new c.PlaneGeometry(.295,.295),h.clone()),[0,.15,.15],[0,Math.PI/2,0]],[new c.Line(C,v),[0,.18,.3],[0,0,Math.PI/2],[.125,1,1]],[new c.Line(C,v),[0,.3,.18],[0,-Math.PI/2,0],[.125,1,1]]],XZ:[[new c.Mesh(new c.PlaneGeometry(.295,.295),d.clone()),[.15,0,.15],[-Math.PI/2,0,0]],[new c.Line(C,P),[.18,0,.3],null,[.125,1,1]],[new c.Line(C,P),[.3,0,.18],[0,-Math.PI/2,0],[.125,1,1]]]},I={X:[[new c.Mesh(new c.CylinderGeometry(.2,0,1,4,1,!1),n),[.6,0,0],[0,0,-Math.PI/2]]],Y:[[new c.Mesh(new c.CylinderGeometry(.2,0,1,4,1,!1),n),[0,.6,0]]],Z:[[new c.Mesh(new c.CylinderGeometry(.2,0,1,4,1,!1),n),[0,0,.6],[Math.PI/2,0,0]]],XYZ:[[new c.Mesh(new c.OctahedronGeometry(.2,0),n)]],XY:[[new c.Mesh(new c.PlaneGeometry(.4,.4),n),[.2,.2,0]]],YZ:[[new c.Mesh(new c.PlaneGeometry(.4,.4),n),[0,.2,.2],[0,Math.PI/2,0]]],XZ:[[new c.Mesh(new c.PlaneGeometry(.4,.4),n),[.2,0,.2],[-Math.PI/2,0,0]]]},F={START:[[new c.Mesh(new c.OctahedronGeometry(.01,2),s),null,null,null,"helper"]],END:[[new c.Mesh(new c.OctahedronGeometry(.01,2),s),null,null,null,"helper"]],DELTA:[[new c.Line(M(),s),null,null,null,"helper"]],X:[[new c.Line(C,s.clone()),[-1e3,0,0],null,[1e6,1,1],"helper"]],Y:[[new c.Line(C,s.clone()),[0,-1e3,0],[0,0,Math.PI/2],[1e6,1,1],"helper"]],Z:[[new c.Line(C,s.clone()),[0,0,-1e3],[0,-Math.PI/2,0],[1e6,1,1],"helper"]]},J={X:[[new c.Line(m(1,.5),g)],[new c.Mesh(new c.OctahedronGeometry(.04,0),r),[0,0,.99],null,[1,3,1]]],Y:[[new c.Line(m(1,.5),x),null,[0,0,-Math.PI/2]],[new c.Mesh(new c.OctahedronGeometry(.04,0),i),[0,0,.99],null,[3,1,1]]],Z:[[new c.Line(m(1,.5),w),null,[0,Math.PI/2,0]],[new c.Mesh(new c.OctahedronGeometry(.04,0),a),[.99,0,0],null,[1,3,1]]],E:[[new c.Line(m(1.25,1),_),null,[0,Math.PI/2,0]],[new c.Mesh(new c.CylinderGeometry(.03,0,.15,4,1,!1),_),[1.17,0,0],[0,0,-Math.PI/2],[1,1,.001]],[new c.Mesh(new c.CylinderGeometry(.03,0,.15,4,1,!1),_),[-1.17,0,0],[0,0,Math.PI/2],[1,1,.001]],[new c.Mesh(new c.CylinderGeometry(.03,0,.15,4,1,!1),_),[0,-1.17,0],[Math.PI,0,0],[1,1,.001]],[new c.Mesh(new c.CylinderGeometry(.03,0,.15,4,1,!1),_),[0,1.17,0],[0,0,0],[1,1,.001]]],XYZE:[[new c.Line(m(1,1),S),null,[0,Math.PI/2,0]]]},G={AXIS:[[new c.Line(C,s.clone()),[-1e3,0,0],null,[1e6,1,1],"helper"]]},Q={X:[[new c.Mesh(new c.TorusGeometry(1,.1,4,24),n),[0,0,0],[0,-Math.PI/2,-Math.PI/2]]],Y:[[new c.Mesh(new c.TorusGeometry(1,.1,4,24),n),[0,0,0],[Math.PI/2,0,0]]],Z:[[new c.Mesh(new c.TorusGeometry(1,.1,4,24),n),[0,0,0],[0,0,-Math.PI/2]]],E:[[new c.Mesh(new c.TorusGeometry(1.25,.1,2,24),n)]],XYZE:[[new c.Mesh(new c.SphereGeometry(.7,10,8),n)]]},K={X:[[new c.Mesh(b,r),[.8,0,0],[0,0,-Math.PI/2]],[new c.Line(C,g),null,null,[.8,1,1]]],Y:[[new c.Mesh(b,i),[0,.8,0]],[new c.Line(C,x),null,[0,0,Math.PI/2],[.8,1,1]]],Z:[[new c.Mesh(b,a),[0,0,.8],[Math.PI/2,0,0]],[new c.Line(C,w),null,[0,-Math.PI/2,0],[.8,1,1]]],XY:[[new c.Mesh(b,u),[.85,.85,0],null,[2,2,.2]],[new c.Line(C,D),[.855,.98,0],null,[.125,1,1]],[new c.Line(C,D),[.98,.855,0],[0,0,Math.PI/2],[.125,1,1]]],YZ:[[new c.Mesh(b,h),[0,.85,.85],null,[.2,2,2]],[new c.Line(C,v),[0,.855,.98],[0,0,Math.PI/2],[.125,1,1]],[new c.Line(C,v),[0,.98,.855],[0,-Math.PI/2,0],[.125,1,1]]],XZ:[[new c.Mesh(b,d),[.85,0,.85],null,[2,.2,2]],[new c.Line(C,P),[.855,0,.98],null,[.125,1,1]],[new c.Line(C,P),[.98,0,.855],[0,-Math.PI/2,0],[.125,1,1]]],XYZX:[[new c.Mesh(new c.BoxGeometry(.125,.125,.125),l.clone()),[1.1,0,0]]],XYZY:[[new c.Mesh(new c.BoxGeometry(.125,.125,.125),l.clone()),[0,1.1,0]]],XYZZ:[[new c.Mesh(new c.BoxGeometry(.125,.125,.125),l.clone()),[0,0,1.1]]]},Z={X:[[new c.Mesh(new c.CylinderGeometry(.2,0,.8,4,1,!1),n),[.5,0,0],[0,0,-Math.PI/2]]],Y:[[new c.Mesh(new c.CylinderGeometry(.2,0,.8,4,1,!1),n),[0,.5,0]]],Z:[[new c.Mesh(new c.CylinderGeometry(.2,0,.8,4,1,!1),n),[0,0,.5],[Math.PI/2,0,0]]],XY:[[new c.Mesh(b,n),[.85,.85,0],null,[3,3,.2]]],YZ:[[new c.Mesh(b,n),[0,.85,.85],null,[.2,3,3]]],XZ:[[new c.Mesh(b,n),[.85,0,.85],null,[3,.2,3]]],XYZX:[[new c.Mesh(new c.BoxGeometry(.2,.2,.2),n),[1.1,0,0]]],XYZY:[[new c.Mesh(new c.BoxGeometry(.2,.2,.2),n),[0,1.1,0]]],XYZZ:[[new c.Mesh(new c.BoxGeometry(.2,.2,.2),n),[0,0,1.1]]]},X={X:[[new c.Line(C,s.clone()),[-1e3,0,0],null,[1e6,1,1],"helper"]],Y:[[new c.Line(C,s.clone()),[0,-1e3,0],[0,0,Math.PI/2],[1e6,1,1],"helper"]],Z:[[new c.Line(C,s.clone()),[0,0,-1e3],[0,-Math.PI/2,0],[1e6,1,1],"helper"]]},ne=se=>{const ue=new c.Object3D;for(let j in se)for(let z=se[j].length;z--;){const A=se[j][z][0].clone(),V=se[j][z][1],ee=se[j][z][2],N=se[j][z][3],R=se[j][z][4];A.name=j,A.tag=R,V&&A.position.set(V[0],V[1],V[2]),ee&&A.rotation.set(ee[0],ee[1],ee[2]),N&&A.scale.set(N[0],N[1],N[2]),A.updateMatrix();const T=A.geometry.clone();T.applyMatrix4(A.matrix),A.geometry=T,A.renderOrder=1/0,A.position.set(0,0,0),A.rotation.set(0,0,0),A.scale.set(1,1,1),ue.add(A)}return ue};this.gizmo={},this.picker={},this.helper={},this.add(this.gizmo.translate=ne(p)),this.add(this.gizmo.rotate=ne(J)),this.add(this.gizmo.scale=ne(K)),this.add(this.picker.translate=ne(I)),this.add(this.picker.rotate=ne(Q)),this.add(this.picker.scale=ne(Z)),this.add(this.helper.translate=ne(F)),this.add(this.helper.rotate=ne(G)),this.add(this.helper.scale=ne(X)),this.picker.translate.visible=!1,this.picker.rotate.visible=!1,this.picker.scale.visible=!1}}class Fo extends c.Mesh{constructor(){super(new c.PlaneGeometry(1e5,1e5,2,2),new c.MeshBasicMaterial({visible:!1,wireframe:!0,side:c.DoubleSide,transparent:!0,opacity:.1,toneMapped:!1})),H(this,"isTransformControlsPlane",!0),H(this,"type","TransformControlsPlane"),H(this,"unitX",new c.Vector3(1,0,0)),H(this,"unitY",new c.Vector3(0,1,0)),H(this,"unitZ",new c.Vector3(0,0,1)),H(this,"tempVector",new c.Vector3),H(this,"dirVector",new c.Vector3),H(this,"alignVector",new c.Vector3),H(this,"tempMatrix",new c.Matrix4),H(this,"identityQuaternion",new c.Quaternion),H(this,"cameraQuaternion",new c.Quaternion),H(this,"worldPosition",new c.Vector3),H(this,"worldQuaternion",new c.Quaternion),H(this,"eye",new c.Vector3),H(this,"axis",null),H(this,"mode","translate"),H(this,"space","world"),H(this,"updateMatrixWorld",()=>{let e=this.space;switch(this.position.copy(this.worldPosition),this.mode==="scale"&&(e="local"),this.unitX.set(1,0,0).applyQuaternion(e==="local"?this.worldQuaternion:this.identityQuaternion),this.unitY.set(0,1,0).applyQuaternion(e==="local"?this.worldQuaternion:this.identityQuaternion),this.unitZ.set(0,0,1).applyQuaternion(e==="local"?this.worldQuaternion:this.identityQuaternion),this.alignVector.copy(this.unitY),this.mode){case"translate":case"scale":switch(this.axis){case"X":this.alignVector.copy(this.eye).cross(this.unitX),this.dirVector.copy(this.unitX).cross(this.alignVector);break;case"Y":this.alignVector.copy(this.eye).cross(this.unitY),this.dirVector.copy(this.unitY).cross(this.alignVector);break;case"Z":this.alignVector.copy(this.eye).cross(this.unitZ),this.dirVector.copy(this.unitZ).cross(this.alignVector);break;case"XY":this.dirVector.copy(this.unitZ);break;case"YZ":this.dirVector.copy(this.unitX);break;case"XZ":this.alignVector.copy(this.unitZ),this.dirVector.copy(this.unitY);break;case"XYZ":case"E":this.dirVector.set(0,0,0);break}break;case"rotate":default:this.dirVector.set(0,0,0)}this.dirVector.length()===0?this.quaternion.copy(this.cameraQuaternion):(this.tempMatrix.lookAt(this.tempVector.set(0,0,0),this.dirVector,this.alignVector),this.quaternion.setFromRotationMatrix(this.tempMatrix)),super.updateMatrixWorld()})}}var ko=Object.defineProperty,Bo=(o,e,t)=>e in o?ko(o,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):o[e]=t,De=(o,e,t)=>(Bo(o,typeof e!="symbol"?e+"":e,t),t);const Lt=new c.Euler(0,0,0,"YXZ"),It=new c.Vector3,Uo={type:"change"},No={type:"lock"},zo={type:"unlock"},er=Math.PI/2;class Wn extends c.EventDispatcher{constructor(e,t){super(),De(this,"camera"),De(this,"domElement"),De(this,"isLocked"),De(this,"minPolarAngle"),De(this,"maxPolarAngle"),De(this,"pointerSpeed"),De(this,"onMouseMove",n=>{if(!this.domElement||this.isLocked===!1)return;const s=n.movementX||n.mozMovementX||n.webkitMovementX||0,r=n.movementY||n.mozMovementY||n.webkitMovementY||0;Lt.setFromQuaternion(this.camera.quaternion),Lt.y-=s*.002*this.pointerSpeed,Lt.x-=r*.002*this.pointerSpeed,Lt.x=Math.max(er-this.maxPolarAngle,Math.min(er-this.minPolarAngle,Lt.x)),this.camera.quaternion.setFromEuler(Lt),this.dispatchEvent(Uo)}),De(this,"onPointerlockChange",()=>{this.domElement&&(this.domElement.ownerDocument.pointerLockElement===this.domElement?(this.dispatchEvent(No),this.isLocked=!0):(this.dispatchEvent(zo),this.isLocked=!1))}),De(this,"onPointerlockError",()=>{console.error("THREE.PointerLockControls: Unable to use Pointer Lock API")}),De(this,"connect",n=>{this.domElement=n||this.domElement,this.domElement&&(this.domElement.ownerDocument.addEventListener("mousemove",this.onMouseMove),this.domElement.ownerDocument.addEventListener("pointerlockchange",this.onPointerlockChange),this.domElement.ownerDocument.addEventListener("pointerlockerror",this.onPointerlockError))}),De(this,"disconnect",()=>{this.domElement&&(this.domElement.ownerDocument.removeEventListener("mousemove",this.onMouseMove),this.domElement.ownerDocument.removeEventListener("pointerlockchange",this.onPointerlockChange),this.domElement.ownerDocument.removeEventListener("pointerlockerror",this.onPointerlockError))}),De(this,"dispose",()=>{this.disconnect()}),De(this,"getObject",()=>this.camera),De(this,"direction",new c.Vector3(0,0,-1)),De(this,"getDirection",n=>n.copy(this.direction).applyQuaternion(this.camera.quaternion)),De(this,"moveForward",n=>{It.setFromMatrixColumn(this.camera.matrix,0),It.crossVectors(this.camera.up,It),this.camera.position.addScaledVector(It,n)}),De(this,"moveRight",n=>{It.setFromMatrixColumn(this.camera.matrix,0),this.camera.position.addScaledVector(It,n)}),De(this,"lock",()=>{this.domElement&&this.domElement.requestPointerLock()}),De(this,"unlock",()=>{this.domElement&&this.domElement.ownerDocument.exitPointerLock()}),this.camera=e,this.domElement=t,this.isLocked=!1,this.minPolarAngle=0,this.maxPolarAngle=Math.PI,this.pointerSpeed=1,t&&this.connect(t)}}var Vo=Object.defineProperty,Ro=(o,e,t)=>e in o?Vo(o,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):o[e]=t,fe=(o,e,t)=>(Ro(o,typeof e!="symbol"?e+"":e,t),t);const pn=new c.Ray,tr=new c.Plane,Go=Math.cos(70*(Math.PI/180)),nr=(o,e)=>(o%e+e)%e;class sr extends c.EventDispatcher{constructor(e,t){super(),fe(this,"object"),fe(this,"domElement"),fe(this,"enabled",!0),fe(this,"target",new c.Vector3),fe(this,"minDistance",0),fe(this,"maxDistance",1/0),fe(this,"minZoom",0),fe(this,"maxZoom",1/0),fe(this,"minPolarAngle",0),fe(this,"maxPolarAngle",Math.PI),fe(this,"minAzimuthAngle",-1/0),fe(this,"maxAzimuthAngle",1/0),fe(this,"enableDamping",!1),fe(this,"dampingFactor",.05),fe(this,"enableZoom",!0),fe(this,"zoomSpeed",1),fe(this,"enableRotate",!0),fe(this,"rotateSpeed",1),fe(this,"enablePan",!0),fe(this,"panSpeed",1),fe(this,"screenSpacePanning",!0),fe(this,"keyPanSpeed",7),fe(this,"zoomToCursor",!1),fe(this,"autoRotate",!1),fe(this,"autoRotateSpeed",2),fe(this,"reverseOrbit",!1),fe(this,"reverseHorizontalOrbit",!1),fe(this,"reverseVerticalOrbit",!1),fe(this,"keys",{LEFT:"ArrowLeft",UP:"ArrowUp",RIGHT:"ArrowRight",BOTTOM:"ArrowDown"}),fe(this,"mouseButtons",{LEFT:c.MOUSE.ROTATE,MIDDLE:c.MOUSE.DOLLY,RIGHT:c.MOUSE.PAN}),fe(this,"touches",{ONE:c.TOUCH.ROTATE,TWO:c.TOUCH.DOLLY_PAN}),fe(this,"target0"),fe(this,"position0"),fe(this,"zoom0"),fe(this,"_domElementKeyEvents",null),fe(this,"getPolarAngle"),fe(this,"getAzimuthalAngle"),fe(this,"setPolarAngle"),fe(this,"setAzimuthalAngle"),fe(this,"getDistance"),fe(this,"listenToKeyEvents"),fe(this,"stopListenToKeyEvents"),fe(this,"saveState"),fe(this,"reset"),fe(this,"update"),fe(this,"connect"),fe(this,"dispose"),this.object=e,this.domElement=t,this.target0=this.target.clone(),this.position0=this.object.position.clone(),this.zoom0=this.object.zoom,this.getPolarAngle=()=>h.phi,this.getAzimuthalAngle=()=>h.theta,this.setPolarAngle=Y=>{let ie=nr(Y,2*Math.PI),me=h.phi;me<0&&(me+=2*Math.PI),ie<0&&(ie+=2*Math.PI);let Se=Math.abs(ie-me);2*Math.PI-Se<Se&&(ie<me?ie+=2*Math.PI:me+=2*Math.PI),d.phi=ie-me,n.update()},this.setAzimuthalAngle=Y=>{let ie=nr(Y,2*Math.PI),me=h.theta;me<0&&(me+=2*Math.PI),ie<0&&(ie+=2*Math.PI);let Se=Math.abs(ie-me);2*Math.PI-Se<Se&&(ie<me?ie+=2*Math.PI:me+=2*Math.PI),d.theta=ie-me,n.update()},this.getDistance=()=>n.object.position.distanceTo(n.target),this.listenToKeyEvents=Y=>{Y.addEventListener("keydown",Gt),this._domElementKeyEvents=Y},this.stopListenToKeyEvents=()=>{this._domElementKeyEvents.removeEventListener("keydown",Gt),this._domElementKeyEvents=null},this.saveState=()=>{n.target0.copy(n.target),n.position0.copy(n.object.position),n.zoom0=n.object.zoom},this.reset=()=>{n.target.copy(n.target0),n.object.position.copy(n.position0),n.object.zoom=n.zoom0,n.object.updateProjectionMatrix(),n.dispatchEvent(s),n.update(),l=a.NONE},this.update=(()=>{const Y=new c.Vector3,ie=new c.Vector3(0,1,0),me=new c.Quaternion().setFromUnitVectors(e.up,ie),Se=me.clone().invert(),Fe=new c.Vector3,lt=new c.Quaternion,xt=2*Math.PI;return function(){const Gi=n.object.position;me.setFromUnitVectors(e.up,ie),Se.copy(me).invert(),Y.copy(Gi).sub(n.target),Y.applyQuaternion(me),h.setFromVector3(Y),n.autoRotate&&l===a.NONE&&G(F()),n.enableDamping?(h.theta+=d.theta*n.dampingFactor,h.phi+=d.phi*n.dampingFactor):(h.theta+=d.theta,h.phi+=d.phi);let ct=n.minAzimuthAngle,ut=n.maxAzimuthAngle;isFinite(ct)&&isFinite(ut)&&(ct<-Math.PI?ct+=xt:ct>Math.PI&&(ct-=xt),ut<-Math.PI?ut+=xt:ut>Math.PI&&(ut-=xt),ct<=ut?h.theta=Math.max(ct,Math.min(ut,h.theta)):h.theta=h.theta>(ct+ut)/2?Math.max(ct,h.theta):Math.min(ut,h.theta)),h.phi=Math.max(n.minPolarAngle,Math.min(n.maxPolarAngle,h.phi)),h.makeSafe(),n.enableDamping===!0?n.target.addScaledVector(g,n.dampingFactor):n.target.add(g),n.zoomToCursor&&M||n.object.isOrthographicCamera?h.radius=j(h.radius):h.radius=j(h.radius*y),Y.setFromSpherical(h),Y.applyQuaternion(Se),Gi.copy(n.target).add(Y),n.object.matrixAutoUpdate||n.object.updateMatrix(),n.object.lookAt(n.target),n.enableDamping===!0?(d.theta*=1-n.dampingFactor,d.phi*=1-n.dampingFactor,g.multiplyScalar(1-n.dampingFactor)):(d.set(0,0,0),g.set(0,0,0));let ln=!1;if(n.zoomToCursor&&M){let cn=null;if(n.object instanceof c.PerspectiveCamera&&n.object.isPerspectiveCamera){const un=Y.length();cn=j(un*y);const Bn=un-cn;n.object.position.addScaledVector(C,Bn),n.object.updateMatrixWorld()}else if(n.object.isOrthographicCamera){const un=new c.Vector3(m.x,m.y,0);un.unproject(n.object),n.object.zoom=Math.max(n.minZoom,Math.min(n.maxZoom,n.object.zoom/y)),n.object.updateProjectionMatrix(),ln=!0;const Bn=new c.Vector3(m.x,m.y,0);Bn.unproject(n.object),n.object.position.sub(Bn).add(un),n.object.updateMatrixWorld(),cn=Y.length()}else console.warn("WARNING: OrbitControls.js encountered an unknown camera type - zoom to cursor disabled."),n.zoomToCursor=!1;cn!==null&&(n.screenSpacePanning?n.target.set(0,0,-1).transformDirection(n.object.matrix).multiplyScalar(cn).add(n.object.position):(pn.origin.copy(n.object.position),pn.direction.set(0,0,-1).transformDirection(n.object.matrix),Math.abs(n.object.up.dot(pn.direction))<Go?e.lookAt(n.target):(tr.setFromNormalAndCoplanarPoint(n.object.up,n.target),pn.intersectPlane(tr,n.target))))}else n.object instanceof c.OrthographicCamera&&n.object.isOrthographicCamera&&(ln=y!==1,ln&&(n.object.zoom=Math.max(n.minZoom,Math.min(n.maxZoom,n.object.zoom/y)),n.object.updateProjectionMatrix()));return y=1,M=!1,ln||Fe.distanceToSquared(n.object.position)>u||8*(1-lt.dot(n.object.quaternion))>u?(n.dispatchEvent(s),Fe.copy(n.object.position),lt.copy(n.object.quaternion),ln=!1,!0):!1}})(),this.connect=Y=>{Y===document&&console.error('THREE.OrbitControls: "document" should not be used as the target "domElement". Please use "renderer.domElement" instead.'),n.domElement=Y,n.domElement.style.touchAction="none",n.domElement.addEventListener("contextmenu",zi),n.domElement.addEventListener("pointerdown",_e),n.domElement.addEventListener("pointercancel",at),n.domElement.addEventListener("wheel",Ke)},this.dispose=()=>{var Y,ie,me,Se,Fe,lt;(Y=n.domElement)==null||Y.removeEventListener("contextmenu",zi),(ie=n.domElement)==null||ie.removeEventListener("pointerdown",_e),(me=n.domElement)==null||me.removeEventListener("pointercancel",at),(Se=n.domElement)==null||Se.removeEventListener("wheel",Ke),(Fe=n.domElement)==null||Fe.ownerDocument.removeEventListener("pointermove",xe),(lt=n.domElement)==null||lt.ownerDocument.removeEventListener("pointerup",Oe),n._domElementKeyEvents!==null&&n._domElementKeyEvents.removeEventListener("keydown",Gt)};const n=this,s={type:"change"},r={type:"start"},i={type:"end"},a={NONE:-1,ROTATE:0,DOLLY:1,PAN:2,TOUCH_ROTATE:3,TOUCH_PAN:4,TOUCH_DOLLY_PAN:5,TOUCH_DOLLY_ROTATE:6};let l=a.NONE;const u=1e-6,h=new c.Spherical,d=new c.Spherical;let y=1;const g=new c.Vector3,x=new c.Vector2,w=new c.Vector2,v=new c.Vector2,P=new c.Vector2,D=new c.Vector2,S=new c.Vector2,_=new c.Vector2,L=new c.Vector2,b=new c.Vector2,C=new c.Vector3,m=new c.Vector2;let M=!1;const p=[],I={};function F(){return 2*Math.PI/60/60*n.autoRotateSpeed}function J(){return Math.pow(.95,n.zoomSpeed)}function G(Y){n.reverseOrbit||n.reverseHorizontalOrbit?d.theta+=Y:d.theta-=Y}function Q(Y){n.reverseOrbit||n.reverseVerticalOrbit?d.phi+=Y:d.phi-=Y}const K=(()=>{const Y=new c.Vector3;return function(me,Se){Y.setFromMatrixColumn(Se,0),Y.multiplyScalar(-me),g.add(Y)}})(),Z=(()=>{const Y=new c.Vector3;return function(me,Se){n.screenSpacePanning===!0?Y.setFromMatrixColumn(Se,1):(Y.setFromMatrixColumn(Se,0),Y.crossVectors(n.object.up,Y)),Y.multiplyScalar(me),g.add(Y)}})(),X=(()=>{const Y=new c.Vector3;return function(me,Se){const Fe=n.domElement;if(Fe&&n.object instanceof c.PerspectiveCamera&&n.object.isPerspectiveCamera){const lt=n.object.position;Y.copy(lt).sub(n.target);let xt=Y.length();xt*=Math.tan(n.object.fov/2*Math.PI/180),K(2*me*xt/Fe.clientHeight,n.object.matrix),Z(2*Se*xt/Fe.clientHeight,n.object.matrix)}else Fe&&n.object instanceof c.OrthographicCamera&&n.object.isOrthographicCamera?(K(me*(n.object.right-n.object.left)/n.object.zoom/Fe.clientWidth,n.object.matrix),Z(Se*(n.object.top-n.object.bottom)/n.object.zoom/Fe.clientHeight,n.object.matrix)):(console.warn("WARNING: OrbitControls.js encountered an unknown camera type - pan disabled."),n.enablePan=!1)}})();function ne(Y){n.object instanceof c.PerspectiveCamera&&n.object.isPerspectiveCamera||n.object instanceof c.OrthographicCamera&&n.object.isOrthographicCamera?y/=Y:(console.warn("WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."),n.enableZoom=!1)}function se(Y){n.object instanceof c.PerspectiveCamera&&n.object.isPerspectiveCamera||n.object instanceof c.OrthographicCamera&&n.object.isOrthographicCamera?y*=Y:(console.warn("WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."),n.enableZoom=!1)}function ue(Y){if(!n.zoomToCursor||!n.domElement)return;M=!0;const ie=n.domElement.getBoundingClientRect(),me=Y.clientX-ie.left,Se=Y.clientY-ie.top,Fe=ie.width,lt=ie.height;m.x=me/Fe*2-1,m.y=-(Se/lt)*2+1,C.set(m.x,m.y,1).unproject(n.object).sub(n.object.position).normalize()}function j(Y){return Math.max(n.minDistance,Math.min(n.maxDistance,Y))}function z(Y){x.set(Y.clientX,Y.clientY)}function A(Y){ue(Y),_.set(Y.clientX,Y.clientY)}function V(Y){P.set(Y.clientX,Y.clientY)}function ee(Y){w.set(Y.clientX,Y.clientY),v.subVectors(w,x).multiplyScalar(n.rotateSpeed);const ie=n.domElement;ie&&(G(2*Math.PI*v.x/ie.clientHeight),Q(2*Math.PI*v.y/ie.clientHeight)),x.copy(w),n.update()}function N(Y){L.set(Y.clientX,Y.clientY),b.subVectors(L,_),b.y>0?ne(J()):b.y<0&&se(J()),_.copy(L),n.update()}function R(Y){D.set(Y.clientX,Y.clientY),S.subVectors(D,P).multiplyScalar(n.panSpeed),X(S.x,S.y),P.copy(D),n.update()}function T(Y){ue(Y),Y.deltaY<0?se(J()):Y.deltaY>0&&ne(J()),n.update()}function O(Y){let ie=!1;switch(Y.code){case n.keys.UP:X(0,n.keyPanSpeed),ie=!0;break;case n.keys.BOTTOM:X(0,-n.keyPanSpeed),ie=!0;break;case n.keys.LEFT:X(n.keyPanSpeed,0),ie=!0;break;case n.keys.RIGHT:X(-n.keyPanSpeed,0),ie=!0;break}ie&&(Y.preventDefault(),n.update())}function k(){if(p.length==1)x.set(p[0].pageX,p[0].pageY);else{const Y=.5*(p[0].pageX+p[1].pageX),ie=.5*(p[0].pageY+p[1].pageY);x.set(Y,ie)}}function E(){if(p.length==1)P.set(p[0].pageX,p[0].pageY);else{const Y=.5*(p[0].pageX+p[1].pageX),ie=.5*(p[0].pageY+p[1].pageY);P.set(Y,ie)}}function q(){const Y=p[0].pageX-p[1].pageX,ie=p[0].pageY-p[1].pageY,me=Math.sqrt(Y*Y+ie*ie);_.set(0,me)}function W(){n.enableZoom&&q(),n.enablePan&&E()}function te(){n.enableZoom&&q(),n.enableRotate&&k()}function U(Y){if(p.length==1)w.set(Y.pageX,Y.pageY);else{const me=Us(Y),Se=.5*(Y.pageX+me.x),Fe=.5*(Y.pageY+me.y);w.set(Se,Fe)}v.subVectors(w,x).multiplyScalar(n.rotateSpeed);const ie=n.domElement;ie&&(G(2*Math.PI*v.x/ie.clientHeight),Q(2*Math.PI*v.y/ie.clientHeight)),x.copy(w)}function B(Y){if(p.length==1)D.set(Y.pageX,Y.pageY);else{const ie=Us(Y),me=.5*(Y.pageX+ie.x),Se=.5*(Y.pageY+ie.y);D.set(me,Se)}S.subVectors(D,P).multiplyScalar(n.panSpeed),X(S.x,S.y),P.copy(D)}function oe(Y){const ie=Us(Y),me=Y.pageX-ie.x,Se=Y.pageY-ie.y,Fe=Math.sqrt(me*me+Se*Se);L.set(0,Fe),b.set(0,Math.pow(L.y/_.y,n.zoomSpeed)),ne(b.y),_.copy(L)}function ce(Y){n.enableZoom&&oe(Y),n.enablePan&&B(Y)}function ge(Y){n.enableZoom&&oe(Y),n.enableRotate&&U(Y)}function _e(Y){var ie,me;n.enabled!==!1&&(p.length===0&&((ie=n.domElement)==null||ie.ownerDocument.addEventListener("pointermove",xe),(me=n.domElement)==null||me.ownerDocument.addEventListener("pointerup",Oe)),$f(Y),Y.pointerType==="touch"?Jf(Y):an(Y))}function xe(Y){n.enabled!==!1&&(Y.pointerType==="touch"?Hf(Y):Rt(Y))}function Oe(Y){var ie,me,Se;Vi(Y),p.length===0&&((ie=n.domElement)==null||ie.releasePointerCapture(Y.pointerId),(me=n.domElement)==null||me.ownerDocument.removeEventListener("pointermove",xe),(Se=n.domElement)==null||Se.ownerDocument.removeEventListener("pointerup",Oe)),n.dispatchEvent(i),l=a.NONE}function at(Y){Vi(Y)}function an(Y){let ie;switch(Y.button){case 0:ie=n.mouseButtons.LEFT;break;case 1:ie=n.mouseButtons.MIDDLE;break;case 2:ie=n.mouseButtons.RIGHT;break;default:ie=-1}switch(ie){case c.MOUSE.DOLLY:if(n.enableZoom===!1)return;A(Y),l=a.DOLLY;break;case c.MOUSE.ROTATE:if(Y.ctrlKey||Y.metaKey||Y.shiftKey){if(n.enablePan===!1)return;V(Y),l=a.PAN}else{if(n.enableRotate===!1)return;z(Y),l=a.ROTATE}break;case c.MOUSE.PAN:if(Y.ctrlKey||Y.metaKey||Y.shiftKey){if(n.enableRotate===!1)return;z(Y),l=a.ROTATE}else{if(n.enablePan===!1)return;V(Y),l=a.PAN}break;default:l=a.NONE}l!==a.NONE&&n.dispatchEvent(r)}function Rt(Y){if(n.enabled!==!1)switch(l){case a.ROTATE:if(n.enableRotate===!1)return;ee(Y);break;case a.DOLLY:if(n.enableZoom===!1)return;N(Y);break;case a.PAN:if(n.enablePan===!1)return;R(Y);break}}function Ke(Y){n.enabled===!1||n.enableZoom===!1||l!==a.NONE&&l!==a.ROTATE||(Y.preventDefault(),n.dispatchEvent(r),T(Y),n.dispatchEvent(i))}function Gt(Y){n.enabled===!1||n.enablePan===!1||O(Y)}function Jf(Y){switch(Ri(Y),p.length){case 1:switch(n.touches.ONE){case c.TOUCH.ROTATE:if(n.enableRotate===!1)return;k(),l=a.TOUCH_ROTATE;break;case c.TOUCH.PAN:if(n.enablePan===!1)return;E(),l=a.TOUCH_PAN;break;default:l=a.NONE}break;case 2:switch(n.touches.TWO){case c.TOUCH.DOLLY_PAN:if(n.enableZoom===!1&&n.enablePan===!1)return;W(),l=a.TOUCH_DOLLY_PAN;break;case c.TOUCH.DOLLY_ROTATE:if(n.enableZoom===!1&&n.enableRotate===!1)return;te(),l=a.TOUCH_DOLLY_ROTATE;break;default:l=a.NONE}break;default:l=a.NONE}l!==a.NONE&&n.dispatchEvent(r)}function Hf(Y){switch(Ri(Y),l){case a.TOUCH_ROTATE:if(n.enableRotate===!1)return;U(Y),n.update();break;case a.TOUCH_PAN:if(n.enablePan===!1)return;B(Y),n.update();break;case a.TOUCH_DOLLY_PAN:if(n.enableZoom===!1&&n.enablePan===!1)return;ce(Y),n.update();break;case a.TOUCH_DOLLY_ROTATE:if(n.enableZoom===!1&&n.enableRotate===!1)return;ge(Y),n.update();break;default:l=a.NONE}}function zi(Y){n.enabled!==!1&&Y.preventDefault()}function $f(Y){p.push(Y)}function Vi(Y){delete I[Y.pointerId];for(let ie=0;ie<p.length;ie++)if(p[ie].pointerId==Y.pointerId){p.splice(ie,1);return}}function Ri(Y){let ie=I[Y.pointerId];ie===void 0&&(ie=new c.Vector2,I[Y.pointerId]=ie),ie.set(Y.pageX,Y.pageY)}function Us(Y){const ie=Y.pointerId===p[0].pointerId?p[1]:p[0];return I[ie.pointerId]}t!==void 0&&this.connect(t),this.update()}}class jo extends sr{constructor(e,t){super(e,t),this.screenSpacePanning=!1,this.mouseButtons.LEFT=c.MOUSE.PAN,this.mouseButtons.RIGHT=c.MOUSE.ROTATE,this.touches.ONE=c.TOUCH.PAN,this.touches.TWO=c.TOUCH.DOLLY_ROTATE}}class Eo extends c.Loader{constructor(e){super(e),this.dracoLoader=null,this.ktx2Loader=null,this.meshoptDecoder=null,this.pluginCallbacks=[],this.register(function(t){return new Ko(t)}),this.register(function(t){return new na(t)}),this.register(function(t){return new sa(t)}),this.register(function(t){return new ra(t)}),this.register(function(t){return new Qo(t)}),this.register(function(t){return new Jo(t)}),this.register(function(t){return new Ho(t)}),this.register(function(t){return new $o(t)}),this.register(function(t){return new Zo(t)}),this.register(function(t){return new ea(t)}),this.register(function(t){return new qo(t)}),this.register(function(t){return new ta(t)}),this.register(function(t){return new Xo(t)}),this.register(function(t){return new ia(t)}),this.register(function(t){return new oa(t)})}load(e,t,n,s){const r=this;let i;this.resourcePath!==""?i=this.resourcePath:this.path!==""?i=this.path:i=c.LoaderUtils.extractUrlBase(e),this.manager.itemStart(e);const a=function(u){s?s(u):console.error(u),r.manager.itemError(e),r.manager.itemEnd(e)},l=new c.FileLoader(this.manager);l.setPath(this.path),l.setResponseType("arraybuffer"),l.setRequestHeader(this.requestHeader),l.setWithCredentials(this.withCredentials),l.load(e,function(u){try{r.parse(u,i,function(h){t(h),r.manager.itemEnd(e)},a)}catch(h){a(h)}},n,a)}setDRACOLoader(e){return this.dracoLoader=e,this}setDDSLoader(){throw new Error('THREE.GLTFLoader: "MSFT_texture_dds" no longer supported. Please update to "KHR_texture_basisu".')}setKTX2Loader(e){return this.ktx2Loader=e,this}setMeshoptDecoder(e){return this.meshoptDecoder=e,this}register(e){return this.pluginCallbacks.indexOf(e)===-1&&this.pluginCallbacks.push(e),this}unregister(e){return this.pluginCallbacks.indexOf(e)!==-1&&this.pluginCallbacks.splice(this.pluginCallbacks.indexOf(e),1),this}parse(e,t,n,s){let r;const i={},a={};if(typeof e=="string")r=JSON.parse(e);else if(e instanceof ArrayBuffer)if(c.LoaderUtils.decodeText(new Uint8Array(e.slice(0,4)))===rr){try{i[be.KHR_BINARY_GLTF]=new aa(e)}catch(h){s&&s(h);return}r=JSON.parse(i[be.KHR_BINARY_GLTF].content)}else r=JSON.parse(c.LoaderUtils.decodeText(new Uint8Array(e)));else r=e;if(r.asset===void 0||r.asset.version[0]<2){s&&s(new Error("THREE.GLTFLoader: Unsupported asset. glTF versions >=2.0 are supported."));return}const l=new xa(r,{path:t||this.resourcePath||"",crossOrigin:this.crossOrigin,requestHeader:this.requestHeader,manager:this.manager,ktx2Loader:this.ktx2Loader,meshoptDecoder:this.meshoptDecoder});l.fileLoader.setRequestHeader(this.requestHeader);for(let u=0;u<this.pluginCallbacks.length;u++){const h=this.pluginCallbacks[u](l);a[h.name]=h,i[h.name]=!0}if(r.extensionsUsed)for(let u=0;u<r.extensionsUsed.length;++u){const h=r.extensionsUsed[u],d=r.extensionsRequired||[];switch(h){case be.KHR_MATERIALS_UNLIT:i[h]=new Wo;break;case be.KHR_DRACO_MESH_COMPRESSION:i[h]=new la(r,this.dracoLoader);break;case be.KHR_TEXTURE_TRANSFORM:i[h]=new ca;break;case be.KHR_MESH_QUANTIZATION:i[h]=new ua;break;default:d.indexOf(h)>=0&&a[h]===void 0&&console.warn('THREE.GLTFLoader: Unknown extension "'+h+'".')}}l.setExtensions(i),l.setPlugins(a),l.parse(n,s)}parseAsync(e,t){const n=this;return new Promise(function(s,r){n.parse(e,t,s,r)})}}function Yo(){let o={};return{get:function(e){return o[e]},add:function(e,t){o[e]=t},remove:function(e){delete o[e]},removeAll:function(){o={}}}}const be={KHR_BINARY_GLTF:"KHR_binary_glTF",KHR_DRACO_MESH_COMPRESSION:"KHR_draco_mesh_compression",KHR_LIGHTS_PUNCTUAL:"KHR_lights_punctual",KHR_MATERIALS_CLEARCOAT:"KHR_materials_clearcoat",KHR_MATERIALS_IOR:"KHR_materials_ior",KHR_MATERIALS_SHEEN:"KHR_materials_sheen",KHR_MATERIALS_SPECULAR:"KHR_materials_specular",KHR_MATERIALS_TRANSMISSION:"KHR_materials_transmission",KHR_MATERIALS_IRIDESCENCE:"KHR_materials_iridescence",KHR_MATERIALS_ANISOTROPY:"KHR_materials_anisotropy",KHR_MATERIALS_UNLIT:"KHR_materials_unlit",KHR_MATERIALS_VOLUME:"KHR_materials_volume",KHR_TEXTURE_BASISU:"KHR_texture_basisu",KHR_TEXTURE_TRANSFORM:"KHR_texture_transform",KHR_MESH_QUANTIZATION:"KHR_mesh_quantization",KHR_MATERIALS_EMISSIVE_STRENGTH:"KHR_materials_emissive_strength",EXT_TEXTURE_WEBP:"EXT_texture_webp",EXT_TEXTURE_AVIF:"EXT_texture_avif",EXT_MESHOPT_COMPRESSION:"EXT_meshopt_compression",EXT_MESH_GPU_INSTANCING:"EXT_mesh_gpu_instancing"};class Xo{constructor(e){this.parser=e,this.name=be.KHR_LIGHTS_PUNCTUAL,this.cache={refs:{},uses:{}}}_markDefs(){const e=this.parser,t=this.parser.json.nodes||[];for(let n=0,s=t.length;n<s;n++){const r=t[n];r.extensions&&r.extensions[this.name]&&r.extensions[this.name].light!==void 0&&e._addNodeRef(this.cache,r.extensions[this.name].light)}}_loadLight(e){const t=this.parser,n="light:"+e;let s=t.cache.get(n);if(s)return s;const r=t.json,l=((r.extensions&&r.extensions[this.name]||{}).lights||[])[e];let u;const h=new c.Color(16777215);l.color!==void 0&&h.fromArray(l.color);const d=l.range!==void 0?l.range:0;switch(l.type){case"directional":u=new c.DirectionalLight(h),u.target.position.set(0,0,-1),u.add(u.target);break;case"point":u=new c.PointLight(h),u.distance=d;break;case"spot":u=new c.SpotLight(h),u.distance=d,l.spot=l.spot||{},l.spot.innerConeAngle=l.spot.innerConeAngle!==void 0?l.spot.innerConeAngle:0,l.spot.outerConeAngle=l.spot.outerConeAngle!==void 0?l.spot.outerConeAngle:Math.PI/4,u.angle=l.spot.outerConeAngle,u.penumbra=1-l.spot.innerConeAngle/l.spot.outerConeAngle,u.target.position.set(0,0,-1),u.add(u.target);break;default:throw new Error("THREE.GLTFLoader: Unexpected light type: "+l.type)}return u.position.set(0,0,0),u.decay=2,pt(u,l),l.intensity!==void 0&&(u.intensity=l.intensity),u.name=t.createUniqueName(l.name||"light_"+e),s=Promise.resolve(u),t.cache.add(n,s),s}getDependency(e,t){if(e==="light")return this._loadLight(t)}createNodeAttachment(e){const t=this,n=this.parser,r=n.json.nodes[e],a=(r.extensions&&r.extensions[this.name]||{}).light;return a===void 0?null:this._loadLight(a).then(function(l){return n._getNodeRef(t.cache,a,l)})}}class Wo{constructor(){this.name=be.KHR_MATERIALS_UNLIT}getMaterialType(){return c.MeshBasicMaterial}extendParams(e,t,n){const s=[];e.color=new c.Color(1,1,1),e.opacity=1;const r=t.pbrMetallicRoughness;if(r){if(Array.isArray(r.baseColorFactor)){const i=r.baseColorFactor;e.color.fromArray(i),e.opacity=i[3]}r.baseColorTexture!==void 0&&s.push(n.assignTexture(e,"map",r.baseColorTexture,3001))}return Promise.all(s)}}class Zo{constructor(e){this.parser=e,this.name=be.KHR_MATERIALS_EMISSIVE_STRENGTH}extendMaterialParams(e,t){const s=this.parser.json.materials[e];if(!s.extensions||!s.extensions[this.name])return Promise.resolve();const r=s.extensions[this.name].emissiveStrength;return r!==void 0&&(t.emissiveIntensity=r),Promise.resolve()}}class Ko{constructor(e){this.parser=e,this.name=be.KHR_MATERIALS_CLEARCOAT}getMaterialType(e){const n=this.parser.json.materials[e];return!n.extensions||!n.extensions[this.name]?null:c.MeshPhysicalMaterial}extendMaterialParams(e,t){const n=this.parser,s=n.json.materials[e];if(!s.extensions||!s.extensions[this.name])return Promise.resolve();const r=[],i=s.extensions[this.name];if(i.clearcoatFactor!==void 0&&(t.clearcoat=i.clearcoatFactor),i.clearcoatTexture!==void 0&&r.push(n.assignTexture(t,"clearcoatMap",i.clearcoatTexture)),i.clearcoatRoughnessFactor!==void 0&&(t.clearcoatRoughness=i.clearcoatRoughnessFactor),i.clearcoatRoughnessTexture!==void 0&&r.push(n.assignTexture(t,"clearcoatRoughnessMap",i.clearcoatRoughnessTexture)),i.clearcoatNormalTexture!==void 0&&(r.push(n.assignTexture(t,"clearcoatNormalMap",i.clearcoatNormalTexture)),i.clearcoatNormalTexture.scale!==void 0)){const a=i.clearcoatNormalTexture.scale;t.clearcoatNormalScale=new c.Vector2(a,a)}return Promise.all(r)}}class qo{constructor(e){this.parser=e,this.name=be.KHR_MATERIALS_IRIDESCENCE}getMaterialType(e){const n=this.parser.json.materials[e];return!n.extensions||!n.extensions[this.name]?null:c.MeshPhysicalMaterial}extendMaterialParams(e,t){const n=this.parser,s=n.json.materials[e];if(!s.extensions||!s.extensions[this.name])return Promise.resolve();const r=[],i=s.extensions[this.name];return i.iridescenceFactor!==void 0&&(t.iridescence=i.iridescenceFactor),i.iridescenceTexture!==void 0&&r.push(n.assignTexture(t,"iridescenceMap",i.iridescenceTexture)),i.iridescenceIor!==void 0&&(t.iridescenceIOR=i.iridescenceIor),t.iridescenceThicknessRange===void 0&&(t.iridescenceThicknessRange=[100,400]),i.iridescenceThicknessMinimum!==void 0&&(t.iridescenceThicknessRange[0]=i.iridescenceThicknessMinimum),i.iridescenceThicknessMaximum!==void 0&&(t.iridescenceThicknessRange[1]=i.iridescenceThicknessMaximum),i.iridescenceThicknessTexture!==void 0&&r.push(n.assignTexture(t,"iridescenceThicknessMap",i.iridescenceThicknessTexture)),Promise.all(r)}}class Qo{constructor(e){this.parser=e,this.name=be.KHR_MATERIALS_SHEEN}getMaterialType(e){const n=this.parser.json.materials[e];return!n.extensions||!n.extensions[this.name]?null:c.MeshPhysicalMaterial}extendMaterialParams(e,t){const n=this.parser,s=n.json.materials[e];if(!s.extensions||!s.extensions[this.name])return Promise.resolve();const r=[];t.sheenColor=new c.Color(0,0,0),t.sheenRoughness=0,t.sheen=1;const i=s.extensions[this.name];return i.sheenColorFactor!==void 0&&t.sheenColor.fromArray(i.sheenColorFactor),i.sheenRoughnessFactor!==void 0&&(t.sheenRoughness=i.sheenRoughnessFactor),i.sheenColorTexture!==void 0&&r.push(n.assignTexture(t,"sheenColorMap",i.sheenColorTexture,3001)),i.sheenRoughnessTexture!==void 0&&r.push(n.assignTexture(t,"sheenRoughnessMap",i.sheenRoughnessTexture)),Promise.all(r)}}class Jo{constructor(e){this.parser=e,this.name=be.KHR_MATERIALS_TRANSMISSION}getMaterialType(e){const n=this.parser.json.materials[e];return!n.extensions||!n.extensions[this.name]?null:c.MeshPhysicalMaterial}extendMaterialParams(e,t){const n=this.parser,s=n.json.materials[e];if(!s.extensions||!s.extensions[this.name])return Promise.resolve();const r=[],i=s.extensions[this.name];return i.transmissionFactor!==void 0&&(t.transmission=i.transmissionFactor),i.transmissionTexture!==void 0&&r.push(n.assignTexture(t,"transmissionMap",i.transmissionTexture)),Promise.all(r)}}class Ho{constructor(e){this.parser=e,this.name=be.KHR_MATERIALS_VOLUME}getMaterialType(e){const n=this.parser.json.materials[e];return!n.extensions||!n.extensions[this.name]?null:c.MeshPhysicalMaterial}extendMaterialParams(e,t){const n=this.parser,s=n.json.materials[e];if(!s.extensions||!s.extensions[this.name])return Promise.resolve();const r=[],i=s.extensions[this.name];t.thickness=i.thicknessFactor!==void 0?i.thicknessFactor:0,i.thicknessTexture!==void 0&&r.push(n.assignTexture(t,"thicknessMap",i.thicknessTexture)),t.attenuationDistance=i.attenuationDistance||1/0;const a=i.attenuationColor||[1,1,1];return t.attenuationColor=new c.Color(a[0],a[1],a[2]),Promise.all(r)}}class $o{constructor(e){this.parser=e,this.name=be.KHR_MATERIALS_IOR}getMaterialType(e){const n=this.parser.json.materials[e];return!n.extensions||!n.extensions[this.name]?null:c.MeshPhysicalMaterial}extendMaterialParams(e,t){const s=this.parser.json.materials[e];if(!s.extensions||!s.extensions[this.name])return Promise.resolve();const r=s.extensions[this.name];return t.ior=r.ior!==void 0?r.ior:1.5,Promise.resolve()}}class ea{constructor(e){this.parser=e,this.name=be.KHR_MATERIALS_SPECULAR}getMaterialType(e){const n=this.parser.json.materials[e];return!n.extensions||!n.extensions[this.name]?null:c.MeshPhysicalMaterial}extendMaterialParams(e,t){const n=this.parser,s=n.json.materials[e];if(!s.extensions||!s.extensions[this.name])return Promise.resolve();const r=[],i=s.extensions[this.name];t.specularIntensity=i.specularFactor!==void 0?i.specularFactor:1,i.specularTexture!==void 0&&r.push(n.assignTexture(t,"specularIntensityMap",i.specularTexture));const a=i.specularColorFactor||[1,1,1];return t.specularColor=new c.Color(a[0],a[1],a[2]),i.specularColorTexture!==void 0&&r.push(n.assignTexture(t,"specularColorMap",i.specularColorTexture,3001)),Promise.all(r)}}class ta{constructor(e){this.parser=e,this.name=be.KHR_MATERIALS_ANISOTROPY}getMaterialType(e){const n=this.parser.json.materials[e];return!n.extensions||!n.extensions[this.name]?null:c.MeshPhysicalMaterial}extendMaterialParams(e,t){const n=this.parser,s=n.json.materials[e];if(!s.extensions||!s.extensions[this.name])return Promise.resolve();const r=[],i=s.extensions[this.name];return i.anisotropyStrength!==void 0&&(t.anisotropy=i.anisotropyStrength),i.anisotropyRotation!==void 0&&(t.anisotropyRotation=i.anisotropyRotation),i.anisotropyTexture!==void 0&&r.push(n.assignTexture(t,"anisotropyMap",i.anisotropyTexture)),Promise.all(r)}}class na{constructor(e){this.parser=e,this.name=be.KHR_TEXTURE_BASISU}loadTexture(e){const t=this.parser,n=t.json,s=n.textures[e];if(!s.extensions||!s.extensions[this.name])return null;const r=s.extensions[this.name],i=t.options.ktx2Loader;if(!i){if(n.extensionsRequired&&n.extensionsRequired.indexOf(this.name)>=0)throw new Error("THREE.GLTFLoader: setKTX2Loader must be called before loading KTX2 textures");return null}return t.loadTextureImage(e,r.source,i)}}class sa{constructor(e){this.parser=e,this.name=be.EXT_TEXTURE_WEBP,this.isSupported=null}loadTexture(e){const t=this.name,n=this.parser,s=n.json,r=s.textures[e];if(!r.extensions||!r.extensions[t])return null;const i=r.extensions[t],a=s.images[i.source];let l=n.textureLoader;if(a.uri){const u=n.options.manager.getHandler(a.uri);u!==null&&(l=u)}return this.detectSupport().then(function(u){if(u)return n.loadTextureImage(e,i.source,l);if(s.extensionsRequired&&s.extensionsRequired.indexOf(t)>=0)throw new Error("THREE.GLTFLoader: WebP required by asset but unsupported.");return n.loadTexture(e)})}detectSupport(){return this.isSupported||(this.isSupported=new Promise(function(e){const t=new Image;t.src="data:image/webp;base64,UklGRiIAAABXRUJQVlA4IBYAAAAwAQCdASoBAAEADsD+JaQAA3AAAAAA",t.onload=t.onerror=function(){e(t.height===1)}})),this.isSupported}}class ra{constructor(e){this.parser=e,this.name=be.EXT_TEXTURE_AVIF,this.isSupported=null}loadTexture(e){const t=this.name,n=this.parser,s=n.json,r=s.textures[e];if(!r.extensions||!r.extensions[t])return null;const i=r.extensions[t],a=s.images[i.source];let l=n.textureLoader;if(a.uri){const u=n.options.manager.getHandler(a.uri);u!==null&&(l=u)}return this.detectSupport().then(function(u){if(u)return n.loadTextureImage(e,i.source,l);if(s.extensionsRequired&&s.extensionsRequired.indexOf(t)>=0)throw new Error("THREE.GLTFLoader: AVIF required by asset but unsupported.");return n.loadTexture(e)})}detectSupport(){return this.isSupported||(this.isSupported=new Promise(function(e){const t=new Image;t.src="data:image/avif;base64,AAAAIGZ0eXBhdmlmAAAAAGF2aWZtaWYxbWlhZk1BMUIAAADybWV0YQAAAAAAAAAoaGRscgAAAAAAAAAAcGljdAAAAAAAAAAAAAAAAGxpYmF2aWYAAAAADnBpdG0AAAAAAAEAAAAeaWxvYwAAAABEAAABAAEAAAABAAABGgAAABcAAAAoaWluZgAAAAAAAQAAABppbmZlAgAAAAABAABhdjAxQ29sb3IAAAAAamlwcnAAAABLaXBjbwAAABRpc3BlAAAAAAAAAAEAAAABAAAAEHBpeGkAAAAAAwgICAAAAAxhdjFDgQAMAAAAABNjb2xybmNseAACAAIABoAAAAAXaXBtYQAAAAAAAAABAAEEAQKDBAAAAB9tZGF0EgAKCBgABogQEDQgMgkQAAAAB8dSLfI=",t.onload=t.onerror=function(){e(t.height===1)}})),this.isSupported}}class ia{constructor(e){this.name=be.EXT_MESHOPT_COMPRESSION,this.parser=e}loadBufferView(e){const t=this.parser.json,n=t.bufferViews[e];if(n.extensions&&n.extensions[this.name]){const s=n.extensions[this.name],r=this.parser.getDependency("buffer",s.buffer),i=this.parser.options.meshoptDecoder;if(!i||!i.supported){if(t.extensionsRequired&&t.extensionsRequired.indexOf(this.name)>=0)throw new Error("THREE.GLTFLoader: setMeshoptDecoder must be called before loading compressed files");return null}return r.then(function(a){const l=s.byteOffset||0,u=s.byteLength||0,h=s.count,d=s.byteStride,y=new Uint8Array(a,l,u);return i.decodeGltfBufferAsync?i.decodeGltfBufferAsync(h,d,y,s.mode,s.filter).then(function(g){return g.buffer}):i.ready.then(function(){const g=new ArrayBuffer(h*d);return i.decodeGltfBuffer(new Uint8Array(g),h,d,y,s.mode,s.filter),g})})}else return null}}class oa{constructor(e){this.name=be.EXT_MESH_GPU_INSTANCING,this.parser=e}createNodeMesh(e){const t=this.parser.json,n=t.nodes[e];if(!n.extensions||!n.extensions[this.name]||n.mesh===void 0)return null;const s=t.meshes[n.mesh];for(const u of s.primitives)if(u.mode!==We.TRIANGLES&&u.mode!==We.TRIANGLE_STRIP&&u.mode!==We.TRIANGLE_FAN&&u.mode!==void 0)return null;const i=n.extensions[this.name].attributes,a=[],l={};for(const u in i)a.push(this.parser.getDependency("accessor",i[u]).then(h=>(l[u]=h,l[u])));return a.length<1?null:(a.push(this.parser.createNodeMesh(e)),Promise.all(a).then(u=>{const h=u.pop(),d=h.isGroup?h.children:[h],y=u[0].count,g=[];for(const x of d){const w=new c.Matrix4,v=new c.Vector3,P=new c.Quaternion,D=new c.Vector3(1,1,1),S=new c.InstancedMesh(x.geometry,x.material,y);for(let _=0;_<y;_++)l.TRANSLATION&&v.fromBufferAttribute(l.TRANSLATION,_),l.ROTATION&&P.fromBufferAttribute(l.ROTATION,_),l.SCALE&&D.fromBufferAttribute(l.SCALE,_),S.setMatrixAt(_,w.compose(v,P,D));for(const _ in l)_!=="TRANSLATION"&&_!=="ROTATION"&&_!=="SCALE"&&x.geometry.setAttribute(_,l[_]);c.Object3D.prototype.copy.call(S,x),this.parser.assignFinalMaterial(S),g.push(S)}return h.isGroup?(h.clear(),h.add(...g),h):g[0]}))}}const rr="glTF",Xt=12,ir={JSON:1313821514,BIN:5130562};class aa{constructor(e){this.name=be.KHR_BINARY_GLTF,this.content=null,this.body=null;const t=new DataView(e,0,Xt);if(this.header={magic:c.LoaderUtils.decodeText(new Uint8Array(e.slice(0,4))),version:t.getUint32(4,!0),length:t.getUint32(8,!0)},this.header.magic!==rr)throw new Error("THREE.GLTFLoader: Unsupported glTF-Binary header.");if(this.header.version<2)throw new Error("THREE.GLTFLoader: Legacy binary file detected.");const n=this.header.length-Xt,s=new DataView(e,Xt);let r=0;for(;r<n;){const i=s.getUint32(r,!0);r+=4;const a=s.getUint32(r,!0);if(r+=4,a===ir.JSON){const l=new Uint8Array(e,Xt+r,i);this.content=c.LoaderUtils.decodeText(l)}else if(a===ir.BIN){const l=Xt+r;this.body=e.slice(l,l+i)}r+=i}if(this.content===null)throw new Error("THREE.GLTFLoader: JSON content not found.")}}class la{constructor(e,t){if(!t)throw new Error("THREE.GLTFLoader: No DRACOLoader instance provided.");this.name=be.KHR_DRACO_MESH_COMPRESSION,this.json=e,this.dracoLoader=t,this.dracoLoader.preload()}decodePrimitive(e,t){const n=this.json,s=this.dracoLoader,r=e.extensions[this.name].bufferView,i=e.extensions[this.name].attributes,a={},l={},u={};for(const h in i){const d=Kn[h]||h.toLowerCase();a[d]=i[h]}for(const h in e.attributes){const d=Kn[h]||h.toLowerCase();if(i[h]!==void 0){const y=n.accessors[e.attributes[h]],g=Dt[y.componentType];u[d]=g.name,l[d]=y.normalized===!0}}return t.getDependency("bufferView",r).then(function(h){return new Promise(function(d){s.decodeDracoFile(h,function(y){for(const g in y.attributes){const x=y.attributes[g],w=l[g];w!==void 0&&(x.normalized=w)}d(y)},a,u)})})}}class ca{constructor(){this.name=be.KHR_TEXTURE_TRANSFORM}extendTexture(e,t){return(t.texCoord===void 0||t.texCoord===e.channel)&&t.offset===void 0&&t.rotation===void 0&&t.scale===void 0||(e=e.clone(),t.texCoord!==void 0&&(e.channel=t.texCoord),t.offset!==void 0&&e.offset.fromArray(t.offset),t.rotation!==void 0&&(e.rotation=t.rotation),t.scale!==void 0&&e.repeat.fromArray(t.scale),e.needsUpdate=!0),e}}class ua{constructor(){this.name=be.KHR_MESH_QUANTIZATION}}class or extends c.Interpolant{constructor(e,t,n,s){super(e,t,n,s)}copySampleValue_(e){const t=this.resultBuffer,n=this.sampleValues,s=this.valueSize,r=e*s*3+s;for(let i=0;i!==s;i++)t[i]=n[r+i];return t}interpolate_(e,t,n,s){const r=this.resultBuffer,i=this.sampleValues,a=this.valueSize,l=a*2,u=a*3,h=s-t,d=(n-t)/h,y=d*d,g=y*d,x=e*u,w=x-u,v=-2*g+3*y,P=g-y,D=1-v,S=P-y+d;for(let _=0;_!==a;_++){const L=i[w+_+a],b=i[w+_+l]*h,C=i[x+_+a],m=i[x+_]*h;r[_]=D*L+S*b+v*C+P*m}return r}}const ha=new c.Quaternion;class fa extends or{interpolate_(e,t,n,s){const r=super.interpolate_(e,t,n,s);return ha.fromArray(r).normalize().toArray(r),r}}const We={FLOAT:5126,FLOAT_MAT3:35675,FLOAT_MAT4:35676,FLOAT_VEC2:35664,FLOAT_VEC3:35665,FLOAT_VEC4:35666,LINEAR:9729,REPEAT:10497,SAMPLER_2D:35678,POINTS:0,LINES:1,LINE_LOOP:2,LINE_STRIP:3,TRIANGLES:4,TRIANGLE_STRIP:5,TRIANGLE_FAN:6,UNSIGNED_BYTE:5121,UNSIGNED_SHORT:5123},Dt={5120:Int8Array,5121:Uint8Array,5122:Int16Array,5123:Uint16Array,5125:Uint32Array,5126:Float32Array},ar={9728:c.NearestFilter,9729:c.LinearFilter,9984:c.NearestMipmapNearestFilter,9985:c.LinearMipmapNearestFilter,9986:c.NearestMipmapLinearFilter,9987:c.LinearMipmapLinearFilter},lr={33071:c.ClampToEdgeWrapping,33648:c.MirroredRepeatWrapping,10497:c.RepeatWrapping},Zn={SCALAR:1,VEC2:2,VEC3:3,VEC4:4,MAT2:4,MAT3:9,MAT4:16},Kn={POSITION:"position",NORMAL:"normal",TANGENT:"tangent",...Vs>=152?{TEXCOORD_0:"uv",TEXCOORD_1:"uv1",TEXCOORD_2:"uv2",TEXCOORD_3:"uv3"}:{TEXCOORD_0:"uv",TEXCOORD_1:"uv2"},COLOR_0:"color",WEIGHTS_0:"skinWeight",JOINTS_0:"skinIndex"},dt={scale:"scale",translation:"position",rotation:"quaternion",weights:"morphTargetInfluences"},da={CUBICSPLINE:void 0,LINEAR:c.InterpolateLinear,STEP:c.InterpolateDiscrete},qn={OPAQUE:"OPAQUE",MASK:"MASK",BLEND:"BLEND"};function pa(o){return o.DefaultMaterial===void 0&&(o.DefaultMaterial=new c.MeshStandardMaterial({color:16777215,emissive:0,metalness:1,roughness:1,transparent:!1,depthTest:!0,side:c.FrontSide})),o.DefaultMaterial}function wt(o,e,t){for(const n in t.extensions)o[n]===void 0&&(e.userData.gltfExtensions=e.userData.gltfExtensions||{},e.userData.gltfExtensions[n]=t.extensions[n])}function pt(o,e){e.extras!==void 0&&(typeof e.extras=="object"?Object.assign(o.userData,e.extras):console.warn("THREE.GLTFLoader: Ignoring primitive type .extras, "+e.extras))}function ma(o,e,t){let n=!1,s=!1,r=!1;for(let u=0,h=e.length;u<h;u++){const d=e[u];if(d.POSITION!==void 0&&(n=!0),d.NORMAL!==void 0&&(s=!0),d.COLOR_0!==void 0&&(r=!0),n&&s&&r)break}if(!n&&!s&&!r)return Promise.resolve(o);const i=[],a=[],l=[];for(let u=0,h=e.length;u<h;u++){const d=e[u];if(n){const y=d.POSITION!==void 0?t.getDependency("accessor",d.POSITION):o.attributes.position;i.push(y)}if(s){const y=d.NORMAL!==void 0?t.getDependency("accessor",d.NORMAL):o.attributes.normal;a.push(y)}if(r){const y=d.COLOR_0!==void 0?t.getDependency("accessor",d.COLOR_0):o.attributes.color;l.push(y)}}return Promise.all([Promise.all(i),Promise.all(a),Promise.all(l)]).then(function(u){const h=u[0],d=u[1],y=u[2];return n&&(o.morphAttributes.position=h),s&&(o.morphAttributes.normal=d),r&&(o.morphAttributes.color=y),o.morphTargetsRelative=!0,o})}function ga(o,e){if(o.updateMorphTargets(),e.weights!==void 0)for(let t=0,n=e.weights.length;t<n;t++)o.morphTargetInfluences[t]=e.weights[t];if(e.extras&&Array.isArray(e.extras.targetNames)){const t=e.extras.targetNames;if(o.morphTargetInfluences.length===t.length){o.morphTargetDictionary={};for(let n=0,s=t.length;n<s;n++)o.morphTargetDictionary[t[n]]=n}else console.warn("THREE.GLTFLoader: Invalid extras.targetNames length. Ignoring names.")}}function ya(o){let e;const t=o.extensions&&o.extensions[be.KHR_DRACO_MESH_COMPRESSION];if(t?e="draco:"+t.bufferView+":"+t.indices+":"+Qn(t.attributes):e=o.indices+":"+Qn(o.attributes)+":"+o.mode,o.targets!==void 0)for(let n=0,s=o.targets.length;n<s;n++)e+=":"+Qn(o.targets[n]);return e}function Qn(o){let e="";const t=Object.keys(o).sort();for(let n=0,s=t.length;n<s;n++)e+=t[n]+":"+o[t[n]]+";";return e}function Jn(o){switch(o){case Int8Array:return 1/127;case Uint8Array:return 1/255;case Int16Array:return 1/32767;case Uint16Array:return 1/65535;default:throw new Error("THREE.GLTFLoader: Unsupported normalized accessor component type.")}}function _a(o){return o.search(/\.jpe?g($|\?)/i)>0||o.search(/^data\:image\/jpeg/)===0?"image/jpeg":o.search(/\.webp($|\?)/i)>0||o.search(/^data\:image\/webp/)===0?"image/webp":"image/png"}const va=new c.Matrix4;class xa{constructor(e={},t={}){this.json=e,this.extensions={},this.plugins={},this.options=t,this.cache=new Yo,this.associations=new Map,this.primitiveCache={},this.nodeCache={},this.meshCache={refs:{},uses:{}},this.cameraCache={refs:{},uses:{}},this.lightCache={refs:{},uses:{}},this.sourceCache={},this.textureCache={},this.nodeNamesUsed={};let n=!1,s=!1,r=-1;typeof navigator<"u"&&typeof navigator.userAgent<"u"&&(n=/^((?!chrome|android).)*safari/i.test(navigator.userAgent)===!0,s=navigator.userAgent.indexOf("Firefox")>-1,r=s?navigator.userAgent.match(/Firefox\/([0-9]+)\./)[1]:-1),typeof createImageBitmap>"u"||n||s&&r<98?this.textureLoader=new c.TextureLoader(this.options.manager):this.textureLoader=new c.ImageBitmapLoader(this.options.manager),this.textureLoader.setCrossOrigin(this.options.crossOrigin),this.textureLoader.setRequestHeader(this.options.requestHeader),this.fileLoader=new c.FileLoader(this.options.manager),this.fileLoader.setResponseType("arraybuffer"),this.options.crossOrigin==="use-credentials"&&this.fileLoader.setWithCredentials(!0)}setExtensions(e){this.extensions=e}setPlugins(e){this.plugins=e}parse(e,t){const n=this,s=this.json,r=this.extensions;this.cache.removeAll(),this.nodeCache={},this._invokeAll(function(i){return i._markDefs&&i._markDefs()}),Promise.all(this._invokeAll(function(i){return i.beforeRoot&&i.beforeRoot()})).then(function(){return Promise.all([n.getDependencies("scene"),n.getDependencies("animation"),n.getDependencies("camera")])}).then(function(i){const a={scene:i[0][s.scene||0],scenes:i[0],animations:i[1],cameras:i[2],asset:s.asset,parser:n,userData:{}};wt(r,a,s),pt(a,s),Promise.all(n._invokeAll(function(l){return l.afterRoot&&l.afterRoot(a)})).then(function(){e(a)})}).catch(t)}_markDefs(){const e=this.json.nodes||[],t=this.json.skins||[],n=this.json.meshes||[];for(let s=0,r=t.length;s<r;s++){const i=t[s].joints;for(let a=0,l=i.length;a<l;a++)e[i[a]].isBone=!0}for(let s=0,r=e.length;s<r;s++){const i=e[s];i.mesh!==void 0&&(this._addNodeRef(this.meshCache,i.mesh),i.skin!==void 0&&(n[i.mesh].isSkinnedMesh=!0)),i.camera!==void 0&&this._addNodeRef(this.cameraCache,i.camera)}}_addNodeRef(e,t){t!==void 0&&(e.refs[t]===void 0&&(e.refs[t]=e.uses[t]=0),e.refs[t]++)}_getNodeRef(e,t,n){if(e.refs[t]<=1)return n;const s=n.clone(),r=(i,a)=>{const l=this.associations.get(i);l!=null&&this.associations.set(a,l);for(const[u,h]of i.children.entries())r(h,a.children[u])};return r(n,s),s.name+="_instance_"+e.uses[t]++,s}_invokeOne(e){const t=Object.values(this.plugins);t.push(this);for(let n=0;n<t.length;n++){const s=e(t[n]);if(s)return s}return null}_invokeAll(e){const t=Object.values(this.plugins);t.unshift(this);const n=[];for(let s=0;s<t.length;s++){const r=e(t[s]);r&&n.push(r)}return n}getDependency(e,t){const n=e+":"+t;let s=this.cache.get(n);if(!s){switch(e){case"scene":s=this.loadScene(t);break;case"node":s=this._invokeOne(function(r){return r.loadNode&&r.loadNode(t)});break;case"mesh":s=this._invokeOne(function(r){return r.loadMesh&&r.loadMesh(t)});break;case"accessor":s=this.loadAccessor(t);break;case"bufferView":s=this._invokeOne(function(r){return r.loadBufferView&&r.loadBufferView(t)});break;case"buffer":s=this.loadBuffer(t);break;case"material":s=this._invokeOne(function(r){return r.loadMaterial&&r.loadMaterial(t)});break;case"texture":s=this._invokeOne(function(r){return r.loadTexture&&r.loadTexture(t)});break;case"skin":s=this.loadSkin(t);break;case"animation":s=this._invokeOne(function(r){return r.loadAnimation&&r.loadAnimation(t)});break;case"camera":s=this.loadCamera(t);break;default:if(s=this._invokeOne(function(r){return r!=this&&r.getDependency&&r.getDependency(e,t)}),!s)throw new Error("Unknown type: "+e);break}this.cache.add(n,s)}return s}getDependencies(e){let t=this.cache.get(e);if(!t){const n=this,s=this.json[e+(e==="mesh"?"es":"s")]||[];t=Promise.all(s.map(function(r,i){return n.getDependency(e,i)})),this.cache.add(e,t)}return t}loadBuffer(e){const t=this.json.buffers[e],n=this.fileLoader;if(t.type&&t.type!=="arraybuffer")throw new Error("THREE.GLTFLoader: "+t.type+" buffer type is not supported.");if(t.uri===void 0&&e===0)return Promise.resolve(this.extensions[be.KHR_BINARY_GLTF].body);const s=this.options;return new Promise(function(r,i){n.load(c.LoaderUtils.resolveURL(t.uri,s.path),r,void 0,function(){i(new Error('THREE.GLTFLoader: Failed to load buffer "'+t.uri+'".'))})})}loadBufferView(e){const t=this.json.bufferViews[e];return this.getDependency("buffer",t.buffer).then(function(n){const s=t.byteLength||0,r=t.byteOffset||0;return n.slice(r,r+s)})}loadAccessor(e){const t=this,n=this.json,s=this.json.accessors[e];if(s.bufferView===void 0&&s.sparse===void 0){const i=Zn[s.type],a=Dt[s.componentType],l=s.normalized===!0,u=new a(s.count*i);return Promise.resolve(new c.BufferAttribute(u,i,l))}const r=[];return s.bufferView!==void 0?r.push(this.getDependency("bufferView",s.bufferView)):r.push(null),s.sparse!==void 0&&(r.push(this.getDependency("bufferView",s.sparse.indices.bufferView)),r.push(this.getDependency("bufferView",s.sparse.values.bufferView))),Promise.all(r).then(function(i){const a=i[0],l=Zn[s.type],u=Dt[s.componentType],h=u.BYTES_PER_ELEMENT,d=h*l,y=s.byteOffset||0,g=s.bufferView!==void 0?n.bufferViews[s.bufferView].byteStride:void 0,x=s.normalized===!0;let w,v;if(g&&g!==d){const P=Math.floor(y/g),D="InterleavedBuffer:"+s.bufferView+":"+s.componentType+":"+P+":"+s.count;let S=t.cache.get(D);S||(w=new u(a,P*g,s.count*g/h),S=new c.InterleavedBuffer(w,g/h),t.cache.add(D,S)),v=new c.InterleavedBufferAttribute(S,l,y%g/h,x)}else a===null?w=new u(s.count*l):w=new u(a,y,s.count*l),v=new c.BufferAttribute(w,l,x);if(s.sparse!==void 0){const P=Zn.SCALAR,D=Dt[s.sparse.indices.componentType],S=s.sparse.indices.byteOffset||0,_=s.sparse.values.byteOffset||0,L=new D(i[1],S,s.sparse.count*P),b=new u(i[2],_,s.sparse.count*l);a!==null&&(v=new c.BufferAttribute(v.array.slice(),v.itemSize,v.normalized));for(let C=0,m=L.length;C<m;C++){const M=L[C];if(v.setX(M,b[C*l]),l>=2&&v.setY(M,b[C*l+1]),l>=3&&v.setZ(M,b[C*l+2]),l>=4&&v.setW(M,b[C*l+3]),l>=5)throw new Error("THREE.GLTFLoader: Unsupported itemSize in sparse BufferAttribute.")}}return v})}loadTexture(e){const t=this.json,n=this.options,r=t.textures[e].source,i=t.images[r];let a=this.textureLoader;if(i.uri){const l=n.manager.getHandler(i.uri);l!==null&&(a=l)}return this.loadTextureImage(e,r,a)}loadTextureImage(e,t,n){const s=this,r=this.json,i=r.textures[e],a=r.images[t],l=(a.uri||a.bufferView)+":"+i.sampler;if(this.textureCache[l])return this.textureCache[l];const u=this.loadImageSource(t,n).then(function(h){h.flipY=!1,h.name=i.name||a.name||"",h.name===""&&typeof a.uri=="string"&&a.uri.startsWith("data:image/")===!1&&(h.name=a.uri);const y=(r.samplers||{})[i.sampler]||{};return h.magFilter=ar[y.magFilter]||c.LinearFilter,h.minFilter=ar[y.minFilter]||c.LinearMipmapLinearFilter,h.wrapS=lr[y.wrapS]||c.RepeatWrapping,h.wrapT=lr[y.wrapT]||c.RepeatWrapping,s.associations.set(h,{textures:e}),h}).catch(function(){return null});return this.textureCache[l]=u,u}loadImageSource(e,t){const n=this,s=this.json,r=this.options;if(this.sourceCache[e]!==void 0)return this.sourceCache[e].then(d=>d.clone());const i=s.images[e],a=self.URL||self.webkitURL;let l=i.uri||"",u=!1;if(i.bufferView!==void 0)l=n.getDependency("bufferView",i.bufferView).then(function(d){u=!0;const y=new Blob([d],{type:i.mimeType});return l=a.createObjectURL(y),l});else if(i.uri===void 0)throw new Error("THREE.GLTFLoader: Image "+e+" is missing URI and bufferView");const h=Promise.resolve(l).then(function(d){return new Promise(function(y,g){let x=y;t.isImageBitmapLoader===!0&&(x=function(w){const v=new c.Texture(w);v.needsUpdate=!0,y(v)}),t.load(c.LoaderUtils.resolveURL(d,r.path),x,void 0,g)})}).then(function(d){return u===!0&&a.revokeObjectURL(l),d.userData.mimeType=i.mimeType||_a(i.uri),d}).catch(function(d){throw console.error("THREE.GLTFLoader: Couldn't load texture",l),d});return this.sourceCache[e]=h,h}assignTexture(e,t,n,s){const r=this;return this.getDependency("texture",n.index).then(function(i){if(!i)return null;if(n.texCoord!==void 0&&n.texCoord>0&&(i=i.clone(),i.channel=n.texCoord),r.extensions[be.KHR_TEXTURE_TRANSFORM]){const a=n.extensions!==void 0?n.extensions[be.KHR_TEXTURE_TRANSFORM]:void 0;if(a){const l=r.associations.get(i);i=r.extensions[be.KHR_TEXTURE_TRANSFORM].extendTexture(i,a),r.associations.set(i,l)}}return s!==void 0&&("colorSpace"in i?i.colorSpace=s===3001?"srgb":"srgb-linear":i.encoding=s),e[t]=i,i})}assignFinalMaterial(e){const t=e.geometry;let n=e.material;const s=t.attributes.tangent===void 0,r=t.attributes.color!==void 0,i=t.attributes.normal===void 0;if(e.isPoints){const a="PointsMaterial:"+n.uuid;let l=this.cache.get(a);l||(l=new c.PointsMaterial,c.Material.prototype.copy.call(l,n),l.color.copy(n.color),l.map=n.map,l.sizeAttenuation=!1,this.cache.add(a,l)),n=l}else if(e.isLine){const a="LineBasicMaterial:"+n.uuid;let l=this.cache.get(a);l||(l=new c.LineBasicMaterial,c.Material.prototype.copy.call(l,n),l.color.copy(n.color),l.map=n.map,this.cache.add(a,l)),n=l}if(s||r||i){let a="ClonedMaterial:"+n.uuid+":";s&&(a+="derivative-tangents:"),r&&(a+="vertex-colors:"),i&&(a+="flat-shading:");let l=this.cache.get(a);l||(l=n.clone(),r&&(l.vertexColors=!0),i&&(l.flatShading=!0),s&&(l.normalScale&&(l.normalScale.y*=-1),l.clearcoatNormalScale&&(l.clearcoatNormalScale.y*=-1)),this.cache.add(a,l),this.associations.set(l,this.associations.get(n))),n=l}e.material=n}getMaterialType(){return c.MeshStandardMaterial}loadMaterial(e){const t=this,n=this.json,s=this.extensions,r=n.materials[e];let i;const a={},l=r.extensions||{},u=[];if(l[be.KHR_MATERIALS_UNLIT]){const d=s[be.KHR_MATERIALS_UNLIT];i=d.getMaterialType(),u.push(d.extendParams(a,r,t))}else{const d=r.pbrMetallicRoughness||{};if(a.color=new c.Color(1,1,1),a.opacity=1,Array.isArray(d.baseColorFactor)){const y=d.baseColorFactor;a.color.fromArray(y),a.opacity=y[3]}d.baseColorTexture!==void 0&&u.push(t.assignTexture(a,"map",d.baseColorTexture,3001)),a.metalness=d.metallicFactor!==void 0?d.metallicFactor:1,a.roughness=d.roughnessFactor!==void 0?d.roughnessFactor:1,d.metallicRoughnessTexture!==void 0&&(u.push(t.assignTexture(a,"metalnessMap",d.metallicRoughnessTexture)),u.push(t.assignTexture(a,"roughnessMap",d.metallicRoughnessTexture))),i=this._invokeOne(function(y){return y.getMaterialType&&y.getMaterialType(e)}),u.push(Promise.all(this._invokeAll(function(y){return y.extendMaterialParams&&y.extendMaterialParams(e,a)})))}r.doubleSided===!0&&(a.side=c.DoubleSide);const h=r.alphaMode||qn.OPAQUE;if(h===qn.BLEND?(a.transparent=!0,a.depthWrite=!1):(a.transparent=!1,h===qn.MASK&&(a.alphaTest=r.alphaCutoff!==void 0?r.alphaCutoff:.5)),r.normalTexture!==void 0&&i!==c.MeshBasicMaterial&&(u.push(t.assignTexture(a,"normalMap",r.normalTexture)),a.normalScale=new c.Vector2(1,1),r.normalTexture.scale!==void 0)){const d=r.normalTexture.scale;a.normalScale.set(d,d)}return r.occlusionTexture!==void 0&&i!==c.MeshBasicMaterial&&(u.push(t.assignTexture(a,"aoMap",r.occlusionTexture)),r.occlusionTexture.strength!==void 0&&(a.aoMapIntensity=r.occlusionTexture.strength)),r.emissiveFactor!==void 0&&i!==c.MeshBasicMaterial&&(a.emissive=new c.Color().fromArray(r.emissiveFactor)),r.emissiveTexture!==void 0&&i!==c.MeshBasicMaterial&&u.push(t.assignTexture(a,"emissiveMap",r.emissiveTexture,3001)),Promise.all(u).then(function(){const d=new i(a);return r.name&&(d.name=r.name),pt(d,r),t.associations.set(d,{materials:e}),r.extensions&&wt(s,d,r),d})}createUniqueName(e){const t=c.PropertyBinding.sanitizeNodeName(e||"");return t in this.nodeNamesUsed?t+"_"+ ++this.nodeNamesUsed[t]:(this.nodeNamesUsed[t]=0,t)}loadGeometries(e){const t=this,n=this.extensions,s=this.primitiveCache;function r(a){return n[be.KHR_DRACO_MESH_COMPRESSION].decodePrimitive(a,t).then(function(l){return cr(l,a,t)})}const i=[];for(let a=0,l=e.length;a<l;a++){const u=e[a],h=ya(u),d=s[h];if(d)i.push(d.promise);else{let y;u.extensions&&u.extensions[be.KHR_DRACO_MESH_COMPRESSION]?y=r(u):y=cr(new c.BufferGeometry,u,t),s[h]={primitive:u,promise:y},i.push(y)}}return Promise.all(i)}loadMesh(e){const t=this,n=this.json,s=this.extensions,r=n.meshes[e],i=r.primitives,a=[];for(let l=0,u=i.length;l<u;l++){const h=i[l].material===void 0?pa(this.cache):this.getDependency("material",i[l].material);a.push(h)}return a.push(t.loadGeometries(i)),Promise.all(a).then(function(l){const u=l.slice(0,l.length-1),h=l[l.length-1],d=[];for(let g=0,x=h.length;g<x;g++){const w=h[g],v=i[g];let P;const D=u[g];if(v.mode===We.TRIANGLES||v.mode===We.TRIANGLE_STRIP||v.mode===We.TRIANGLE_FAN||v.mode===void 0)P=r.isSkinnedMesh===!0?new c.SkinnedMesh(w,D):new c.Mesh(w,D),P.isSkinnedMesh===!0&&P.normalizeSkinWeights(),v.mode===We.TRIANGLE_STRIP?P.geometry=zs(P.geometry,c.TriangleStripDrawMode):v.mode===We.TRIANGLE_FAN&&(P.geometry=zs(P.geometry,c.TriangleFanDrawMode));else if(v.mode===We.LINES)P=new c.LineSegments(w,D);else if(v.mode===We.LINE_STRIP)P=new c.Line(w,D);else if(v.mode===We.LINE_LOOP)P=new c.LineLoop(w,D);else if(v.mode===We.POINTS)P=new c.Points(w,D);else throw new Error("THREE.GLTFLoader: Primitive mode unsupported: "+v.mode);Object.keys(P.geometry.morphAttributes).length>0&&ga(P,r),P.name=t.createUniqueName(r.name||"mesh_"+e),pt(P,r),v.extensions&&wt(s,P,v),t.assignFinalMaterial(P),d.push(P)}for(let g=0,x=d.length;g<x;g++)t.associations.set(d[g],{meshes:e,primitives:g});if(d.length===1)return r.extensions&&wt(s,d[0],r),d[0];const y=new c.Group;r.extensions&&wt(s,y,r),t.associations.set(y,{meshes:e});for(let g=0,x=d.length;g<x;g++)y.add(d[g]);return y})}loadCamera(e){let t;const n=this.json.cameras[e],s=n[n.type];if(!s){console.warn("THREE.GLTFLoader: Missing camera parameters.");return}return n.type==="perspective"?t=new c.PerspectiveCamera(c.MathUtils.radToDeg(s.yfov),s.aspectRatio||1,s.znear||1,s.zfar||2e6):n.type==="orthographic"&&(t=new c.OrthographicCamera(-s.xmag,s.xmag,s.ymag,-s.ymag,s.znear,s.zfar)),n.name&&(t.name=this.createUniqueName(n.name)),pt(t,n),Promise.resolve(t)}loadSkin(e){const t=this.json.skins[e],n=[];for(let s=0,r=t.joints.length;s<r;s++)n.push(this._loadNodeShallow(t.joints[s]));return t.inverseBindMatrices!==void 0?n.push(this.getDependency("accessor",t.inverseBindMatrices)):n.push(null),Promise.all(n).then(function(s){const r=s.pop(),i=s,a=[],l=[];for(let u=0,h=i.length;u<h;u++){const d=i[u];if(d){a.push(d);const y=new c.Matrix4;r!==null&&y.fromArray(r.array,u*16),l.push(y)}else console.warn('THREE.GLTFLoader: Joint "%s" could not be found.',t.joints[u])}return new c.Skeleton(a,l)})}loadAnimation(e){const n=this.json.animations[e],s=n.name?n.name:"animation_"+e,r=[],i=[],a=[],l=[],u=[];for(let h=0,d=n.channels.length;h<d;h++){const y=n.channels[h],g=n.samplers[y.sampler],x=y.target,w=x.node,v=n.parameters!==void 0?n.parameters[g.input]:g.input,P=n.parameters!==void 0?n.parameters[g.output]:g.output;x.node!==void 0&&(r.push(this.getDependency("node",w)),i.push(this.getDependency("accessor",v)),a.push(this.getDependency("accessor",P)),l.push(g),u.push(x))}return Promise.all([Promise.all(r),Promise.all(i),Promise.all(a),Promise.all(l),Promise.all(u)]).then(function(h){const d=h[0],y=h[1],g=h[2],x=h[3],w=h[4],v=[];for(let P=0,D=d.length;P<D;P++){const S=d[P],_=y[P],L=g[P],b=x[P],C=w[P];if(S===void 0)continue;S.updateMatrix();let m;switch(dt[C.path]){case dt.weights:m=c.NumberKeyframeTrack;break;case dt.rotation:m=c.QuaternionKeyframeTrack;break;case dt.position:case dt.scale:default:m=c.VectorKeyframeTrack;break}const M=S.name?S.name:S.uuid,p=b.interpolation!==void 0?da[b.interpolation]:c.InterpolateLinear,I=[];dt[C.path]===dt.weights?S.traverse(function(J){J.morphTargetInfluences&&I.push(J.name?J.name:J.uuid)}):I.push(M);let F=L.array;if(L.normalized){const J=Jn(F.constructor),G=new Float32Array(F.length);for(let Q=0,K=F.length;Q<K;Q++)G[Q]=F[Q]*J;F=G}for(let J=0,G=I.length;J<G;J++){const Q=new m(I[J]+"."+dt[C.path],_.array,F,p);b.interpolation==="CUBICSPLINE"&&(Q.createInterpolant=function(Z){const X=this instanceof c.QuaternionKeyframeTrack?fa:or;return new X(this.times,this.values,this.getValueSize()/3,Z)},Q.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline=!0),v.push(Q)}}return new c.AnimationClip(s,void 0,v)})}createNodeMesh(e){const t=this.json,n=this,s=t.nodes[e];return s.mesh===void 0?null:n.getDependency("mesh",s.mesh).then(function(r){const i=n._getNodeRef(n.meshCache,s.mesh,r);return s.weights!==void 0&&i.traverse(function(a){if(a.isMesh)for(let l=0,u=s.weights.length;l<u;l++)a.morphTargetInfluences[l]=s.weights[l]}),i})}loadNode(e){const t=this.json,n=this,s=t.nodes[e],r=n._loadNodeShallow(e),i=[],a=s.children||[];for(let u=0,h=a.length;u<h;u++)i.push(n.getDependency("node",a[u]));const l=s.skin===void 0?Promise.resolve(null):n.getDependency("skin",s.skin);return Promise.all([r,Promise.all(i),l]).then(function(u){const h=u[0],d=u[1],y=u[2];y!==null&&h.traverse(function(g){g.isSkinnedMesh&&g.bind(y,va)});for(let g=0,x=d.length;g<x;g++)h.add(d[g]);return h})}_loadNodeShallow(e){const t=this.json,n=this.extensions,s=this;if(this.nodeCache[e]!==void 0)return this.nodeCache[e];const r=t.nodes[e],i=r.name?s.createUniqueName(r.name):"",a=[],l=s._invokeOne(function(u){return u.createNodeMesh&&u.createNodeMesh(e)});return l&&a.push(l),r.camera!==void 0&&a.push(s.getDependency("camera",r.camera).then(function(u){return s._getNodeRef(s.cameraCache,r.camera,u)})),s._invokeAll(function(u){return u.createNodeAttachment&&u.createNodeAttachment(e)}).forEach(function(u){a.push(u)}),this.nodeCache[e]=Promise.all(a).then(function(u){let h;if(r.isBone===!0?h=new c.Bone:u.length>1?h=new c.Group:u.length===1?h=u[0]:h=new c.Object3D,h!==u[0])for(let d=0,y=u.length;d<y;d++)h.add(u[d]);if(r.name&&(h.userData.name=r.name,h.name=i),pt(h,r),r.extensions&&wt(n,h,r),r.matrix!==void 0){const d=new c.Matrix4;d.fromArray(r.matrix),h.applyMatrix4(d)}else r.translation!==void 0&&h.position.fromArray(r.translation),r.rotation!==void 0&&h.quaternion.fromArray(r.rotation),r.scale!==void 0&&h.scale.fromArray(r.scale);return s.associations.has(h)||s.associations.set(h,{}),s.associations.get(h).nodes=e,h}),this.nodeCache[e]}loadScene(e){const t=this.extensions,n=this.json.scenes[e],s=this,r=new c.Group;n.name&&(r.name=s.createUniqueName(n.name)),pt(r,n),n.extensions&&wt(t,r,n);const i=n.nodes||[],a=[];for(let l=0,u=i.length;l<u;l++)a.push(s.getDependency("node",i[l]));return Promise.all(a).then(function(l){for(let h=0,d=l.length;h<d;h++)r.add(l[h]);const u=h=>{const d=new Map;for(const[y,g]of s.associations)(y instanceof c.Material||y instanceof c.Texture)&&d.set(y,g);return h.traverse(y=>{const g=s.associations.get(y);g!=null&&d.set(y,g)}),d};return s.associations=u(r),r})}}function wa(o,e,t){const n=e.attributes,s=new c.Box3;if(n.POSITION!==void 0){const a=t.json.accessors[n.POSITION],l=a.min,u=a.max;if(l!==void 0&&u!==void 0){if(s.set(new c.Vector3(l[0],l[1],l[2]),new c.Vector3(u[0],u[1],u[2])),a.normalized){const h=Jn(Dt[a.componentType]);s.min.multiplyScalar(h),s.max.multiplyScalar(h)}}else{console.warn("THREE.GLTFLoader: Missing min/max properties for accessor POSITION.");return}}else return;const r=e.targets;if(r!==void 0){const a=new c.Vector3,l=new c.Vector3;for(let u=0,h=r.length;u<h;u++){const d=r[u];if(d.POSITION!==void 0){const y=t.json.accessors[d.POSITION],g=y.min,x=y.max;if(g!==void 0&&x!==void 0){if(l.setX(Math.max(Math.abs(g[0]),Math.abs(x[0]))),l.setY(Math.max(Math.abs(g[1]),Math.abs(x[1]))),l.setZ(Math.max(Math.abs(g[2]),Math.abs(x[2]))),y.normalized){const w=Jn(Dt[y.componentType]);l.multiplyScalar(w)}a.max(l)}else console.warn("THREE.GLTFLoader: Missing min/max properties for accessor POSITION.")}}s.expandByVector(a)}o.boundingBox=s;const i=new c.Sphere;s.getCenter(i.center),i.radius=s.min.distanceTo(s.max)/2,o.boundingSphere=i}function cr(o,e,t){const n=e.attributes,s=[];function r(i,a){return t.getDependency("accessor",i).then(function(l){o.setAttribute(a,l)})}for(const i in n){const a=Kn[i]||i.toLowerCase();a in o.attributes||s.push(r(n[i],a))}if(e.indices!==void 0&&!o.index){const i=t.getDependency("accessor",e.indices).then(function(a){o.setIndex(a)});s.push(i)}return pt(o,e),wa(o,e,t),Promise.all(s).then(function(){return e.targets!==void 0?ma(o,e.targets,t):o})}class ur extends c.ExtrudeGeometry{constructor(e,t={}){const{bevelEnabled:n=!1,bevelSize:s=8,bevelThickness:r=10,font:i,height:a=50,size:l=100,lineHeight:u=1,letterSpacing:h=0,...d}=t;if(i===void 0)super();else{const y=i.generateShapes(e,l,{lineHeight:u,letterSpacing:h});super(y,{...d,bevelEnabled:n,bevelSize:s,bevelThickness:r,depth:a})}this.type="TextGeometry"}}const ba={uniforms:{tDiffuse:{value:null},h:{value:1/512}},vertexShader:`
+      `})),Lt.uniforms.blitTexture.value=o,Lt.defines.IS_SRGB="colorSpace"in o?o.colorSpace==="srgb":o.encoding===3001,Lt.needsUpdate=!0,mn||(mn=new l.Mesh(Vn,Lt),mn.frustrumCulled=!1);const n=new l.PerspectiveCamera,r=new l.Scene;r.add(mn),t||(t=pn=new l.WebGLRenderer({antialias:!1})),t.setSize(Math.min(o.image.width,e),Math.min(o.image.height,e)),t.clear(),t.render(r,n);const i=new l.Texture(t.domElement);return i.minFilter=o.minFilter,i.magFilter=o.magFilter,i.wrapS=o.wrapS,i.wrapT=o.wrapT,i.name=o.name,pn&&(pn.dispose(),pn=null),i}const Wr={POSITION:["byte","byte normalized","unsigned byte","unsigned byte normalized","short","short normalized","unsigned short","unsigned short normalized"],NORMAL:["byte normalized","short normalized"],TANGENT:["byte normalized","short normalized"],TEXCOORD:["byte","byte normalized","unsigned byte","short","short normalized","unsigned short"]};class Gn{constructor(){this.pluginCallbacks=[],this.register(function(e){return new oo(e)}),this.register(function(e){return new ao(e)}),this.register(function(e){return new uo(e)}),this.register(function(e){return new ho(e)}),this.register(function(e){return new fo(e)}),this.register(function(e){return new po(e)}),this.register(function(e){return new lo(e)}),this.register(function(e){return new co(e)}),this.register(function(e){return new mo(e)}),this.register(function(e){return new go(e)}),this.register(function(e){return new yo(e)})}register(e){return this.pluginCallbacks.indexOf(e)===-1&&this.pluginCallbacks.push(e),this}unregister(e){return this.pluginCallbacks.indexOf(e)!==-1&&this.pluginCallbacks.splice(this.pluginCallbacks.indexOf(e),1),this}parse(e,t,n,r){const i=new so,s=[];for(let a=0,c=this.pluginCallbacks.length;a<c;a++)s.push(this.pluginCallbacks[a](i));i.setPlugins(s),i.write(e,t,r).catch(n)}parseAsync(e,t){const n=this;return new Promise(function(r,i){n.parse(e,r,i,t)})}}Qs(Gn,"Utils",{insertKeyframe:function(o,e){const n=o.getValueSize(),r=new o.TimeBufferType(o.times.length+1),i=new o.ValueBufferType(o.values.length+n),s=o.createInterpolant(new o.ValueBufferType(n));let a;if(o.times.length===0){r[0]=e;for(let c=0;c<n;c++)i[c]=0;a=0}else if(e<o.times[0]){if(Math.abs(o.times[0]-e)<.001)return 0;r[0]=e,r.set(o.times,1),i.set(s.evaluate(e),0),i.set(o.values,n),a=0}else if(e>o.times[o.times.length-1]){if(Math.abs(o.times[o.times.length-1]-e)<.001)return o.times.length-1;r[r.length-1]=e,r.set(o.times,0),i.set(o.values,0),i.set(s.evaluate(e),o.values.length),a=r.length-1}else for(let c=0;c<o.times.length;c++){if(Math.abs(o.times[c]-e)<.001)return c;if(o.times[c]<e&&o.times[c+1]>e){r.set(o.times.slice(0,c+1),0),r[c+1]=e,r.set(o.times.slice(c+1),c+2),i.set(o.values.slice(0,(c+1)*n),0),i.set(s.evaluate(e),(c+1)*n),i.set(o.values.slice((c+1)*n),(c+2)*n),a=c+1;break}}return o.times=r,o.values=i,a},mergeMorphTargetTracks:function(o,e){const t=[],n={},r=o.tracks;for(let i=0;i<r.length;++i){let s=r[i];const a=l.PropertyBinding.parseTrackName(s.name),c=l.PropertyBinding.findNode(e,a.nodeName);if(a.propertyName!=="morphTargetInfluences"||a.propertyIndex===void 0){t.push(s);continue}if(s.createInterpolant!==s.InterpolantFactoryMethodDiscrete&&s.createInterpolant!==s.InterpolantFactoryMethodLinear){if(s.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline)throw new Error("THREE.GLTFExporter: Cannot merge tracks with glTF CUBICSPLINE interpolation.");console.warn("THREE.GLTFExporter: Morph target interpolation mode not yet supported. Using LINEAR instead."),s=s.clone(),s.setInterpolation(l.InterpolateLinear)}const h=c.morphTargetInfluences.length,f=c.morphTargetDictionary[a.propertyIndex];if(f===void 0)throw new Error("THREE.GLTFExporter: Morph target name not found: "+a.propertyIndex);let d;if(n[c.uuid]===void 0){d=s.clone();const m=new d.ValueBufferType(h*d.times.length);for(let x=0;x<d.times.length;x++)m[x*h+f]=d.values[x];d.name=(a.nodeName||"")+".morphTargetInfluences",d.values=m,n[c.uuid]=d,t.push(d);continue}const p=s.createInterpolant(new s.ValueBufferType(1));d=n[c.uuid];for(let m=0;m<d.times.length;m++)d.values[m*h+f]=p.evaluate(d.times[m]);for(let m=0;m<s.times.length;m++){const x=this.insertKeyframe(d,s.times[m]);d.values[x*h+f]=s.values[m]}}return o.tracks=t,o}});const xe={POINTS:0,LINES:1,LINE_LOOP:2,LINE_STRIP:3,TRIANGLES:4,TRIANGLE_STRIP:5,TRIANGLE_FAN:6,BYTE:5120,UNSIGNED_BYTE:5121,SHORT:5122,UNSIGNED_SHORT:5123,INT:5124,UNSIGNED_INT:5125,FLOAT:5126,ARRAY_BUFFER:34962,ELEMENT_ARRAY_BUFFER:34963,NEAREST:9728,LINEAR:9729,NEAREST_MIPMAP_NEAREST:9984,LINEAR_MIPMAP_NEAREST:9985,NEAREST_MIPMAP_LINEAR:9986,LINEAR_MIPMAP_LINEAR:9987,CLAMP_TO_EDGE:33071,MIRRORED_REPEAT:33648,REPEAT:10497},jn="KHR_mesh_quantization",Ee={};Ee[l.NearestFilter]=xe.NEAREST,Ee[l.NearestMipmapNearestFilter]=xe.NEAREST_MIPMAP_NEAREST,Ee[l.NearestMipmapLinearFilter]=xe.NEAREST_MIPMAP_LINEAR,Ee[l.LinearFilter]=xe.LINEAR,Ee[l.LinearMipmapNearestFilter]=xe.LINEAR_MIPMAP_NEAREST,Ee[l.LinearMipmapLinearFilter]=xe.LINEAR_MIPMAP_LINEAR,Ee[l.ClampToEdgeWrapping]=xe.CLAMP_TO_EDGE,Ee[l.RepeatWrapping]=xe.REPEAT,Ee[l.MirroredRepeatWrapping]=xe.MIRRORED_REPEAT;const Yr={scale:"scale",position:"translation",quaternion:"rotation",morphTargetInfluences:"weights"},Js=new l.Color,Xr=12,Hs=1179937895,$s=2,Zr=8,eo=1313821514,to=5130562;function Wt(o,e){return o.length===e.length&&o.every(function(t,n){return t===e[n]})}function no(o){return new TextEncoder().encode(o).buffer}function ro(o){return Wt(o.elements,[1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1])}function io(o,e,t){const n={min:new Array(o.itemSize).fill(Number.POSITIVE_INFINITY),max:new Array(o.itemSize).fill(Number.NEGATIVE_INFINITY)};for(let r=e;r<e+t;r++)for(let i=0;i<o.itemSize;i++){let s;o.itemSize>4?s=o.array[r*o.itemSize+i]:(i===0?s=o.getX(r):i===1?s=o.getY(r):i===2?s=o.getZ(r):i===3&&(s=o.getW(r)),o.normalized===!0&&(s=l.MathUtils.normalize(s,o.array))),n.min[i]=Math.min(n.min[i],s),n.max[i]=Math.max(n.max[i],s)}return n}function Kr(o){return Math.ceil(o/4)*4}function En(o,e=0){const t=Kr(o.byteLength);if(t!==o.byteLength){const n=new Uint8Array(t);if(n.set(new Uint8Array(o)),e!==0)for(let r=o.byteLength;r<t;r++)n[r]=e;return n.buffer}return o}function qr(){return typeof document>"u"&&typeof OffscreenCanvas<"u"?new OffscreenCanvas(1,1):document.createElement("canvas")}function Qr(o,e){if(o.toBlob!==void 0)return new Promise(n=>o.toBlob(n,e));let t;return e==="image/jpeg"?t=.92:e==="image/webp"&&(t=.8),o.convertToBlob({type:e,quality:t})}class so{constructor(){this.plugins=[],this.options={},this.pending=[],this.buffers=[],this.byteOffset=0,this.buffers=[],this.nodeMap=new Map,this.skins=[],this.extensionsUsed={},this.extensionsRequired={},this.uids=new Map,this.uid=0,this.json={asset:{version:"2.0",generator:"THREE.GLTFExporter"}},this.cache={meshes:new Map,attributes:new Map,attributesNormalized:new Map,materials:new Map,textures:new Map,images:new Map}}setPlugins(e){this.plugins=e}async write(e,t,n={}){this.options=Object.assign({binary:!1,trs:!1,onlyVisible:!0,maxTextureSize:1/0,animations:[],includeCustomExtensions:!1},n),this.options.animations.length>0&&(this.options.trs=!0),this.processInput(e),await Promise.all(this.pending);const r=this,i=r.buffers,s=r.json;n=r.options;const a=r.extensionsUsed,c=r.extensionsRequired,h=new Blob(i,{type:"application/octet-stream"}),f=Object.keys(a),d=Object.keys(c);f.length>0&&(s.extensionsUsed=f),d.length>0&&(s.extensionsRequired=d),s.buffers&&s.buffers.length>0&&(s.buffers[0].byteLength=h.size),n.binary===!0?h.arrayBuffer().then(p=>{const m=En(p),x=new DataView(new ArrayBuffer(Zr));x.setUint32(0,m.byteLength,!0),x.setUint32(4,to,!0);const b=En(no(JSON.stringify(s)),32),v=new DataView(new ArrayBuffer(Zr));v.setUint32(0,b.byteLength,!0),v.setUint32(4,eo,!0);const _=new ArrayBuffer(Xr),T=new DataView(_);T.setUint32(0,Hs,!0),T.setUint32(4,$s,!0);const w=Xr+v.byteLength+b.byteLength+x.byteLength+m.byteLength;T.setUint32(8,w,!0),new Blob([_,v,b,x,m],{type:"application/octet-stream"}).arrayBuffer().then(t)}):s.buffers&&s.buffers.length>0?Er(h).then(p=>{s.buffers[0].uri=p,t(s)}):t(s)}serializeUserData(e,t){if(Object.keys(e.userData).length===0)return;const n=this.options,r=this.extensionsUsed;try{const i=JSON.parse(JSON.stringify(e.userData));if(n.includeCustomExtensions&&i.gltfExtensions){t.extensions===void 0&&(t.extensions={});for(const s in i.gltfExtensions)t.extensions[s]=i.gltfExtensions[s],r[s]=!0;delete i.gltfExtensions}Object.keys(i).length>0&&(t.extras=i)}catch(i){console.warn("THREE.GLTFExporter: userData of '"+e.name+"' won't be serialized because of JSON.stringify error - "+i.message)}}getUID(e,t=!1){if(this.uids.has(e)===!1){const r=new Map;r.set(!0,this.uid++),r.set(!1,this.uid++),this.uids.set(e,r)}return this.uids.get(e).get(t)}isNormalizedNormalAttribute(e){if(this.cache.attributesNormalized.has(e))return!1;const n=new l.Vector3;for(let r=0,i=e.count;r<i;r++)if(Math.abs(n.fromBufferAttribute(e,r).length()-1)>5e-4)return!1;return!0}createNormalizedNormalAttribute(e){const t=this.cache;if(t.attributesNormalized.has(e))return t.attributesNormalized.get(e);const n=e.clone(),r=new l.Vector3;for(let i=0,s=n.count;i<s;i++)r.fromBufferAttribute(n,i),r.x===0&&r.y===0&&r.z===0?r.setX(1):r.normalize(),n.setXYZ(i,r.x,r.y,r.z);return t.attributesNormalized.set(e,n),n}applyTextureTransform(e,t){let n=!1;const r={};(t.offset.x!==0||t.offset.y!==0)&&(r.offset=t.offset.toArray(),n=!0),t.rotation!==0&&(r.rotation=t.rotation,n=!0),(t.repeat.x!==1||t.repeat.y!==1)&&(r.scale=t.repeat.toArray(),n=!0),n&&(e.extensions=e.extensions||{},e.extensions.KHR_texture_transform=r,this.extensionsUsed.KHR_texture_transform=!0)}buildMetalRoughTexture(e,t){if(e===t)return e;function n(m){return("colorSpace"in m?m.colorSpace==="srgb":m.encoding===3001)?function(b){return b<.04045?b*.0773993808:Math.pow(b*.9478672986+.0521327014,2.4)}:function(b){return b}}console.warn("THREE.GLTFExporter: Merged metalnessMap and roughnessMap textures."),e instanceof l.CompressedTexture&&(e=Rn(e)),t instanceof l.CompressedTexture&&(t=Rn(t));const r=e?e.image:null,i=t?t.image:null,s=Math.max(r?r.width:0,i?i.width:0),a=Math.max(r?r.height:0,i?i.height:0),c=qr();c.width=s,c.height=a;const h=c.getContext("2d");h.fillStyle="#00ffff",h.fillRect(0,0,s,a);const f=h.getImageData(0,0,s,a);if(r){h.drawImage(r,0,0,s,a);const m=n(e),x=h.getImageData(0,0,s,a).data;for(let b=2;b<x.length;b+=4)f.data[b]=m(x[b]/256)*256}if(i){h.drawImage(i,0,0,s,a);const m=n(t),x=h.getImageData(0,0,s,a).data;for(let b=1;b<x.length;b+=4)f.data[b]=m(x[b]/256)*256}h.putImageData(f,0,0);const p=(e||t).clone();return p.source=new l.Texture(c).source,"colorSpace"in p?p.colorSpace="":p.encoding=3e3,p.channel=(e||t).channel,e&&t&&e.channel!==t.channel&&console.warn("THREE.GLTFExporter: UV channels for metalnessMap and roughnessMap textures must match."),p}processBuffer(e){const t=this.json,n=this.buffers;return t.buffers||(t.buffers=[{byteLength:0}]),n.push(e),0}processBufferView(e,t,n,r,i){const s=this.json;s.bufferViews||(s.bufferViews=[]);let a;switch(t){case xe.BYTE:case xe.UNSIGNED_BYTE:a=1;break;case xe.SHORT:case xe.UNSIGNED_SHORT:a=2;break;default:a=4}const c=Kr(r*e.itemSize*a),h=new DataView(new ArrayBuffer(c));let f=0;for(let m=n;m<n+r;m++)for(let x=0;x<e.itemSize;x++){let b;e.itemSize>4?b=e.array[m*e.itemSize+x]:(x===0?b=e.getX(m):x===1?b=e.getY(m):x===2?b=e.getZ(m):x===3&&(b=e.getW(m)),e.normalized===!0&&(b=l.MathUtils.normalize(b,e.array))),t===xe.FLOAT?h.setFloat32(f,b,!0):t===xe.INT?h.setInt32(f,b,!0):t===xe.UNSIGNED_INT?h.setUint32(f,b,!0):t===xe.SHORT?h.setInt16(f,b,!0):t===xe.UNSIGNED_SHORT?h.setUint16(f,b,!0):t===xe.BYTE?h.setInt8(f,b):t===xe.UNSIGNED_BYTE&&h.setUint8(f,b),f+=a}const d={buffer:this.processBuffer(h.buffer),byteOffset:this.byteOffset,byteLength:c};return i!==void 0&&(d.target=i),i===xe.ARRAY_BUFFER&&(d.byteStride=e.itemSize*a),this.byteOffset+=c,s.bufferViews.push(d),{id:s.bufferViews.length-1,byteLength:0}}processBufferViewImage(e){const t=this,n=t.json;return n.bufferViews||(n.bufferViews=[]),e.arrayBuffer().then(r=>{const i=En(r),s={buffer:t.processBuffer(i),byteOffset:t.byteOffset,byteLength:i.byteLength};return t.byteOffset+=i.byteLength,n.bufferViews.push(s)-1})}processAccessor(e,t,n,r){const i=this.json,s={1:"SCALAR",2:"VEC2",3:"VEC3",4:"VEC4",9:"MAT3",16:"MAT4"};let a;if(e.array.constructor===Float32Array)a=xe.FLOAT;else if(e.array.constructor===Int32Array)a=xe.INT;else if(e.array.constructor===Uint32Array)a=xe.UNSIGNED_INT;else if(e.array.constructor===Int16Array)a=xe.SHORT;else if(e.array.constructor===Uint16Array)a=xe.UNSIGNED_SHORT;else if(e.array.constructor===Int8Array)a=xe.BYTE;else if(e.array.constructor===Uint8Array)a=xe.UNSIGNED_BYTE;else throw new Error("THREE.GLTFExporter: Unsupported bufferAttribute component type: "+e.array.constructor.name);if(n===void 0&&(n=0),r===void 0&&(r=e.count),r===0)return null;const c=io(e,n,r);let h;t!==void 0&&(h=e===t.index?xe.ELEMENT_ARRAY_BUFFER:xe.ARRAY_BUFFER);const f=this.processBufferView(e,a,n,r,h),d={bufferView:f.id,byteOffset:f.byteOffset,componentType:a,count:r,max:c.max,min:c.min,type:s[e.itemSize]};return e.normalized===!0&&(d.normalized=!0),i.accessors||(i.accessors=[]),i.accessors.push(d)-1}processImage(e,t,n,r="image/png"){if(e!==null){const i=this,s=i.cache,a=i.json,c=i.options,h=i.pending;s.images.has(e)||s.images.set(e,{});const f=s.images.get(e),d=r+":flipY/"+n.toString();if(f[d]!==void 0)return f[d];a.images||(a.images=[]);const p={mimeType:r},m=qr();m.width=Math.min(e.width,c.maxTextureSize),m.height=Math.min(e.height,c.maxTextureSize);const x=m.getContext("2d");if(n===!0&&(x.translate(0,m.height),x.scale(1,-1)),e.data!==void 0){t!==l.RGBAFormat&&console.error("GLTFExporter: Only RGBAFormat is supported.",t),(e.width>c.maxTextureSize||e.height>c.maxTextureSize)&&console.warn("GLTFExporter: Image size is bigger than maxTextureSize",e);const v=new Uint8ClampedArray(e.height*e.width*4);for(let _=0;_<v.length;_+=4)v[_+0]=e.data[_+0],v[_+1]=e.data[_+1],v[_+2]=e.data[_+2],v[_+3]=e.data[_+3];x.putImageData(new ImageData(v,e.width,e.height),0,0)}else x.drawImage(e,0,0,m.width,m.height);c.binary===!0?h.push(Qr(m,r).then(v=>i.processBufferViewImage(v)).then(v=>{p.bufferView=v})):m.toDataURL!==void 0?p.uri=m.toDataURL(r):h.push(Qr(m,r).then(Er).then(v=>{p.uri=v}));const b=a.images.push(p)-1;return f[d]=b,b}else throw new Error("THREE.GLTFExporter: No valid image data found. Unable to process texture.")}processSampler(e){const t=this.json;t.samplers||(t.samplers=[]);const n={magFilter:Ee[e.magFilter],minFilter:Ee[e.minFilter],wrapS:Ee[e.wrapS],wrapT:Ee[e.wrapT]};return t.samplers.push(n)-1}processTexture(e){const n=this.options,r=this.cache,i=this.json;if(r.textures.has(e))return r.textures.get(e);i.textures||(i.textures=[]),e instanceof l.CompressedTexture&&(e=Rn(e,n.maxTextureSize));let s=e.userData.mimeType;s==="image/webp"&&(s="image/png");const a={sampler:this.processSampler(e),source:this.processImage(e.image,e.format,e.flipY,s)};e.name&&(a.name=e.name),this._invokeAll(function(h){h.writeTexture&&h.writeTexture(e,a)});const c=i.textures.push(a)-1;return r.textures.set(e,c),c}processMaterial(e){const t=this.cache,n=this.json;if(t.materials.has(e))return t.materials.get(e);if(e.isShaderMaterial)return console.warn("GLTFExporter: THREE.ShaderMaterial not supported."),null;n.materials||(n.materials=[]);const r={pbrMetallicRoughness:{}};e.isMeshStandardMaterial!==!0&&e.isMeshBasicMaterial!==!0&&console.warn("GLTFExporter: Use MeshStandardMaterial or MeshBasicMaterial for best results.");const i=e.color.toArray().concat([e.opacity]);if(Wt(i,[1,1,1,1])||(r.pbrMetallicRoughness.baseColorFactor=i),e.isMeshStandardMaterial?(r.pbrMetallicRoughness.metallicFactor=e.metalness,r.pbrMetallicRoughness.roughnessFactor=e.roughness):(r.pbrMetallicRoughness.metallicFactor=.5,r.pbrMetallicRoughness.roughnessFactor=.5),e.metalnessMap||e.roughnessMap){const a=this.buildMetalRoughTexture(e.metalnessMap,e.roughnessMap),c={index:this.processTexture(a),channel:a.channel};this.applyTextureTransform(c,a),r.pbrMetallicRoughness.metallicRoughnessTexture=c}if(e.map){const a={index:this.processTexture(e.map),texCoord:e.map.channel};this.applyTextureTransform(a,e.map),r.pbrMetallicRoughness.baseColorTexture=a}if(e.emissive){const a=e.emissive;if(Math.max(a.r,a.g,a.b)>0&&(r.emissiveFactor=e.emissive.toArray()),e.emissiveMap){const h={index:this.processTexture(e.emissiveMap),texCoord:e.emissiveMap.channel};this.applyTextureTransform(h,e.emissiveMap),r.emissiveTexture=h}}if(e.normalMap){const a={index:this.processTexture(e.normalMap),texCoord:e.normalMap.channel};e.normalScale&&e.normalScale.x!==1&&(a.scale=e.normalScale.x),this.applyTextureTransform(a,e.normalMap),r.normalTexture=a}if(e.aoMap){const a={index:this.processTexture(e.aoMap),texCoord:e.aoMap.channel};e.aoMapIntensity!==1&&(a.strength=e.aoMapIntensity),this.applyTextureTransform(a,e.aoMap),r.occlusionTexture=a}e.transparent?r.alphaMode="BLEND":e.alphaTest>0&&(r.alphaMode="MASK",r.alphaCutoff=e.alphaTest),e.side===l.DoubleSide&&(r.doubleSided=!0),e.name!==""&&(r.name=e.name),this.serializeUserData(e,r),this._invokeAll(function(a){a.writeMaterial&&a.writeMaterial(e,r)});const s=n.materials.push(r)-1;return t.materials.set(e,s),s}processMesh(e){const t=this.cache,n=this.json,r=[e.geometry.uuid];if(Array.isArray(e.material))for(let w=0,M=e.material.length;w<M;w++)r.push(e.material[w].uuid);else r.push(e.material.uuid);const i=r.join(":");if(t.meshes.has(i))return t.meshes.get(i);const s=e.geometry;let a;e.isLineSegments?a=xe.LINES:e.isLineLoop?a=xe.LINE_LOOP:e.isLine?a=xe.LINE_STRIP:e.isPoints?a=xe.POINTS:a=e.material.wireframe?xe.LINES:xe.TRIANGLES;const c={},h={},f=[],d=[],p={...jr>=152?{uv:"TEXCOORD_0",uv1:"TEXCOORD_1",uv2:"TEXCOORD_2",uv3:"TEXCOORD_3"}:{uv:"TEXCOORD_0",uv2:"TEXCOORD_1"},color:"COLOR_0",skinWeight:"WEIGHTS_0",skinIndex:"JOINTS_0"},m=s.getAttribute("normal");m!==void 0&&!this.isNormalizedNormalAttribute(m)&&(console.warn("THREE.GLTFExporter: Creating normalized normal attribute from the non-normalized one."),s.setAttribute("normal",this.createNormalizedNormalAttribute(m)));let x=null;for(let w in s.attributes){if(w.slice(0,5)==="morph")continue;const M=s.attributes[w];if(w=p[w]||w.toUpperCase(),/^(POSITION|NORMAL|TANGENT|TEXCOORD_\d+|COLOR_\d+|JOINTS_\d+|WEIGHTS_\d+)$/.test(w)||(w="_"+w),t.attributes.has(this.getUID(M))){h[w]=t.attributes.get(this.getUID(M));continue}x=null;const S=M.array;w==="JOINTS_0"&&!(S instanceof Uint16Array)&&!(S instanceof Uint8Array)&&(console.warn('GLTFExporter: Attribute "skinIndex" converted to type UNSIGNED_SHORT.'),x=new l.BufferAttribute(new Uint16Array(S),M.itemSize,M.normalized));const C=this.processAccessor(x||M,s);C!==null&&(w.startsWith("_")||this.detectMeshQuantization(w,M),h[w]=C,t.attributes.set(this.getUID(M),C))}if(m!==void 0&&s.setAttribute("normal",m),Object.keys(h).length===0)return null;if(e.morphTargetInfluences!==void 0&&e.morphTargetInfluences.length>0){const w=[],M=[],D={};if(e.morphTargetDictionary!==void 0)for(const S in e.morphTargetDictionary)D[e.morphTargetDictionary[S]]=S;for(let S=0;S<e.morphTargetInfluences.length;++S){const C={};let y=!1;for(const A in s.morphAttributes){if(A!=="position"&&A!=="normal"){y||(console.warn("GLTFExporter: Only POSITION and NORMAL morph are supported."),y=!0);continue}const g=s.morphAttributes[A][S],I=A.toUpperCase(),k=s.attributes[A];if(t.attributes.has(this.getUID(g,!0))){C[I]=t.attributes.get(this.getUID(g,!0));continue}const J=g.clone();if(!s.morphTargetsRelative)for(let G=0,Z=g.count;G<Z;G++)for(let X=0;X<g.itemSize;X++)X===0&&J.setX(G,g.getX(G)-k.getX(G)),X===1&&J.setY(G,g.getY(G)-k.getY(G)),X===2&&J.setZ(G,g.getZ(G)-k.getZ(G)),X===3&&J.setW(G,g.getW(G)-k.getW(G));C[I]=this.processAccessor(J,s),t.attributes.set(this.getUID(k,!0),C[I])}d.push(C),w.push(e.morphTargetInfluences[S]),e.morphTargetDictionary!==void 0&&M.push(D[S])}c.weights=w,M.length>0&&(c.extras={},c.extras.targetNames=M)}const b=Array.isArray(e.material);if(b&&s.groups.length===0)return null;const v=b?e.material:[e.material],_=b?s.groups:[{materialIndex:0,start:void 0,count:void 0}];for(let w=0,M=_.length;w<M;w++){const D={mode:a,attributes:h};if(this.serializeUserData(s,D),d.length>0&&(D.targets=d),s.index!==null){let C=this.getUID(s.index);(_[w].start!==void 0||_[w].count!==void 0)&&(C+=":"+_[w].start+":"+_[w].count),t.attributes.has(C)?D.indices=t.attributes.get(C):(D.indices=this.processAccessor(s.index,s,_[w].start,_[w].count),t.attributes.set(C,D.indices)),D.indices===null&&delete D.indices}const S=this.processMaterial(v[_[w].materialIndex]);S!==null&&(D.material=S),f.push(D)}c.primitives=f,n.meshes||(n.meshes=[]),this._invokeAll(function(w){w.writeMesh&&w.writeMesh(e,c)});const T=n.meshes.push(c)-1;return t.meshes.set(i,T),T}detectMeshQuantization(e,t){if(this.extensionsUsed[jn])return;let n;switch(t.array.constructor){case Int8Array:n="byte";break;case Uint8Array:n="unsigned byte";break;case Int16Array:n="short";break;case Uint16Array:n="unsigned short";break;default:return}t.normalized&&(n+=" normalized");const r=e.split("_",1)[0];Wr[r]&&Wr[r].includes(n)&&(this.extensionsUsed[jn]=!0,this.extensionsRequired[jn]=!0)}processCamera(e){const t=this.json;t.cameras||(t.cameras=[]);const n=e.isOrthographicCamera,r={type:n?"orthographic":"perspective"};return n?r.orthographic={xmag:e.right*2,ymag:e.top*2,zfar:e.far<=0?.001:e.far,znear:e.near<0?0:e.near}:r.perspective={aspectRatio:e.aspect,yfov:l.MathUtils.degToRad(e.fov),zfar:e.far<=0?.001:e.far,znear:e.near<0?0:e.near},e.name!==""&&(r.name=e.type),t.cameras.push(r)-1}processAnimation(e,t){const n=this.json,r=this.nodeMap;n.animations||(n.animations=[]),e=Gn.Utils.mergeMorphTargetTracks(e.clone(),t);const i=e.tracks,s=[],a=[];for(let c=0;c<i.length;++c){const h=i[c],f=l.PropertyBinding.parseTrackName(h.name);let d=l.PropertyBinding.findNode(t,f.nodeName);const p=Yr[f.propertyName];if(f.objectName==="bones"&&(d.isSkinnedMesh===!0?d=d.skeleton.getBoneByName(f.objectIndex):d=void 0),!d||!p)return console.warn('THREE.GLTFExporter: Could not export animation track "%s".',h.name),null;const m=1;let x=h.values.length/h.times.length;p===Yr.morphTargetInfluences&&(x/=d.morphTargetInfluences.length);let b;h.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline===!0?(b="CUBICSPLINE",x/=3):h.getInterpolation()===l.InterpolateDiscrete?b="STEP":b="LINEAR",a.push({input:this.processAccessor(new l.BufferAttribute(h.times,m)),output:this.processAccessor(new l.BufferAttribute(h.values,x)),interpolation:b}),s.push({sampler:a.length-1,target:{node:r.get(d),path:p}})}return n.animations.push({name:e.name||"clip_"+n.animations.length,samplers:a,channels:s}),n.animations.length-1}processSkin(e){const t=this.json,n=this.nodeMap,r=t.nodes[n.get(e)],i=e.skeleton;if(i===void 0)return null;const s=e.skeleton.bones[0];if(s===void 0)return null;const a=[],c=new Float32Array(i.bones.length*16),h=new l.Matrix4;for(let d=0;d<i.bones.length;++d)a.push(n.get(i.bones[d])),h.copy(i.boneInverses[d]),h.multiply(e.bindMatrix).toArray(c,d*16);return t.skins===void 0&&(t.skins=[]),t.skins.push({inverseBindMatrices:this.processAccessor(new l.BufferAttribute(c,16)),joints:a,skeleton:n.get(s)}),r.skin=t.skins.length-1}processNode(e){const t=this.json,n=this.options,r=this.nodeMap;t.nodes||(t.nodes=[]);const i={};if(n.trs){const a=e.quaternion.toArray(),c=e.position.toArray(),h=e.scale.toArray();Wt(a,[0,0,0,1])||(i.rotation=a),Wt(c,[0,0,0])||(i.translation=c),Wt(h,[1,1,1])||(i.scale=h)}else e.matrixAutoUpdate&&e.updateMatrix(),ro(e.matrix)===!1&&(i.matrix=e.matrix.elements);if(e.name!==""&&(i.name=String(e.name)),this.serializeUserData(e,i),e.isMesh||e.isLine||e.isPoints){const a=this.processMesh(e);a!==null&&(i.mesh=a)}else e.isCamera&&(i.camera=this.processCamera(e));if(e.isSkinnedMesh&&this.skins.push(e),e.children.length>0){const a=[];for(let c=0,h=e.children.length;c<h;c++){const f=e.children[c];if(f.visible||n.onlyVisible===!1){const d=this.processNode(f);d!==null&&a.push(d)}}a.length>0&&(i.children=a)}this._invokeAll(function(a){a.writeNode&&a.writeNode(e,i)});const s=t.nodes.push(i)-1;return r.set(e,s),s}processScene(e){const t=this.json,n=this.options;t.scenes||(t.scenes=[],t.scene=0);const r={};e.name!==""&&(r.name=e.name),t.scenes.push(r);const i=[];for(let s=0,a=e.children.length;s<a;s++){const c=e.children[s];if(c.visible||n.onlyVisible===!1){const h=this.processNode(c);h!==null&&i.push(h)}}i.length>0&&(r.nodes=i),this.serializeUserData(e,r)}processObjects(e){const t=new l.Scene;t.name="AuxScene";for(let n=0;n<e.length;n++)t.children.push(e[n]);this.processScene(t)}processInput(e){const t=this.options;e=e instanceof Array?e:[e],this._invokeAll(function(r){r.beforeParse&&r.beforeParse(e)});const n=[];for(let r=0;r<e.length;r++)e[r]instanceof l.Scene?this.processScene(e[r]):n.push(e[r]);n.length>0&&this.processObjects(n);for(let r=0;r<this.skins.length;++r)this.processSkin(this.skins[r]);for(let r=0;r<t.animations.length;++r)this.processAnimation(t.animations[r],e[0]);this._invokeAll(function(r){r.afterParse&&r.afterParse(e)})}_invokeAll(e){for(let t=0,n=this.plugins.length;t<n;t++)e(this.plugins[t])}}class oo{constructor(e){this.writer=e,this.name="KHR_lights_punctual"}writeNode(e,t){if(!e.isLight)return;if(!e.isDirectionalLight&&!e.isPointLight&&!e.isSpotLight){console.warn("THREE.GLTFExporter: Only directional, point, and spot lights are supported.",e);return}const n=this.writer,r=n.json,i=n.extensionsUsed,s={};e.name&&(s.name=e.name),s.color=e.color.toArray(),s.intensity=e.intensity,e.isDirectionalLight?s.type="directional":e.isPointLight?(s.type="point",e.distance>0&&(s.range=e.distance)):e.isSpotLight&&(s.type="spot",e.distance>0&&(s.range=e.distance),s.spot={},s.spot.innerConeAngle=(e.penumbra-1)*e.angle*-1,s.spot.outerConeAngle=e.angle),e.decay!==void 0&&e.decay!==2&&console.warn("THREE.GLTFExporter: Light decay may be lost. glTF is physically-based, and expects light.decay=2."),e.target&&(e.target.parent!==e||e.target.position.x!==0||e.target.position.y!==0||e.target.position.z!==-1)&&console.warn("THREE.GLTFExporter: Light direction may be lost. For best results, make light.target a child of the light with position 0,0,-1."),i[this.name]||(r.extensions=r.extensions||{},r.extensions[this.name]={lights:[]},i[this.name]=!0);const a=r.extensions[this.name].lights;a.push(s),t.extensions=t.extensions||{},t.extensions[this.name]={light:a.length-1}}}let ao=class{constructor(e){this.writer=e,this.name="KHR_materials_unlit"}writeMaterial(e,t){if(!e.isMeshBasicMaterial)return;const r=this.writer.extensionsUsed;t.extensions=t.extensions||{},t.extensions[this.name]={},r[this.name]=!0,t.pbrMetallicRoughness.metallicFactor=0,t.pbrMetallicRoughness.roughnessFactor=.9}},lo=class{constructor(e){this.writer=e,this.name="KHR_materials_clearcoat"}writeMaterial(e,t){if(!e.isMeshPhysicalMaterial||e.clearcoat===0)return;const n=this.writer,r=n.extensionsUsed,i={};if(i.clearcoatFactor=e.clearcoat,e.clearcoatMap){const s={index:n.processTexture(e.clearcoatMap),texCoord:e.clearcoatMap.channel};n.applyTextureTransform(s,e.clearcoatMap),i.clearcoatTexture=s}if(i.clearcoatRoughnessFactor=e.clearcoatRoughness,e.clearcoatRoughnessMap){const s={index:n.processTexture(e.clearcoatRoughnessMap),texCoord:e.clearcoatRoughnessMap.channel};n.applyTextureTransform(s,e.clearcoatRoughnessMap),i.clearcoatRoughnessTexture=s}if(e.clearcoatNormalMap){const s={index:n.processTexture(e.clearcoatNormalMap),texCoord:e.clearcoatNormalMap.channel};n.applyTextureTransform(s,e.clearcoatNormalMap),i.clearcoatNormalTexture=s}t.extensions=t.extensions||{},t.extensions[this.name]=i,r[this.name]=!0}},co=class{constructor(e){this.writer=e,this.name="KHR_materials_iridescence"}writeMaterial(e,t){if(!e.isMeshPhysicalMaterial||e.iridescence===0)return;const n=this.writer,r=n.extensionsUsed,i={};if(i.iridescenceFactor=e.iridescence,e.iridescenceMap){const s={index:n.processTexture(e.iridescenceMap),texCoord:e.iridescenceMap.channel};n.applyTextureTransform(s,e.iridescenceMap),i.iridescenceTexture=s}if(i.iridescenceIor=e.iridescenceIOR,i.iridescenceThicknessMinimum=e.iridescenceThicknessRange[0],i.iridescenceThicknessMaximum=e.iridescenceThicknessRange[1],e.iridescenceThicknessMap){const s={index:n.processTexture(e.iridescenceThicknessMap),texCoord:e.iridescenceThicknessMap.channel};n.applyTextureTransform(s,e.iridescenceThicknessMap),i.iridescenceThicknessTexture=s}t.extensions=t.extensions||{},t.extensions[this.name]=i,r[this.name]=!0}},uo=class{constructor(e){this.writer=e,this.name="KHR_materials_transmission"}writeMaterial(e,t){if(!e.isMeshPhysicalMaterial||e.transmission===0)return;const n=this.writer,r=n.extensionsUsed,i={};if(i.transmissionFactor=e.transmission,e.transmissionMap){const s={index:n.processTexture(e.transmissionMap),texCoord:e.transmissionMap.channel};n.applyTextureTransform(s,e.transmissionMap),i.transmissionTexture=s}t.extensions=t.extensions||{},t.extensions[this.name]=i,r[this.name]=!0}},ho=class{constructor(e){this.writer=e,this.name="KHR_materials_volume"}writeMaterial(e,t){if(!e.isMeshPhysicalMaterial||e.transmission===0)return;const n=this.writer,r=n.extensionsUsed,i={};if(i.thicknessFactor=e.thickness,e.thicknessMap){const s={index:n.processTexture(e.thicknessMap),texCoord:e.thicknessMap.channel};n.applyTextureTransform(s,e.thicknessMap),i.thicknessTexture=s}i.attenuationDistance=e.attenuationDistance,i.attenuationColor=e.attenuationColor.toArray(),t.extensions=t.extensions||{},t.extensions[this.name]=i,r[this.name]=!0}},fo=class{constructor(e){this.writer=e,this.name="KHR_materials_ior"}writeMaterial(e,t){if(!e.isMeshPhysicalMaterial||e.ior===1.5)return;const r=this.writer.extensionsUsed,i={};i.ior=e.ior,t.extensions=t.extensions||{},t.extensions[this.name]=i,r[this.name]=!0}},po=class{constructor(e){this.writer=e,this.name="KHR_materials_specular"}writeMaterial(e,t){if(!e.isMeshPhysicalMaterial||e.specularIntensity===1&&e.specularColor.equals(Js)&&!e.specularIntensityMap&&!e.specularColorTexture)return;const n=this.writer,r=n.extensionsUsed,i={};if(e.specularIntensityMap){const s={index:n.processTexture(e.specularIntensityMap),texCoord:e.specularIntensityMap.channel};n.applyTextureTransform(s,e.specularIntensityMap),i.specularTexture=s}if(e.specularColorMap){const s={index:n.processTexture(e.specularColorMap),texCoord:e.specularColorMap.channel};n.applyTextureTransform(s,e.specularColorMap),i.specularColorTexture=s}i.specularFactor=e.specularIntensity,i.specularColorFactor=e.specularColor.toArray(),t.extensions=t.extensions||{},t.extensions[this.name]=i,r[this.name]=!0}},mo=class{constructor(e){this.writer=e,this.name="KHR_materials_sheen"}writeMaterial(e,t){if(!e.isMeshPhysicalMaterial||e.sheen==0)return;const n=this.writer,r=n.extensionsUsed,i={};if(e.sheenRoughnessMap){const s={index:n.processTexture(e.sheenRoughnessMap),texCoord:e.sheenRoughnessMap.channel};n.applyTextureTransform(s,e.sheenRoughnessMap),i.sheenRoughnessTexture=s}if(e.sheenColorMap){const s={index:n.processTexture(e.sheenColorMap),texCoord:e.sheenColorMap.channel};n.applyTextureTransform(s,e.sheenColorMap),i.sheenColorTexture=s}i.sheenRoughnessFactor=e.sheenRoughness,i.sheenColorFactor=e.sheenColor.toArray(),t.extensions=t.extensions||{},t.extensions[this.name]=i,r[this.name]=!0}},go=class{constructor(e){this.writer=e,this.name="KHR_materials_anisotropy"}writeMaterial(e,t){if(!e.isMeshPhysicalMaterial||e.anisotropy==0)return;const n=this.writer,r=n.extensionsUsed,i={};if(e.anisotropyMap){const s={index:n.processTexture(e.anisotropyMap)};n.applyTextureTransform(s,e.anisotropyMap),i.anisotropyTexture=s}i.anisotropyStrength=e.anisotropy,i.anisotropyRotation=e.anisotropyRotation,t.extensions=t.extensions||{},t.extensions[this.name]=i,r[this.name]=!0}},yo=class{constructor(e){this.writer=e,this.name="KHR_materials_emissive_strength"}writeMaterial(e,t){if(!e.isMeshStandardMaterial||e.emissiveIntensity===1)return;const r=this.writer.extensionsUsed,i={};i.emissiveStrength=e.emissiveIntensity,t.extensions=t.extensions||{},t.extensions[this.name]=i,r[this.name]=!0}};var Ye=Uint8Array,ft=Uint16Array,Wn=Uint32Array,Jr=new Ye([0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0,0,0,0]),Hr=new Ye([0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13,0,0]),vo=new Ye([16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15]),$r=function(o,e){for(var t=new ft(31),n=0;n<31;++n)t[n]=e+=1<<o[n-1];for(var r=new Wn(t[30]),n=1;n<30;++n)for(var i=t[n];i<t[n+1];++i)r[i]=i-t[n]<<5|n;return[t,r]},ei=$r(Jr,2),ti=ei[0],_o=ei[1];ti[28]=258,_o[258]=28;for(var xo=$r(Hr,0),wo=xo[0],Yn=new ft(32768),Pe=0;Pe<32768;++Pe){var dt=(Pe&43690)>>>1|(Pe&21845)<<1;dt=(dt&52428)>>>2|(dt&13107)<<2,dt=(dt&61680)>>>4|(dt&3855)<<4,Yn[Pe]=((dt&65280)>>>8|(dt&255)<<8)>>>1}for(var Yt=function(o,e,t){for(var n=o.length,r=0,i=new ft(e);r<n;++r)++i[o[r]-1];var s=new ft(e);for(r=0;r<e;++r)s[r]=s[r-1]+i[r-1]<<1;var a;if(t){a=new ft(1<<e);var c=15-e;for(r=0;r<n;++r)if(o[r])for(var h=r<<4|o[r],f=e-o[r],d=s[o[r]-1]++<<f,p=d|(1<<f)-1;d<=p;++d)a[Yn[d]>>>c]=h}else for(a=new ft(n),r=0;r<n;++r)o[r]&&(a[r]=Yn[s[o[r]-1]++]>>>15-o[r]);return a},Xt=new Ye(288),Pe=0;Pe<144;++Pe)Xt[Pe]=8;for(var Pe=144;Pe<256;++Pe)Xt[Pe]=9;for(var Pe=256;Pe<280;++Pe)Xt[Pe]=7;for(var Pe=280;Pe<288;++Pe)Xt[Pe]=8;for(var ni=new Ye(32),Pe=0;Pe<32;++Pe)ni[Pe]=5;var bo=Yt(Xt,9,1),Mo=Yt(ni,5,1),Xn=function(o){for(var e=o[0],t=1;t<o.length;++t)o[t]>e&&(e=o[t]);return e},Qe=function(o,e,t){var n=e/8|0;return(o[n]|o[n+1]<<8)>>(e&7)&t},Zn=function(o,e){var t=e/8|0;return(o[t]|o[t+1]<<8|o[t+2]<<16)>>(e&7)},So=function(o){return(o/8|0)+(o&7&&1)},Ao=function(o,e,t){(e==null||e<0)&&(e=0),(t==null||t>o.length)&&(t=o.length);var n=new(o instanceof ft?ft:o instanceof Wn?Wn:Ye)(t-e);return n.set(o.subarray(e,t)),n},Co=function(o,e,t){var n=o.length;if(!n||t&&!t.l&&n<5)return e||new Ye(0);var r=!e||t,i=!t||t.i;t||(t={}),e||(e=new Ye(n*3));var s=function(ee){var N=e.length;if(ee>N){var R=new Ye(Math.max(N*2,ee));R.set(e),e=R}},a=t.f||0,c=t.p||0,h=t.b||0,f=t.l,d=t.d,p=t.m,m=t.n,x=n*8;do{if(!f){t.f=a=Qe(o,c,1);var b=Qe(o,c+1,3);if(c+=3,b)if(b==1)f=bo,d=Mo,p=9,m=5;else if(b==2){var w=Qe(o,c,31)+257,M=Qe(o,c+10,15)+4,D=w+Qe(o,c+5,31)+1;c+=14;for(var S=new Ye(D),C=new Ye(19),y=0;y<M;++y)C[vo[y]]=Qe(o,c+y*3,7);c+=M*3;for(var A=Xn(C),g=(1<<A)-1,I=Yt(C,A,1),y=0;y<D;){var k=I[Qe(o,c,g)];c+=k&15;var v=k>>>4;if(v<16)S[y++]=v;else{var J=0,G=0;for(v==16?(G=3+Qe(o,c,3),c+=2,J=S[y-1]):v==17?(G=3+Qe(o,c,7),c+=3):v==18&&(G=11+Qe(o,c,127),c+=7);G--;)S[y++]=J}}var Z=S.subarray(0,w),X=S.subarray(w);p=Xn(Z),m=Xn(X),f=Yt(Z,p,1),d=Yt(X,m,1)}else throw"invalid block type";else{var v=So(c)+4,_=o[v-4]|o[v-3]<<8,T=v+_;if(T>n){if(i)throw"unexpected EOF";break}r&&s(h+_),e.set(o.subarray(v,T),h),t.b=h+=_,t.p=c=T*8;continue}if(c>x){if(i)throw"unexpected EOF";break}}r&&s(h+131072);for(var K=(1<<p)-1,Y=(1<<m)-1,te=c;;te=c){var J=f[Zn(o,c)&K],re=J>>>4;if(c+=J&15,c>x){if(i)throw"unexpected EOF";break}if(!J)throw"invalid length/literal";if(re<256)e[h++]=re;else if(re==256){te=c,f=null;break}else{var ce=re-254;if(re>264){var y=re-257,j=Jr[y];ce=Qe(o,c,(1<<j)-1)+ti[y],c+=j}var z=d[Zn(o,c)&Y],P=z>>>4;if(!z)throw"invalid distance";c+=z&15;var X=wo[P];if(P>3){var j=Hr[P];X+=Zn(o,c)&(1<<j)-1,c+=j}if(c>x){if(i)throw"unexpected EOF";break}r&&s(h+131072);for(var V=h+ce;h<V;h+=4)e[h]=e[h-X],e[h+1]=e[h+1-X],e[h+2]=e[h+2-X],e[h+3]=e[h+3-X];h=V}}t.l=f,t.p=te,t.b=h,f&&(a=1,t.m=p,t.d=d,t.n=m)}while(!a);return h==e.length?e:Ao(e,0,h)},Po=new Ye(0),To=function(o){if((o[0]&15)!=8||o[0]>>>4>7||(o[0]<<8|o[1])%31)throw"invalid zlib data";if(o[1]&32)throw"invalid zlib data: preset dictionaries not supported"};function Lo(o,e){return Co((To(o),o.subarray(2,-4)),e)}var Do=typeof TextDecoder<"u"&&new TextDecoder,Io=0;try{Do.decode(Po,{stream:!0}),Io=1}catch{}const Be=new l.Triangle,gn=new l.Vector3;class Oo{constructor(e){let t=e.geometry;t.index&&(console.warn("THREE.MeshSurfaceSampler: Converting geometry to non-indexed BufferGeometry."),t=t.toNonIndexed()),this.geometry=t,this.randomFunction=Math.random,this.positionAttribute=this.geometry.getAttribute("position"),this.colorAttribute=this.geometry.getAttribute("color"),this.weightAttribute=null,this.distribution=null}setWeightAttribute(e){return this.weightAttribute=e?this.geometry.getAttribute(e):null,this}build(){const e=this.positionAttribute,t=this.weightAttribute,n=new Float32Array(e.count/3);for(let i=0;i<e.count;i+=3){let s=1;t&&(s=t.getX(i)+t.getX(i+1)+t.getX(i+2)),Be.a.fromBufferAttribute(e,i),Be.b.fromBufferAttribute(e,i+1),Be.c.fromBufferAttribute(e,i+2),s*=Be.getArea(),n[i/3]=s}this.distribution=new Float32Array(e.count/3);let r=0;for(let i=0;i<n.length;i++)r+=n[i],this.distribution[i]=r;return this}setRandomGenerator(e){return this.randomFunction=e,this}sample(e,t,n){const r=this.sampleFaceIndex();return this.sampleFace(r,e,t,n)}sampleFaceIndex(){const e=this.distribution[this.distribution.length-1];return this.binarySearch(this.randomFunction()*e)}binarySearch(e){const t=this.distribution;let n=0,r=t.length-1,i=-1;for(;n<=r;){const s=Math.ceil((n+r)/2);if(s===0||t[s-1]<=e&&t[s]>e){i=s;break}else e<t[s]?r=s-1:n=s+1}return i}sampleFace(e,t,n,r){let i=this.randomFunction(),s=this.randomFunction();return i+s>1&&(i=1-i,s=1-s),Be.a.fromBufferAttribute(this.positionAttribute,e*3),Be.b.fromBufferAttribute(this.positionAttribute,e*3+1),Be.c.fromBufferAttribute(this.positionAttribute,e*3+2),t.set(0,0,0).addScaledVector(Be.a,i).addScaledVector(Be.b,s).addScaledVector(Be.c,1-(i+s)),n!==void 0&&Be.getNormal(n),r!==void 0&&this.colorAttribute!==void 0&&(Be.a.fromBufferAttribute(this.colorAttribute,e*3),Be.b.fromBufferAttribute(this.colorAttribute,e*3+1),Be.c.fromBufferAttribute(this.colorAttribute,e*3+2),gn.set(0,0,0).addScaledVector(Be.a,i).addScaledVector(Be.b,s).addScaledVector(Be.c,1-(i+s)),r.r=gn.x,r.g=gn.y,r.b=gn.z),this}}var ko=Object.defineProperty,Bo=(o,e,t)=>e in o?ko(o,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):o[e]=t,H=(o,e,t)=>(Bo(o,typeof e!="symbol"?e+"":e,t),t);class Fo extends l.Object3D{constructor(e,t){super(),H(this,"isTransformControls",!0),H(this,"visible",!1),H(this,"domElement"),H(this,"raycaster",new l.Raycaster),H(this,"gizmo"),H(this,"plane"),H(this,"tempVector",new l.Vector3),H(this,"tempVector2",new l.Vector3),H(this,"tempQuaternion",new l.Quaternion),H(this,"unit",{X:new l.Vector3(1,0,0),Y:new l.Vector3(0,1,0),Z:new l.Vector3(0,0,1)}),H(this,"pointStart",new l.Vector3),H(this,"pointEnd",new l.Vector3),H(this,"offset",new l.Vector3),H(this,"rotationAxis",new l.Vector3),H(this,"startNorm",new l.Vector3),H(this,"endNorm",new l.Vector3),H(this,"rotationAngle",0),H(this,"cameraPosition",new l.Vector3),H(this,"cameraQuaternion",new l.Quaternion),H(this,"cameraScale",new l.Vector3),H(this,"parentPosition",new l.Vector3),H(this,"parentQuaternion",new l.Quaternion),H(this,"parentQuaternionInv",new l.Quaternion),H(this,"parentScale",new l.Vector3),H(this,"worldPositionStart",new l.Vector3),H(this,"worldQuaternionStart",new l.Quaternion),H(this,"worldScaleStart",new l.Vector3),H(this,"worldPosition",new l.Vector3),H(this,"worldQuaternion",new l.Quaternion),H(this,"worldQuaternionInv",new l.Quaternion),H(this,"worldScale",new l.Vector3),H(this,"eye",new l.Vector3),H(this,"positionStart",new l.Vector3),H(this,"quaternionStart",new l.Quaternion),H(this,"scaleStart",new l.Vector3),H(this,"camera"),H(this,"object"),H(this,"enabled",!0),H(this,"axis",null),H(this,"mode","translate"),H(this,"translationSnap",null),H(this,"rotationSnap",null),H(this,"scaleSnap",null),H(this,"space","world"),H(this,"size",1),H(this,"dragging",!1),H(this,"showX",!0),H(this,"showY",!0),H(this,"showZ",!0),H(this,"changeEvent",{type:"change"}),H(this,"mouseDownEvent",{type:"mouseDown",mode:this.mode}),H(this,"mouseUpEvent",{type:"mouseUp",mode:this.mode}),H(this,"objectChangeEvent",{type:"objectChange"}),H(this,"intersectObjectWithRay",(r,i,s)=>{const a=i.intersectObject(r,!0);for(let c=0;c<a.length;c++)if(a[c].object.visible||s)return a[c];return!1}),H(this,"attach",r=>(this.object=r,this.visible=!0,this)),H(this,"detach",()=>(this.object=void 0,this.visible=!1,this.axis=null,this)),H(this,"reset",()=>this.enabled?(this.dragging&&this.object!==void 0&&(this.object.position.copy(this.positionStart),this.object.quaternion.copy(this.quaternionStart),this.object.scale.copy(this.scaleStart),this.dispatchEvent(this.changeEvent),this.dispatchEvent(this.objectChangeEvent),this.pointStart.copy(this.pointEnd)),this):this),H(this,"updateMatrixWorld",()=>{this.object!==void 0&&(this.object.updateMatrixWorld(),this.object.parent===null?console.error("TransformControls: The attached 3D object must be a part of the scene graph."):this.object.parent.matrixWorld.decompose(this.parentPosition,this.parentQuaternion,this.parentScale),this.object.matrixWorld.decompose(this.worldPosition,this.worldQuaternion,this.worldScale),this.parentQuaternionInv.copy(this.parentQuaternion).invert(),this.worldQuaternionInv.copy(this.worldQuaternion).invert()),this.camera.updateMatrixWorld(),this.camera.matrixWorld.decompose(this.cameraPosition,this.cameraQuaternion,this.cameraScale),this.eye.copy(this.cameraPosition).sub(this.worldPosition).normalize(),super.updateMatrixWorld()}),H(this,"pointerHover",r=>{if(this.object===void 0||this.dragging===!0)return;this.raycaster.setFromCamera(r,this.camera);const i=this.intersectObjectWithRay(this.gizmo.picker[this.mode],this.raycaster);i?this.axis=i.object.name:this.axis=null}),H(this,"pointerDown",r=>{if(!(this.object===void 0||this.dragging===!0||r.button!==0)&&this.axis!==null){this.raycaster.setFromCamera(r,this.camera);const i=this.intersectObjectWithRay(this.plane,this.raycaster,!0);if(i){let s=this.space;if(this.mode==="scale"?s="local":(this.axis==="E"||this.axis==="XYZE"||this.axis==="XYZ")&&(s="world"),s==="local"&&this.mode==="rotate"){const a=this.rotationSnap;this.axis==="X"&&a&&(this.object.rotation.x=Math.round(this.object.rotation.x/a)*a),this.axis==="Y"&&a&&(this.object.rotation.y=Math.round(this.object.rotation.y/a)*a),this.axis==="Z"&&a&&(this.object.rotation.z=Math.round(this.object.rotation.z/a)*a)}this.object.updateMatrixWorld(),this.object.parent&&this.object.parent.updateMatrixWorld(),this.positionStart.copy(this.object.position),this.quaternionStart.copy(this.object.quaternion),this.scaleStart.copy(this.object.scale),this.object.matrixWorld.decompose(this.worldPositionStart,this.worldQuaternionStart,this.worldScaleStart),this.pointStart.copy(i.point).sub(this.worldPositionStart)}this.dragging=!0,this.mouseDownEvent.mode=this.mode,this.dispatchEvent(this.mouseDownEvent)}}),H(this,"pointerMove",r=>{const i=this.axis,s=this.mode,a=this.object;let c=this.space;if(s==="scale"?c="local":(i==="E"||i==="XYZE"||i==="XYZ")&&(c="world"),a===void 0||i===null||this.dragging===!1||r.button!==-1)return;this.raycaster.setFromCamera(r,this.camera);const h=this.intersectObjectWithRay(this.plane,this.raycaster,!0);if(h){if(this.pointEnd.copy(h.point).sub(this.worldPositionStart),s==="translate")this.offset.copy(this.pointEnd).sub(this.pointStart),c==="local"&&i!=="XYZ"&&this.offset.applyQuaternion(this.worldQuaternionInv),i.indexOf("X")===-1&&(this.offset.x=0),i.indexOf("Y")===-1&&(this.offset.y=0),i.indexOf("Z")===-1&&(this.offset.z=0),c==="local"&&i!=="XYZ"?this.offset.applyQuaternion(this.quaternionStart).divide(this.parentScale):this.offset.applyQuaternion(this.parentQuaternionInv).divide(this.parentScale),a.position.copy(this.offset).add(this.positionStart),this.translationSnap&&(c==="local"&&(a.position.applyQuaternion(this.tempQuaternion.copy(this.quaternionStart).invert()),i.search("X")!==-1&&(a.position.x=Math.round(a.position.x/this.translationSnap)*this.translationSnap),i.search("Y")!==-1&&(a.position.y=Math.round(a.position.y/this.translationSnap)*this.translationSnap),i.search("Z")!==-1&&(a.position.z=Math.round(a.position.z/this.translationSnap)*this.translationSnap),a.position.applyQuaternion(this.quaternionStart)),c==="world"&&(a.parent&&a.position.add(this.tempVector.setFromMatrixPosition(a.parent.matrixWorld)),i.search("X")!==-1&&(a.position.x=Math.round(a.position.x/this.translationSnap)*this.translationSnap),i.search("Y")!==-1&&(a.position.y=Math.round(a.position.y/this.translationSnap)*this.translationSnap),i.search("Z")!==-1&&(a.position.z=Math.round(a.position.z/this.translationSnap)*this.translationSnap),a.parent&&a.position.sub(this.tempVector.setFromMatrixPosition(a.parent.matrixWorld))));else if(s==="scale"){if(i.search("XYZ")!==-1){let f=this.pointEnd.length()/this.pointStart.length();this.pointEnd.dot(this.pointStart)<0&&(f*=-1),this.tempVector2.set(f,f,f)}else this.tempVector.copy(this.pointStart),this.tempVector2.copy(this.pointEnd),this.tempVector.applyQuaternion(this.worldQuaternionInv),this.tempVector2.applyQuaternion(this.worldQuaternionInv),this.tempVector2.divide(this.tempVector),i.search("X")===-1&&(this.tempVector2.x=1),i.search("Y")===-1&&(this.tempVector2.y=1),i.search("Z")===-1&&(this.tempVector2.z=1);a.scale.copy(this.scaleStart).multiply(this.tempVector2),this.scaleSnap&&this.object&&(i.search("X")!==-1&&(this.object.scale.x=Math.round(a.scale.x/this.scaleSnap)*this.scaleSnap||this.scaleSnap),i.search("Y")!==-1&&(a.scale.y=Math.round(a.scale.y/this.scaleSnap)*this.scaleSnap||this.scaleSnap),i.search("Z")!==-1&&(a.scale.z=Math.round(a.scale.z/this.scaleSnap)*this.scaleSnap||this.scaleSnap))}else if(s==="rotate"){this.offset.copy(this.pointEnd).sub(this.pointStart);const f=20/this.worldPosition.distanceTo(this.tempVector.setFromMatrixPosition(this.camera.matrixWorld));i==="E"?(this.rotationAxis.copy(this.eye),this.rotationAngle=this.pointEnd.angleTo(this.pointStart),this.startNorm.copy(this.pointStart).normalize(),this.endNorm.copy(this.pointEnd).normalize(),this.rotationAngle*=this.endNorm.cross(this.startNorm).dot(this.eye)<0?1:-1):i==="XYZE"?(this.rotationAxis.copy(this.offset).cross(this.eye).normalize(),this.rotationAngle=this.offset.dot(this.tempVector.copy(this.rotationAxis).cross(this.eye))*f):(i==="X"||i==="Y"||i==="Z")&&(this.rotationAxis.copy(this.unit[i]),this.tempVector.copy(this.unit[i]),c==="local"&&this.tempVector.applyQuaternion(this.worldQuaternion),this.rotationAngle=this.offset.dot(this.tempVector.cross(this.eye).normalize())*f),this.rotationSnap&&(this.rotationAngle=Math.round(this.rotationAngle/this.rotationSnap)*this.rotationSnap),c==="local"&&i!=="E"&&i!=="XYZE"?(a.quaternion.copy(this.quaternionStart),a.quaternion.multiply(this.tempQuaternion.setFromAxisAngle(this.rotationAxis,this.rotationAngle)).normalize()):(this.rotationAxis.applyQuaternion(this.parentQuaternionInv),a.quaternion.copy(this.tempQuaternion.setFromAxisAngle(this.rotationAxis,this.rotationAngle)),a.quaternion.multiply(this.quaternionStart).normalize())}this.dispatchEvent(this.changeEvent),this.dispatchEvent(this.objectChangeEvent)}}),H(this,"pointerUp",r=>{r.button===0&&(this.dragging&&this.axis!==null&&(this.mouseUpEvent.mode=this.mode,this.dispatchEvent(this.mouseUpEvent)),this.dragging=!1,this.axis=null)}),H(this,"getPointer",r=>{var i;if(this.domElement&&((i=this.domElement.ownerDocument)!=null&&i.pointerLockElement))return{x:0,y:0,button:r.button};{const s=r.changedTouches?r.changedTouches[0]:r,a=this.domElement.getBoundingClientRect();return{x:(s.clientX-a.left)/a.width*2-1,y:-(s.clientY-a.top)/a.height*2+1,button:r.button}}}),H(this,"onPointerHover",r=>{if(this.enabled)switch(r.pointerType){case"mouse":case"pen":this.pointerHover(this.getPointer(r));break}}),H(this,"onPointerDown",r=>{!this.enabled||!this.domElement||(this.domElement.style.touchAction="none",this.domElement.ownerDocument.addEventListener("pointermove",this.onPointerMove),this.pointerHover(this.getPointer(r)),this.pointerDown(this.getPointer(r)))}),H(this,"onPointerMove",r=>{this.enabled&&this.pointerMove(this.getPointer(r))}),H(this,"onPointerUp",r=>{!this.enabled||!this.domElement||(this.domElement.style.touchAction="",this.domElement.ownerDocument.removeEventListener("pointermove",this.onPointerMove),this.pointerUp(this.getPointer(r)))}),H(this,"getMode",()=>this.mode),H(this,"setMode",r=>{this.mode=r}),H(this,"setTranslationSnap",r=>{this.translationSnap=r}),H(this,"setRotationSnap",r=>{this.rotationSnap=r}),H(this,"setScaleSnap",r=>{this.scaleSnap=r}),H(this,"setSize",r=>{this.size=r}),H(this,"setSpace",r=>{this.space=r}),H(this,"update",()=>{console.warn("THREE.TransformControls: update function has no more functionality and therefore has been deprecated.")}),H(this,"connect",r=>{r===document&&console.error('THREE.OrbitControls: "document" should not be used as the target "domElement". Please use "renderer.domElement" instead.'),this.domElement=r,this.domElement.addEventListener("pointerdown",this.onPointerDown),this.domElement.addEventListener("pointermove",this.onPointerHover),this.domElement.ownerDocument.addEventListener("pointerup",this.onPointerUp)}),H(this,"dispose",()=>{var r,i,s,a,c,h;(r=this.domElement)==null||r.removeEventListener("pointerdown",this.onPointerDown),(i=this.domElement)==null||i.removeEventListener("pointermove",this.onPointerHover),(a=(s=this.domElement)==null?void 0:s.ownerDocument)==null||a.removeEventListener("pointermove",this.onPointerMove),(h=(c=this.domElement)==null?void 0:c.ownerDocument)==null||h.removeEventListener("pointerup",this.onPointerUp),this.traverse(f=>{const d=f;d.geometry&&d.geometry.dispose(),d.material&&d.material.dispose()})}),this.domElement=t,this.camera=e,this.gizmo=new Uo,this.add(this.gizmo),this.plane=new No,this.add(this.plane);const n=(r,i)=>{let s=i;Object.defineProperty(this,r,{get:function(){return s!==void 0?s:i},set:function(a){s!==a&&(s=a,this.plane[r]=a,this.gizmo[r]=a,this.dispatchEvent({type:r+"-changed",value:a}),this.dispatchEvent(this.changeEvent))}}),this[r]=i,this.plane[r]=i,this.gizmo[r]=i};n("camera",this.camera),n("object",this.object),n("enabled",this.enabled),n("axis",this.axis),n("mode",this.mode),n("translationSnap",this.translationSnap),n("rotationSnap",this.rotationSnap),n("scaleSnap",this.scaleSnap),n("space",this.space),n("size",this.size),n("dragging",this.dragging),n("showX",this.showX),n("showY",this.showY),n("showZ",this.showZ),n("worldPosition",this.worldPosition),n("worldPositionStart",this.worldPositionStart),n("worldQuaternion",this.worldQuaternion),n("worldQuaternionStart",this.worldQuaternionStart),n("cameraPosition",this.cameraPosition),n("cameraQuaternion",this.cameraQuaternion),n("pointStart",this.pointStart),n("pointEnd",this.pointEnd),n("rotationAxis",this.rotationAxis),n("rotationAngle",this.rotationAngle),n("eye",this.eye),t!==void 0&&this.connect(t)}}class Uo extends l.Object3D{constructor(){super(),H(this,"isTransformControlsGizmo",!0),H(this,"type","TransformControlsGizmo"),H(this,"tempVector",new l.Vector3(0,0,0)),H(this,"tempEuler",new l.Euler),H(this,"alignVector",new l.Vector3(0,1,0)),H(this,"zeroVector",new l.Vector3(0,0,0)),H(this,"lookAtMatrix",new l.Matrix4),H(this,"tempQuaternion",new l.Quaternion),H(this,"tempQuaternion2",new l.Quaternion),H(this,"identityQuaternion",new l.Quaternion),H(this,"unitX",new l.Vector3(1,0,0)),H(this,"unitY",new l.Vector3(0,1,0)),H(this,"unitZ",new l.Vector3(0,0,1)),H(this,"gizmo"),H(this,"picker"),H(this,"helper"),H(this,"rotationAxis",new l.Vector3),H(this,"cameraPosition",new l.Vector3),H(this,"worldPositionStart",new l.Vector3),H(this,"worldQuaternionStart",new l.Quaternion),H(this,"worldPosition",new l.Vector3),H(this,"worldQuaternion",new l.Quaternion),H(this,"eye",new l.Vector3),H(this,"camera",null),H(this,"enabled",!0),H(this,"axis",null),H(this,"mode","translate"),H(this,"space","world"),H(this,"size",1),H(this,"dragging",!1),H(this,"showX",!0),H(this,"showY",!0),H(this,"showZ",!0),H(this,"updateMatrixWorld",()=>{let re=this.space;this.mode==="scale"&&(re="local");const ce=re==="local"?this.worldQuaternion:this.identityQuaternion;this.gizmo.translate.visible=this.mode==="translate",this.gizmo.rotate.visible=this.mode==="rotate",this.gizmo.scale.visible=this.mode==="scale",this.helper.translate.visible=this.mode==="translate",this.helper.rotate.visible=this.mode==="rotate",this.helper.scale.visible=this.mode==="scale";let j=[];j=j.concat(this.picker[this.mode].children),j=j.concat(this.gizmo[this.mode].children),j=j.concat(this.helper[this.mode].children);for(let z=0;z<j.length;z++){const P=j[z];P.visible=!0,P.rotation.set(0,0,0),P.position.copy(this.worldPosition);let V;if(this.camera.isOrthographicCamera?V=(this.camera.top-this.camera.bottom)/this.camera.zoom:V=this.worldPosition.distanceTo(this.cameraPosition)*Math.min(1.9*Math.tan(Math.PI*this.camera.fov/360)/this.camera.zoom,7),P.scale.set(1,1,1).multiplyScalar(V*this.size/7),P.tag==="helper"){P.visible=!1,P.name==="AXIS"?(P.position.copy(this.worldPositionStart),P.visible=!!this.axis,this.axis==="X"&&(this.tempQuaternion.setFromEuler(this.tempEuler.set(0,0,0)),P.quaternion.copy(ce).multiply(this.tempQuaternion),Math.abs(this.alignVector.copy(this.unitX).applyQuaternion(ce).dot(this.eye))>.9&&(P.visible=!1)),this.axis==="Y"&&(this.tempQuaternion.setFromEuler(this.tempEuler.set(0,0,Math.PI/2)),P.quaternion.copy(ce).multiply(this.tempQuaternion),Math.abs(this.alignVector.copy(this.unitY).applyQuaternion(ce).dot(this.eye))>.9&&(P.visible=!1)),this.axis==="Z"&&(this.tempQuaternion.setFromEuler(this.tempEuler.set(0,Math.PI/2,0)),P.quaternion.copy(ce).multiply(this.tempQuaternion),Math.abs(this.alignVector.copy(this.unitZ).applyQuaternion(ce).dot(this.eye))>.9&&(P.visible=!1)),this.axis==="XYZE"&&(this.tempQuaternion.setFromEuler(this.tempEuler.set(0,Math.PI/2,0)),this.alignVector.copy(this.rotationAxis),P.quaternion.setFromRotationMatrix(this.lookAtMatrix.lookAt(this.zeroVector,this.alignVector,this.unitY)),P.quaternion.multiply(this.tempQuaternion),P.visible=this.dragging),this.axis==="E"&&(P.visible=!1)):P.name==="START"?(P.position.copy(this.worldPositionStart),P.visible=this.dragging):P.name==="END"?(P.position.copy(this.worldPosition),P.visible=this.dragging):P.name==="DELTA"?(P.position.copy(this.worldPositionStart),P.quaternion.copy(this.worldQuaternionStart),this.tempVector.set(1e-10,1e-10,1e-10).add(this.worldPositionStart).sub(this.worldPosition).multiplyScalar(-1),this.tempVector.applyQuaternion(this.worldQuaternionStart.clone().invert()),P.scale.copy(this.tempVector),P.visible=this.dragging):(P.quaternion.copy(ce),this.dragging?P.position.copy(this.worldPositionStart):P.position.copy(this.worldPosition),this.axis&&(P.visible=this.axis.search(P.name)!==-1));continue}P.quaternion.copy(ce),this.mode==="translate"||this.mode==="scale"?((P.name==="X"||P.name==="XYZX")&&Math.abs(this.alignVector.copy(this.unitX).applyQuaternion(ce).dot(this.eye))>.99&&(P.scale.set(1e-10,1e-10,1e-10),P.visible=!1),(P.name==="Y"||P.name==="XYZY")&&Math.abs(this.alignVector.copy(this.unitY).applyQuaternion(ce).dot(this.eye))>.99&&(P.scale.set(1e-10,1e-10,1e-10),P.visible=!1),(P.name==="Z"||P.name==="XYZZ")&&Math.abs(this.alignVector.copy(this.unitZ).applyQuaternion(ce).dot(this.eye))>.99&&(P.scale.set(1e-10,1e-10,1e-10),P.visible=!1),P.name==="XY"&&Math.abs(this.alignVector.copy(this.unitZ).applyQuaternion(ce).dot(this.eye))<.2&&(P.scale.set(1e-10,1e-10,1e-10),P.visible=!1),P.name==="YZ"&&Math.abs(this.alignVector.copy(this.unitX).applyQuaternion(ce).dot(this.eye))<.2&&(P.scale.set(1e-10,1e-10,1e-10),P.visible=!1),P.name==="XZ"&&Math.abs(this.alignVector.copy(this.unitY).applyQuaternion(ce).dot(this.eye))<.2&&(P.scale.set(1e-10,1e-10,1e-10),P.visible=!1),P.name.search("X")!==-1&&(this.alignVector.copy(this.unitX).applyQuaternion(ce).dot(this.eye)<0?P.tag==="fwd"?P.visible=!1:P.scale.x*=-1:P.tag==="bwd"&&(P.visible=!1)),P.name.search("Y")!==-1&&(this.alignVector.copy(this.unitY).applyQuaternion(ce).dot(this.eye)<0?P.tag==="fwd"?P.visible=!1:P.scale.y*=-1:P.tag==="bwd"&&(P.visible=!1)),P.name.search("Z")!==-1&&(this.alignVector.copy(this.unitZ).applyQuaternion(ce).dot(this.eye)<0?P.tag==="fwd"?P.visible=!1:P.scale.z*=-1:P.tag==="bwd"&&(P.visible=!1))):this.mode==="rotate"&&(this.tempQuaternion2.copy(ce),this.alignVector.copy(this.eye).applyQuaternion(this.tempQuaternion.copy(ce).invert()),P.name.search("E")!==-1&&P.quaternion.setFromRotationMatrix(this.lookAtMatrix.lookAt(this.eye,this.zeroVector,this.unitY)),P.name==="X"&&(this.tempQuaternion.setFromAxisAngle(this.unitX,Math.atan2(-this.alignVector.y,this.alignVector.z)),this.tempQuaternion.multiplyQuaternions(this.tempQuaternion2,this.tempQuaternion),P.quaternion.copy(this.tempQuaternion)),P.name==="Y"&&(this.tempQuaternion.setFromAxisAngle(this.unitY,Math.atan2(this.alignVector.x,this.alignVector.z)),this.tempQuaternion.multiplyQuaternions(this.tempQuaternion2,this.tempQuaternion),P.quaternion.copy(this.tempQuaternion)),P.name==="Z"&&(this.tempQuaternion.setFromAxisAngle(this.unitZ,Math.atan2(this.alignVector.y,this.alignVector.x)),this.tempQuaternion.multiplyQuaternions(this.tempQuaternion2,this.tempQuaternion),P.quaternion.copy(this.tempQuaternion))),P.visible=P.visible&&(P.name.indexOf("X")===-1||this.showX),P.visible=P.visible&&(P.name.indexOf("Y")===-1||this.showY),P.visible=P.visible&&(P.name.indexOf("Z")===-1||this.showZ),P.visible=P.visible&&(P.name.indexOf("E")===-1||this.showX&&this.showY&&this.showZ),P.material.tempOpacity=P.material.tempOpacity||P.material.opacity,P.material.tempColor=P.material.tempColor||P.material.color.clone(),P.material.color.copy(P.material.tempColor),P.material.opacity=P.material.tempOpacity,this.enabled?this.axis&&(P.name===this.axis?(P.material.opacity=1,P.material.color.lerp(new l.Color(1,1,1),.5)):this.axis.split("").some(function(ee){return P.name===ee})?(P.material.opacity=1,P.material.color.lerp(new l.Color(1,1,1),.5)):(P.material.opacity*=.25,P.material.color.lerp(new l.Color(1,1,1),.5))):(P.material.opacity*=.5,P.material.color.lerp(new l.Color(1,1,1),.5))}super.updateMatrixWorld()});const e=new l.MeshBasicMaterial({depthTest:!1,depthWrite:!1,transparent:!0,side:l.DoubleSide,fog:!1,toneMapped:!1}),t=new l.LineBasicMaterial({depthTest:!1,depthWrite:!1,transparent:!0,linewidth:1,fog:!1,toneMapped:!1}),n=e.clone();n.opacity=.15;const r=e.clone();r.opacity=.33;const i=e.clone();i.color.set(16711680);const s=e.clone();s.color.set(65280);const a=e.clone();a.color.set(255);const c=e.clone();c.opacity=.25;const h=c.clone();h.color.set(16776960);const f=c.clone();f.color.set(65535);const d=c.clone();d.color.set(16711935),e.clone().color.set(16776960);const m=t.clone();m.color.set(16711680);const x=t.clone();x.color.set(65280);const b=t.clone();b.color.set(255);const v=t.clone();v.color.set(65535);const _=t.clone();_.color.set(16711935);const T=t.clone();T.color.set(16776960);const w=t.clone();w.color.set(7895160);const M=T.clone();M.opacity=.25;const D=new l.CylinderGeometry(0,.05,.2,12,1,!1),S=new l.BoxGeometry(.125,.125,.125),C=new l.BufferGeometry;C.setAttribute("position",new l.Float32BufferAttribute([0,0,0,1,0,0],3));const y=(re,ce)=>{const j=new l.BufferGeometry,z=[];for(let P=0;P<=64*ce;++P)z.push(0,Math.cos(P/32*Math.PI)*re,Math.sin(P/32*Math.PI)*re);return j.setAttribute("position",new l.Float32BufferAttribute(z,3)),j},A=()=>{const re=new l.BufferGeometry;return re.setAttribute("position",new l.Float32BufferAttribute([0,0,0,1,1,1],3)),re},g={X:[[new l.Mesh(D,i),[1,0,0],[0,0,-Math.PI/2],null,"fwd"],[new l.Mesh(D,i),[1,0,0],[0,0,Math.PI/2],null,"bwd"],[new l.Line(C,m)]],Y:[[new l.Mesh(D,s),[0,1,0],null,null,"fwd"],[new l.Mesh(D,s),[0,1,0],[Math.PI,0,0],null,"bwd"],[new l.Line(C,x),null,[0,0,Math.PI/2]]],Z:[[new l.Mesh(D,a),[0,0,1],[Math.PI/2,0,0],null,"fwd"],[new l.Mesh(D,a),[0,0,1],[-Math.PI/2,0,0],null,"bwd"],[new l.Line(C,b),null,[0,-Math.PI/2,0]]],XYZ:[[new l.Mesh(new l.OctahedronGeometry(.1,0),c.clone()),[0,0,0],[0,0,0]]],XY:[[new l.Mesh(new l.PlaneGeometry(.295,.295),h.clone()),[.15,.15,0]],[new l.Line(C,T),[.18,.3,0],null,[.125,1,1]],[new l.Line(C,T),[.3,.18,0],[0,0,Math.PI/2],[.125,1,1]]],YZ:[[new l.Mesh(new l.PlaneGeometry(.295,.295),f.clone()),[0,.15,.15],[0,Math.PI/2,0]],[new l.Line(C,v),[0,.18,.3],[0,0,Math.PI/2],[.125,1,1]],[new l.Line(C,v),[0,.3,.18],[0,-Math.PI/2,0],[.125,1,1]]],XZ:[[new l.Mesh(new l.PlaneGeometry(.295,.295),d.clone()),[.15,0,.15],[-Math.PI/2,0,0]],[new l.Line(C,_),[.18,0,.3],null,[.125,1,1]],[new l.Line(C,_),[.3,0,.18],[0,-Math.PI/2,0],[.125,1,1]]]},I={X:[[new l.Mesh(new l.CylinderGeometry(.2,0,1,4,1,!1),n),[.6,0,0],[0,0,-Math.PI/2]]],Y:[[new l.Mesh(new l.CylinderGeometry(.2,0,1,4,1,!1),n),[0,.6,0]]],Z:[[new l.Mesh(new l.CylinderGeometry(.2,0,1,4,1,!1),n),[0,0,.6],[Math.PI/2,0,0]]],XYZ:[[new l.Mesh(new l.OctahedronGeometry(.2,0),n)]],XY:[[new l.Mesh(new l.PlaneGeometry(.4,.4),n),[.2,.2,0]]],YZ:[[new l.Mesh(new l.PlaneGeometry(.4,.4),n),[0,.2,.2],[0,Math.PI/2,0]]],XZ:[[new l.Mesh(new l.PlaneGeometry(.4,.4),n),[.2,0,.2],[-Math.PI/2,0,0]]]},k={START:[[new l.Mesh(new l.OctahedronGeometry(.01,2),r),null,null,null,"helper"]],END:[[new l.Mesh(new l.OctahedronGeometry(.01,2),r),null,null,null,"helper"]],DELTA:[[new l.Line(A(),r),null,null,null,"helper"]],X:[[new l.Line(C,r.clone()),[-1e3,0,0],null,[1e6,1,1],"helper"]],Y:[[new l.Line(C,r.clone()),[0,-1e3,0],[0,0,Math.PI/2],[1e6,1,1],"helper"]],Z:[[new l.Line(C,r.clone()),[0,0,-1e3],[0,-Math.PI/2,0],[1e6,1,1],"helper"]]},J={X:[[new l.Line(y(1,.5),m)],[new l.Mesh(new l.OctahedronGeometry(.04,0),i),[0,0,.99],null,[1,3,1]]],Y:[[new l.Line(y(1,.5),x),null,[0,0,-Math.PI/2]],[new l.Mesh(new l.OctahedronGeometry(.04,0),s),[0,0,.99],null,[3,1,1]]],Z:[[new l.Line(y(1,.5),b),null,[0,Math.PI/2,0]],[new l.Mesh(new l.OctahedronGeometry(.04,0),a),[.99,0,0],null,[1,3,1]]],E:[[new l.Line(y(1.25,1),M),null,[0,Math.PI/2,0]],[new l.Mesh(new l.CylinderGeometry(.03,0,.15,4,1,!1),M),[1.17,0,0],[0,0,-Math.PI/2],[1,1,.001]],[new l.Mesh(new l.CylinderGeometry(.03,0,.15,4,1,!1),M),[-1.17,0,0],[0,0,Math.PI/2],[1,1,.001]],[new l.Mesh(new l.CylinderGeometry(.03,0,.15,4,1,!1),M),[0,-1.17,0],[Math.PI,0,0],[1,1,.001]],[new l.Mesh(new l.CylinderGeometry(.03,0,.15,4,1,!1),M),[0,1.17,0],[0,0,0],[1,1,.001]]],XYZE:[[new l.Line(y(1,1),w),null,[0,Math.PI/2,0]]]},G={AXIS:[[new l.Line(C,r.clone()),[-1e3,0,0],null,[1e6,1,1],"helper"]]},Z={X:[[new l.Mesh(new l.TorusGeometry(1,.1,4,24),n),[0,0,0],[0,-Math.PI/2,-Math.PI/2]]],Y:[[new l.Mesh(new l.TorusGeometry(1,.1,4,24),n),[0,0,0],[Math.PI/2,0,0]]],Z:[[new l.Mesh(new l.TorusGeometry(1,.1,4,24),n),[0,0,0],[0,0,-Math.PI/2]]],E:[[new l.Mesh(new l.TorusGeometry(1.25,.1,2,24),n)]],XYZE:[[new l.Mesh(new l.SphereGeometry(.7,10,8),n)]]},X={X:[[new l.Mesh(S,i),[.8,0,0],[0,0,-Math.PI/2]],[new l.Line(C,m),null,null,[.8,1,1]]],Y:[[new l.Mesh(S,s),[0,.8,0]],[new l.Line(C,x),null,[0,0,Math.PI/2],[.8,1,1]]],Z:[[new l.Mesh(S,a),[0,0,.8],[Math.PI/2,0,0]],[new l.Line(C,b),null,[0,-Math.PI/2,0],[.8,1,1]]],XY:[[new l.Mesh(S,h),[.85,.85,0],null,[2,2,.2]],[new l.Line(C,T),[.855,.98,0],null,[.125,1,1]],[new l.Line(C,T),[.98,.855,0],[0,0,Math.PI/2],[.125,1,1]]],YZ:[[new l.Mesh(S,f),[0,.85,.85],null,[.2,2,2]],[new l.Line(C,v),[0,.855,.98],[0,0,Math.PI/2],[.125,1,1]],[new l.Line(C,v),[0,.98,.855],[0,-Math.PI/2,0],[.125,1,1]]],XZ:[[new l.Mesh(S,d),[.85,0,.85],null,[2,.2,2]],[new l.Line(C,_),[.855,0,.98],null,[.125,1,1]],[new l.Line(C,_),[.98,0,.855],[0,-Math.PI/2,0],[.125,1,1]]],XYZX:[[new l.Mesh(new l.BoxGeometry(.125,.125,.125),c.clone()),[1.1,0,0]]],XYZY:[[new l.Mesh(new l.BoxGeometry(.125,.125,.125),c.clone()),[0,1.1,0]]],XYZZ:[[new l.Mesh(new l.BoxGeometry(.125,.125,.125),c.clone()),[0,0,1.1]]]},K={X:[[new l.Mesh(new l.CylinderGeometry(.2,0,.8,4,1,!1),n),[.5,0,0],[0,0,-Math.PI/2]]],Y:[[new l.Mesh(new l.CylinderGeometry(.2,0,.8,4,1,!1),n),[0,.5,0]]],Z:[[new l.Mesh(new l.CylinderGeometry(.2,0,.8,4,1,!1),n),[0,0,.5],[Math.PI/2,0,0]]],XY:[[new l.Mesh(S,n),[.85,.85,0],null,[3,3,.2]]],YZ:[[new l.Mesh(S,n),[0,.85,.85],null,[.2,3,3]]],XZ:[[new l.Mesh(S,n),[.85,0,.85],null,[3,.2,3]]],XYZX:[[new l.Mesh(new l.BoxGeometry(.2,.2,.2),n),[1.1,0,0]]],XYZY:[[new l.Mesh(new l.BoxGeometry(.2,.2,.2),n),[0,1.1,0]]],XYZZ:[[new l.Mesh(new l.BoxGeometry(.2,.2,.2),n),[0,0,1.1]]]},Y={X:[[new l.Line(C,r.clone()),[-1e3,0,0],null,[1e6,1,1],"helper"]],Y:[[new l.Line(C,r.clone()),[0,-1e3,0],[0,0,Math.PI/2],[1e6,1,1],"helper"]],Z:[[new l.Line(C,r.clone()),[0,0,-1e3],[0,-Math.PI/2,0],[1e6,1,1],"helper"]]},te=re=>{const ce=new l.Object3D;for(let j in re)for(let z=re[j].length;z--;){const P=re[j][z][0].clone(),V=re[j][z][1],ee=re[j][z][2],N=re[j][z][3],R=re[j][z][4];P.name=j,P.tag=R,V&&P.position.set(V[0],V[1],V[2]),ee&&P.rotation.set(ee[0],ee[1],ee[2]),N&&P.scale.set(N[0],N[1],N[2]),P.updateMatrix();const L=P.geometry.clone();L.applyMatrix4(P.matrix),P.geometry=L,P.renderOrder=1/0,P.position.set(0,0,0),P.rotation.set(0,0,0),P.scale.set(1,1,1),ce.add(P)}return ce};this.gizmo={},this.picker={},this.helper={},this.add(this.gizmo.translate=te(g)),this.add(this.gizmo.rotate=te(J)),this.add(this.gizmo.scale=te(X)),this.add(this.picker.translate=te(I)),this.add(this.picker.rotate=te(Z)),this.add(this.picker.scale=te(K)),this.add(this.helper.translate=te(k)),this.add(this.helper.rotate=te(G)),this.add(this.helper.scale=te(Y)),this.picker.translate.visible=!1,this.picker.rotate.visible=!1,this.picker.scale.visible=!1}}class No extends l.Mesh{constructor(){super(new l.PlaneGeometry(1e5,1e5,2,2),new l.MeshBasicMaterial({visible:!1,wireframe:!0,side:l.DoubleSide,transparent:!0,opacity:.1,toneMapped:!1})),H(this,"isTransformControlsPlane",!0),H(this,"type","TransformControlsPlane"),H(this,"unitX",new l.Vector3(1,0,0)),H(this,"unitY",new l.Vector3(0,1,0)),H(this,"unitZ",new l.Vector3(0,0,1)),H(this,"tempVector",new l.Vector3),H(this,"dirVector",new l.Vector3),H(this,"alignVector",new l.Vector3),H(this,"tempMatrix",new l.Matrix4),H(this,"identityQuaternion",new l.Quaternion),H(this,"cameraQuaternion",new l.Quaternion),H(this,"worldPosition",new l.Vector3),H(this,"worldQuaternion",new l.Quaternion),H(this,"eye",new l.Vector3),H(this,"axis",null),H(this,"mode","translate"),H(this,"space","world"),H(this,"updateMatrixWorld",()=>{let e=this.space;switch(this.position.copy(this.worldPosition),this.mode==="scale"&&(e="local"),this.unitX.set(1,0,0).applyQuaternion(e==="local"?this.worldQuaternion:this.identityQuaternion),this.unitY.set(0,1,0).applyQuaternion(e==="local"?this.worldQuaternion:this.identityQuaternion),this.unitZ.set(0,0,1).applyQuaternion(e==="local"?this.worldQuaternion:this.identityQuaternion),this.alignVector.copy(this.unitY),this.mode){case"translate":case"scale":switch(this.axis){case"X":this.alignVector.copy(this.eye).cross(this.unitX),this.dirVector.copy(this.unitX).cross(this.alignVector);break;case"Y":this.alignVector.copy(this.eye).cross(this.unitY),this.dirVector.copy(this.unitY).cross(this.alignVector);break;case"Z":this.alignVector.copy(this.eye).cross(this.unitZ),this.dirVector.copy(this.unitZ).cross(this.alignVector);break;case"XY":this.dirVector.copy(this.unitZ);break;case"YZ":this.dirVector.copy(this.unitX);break;case"XZ":this.alignVector.copy(this.unitZ),this.dirVector.copy(this.unitY);break;case"XYZ":case"E":this.dirVector.set(0,0,0);break}break;case"rotate":default:this.dirVector.set(0,0,0)}this.dirVector.length()===0?this.quaternion.copy(this.cameraQuaternion):(this.tempMatrix.lookAt(this.tempVector.set(0,0,0),this.dirVector,this.alignVector),this.quaternion.setFromRotationMatrix(this.tempMatrix)),super.updateMatrixWorld()})}}var zo=Object.defineProperty,Vo=(o,e,t)=>e in o?zo(o,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):o[e]=t,Ie=(o,e,t)=>(Vo(o,typeof e!="symbol"?e+"":e,t),t);const Dt=new l.Euler(0,0,0,"YXZ"),It=new l.Vector3,Ro={type:"change"},Go={type:"lock"},jo={type:"unlock"},ri=Math.PI/2;class Kn extends l.EventDispatcher{constructor(e,t){super(),Ie(this,"camera"),Ie(this,"domElement"),Ie(this,"isLocked"),Ie(this,"minPolarAngle"),Ie(this,"maxPolarAngle"),Ie(this,"pointerSpeed"),Ie(this,"onMouseMove",n=>{if(!this.domElement||this.isLocked===!1)return;const r=n.movementX||n.mozMovementX||n.webkitMovementX||0,i=n.movementY||n.mozMovementY||n.webkitMovementY||0;Dt.setFromQuaternion(this.camera.quaternion),Dt.y-=r*.002*this.pointerSpeed,Dt.x-=i*.002*this.pointerSpeed,Dt.x=Math.max(ri-this.maxPolarAngle,Math.min(ri-this.minPolarAngle,Dt.x)),this.camera.quaternion.setFromEuler(Dt),this.dispatchEvent(Ro)}),Ie(this,"onPointerlockChange",()=>{this.domElement&&(this.domElement.ownerDocument.pointerLockElement===this.domElement?(this.dispatchEvent(Go),this.isLocked=!0):(this.dispatchEvent(jo),this.isLocked=!1))}),Ie(this,"onPointerlockError",()=>{console.error("THREE.PointerLockControls: Unable to use Pointer Lock API")}),Ie(this,"connect",n=>{this.domElement=n||this.domElement,this.domElement&&(this.domElement.ownerDocument.addEventListener("mousemove",this.onMouseMove),this.domElement.ownerDocument.addEventListener("pointerlockchange",this.onPointerlockChange),this.domElement.ownerDocument.addEventListener("pointerlockerror",this.onPointerlockError))}),Ie(this,"disconnect",()=>{this.domElement&&(this.domElement.ownerDocument.removeEventListener("mousemove",this.onMouseMove),this.domElement.ownerDocument.removeEventListener("pointerlockchange",this.onPointerlockChange),this.domElement.ownerDocument.removeEventListener("pointerlockerror",this.onPointerlockError))}),Ie(this,"dispose",()=>{this.disconnect()}),Ie(this,"getObject",()=>this.camera),Ie(this,"direction",new l.Vector3(0,0,-1)),Ie(this,"getDirection",n=>n.copy(this.direction).applyQuaternion(this.camera.quaternion)),Ie(this,"moveForward",n=>{It.setFromMatrixColumn(this.camera.matrix,0),It.crossVectors(this.camera.up,It),this.camera.position.addScaledVector(It,n)}),Ie(this,"moveRight",n=>{It.setFromMatrixColumn(this.camera.matrix,0),this.camera.position.addScaledVector(It,n)}),Ie(this,"lock",()=>{this.domElement&&this.domElement.requestPointerLock()}),Ie(this,"unlock",()=>{this.domElement&&this.domElement.ownerDocument.exitPointerLock()}),this.camera=e,this.domElement=t,this.isLocked=!1,this.minPolarAngle=0,this.maxPolarAngle=Math.PI,this.pointerSpeed=1,t&&this.connect(t)}}var Eo=Object.defineProperty,Wo=(o,e,t)=>e in o?Eo(o,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):o[e]=t,fe=(o,e,t)=>(Wo(o,typeof e!="symbol"?e+"":e,t),t);const yn=new l.Ray,ii=new l.Plane,Yo=Math.cos(70*(Math.PI/180)),si=(o,e)=>(o%e+e)%e;class oi extends l.EventDispatcher{constructor(e,t){super(),fe(this,"object"),fe(this,"domElement"),fe(this,"enabled",!0),fe(this,"target",new l.Vector3),fe(this,"minDistance",0),fe(this,"maxDistance",1/0),fe(this,"minZoom",0),fe(this,"maxZoom",1/0),fe(this,"minPolarAngle",0),fe(this,"maxPolarAngle",Math.PI),fe(this,"minAzimuthAngle",-1/0),fe(this,"maxAzimuthAngle",1/0),fe(this,"enableDamping",!1),fe(this,"dampingFactor",.05),fe(this,"enableZoom",!0),fe(this,"zoomSpeed",1),fe(this,"enableRotate",!0),fe(this,"rotateSpeed",1),fe(this,"enablePan",!0),fe(this,"panSpeed",1),fe(this,"screenSpacePanning",!0),fe(this,"keyPanSpeed",7),fe(this,"zoomToCursor",!1),fe(this,"autoRotate",!1),fe(this,"autoRotateSpeed",2),fe(this,"reverseOrbit",!1),fe(this,"reverseHorizontalOrbit",!1),fe(this,"reverseVerticalOrbit",!1),fe(this,"keys",{LEFT:"ArrowLeft",UP:"ArrowUp",RIGHT:"ArrowRight",BOTTOM:"ArrowDown"}),fe(this,"mouseButtons",{LEFT:l.MOUSE.ROTATE,MIDDLE:l.MOUSE.DOLLY,RIGHT:l.MOUSE.PAN}),fe(this,"touches",{ONE:l.TOUCH.ROTATE,TWO:l.TOUCH.DOLLY_PAN}),fe(this,"target0"),fe(this,"position0"),fe(this,"zoom0"),fe(this,"_domElementKeyEvents",null),fe(this,"getPolarAngle"),fe(this,"getAzimuthalAngle"),fe(this,"setPolarAngle"),fe(this,"setAzimuthalAngle"),fe(this,"getDistance"),fe(this,"listenToKeyEvents"),fe(this,"stopListenToKeyEvents"),fe(this,"saveState"),fe(this,"reset"),fe(this,"update"),fe(this,"connect"),fe(this,"dispose"),this.object=e,this.domElement=t,this.target0=this.target.clone(),this.position0=this.object.position.clone(),this.zoom0=this.object.zoom,this.getPolarAngle=()=>f.phi,this.getAzimuthalAngle=()=>f.theta,this.setPolarAngle=W=>{let se=si(W,2*Math.PI),pe=f.phi;pe<0&&(pe+=2*Math.PI),se<0&&(se+=2*Math.PI);let Me=Math.abs(se-pe);2*Math.PI-Me<Me&&(se<pe?se+=2*Math.PI:pe+=2*Math.PI),d.phi=se-pe,n.update()},this.setAzimuthalAngle=W=>{let se=si(W,2*Math.PI),pe=f.theta;pe<0&&(pe+=2*Math.PI),se<0&&(se+=2*Math.PI);let Me=Math.abs(se-pe);2*Math.PI-Me<Me&&(se<pe?se+=2*Math.PI:pe+=2*Math.PI),d.theta=se-pe,n.update()},this.getDistance=()=>n.object.position.distanceTo(n.target),this.listenToKeyEvents=W=>{W.addEventListener("keydown",jt),this._domElementKeyEvents=W},this.stopListenToKeyEvents=()=>{this._domElementKeyEvents.removeEventListener("keydown",jt),this._domElementKeyEvents=null},this.saveState=()=>{n.target0.copy(n.target),n.position0.copy(n.object.position),n.zoom0=n.object.zoom},this.reset=()=>{n.target.copy(n.target0),n.object.position.copy(n.position0),n.object.zoom=n.zoom0,n.object.updateProjectionMatrix(),n.dispatchEvent(r),n.update(),c=a.NONE},this.update=(()=>{const W=new l.Vector3,se=new l.Vector3(0,1,0),pe=new l.Quaternion().setFromUnitVectors(e.up,se),Me=pe.clone().invert(),ke=new l.Vector3,ct=new l.Quaternion,wt=2*Math.PI;return function(){const Ys=n.object.position;pe.setFromUnitVectors(e.up,se),Me.copy(pe).invert(),W.copy(Ys).sub(n.target),W.applyQuaternion(pe),f.setFromVector3(W),n.autoRotate&&c===a.NONE&&G(k()),n.enableDamping?(f.theta+=d.theta*n.dampingFactor,f.phi+=d.phi*n.dampingFactor):(f.theta+=d.theta,f.phi+=d.phi);let ut=n.minAzimuthAngle,ht=n.maxAzimuthAngle;isFinite(ut)&&isFinite(ht)&&(ut<-Math.PI?ut+=wt:ut>Math.PI&&(ut-=wt),ht<-Math.PI?ht+=wt:ht>Math.PI&&(ht-=wt),ut<=ht?f.theta=Math.max(ut,Math.min(ht,f.theta)):f.theta=f.theta>(ut+ht)/2?Math.max(ut,f.theta):Math.min(ht,f.theta)),f.phi=Math.max(n.minPolarAngle,Math.min(n.maxPolarAngle,f.phi)),f.makeSafe(),n.enableDamping===!0?n.target.addScaledVector(m,n.dampingFactor):n.target.add(m),n.zoomToCursor&&A||n.object.isOrthographicCamera?f.radius=j(f.radius):f.radius=j(f.radius*p),W.setFromSpherical(f),W.applyQuaternion(Me),Ys.copy(n.target).add(W),n.object.matrixAutoUpdate||n.object.updateMatrix(),n.object.lookAt(n.target),n.enableDamping===!0?(d.theta*=1-n.dampingFactor,d.phi*=1-n.dampingFactor,m.multiplyScalar(1-n.dampingFactor)):(d.set(0,0,0),m.set(0,0,0));let hn=!1;if(n.zoomToCursor&&A){let fn=null;if(n.object instanceof l.PerspectiveCamera&&n.object.isPerspectiveCamera){const dn=W.length();fn=j(dn*p);const zn=dn-fn;n.object.position.addScaledVector(C,zn),n.object.updateMatrixWorld()}else if(n.object.isOrthographicCamera){const dn=new l.Vector3(y.x,y.y,0);dn.unproject(n.object),n.object.zoom=Math.max(n.minZoom,Math.min(n.maxZoom,n.object.zoom/p)),n.object.updateProjectionMatrix(),hn=!0;const zn=new l.Vector3(y.x,y.y,0);zn.unproject(n.object),n.object.position.sub(zn).add(dn),n.object.updateMatrixWorld(),fn=W.length()}else console.warn("WARNING: OrbitControls.js encountered an unknown camera type - zoom to cursor disabled."),n.zoomToCursor=!1;fn!==null&&(n.screenSpacePanning?n.target.set(0,0,-1).transformDirection(n.object.matrix).multiplyScalar(fn).add(n.object.position):(yn.origin.copy(n.object.position),yn.direction.set(0,0,-1).transformDirection(n.object.matrix),Math.abs(n.object.up.dot(yn.direction))<Yo?e.lookAt(n.target):(ii.setFromNormalAndCoplanarPoint(n.object.up,n.target),yn.intersectPlane(ii,n.target))))}else n.object instanceof l.OrthographicCamera&&n.object.isOrthographicCamera&&(hn=p!==1,hn&&(n.object.zoom=Math.max(n.minZoom,Math.min(n.maxZoom,n.object.zoom/p)),n.object.updateProjectionMatrix()));return p=1,A=!1,hn||ke.distanceToSquared(n.object.position)>h||8*(1-ct.dot(n.object.quaternion))>h?(n.dispatchEvent(r),ke.copy(n.object.position),ct.copy(n.object.quaternion),hn=!1,!0):!1}})(),this.connect=W=>{W===document&&console.error('THREE.OrbitControls: "document" should not be used as the target "domElement". Please use "renderer.domElement" instead.'),n.domElement=W,n.domElement.style.touchAction="none",n.domElement.addEventListener("contextmenu",js),n.domElement.addEventListener("pointerdown",ye),n.domElement.addEventListener("pointercancel",lt),n.domElement.addEventListener("wheel",qe)},this.dispose=()=>{var W,se,pe,Me,ke,ct;(W=n.domElement)==null||W.removeEventListener("contextmenu",js),(se=n.domElement)==null||se.removeEventListener("pointerdown",ye),(pe=n.domElement)==null||pe.removeEventListener("pointercancel",lt),(Me=n.domElement)==null||Me.removeEventListener("wheel",qe),(ke=n.domElement)==null||ke.ownerDocument.removeEventListener("pointermove",_e),(ct=n.domElement)==null||ct.ownerDocument.removeEventListener("pointerup",Oe),n._domElementKeyEvents!==null&&n._domElementKeyEvents.removeEventListener("keydown",jt)};const n=this,r={type:"change"},i={type:"start"},s={type:"end"},a={NONE:-1,ROTATE:0,DOLLY:1,PAN:2,TOUCH_ROTATE:3,TOUCH_PAN:4,TOUCH_DOLLY_PAN:5,TOUCH_DOLLY_ROTATE:6};let c=a.NONE;const h=1e-6,f=new l.Spherical,d=new l.Spherical;let p=1;const m=new l.Vector3,x=new l.Vector2,b=new l.Vector2,v=new l.Vector2,_=new l.Vector2,T=new l.Vector2,w=new l.Vector2,M=new l.Vector2,D=new l.Vector2,S=new l.Vector2,C=new l.Vector3,y=new l.Vector2;let A=!1;const g=[],I={};function k(){return 2*Math.PI/60/60*n.autoRotateSpeed}function J(){return Math.pow(.95,n.zoomSpeed)}function G(W){n.reverseOrbit||n.reverseHorizontalOrbit?d.theta+=W:d.theta-=W}function Z(W){n.reverseOrbit||n.reverseVerticalOrbit?d.phi+=W:d.phi-=W}const X=(()=>{const W=new l.Vector3;return function(pe,Me){W.setFromMatrixColumn(Me,0),W.multiplyScalar(-pe),m.add(W)}})(),K=(()=>{const W=new l.Vector3;return function(pe,Me){n.screenSpacePanning===!0?W.setFromMatrixColumn(Me,1):(W.setFromMatrixColumn(Me,0),W.crossVectors(n.object.up,W)),W.multiplyScalar(pe),m.add(W)}})(),Y=(()=>{const W=new l.Vector3;return function(pe,Me){const ke=n.domElement;if(ke&&n.object instanceof l.PerspectiveCamera&&n.object.isPerspectiveCamera){const ct=n.object.position;W.copy(ct).sub(n.target);let wt=W.length();wt*=Math.tan(n.object.fov/2*Math.PI/180),X(2*pe*wt/ke.clientHeight,n.object.matrix),K(2*Me*wt/ke.clientHeight,n.object.matrix)}else ke&&n.object instanceof l.OrthographicCamera&&n.object.isOrthographicCamera?(X(pe*(n.object.right-n.object.left)/n.object.zoom/ke.clientWidth,n.object.matrix),K(Me*(n.object.top-n.object.bottom)/n.object.zoom/ke.clientHeight,n.object.matrix)):(console.warn("WARNING: OrbitControls.js encountered an unknown camera type - pan disabled."),n.enablePan=!1)}})();function te(W){n.object instanceof l.PerspectiveCamera&&n.object.isPerspectiveCamera||n.object instanceof l.OrthographicCamera&&n.object.isOrthographicCamera?p/=W:(console.warn("WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."),n.enableZoom=!1)}function re(W){n.object instanceof l.PerspectiveCamera&&n.object.isPerspectiveCamera||n.object instanceof l.OrthographicCamera&&n.object.isOrthographicCamera?p*=W:(console.warn("WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."),n.enableZoom=!1)}function ce(W){if(!n.zoomToCursor||!n.domElement)return;A=!0;const se=n.domElement.getBoundingClientRect(),pe=W.clientX-se.left,Me=W.clientY-se.top,ke=se.width,ct=se.height;y.x=pe/ke*2-1,y.y=-(Me/ct)*2+1,C.set(y.x,y.y,1).unproject(n.object).sub(n.object.position).normalize()}function j(W){return Math.max(n.minDistance,Math.min(n.maxDistance,W))}function z(W){x.set(W.clientX,W.clientY)}function P(W){ce(W),M.set(W.clientX,W.clientY)}function V(W){_.set(W.clientX,W.clientY)}function ee(W){b.set(W.clientX,W.clientY),v.subVectors(b,x).multiplyScalar(n.rotateSpeed);const se=n.domElement;se&&(G(2*Math.PI*v.x/se.clientHeight),Z(2*Math.PI*v.y/se.clientHeight)),x.copy(b),n.update()}function N(W){D.set(W.clientX,W.clientY),S.subVectors(D,M),S.y>0?te(J()):S.y<0&&re(J()),M.copy(D),n.update()}function R(W){T.set(W.clientX,W.clientY),w.subVectors(T,_).multiplyScalar(n.panSpeed),Y(w.x,w.y),_.copy(T),n.update()}function L(W){ce(W),W.deltaY<0?re(J()):W.deltaY>0&&te(J()),n.update()}function O(W){let se=!1;switch(W.code){case n.keys.UP:Y(0,n.keyPanSpeed),se=!0;break;case n.keys.BOTTOM:Y(0,-n.keyPanSpeed),se=!0;break;case n.keys.LEFT:Y(n.keyPanSpeed,0),se=!0;break;case n.keys.RIGHT:Y(-n.keyPanSpeed,0),se=!0;break}se&&(W.preventDefault(),n.update())}function B(){if(g.length==1)x.set(g[0].pageX,g[0].pageY);else{const W=.5*(g[0].pageX+g[1].pageX),se=.5*(g[0].pageY+g[1].pageY);x.set(W,se)}}function E(){if(g.length==1)_.set(g[0].pageX,g[0].pageY);else{const W=.5*(g[0].pageX+g[1].pageX),se=.5*(g[0].pageY+g[1].pageY);_.set(W,se)}}function Q(){const W=g[0].pageX-g[1].pageX,se=g[0].pageY-g[1].pageY,pe=Math.sqrt(W*W+se*se);M.set(0,pe)}function q(){n.enableZoom&&Q(),n.enablePan&&E()}function ne(){n.enableZoom&&Q(),n.enableRotate&&B()}function U(W){if(g.length==1)b.set(W.pageX,W.pageY);else{const pe=Vr(W),Me=.5*(W.pageX+pe.x),ke=.5*(W.pageY+pe.y);b.set(Me,ke)}v.subVectors(b,x).multiplyScalar(n.rotateSpeed);const se=n.domElement;se&&(G(2*Math.PI*v.x/se.clientHeight),Z(2*Math.PI*v.y/se.clientHeight)),x.copy(b)}function F(W){if(g.length==1)T.set(W.pageX,W.pageY);else{const se=Vr(W),pe=.5*(W.pageX+se.x),Me=.5*(W.pageY+se.y);T.set(pe,Me)}w.subVectors(T,_).multiplyScalar(n.panSpeed),Y(w.x,w.y),_.copy(T)}function ae(W){const se=Vr(W),pe=W.pageX-se.x,Me=W.pageY-se.y,ke=Math.sqrt(pe*pe+Me*Me);D.set(0,ke),S.set(0,Math.pow(D.y/M.y,n.zoomSpeed)),te(S.y),M.copy(D)}function ue(W){n.enableZoom&&ae(W),n.enablePan&&F(W)}function me(W){n.enableZoom&&ae(W),n.enableRotate&&U(W)}function ye(W){var se,pe;n.enabled!==!1&&(g.length===0&&((se=n.domElement)==null||se.ownerDocument.addEventListener("pointermove",_e),(pe=n.domElement)==null||pe.ownerDocument.addEventListener("pointerup",Oe)),_d(W),W.pointerType==="touch"?yd(W):un(W))}function _e(W){n.enabled!==!1&&(W.pointerType==="touch"?vd(W):Gt(W))}function Oe(W){var se,pe,Me;Es(W),g.length===0&&((se=n.domElement)==null||se.releasePointerCapture(W.pointerId),(pe=n.domElement)==null||pe.ownerDocument.removeEventListener("pointermove",_e),(Me=n.domElement)==null||Me.ownerDocument.removeEventListener("pointerup",Oe)),n.dispatchEvent(s),c=a.NONE}function lt(W){Es(W)}function un(W){let se;switch(W.button){case 0:se=n.mouseButtons.LEFT;break;case 1:se=n.mouseButtons.MIDDLE;break;case 2:se=n.mouseButtons.RIGHT;break;default:se=-1}switch(se){case l.MOUSE.DOLLY:if(n.enableZoom===!1)return;P(W),c=a.DOLLY;break;case l.MOUSE.ROTATE:if(W.ctrlKey||W.metaKey||W.shiftKey){if(n.enablePan===!1)return;V(W),c=a.PAN}else{if(n.enableRotate===!1)return;z(W),c=a.ROTATE}break;case l.MOUSE.PAN:if(W.ctrlKey||W.metaKey||W.shiftKey){if(n.enableRotate===!1)return;z(W),c=a.ROTATE}else{if(n.enablePan===!1)return;V(W),c=a.PAN}break;default:c=a.NONE}c!==a.NONE&&n.dispatchEvent(i)}function Gt(W){if(n.enabled!==!1)switch(c){case a.ROTATE:if(n.enableRotate===!1)return;ee(W);break;case a.DOLLY:if(n.enableZoom===!1)return;N(W);break;case a.PAN:if(n.enablePan===!1)return;R(W);break}}function qe(W){n.enabled===!1||n.enableZoom===!1||c!==a.NONE&&c!==a.ROTATE||(W.preventDefault(),n.dispatchEvent(i),L(W),n.dispatchEvent(s))}function jt(W){n.enabled===!1||n.enablePan===!1||O(W)}function yd(W){switch(Ws(W),g.length){case 1:switch(n.touches.ONE){case l.TOUCH.ROTATE:if(n.enableRotate===!1)return;B(),c=a.TOUCH_ROTATE;break;case l.TOUCH.PAN:if(n.enablePan===!1)return;E(),c=a.TOUCH_PAN;break;default:c=a.NONE}break;case 2:switch(n.touches.TWO){case l.TOUCH.DOLLY_PAN:if(n.enableZoom===!1&&n.enablePan===!1)return;q(),c=a.TOUCH_DOLLY_PAN;break;case l.TOUCH.DOLLY_ROTATE:if(n.enableZoom===!1&&n.enableRotate===!1)return;ne(),c=a.TOUCH_DOLLY_ROTATE;break;default:c=a.NONE}break;default:c=a.NONE}c!==a.NONE&&n.dispatchEvent(i)}function vd(W){switch(Ws(W),c){case a.TOUCH_ROTATE:if(n.enableRotate===!1)return;U(W),n.update();break;case a.TOUCH_PAN:if(n.enablePan===!1)return;F(W),n.update();break;case a.TOUCH_DOLLY_PAN:if(n.enableZoom===!1&&n.enablePan===!1)return;ue(W),n.update();break;case a.TOUCH_DOLLY_ROTATE:if(n.enableZoom===!1&&n.enableRotate===!1)return;me(W),n.update();break;default:c=a.NONE}}function js(W){n.enabled!==!1&&W.preventDefault()}function _d(W){g.push(W)}function Es(W){delete I[W.pointerId];for(let se=0;se<g.length;se++)if(g[se].pointerId==W.pointerId){g.splice(se,1);return}}function Ws(W){let se=I[W.pointerId];se===void 0&&(se=new l.Vector2,I[W.pointerId]=se),se.set(W.pageX,W.pageY)}function Vr(W){const se=W.pointerId===g[0].pointerId?g[1]:g[0];return I[se.pointerId]}t!==void 0&&this.connect(t),this.update()}}class Xo extends oi{constructor(e,t){super(e,t),this.screenSpacePanning=!1,this.mouseButtons.LEFT=l.MOUSE.PAN,this.mouseButtons.RIGHT=l.MOUSE.ROTATE,this.touches.ONE=l.TOUCH.PAN,this.touches.TWO=l.TOUCH.DOLLY_ROTATE}}class Zo extends l.Loader{constructor(e){super(e),this.dracoLoader=null,this.ktx2Loader=null,this.meshoptDecoder=null,this.pluginCallbacks=[],this.register(function(t){return new Ho(t)}),this.register(function(t){return new oa(t)}),this.register(function(t){return new aa(t)}),this.register(function(t){return new la(t)}),this.register(function(t){return new ea(t)}),this.register(function(t){return new ta(t)}),this.register(function(t){return new na(t)}),this.register(function(t){return new ra(t)}),this.register(function(t){return new Jo(t)}),this.register(function(t){return new ia(t)}),this.register(function(t){return new $o(t)}),this.register(function(t){return new sa(t)}),this.register(function(t){return new qo(t)}),this.register(function(t){return new ca(t)}),this.register(function(t){return new ua(t)})}load(e,t,n,r){const i=this;let s;this.resourcePath!==""?s=this.resourcePath:this.path!==""?s=this.path:s=l.LoaderUtils.extractUrlBase(e),this.manager.itemStart(e);const a=function(h){r?r(h):console.error(h),i.manager.itemError(e),i.manager.itemEnd(e)},c=new l.FileLoader(this.manager);c.setPath(this.path),c.setResponseType("arraybuffer"),c.setRequestHeader(this.requestHeader),c.setWithCredentials(this.withCredentials),c.load(e,function(h){try{i.parse(h,s,function(f){t(f),i.manager.itemEnd(e)},a)}catch(f){a(f)}},n,a)}setDRACOLoader(e){return this.dracoLoader=e,this}setDDSLoader(){throw new Error('THREE.GLTFLoader: "MSFT_texture_dds" no longer supported. Please update to "KHR_texture_basisu".')}setKTX2Loader(e){return this.ktx2Loader=e,this}setMeshoptDecoder(e){return this.meshoptDecoder=e,this}register(e){return this.pluginCallbacks.indexOf(e)===-1&&this.pluginCallbacks.push(e),this}unregister(e){return this.pluginCallbacks.indexOf(e)!==-1&&this.pluginCallbacks.splice(this.pluginCallbacks.indexOf(e),1),this}parse(e,t,n,r){let i;const s={},a={};if(typeof e=="string")i=JSON.parse(e);else if(e instanceof ArrayBuffer)if(l.LoaderUtils.decodeText(new Uint8Array(e.slice(0,4)))===ai){try{s[we.KHR_BINARY_GLTF]=new ha(e)}catch(f){r&&r(f);return}i=JSON.parse(s[we.KHR_BINARY_GLTF].content)}else i=JSON.parse(l.LoaderUtils.decodeText(new Uint8Array(e)));else i=e;if(i.asset===void 0||i.asset.version[0]<2){r&&r(new Error("THREE.GLTFLoader: Unsupported asset. glTF versions >=2.0 are supported."));return}const c=new Sa(i,{path:t||this.resourcePath||"",crossOrigin:this.crossOrigin,requestHeader:this.requestHeader,manager:this.manager,ktx2Loader:this.ktx2Loader,meshoptDecoder:this.meshoptDecoder});c.fileLoader.setRequestHeader(this.requestHeader);for(let h=0;h<this.pluginCallbacks.length;h++){const f=this.pluginCallbacks[h](c);a[f.name]=f,s[f.name]=!0}if(i.extensionsUsed)for(let h=0;h<i.extensionsUsed.length;++h){const f=i.extensionsUsed[h],d=i.extensionsRequired||[];switch(f){case we.KHR_MATERIALS_UNLIT:s[f]=new Qo;break;case we.KHR_DRACO_MESH_COMPRESSION:s[f]=new fa(i,this.dracoLoader);break;case we.KHR_TEXTURE_TRANSFORM:s[f]=new da;break;case we.KHR_MESH_QUANTIZATION:s[f]=new pa;break;default:d.indexOf(f)>=0&&a[f]===void 0&&console.warn('THREE.GLTFLoader: Unknown extension "'+f+'".')}}c.setExtensions(s),c.setPlugins(a),c.parse(n,r)}parseAsync(e,t){const n=this;return new Promise(function(r,i){n.parse(e,t,r,i)})}}function Ko(){let o={};return{get:function(e){return o[e]},add:function(e,t){o[e]=t},remove:function(e){delete o[e]},removeAll:function(){o={}}}}const we={KHR_BINARY_GLTF:"KHR_binary_glTF",KHR_DRACO_MESH_COMPRESSION:"KHR_draco_mesh_compression",KHR_LIGHTS_PUNCTUAL:"KHR_lights_punctual",KHR_MATERIALS_CLEARCOAT:"KHR_materials_clearcoat",KHR_MATERIALS_IOR:"KHR_materials_ior",KHR_MATERIALS_SHEEN:"KHR_materials_sheen",KHR_MATERIALS_SPECULAR:"KHR_materials_specular",KHR_MATERIALS_TRANSMISSION:"KHR_materials_transmission",KHR_MATERIALS_IRIDESCENCE:"KHR_materials_iridescence",KHR_MATERIALS_ANISOTROPY:"KHR_materials_anisotropy",KHR_MATERIALS_UNLIT:"KHR_materials_unlit",KHR_MATERIALS_VOLUME:"KHR_materials_volume",KHR_TEXTURE_BASISU:"KHR_texture_basisu",KHR_TEXTURE_TRANSFORM:"KHR_texture_transform",KHR_MESH_QUANTIZATION:"KHR_mesh_quantization",KHR_MATERIALS_EMISSIVE_STRENGTH:"KHR_materials_emissive_strength",EXT_TEXTURE_WEBP:"EXT_texture_webp",EXT_TEXTURE_AVIF:"EXT_texture_avif",EXT_MESHOPT_COMPRESSION:"EXT_meshopt_compression",EXT_MESH_GPU_INSTANCING:"EXT_mesh_gpu_instancing"};class qo{constructor(e){this.parser=e,this.name=we.KHR_LIGHTS_PUNCTUAL,this.cache={refs:{},uses:{}}}_markDefs(){const e=this.parser,t=this.parser.json.nodes||[];for(let n=0,r=t.length;n<r;n++){const i=t[n];i.extensions&&i.extensions[this.name]&&i.extensions[this.name].light!==void 0&&e._addNodeRef(this.cache,i.extensions[this.name].light)}}_loadLight(e){const t=this.parser,n="light:"+e;let r=t.cache.get(n);if(r)return r;const i=t.json,c=((i.extensions&&i.extensions[this.name]||{}).lights||[])[e];let h;const f=new l.Color(16777215);c.color!==void 0&&f.fromArray(c.color);const d=c.range!==void 0?c.range:0;switch(c.type){case"directional":h=new l.DirectionalLight(f),h.target.position.set(0,0,-1),h.add(h.target);break;case"point":h=new l.PointLight(f),h.distance=d;break;case"spot":h=new l.SpotLight(f),h.distance=d,c.spot=c.spot||{},c.spot.innerConeAngle=c.spot.innerConeAngle!==void 0?c.spot.innerConeAngle:0,c.spot.outerConeAngle=c.spot.outerConeAngle!==void 0?c.spot.outerConeAngle:Math.PI/4,h.angle=c.spot.outerConeAngle,h.penumbra=1-c.spot.innerConeAngle/c.spot.outerConeAngle,h.target.position.set(0,0,-1),h.add(h.target);break;default:throw new Error("THREE.GLTFLoader: Unexpected light type: "+c.type)}return h.position.set(0,0,0),h.decay=2,mt(h,c),c.intensity!==void 0&&(h.intensity=c.intensity),h.name=t.createUniqueName(c.name||"light_"+e),r=Promise.resolve(h),t.cache.add(n,r),r}getDependency(e,t){if(e==="light")return this._loadLight(t)}createNodeAttachment(e){const t=this,n=this.parser,i=n.json.nodes[e],a=(i.extensions&&i.extensions[this.name]||{}).light;return a===void 0?null:this._loadLight(a).then(function(c){return n._getNodeRef(t.cache,a,c)})}}class Qo{constructor(){this.name=we.KHR_MATERIALS_UNLIT}getMaterialType(){return l.MeshBasicMaterial}extendParams(e,t,n){const r=[];e.color=new l.Color(1,1,1),e.opacity=1;const i=t.pbrMetallicRoughness;if(i){if(Array.isArray(i.baseColorFactor)){const s=i.baseColorFactor;e.color.fromArray(s),e.opacity=s[3]}i.baseColorTexture!==void 0&&r.push(n.assignTexture(e,"map",i.baseColorTexture,3001))}return Promise.all(r)}}class Jo{constructor(e){this.parser=e,this.name=we.KHR_MATERIALS_EMISSIVE_STRENGTH}extendMaterialParams(e,t){const r=this.parser.json.materials[e];if(!r.extensions||!r.extensions[this.name])return Promise.resolve();const i=r.extensions[this.name].emissiveStrength;return i!==void 0&&(t.emissiveIntensity=i),Promise.resolve()}}class Ho{constructor(e){this.parser=e,this.name=we.KHR_MATERIALS_CLEARCOAT}getMaterialType(e){const n=this.parser.json.materials[e];return!n.extensions||!n.extensions[this.name]?null:l.MeshPhysicalMaterial}extendMaterialParams(e,t){const n=this.parser,r=n.json.materials[e];if(!r.extensions||!r.extensions[this.name])return Promise.resolve();const i=[],s=r.extensions[this.name];if(s.clearcoatFactor!==void 0&&(t.clearcoat=s.clearcoatFactor),s.clearcoatTexture!==void 0&&i.push(n.assignTexture(t,"clearcoatMap",s.clearcoatTexture)),s.clearcoatRoughnessFactor!==void 0&&(t.clearcoatRoughness=s.clearcoatRoughnessFactor),s.clearcoatRoughnessTexture!==void 0&&i.push(n.assignTexture(t,"clearcoatRoughnessMap",s.clearcoatRoughnessTexture)),s.clearcoatNormalTexture!==void 0&&(i.push(n.assignTexture(t,"clearcoatNormalMap",s.clearcoatNormalTexture)),s.clearcoatNormalTexture.scale!==void 0)){const a=s.clearcoatNormalTexture.scale;t.clearcoatNormalScale=new l.Vector2(a,a)}return Promise.all(i)}}class $o{constructor(e){this.parser=e,this.name=we.KHR_MATERIALS_IRIDESCENCE}getMaterialType(e){const n=this.parser.json.materials[e];return!n.extensions||!n.extensions[this.name]?null:l.MeshPhysicalMaterial}extendMaterialParams(e,t){const n=this.parser,r=n.json.materials[e];if(!r.extensions||!r.extensions[this.name])return Promise.resolve();const i=[],s=r.extensions[this.name];return s.iridescenceFactor!==void 0&&(t.iridescence=s.iridescenceFactor),s.iridescenceTexture!==void 0&&i.push(n.assignTexture(t,"iridescenceMap",s.iridescenceTexture)),s.iridescenceIor!==void 0&&(t.iridescenceIOR=s.iridescenceIor),t.iridescenceThicknessRange===void 0&&(t.iridescenceThicknessRange=[100,400]),s.iridescenceThicknessMinimum!==void 0&&(t.iridescenceThicknessRange[0]=s.iridescenceThicknessMinimum),s.iridescenceThicknessMaximum!==void 0&&(t.iridescenceThicknessRange[1]=s.iridescenceThicknessMaximum),s.iridescenceThicknessTexture!==void 0&&i.push(n.assignTexture(t,"iridescenceThicknessMap",s.iridescenceThicknessTexture)),Promise.all(i)}}class ea{constructor(e){this.parser=e,this.name=we.KHR_MATERIALS_SHEEN}getMaterialType(e){const n=this.parser.json.materials[e];return!n.extensions||!n.extensions[this.name]?null:l.MeshPhysicalMaterial}extendMaterialParams(e,t){const n=this.parser,r=n.json.materials[e];if(!r.extensions||!r.extensions[this.name])return Promise.resolve();const i=[];t.sheenColor=new l.Color(0,0,0),t.sheenRoughness=0,t.sheen=1;const s=r.extensions[this.name];return s.sheenColorFactor!==void 0&&t.sheenColor.fromArray(s.sheenColorFactor),s.sheenRoughnessFactor!==void 0&&(t.sheenRoughness=s.sheenRoughnessFactor),s.sheenColorTexture!==void 0&&i.push(n.assignTexture(t,"sheenColorMap",s.sheenColorTexture,3001)),s.sheenRoughnessTexture!==void 0&&i.push(n.assignTexture(t,"sheenRoughnessMap",s.sheenRoughnessTexture)),Promise.all(i)}}class ta{constructor(e){this.parser=e,this.name=we.KHR_MATERIALS_TRANSMISSION}getMaterialType(e){const n=this.parser.json.materials[e];return!n.extensions||!n.extensions[this.name]?null:l.MeshPhysicalMaterial}extendMaterialParams(e,t){const n=this.parser,r=n.json.materials[e];if(!r.extensions||!r.extensions[this.name])return Promise.resolve();const i=[],s=r.extensions[this.name];return s.transmissionFactor!==void 0&&(t.transmission=s.transmissionFactor),s.transmissionTexture!==void 0&&i.push(n.assignTexture(t,"transmissionMap",s.transmissionTexture)),Promise.all(i)}}class na{constructor(e){this.parser=e,this.name=we.KHR_MATERIALS_VOLUME}getMaterialType(e){const n=this.parser.json.materials[e];return!n.extensions||!n.extensions[this.name]?null:l.MeshPhysicalMaterial}extendMaterialParams(e,t){const n=this.parser,r=n.json.materials[e];if(!r.extensions||!r.extensions[this.name])return Promise.resolve();const i=[],s=r.extensions[this.name];t.thickness=s.thicknessFactor!==void 0?s.thicknessFactor:0,s.thicknessTexture!==void 0&&i.push(n.assignTexture(t,"thicknessMap",s.thicknessTexture)),t.attenuationDistance=s.attenuationDistance||1/0;const a=s.attenuationColor||[1,1,1];return t.attenuationColor=new l.Color(a[0],a[1],a[2]),Promise.all(i)}}class ra{constructor(e){this.parser=e,this.name=we.KHR_MATERIALS_IOR}getMaterialType(e){const n=this.parser.json.materials[e];return!n.extensions||!n.extensions[this.name]?null:l.MeshPhysicalMaterial}extendMaterialParams(e,t){const r=this.parser.json.materials[e];if(!r.extensions||!r.extensions[this.name])return Promise.resolve();const i=r.extensions[this.name];return t.ior=i.ior!==void 0?i.ior:1.5,Promise.resolve()}}class ia{constructor(e){this.parser=e,this.name=we.KHR_MATERIALS_SPECULAR}getMaterialType(e){const n=this.parser.json.materials[e];return!n.extensions||!n.extensions[this.name]?null:l.MeshPhysicalMaterial}extendMaterialParams(e,t){const n=this.parser,r=n.json.materials[e];if(!r.extensions||!r.extensions[this.name])return Promise.resolve();const i=[],s=r.extensions[this.name];t.specularIntensity=s.specularFactor!==void 0?s.specularFactor:1,s.specularTexture!==void 0&&i.push(n.assignTexture(t,"specularIntensityMap",s.specularTexture));const a=s.specularColorFactor||[1,1,1];return t.specularColor=new l.Color(a[0],a[1],a[2]),s.specularColorTexture!==void 0&&i.push(n.assignTexture(t,"specularColorMap",s.specularColorTexture,3001)),Promise.all(i)}}class sa{constructor(e){this.parser=e,this.name=we.KHR_MATERIALS_ANISOTROPY}getMaterialType(e){const n=this.parser.json.materials[e];return!n.extensions||!n.extensions[this.name]?null:l.MeshPhysicalMaterial}extendMaterialParams(e,t){const n=this.parser,r=n.json.materials[e];if(!r.extensions||!r.extensions[this.name])return Promise.resolve();const i=[],s=r.extensions[this.name];return s.anisotropyStrength!==void 0&&(t.anisotropy=s.anisotropyStrength),s.anisotropyRotation!==void 0&&(t.anisotropyRotation=s.anisotropyRotation),s.anisotropyTexture!==void 0&&i.push(n.assignTexture(t,"anisotropyMap",s.anisotropyTexture)),Promise.all(i)}}class oa{constructor(e){this.parser=e,this.name=we.KHR_TEXTURE_BASISU}loadTexture(e){const t=this.parser,n=t.json,r=n.textures[e];if(!r.extensions||!r.extensions[this.name])return null;const i=r.extensions[this.name],s=t.options.ktx2Loader;if(!s){if(n.extensionsRequired&&n.extensionsRequired.indexOf(this.name)>=0)throw new Error("THREE.GLTFLoader: setKTX2Loader must be called before loading KTX2 textures");return null}return t.loadTextureImage(e,i.source,s)}}class aa{constructor(e){this.parser=e,this.name=we.EXT_TEXTURE_WEBP,this.isSupported=null}loadTexture(e){const t=this.name,n=this.parser,r=n.json,i=r.textures[e];if(!i.extensions||!i.extensions[t])return null;const s=i.extensions[t],a=r.images[s.source];let c=n.textureLoader;if(a.uri){const h=n.options.manager.getHandler(a.uri);h!==null&&(c=h)}return this.detectSupport().then(function(h){if(h)return n.loadTextureImage(e,s.source,c);if(r.extensionsRequired&&r.extensionsRequired.indexOf(t)>=0)throw new Error("THREE.GLTFLoader: WebP required by asset but unsupported.");return n.loadTexture(e)})}detectSupport(){return this.isSupported||(this.isSupported=new Promise(function(e){const t=new Image;t.src="data:image/webp;base64,UklGRiIAAABXRUJQVlA4IBYAAAAwAQCdASoBAAEADsD+JaQAA3AAAAAA",t.onload=t.onerror=function(){e(t.height===1)}})),this.isSupported}}class la{constructor(e){this.parser=e,this.name=we.EXT_TEXTURE_AVIF,this.isSupported=null}loadTexture(e){const t=this.name,n=this.parser,r=n.json,i=r.textures[e];if(!i.extensions||!i.extensions[t])return null;const s=i.extensions[t],a=r.images[s.source];let c=n.textureLoader;if(a.uri){const h=n.options.manager.getHandler(a.uri);h!==null&&(c=h)}return this.detectSupport().then(function(h){if(h)return n.loadTextureImage(e,s.source,c);if(r.extensionsRequired&&r.extensionsRequired.indexOf(t)>=0)throw new Error("THREE.GLTFLoader: AVIF required by asset but unsupported.");return n.loadTexture(e)})}detectSupport(){return this.isSupported||(this.isSupported=new Promise(function(e){const t=new Image;t.src="data:image/avif;base64,AAAAIGZ0eXBhdmlmAAAAAGF2aWZtaWYxbWlhZk1BMUIAAADybWV0YQAAAAAAAAAoaGRscgAAAAAAAAAAcGljdAAAAAAAAAAAAAAAAGxpYmF2aWYAAAAADnBpdG0AAAAAAAEAAAAeaWxvYwAAAABEAAABAAEAAAABAAABGgAAABcAAAAoaWluZgAAAAAAAQAAABppbmZlAgAAAAABAABhdjAxQ29sb3IAAAAAamlwcnAAAABLaXBjbwAAABRpc3BlAAAAAAAAAAEAAAABAAAAEHBpeGkAAAAAAwgICAAAAAxhdjFDgQAMAAAAABNjb2xybmNseAACAAIABoAAAAAXaXBtYQAAAAAAAAABAAEEAQKDBAAAAB9tZGF0EgAKCBgABogQEDQgMgkQAAAAB8dSLfI=",t.onload=t.onerror=function(){e(t.height===1)}})),this.isSupported}}class ca{constructor(e){this.name=we.EXT_MESHOPT_COMPRESSION,this.parser=e}loadBufferView(e){const t=this.parser.json,n=t.bufferViews[e];if(n.extensions&&n.extensions[this.name]){const r=n.extensions[this.name],i=this.parser.getDependency("buffer",r.buffer),s=this.parser.options.meshoptDecoder;if(!s||!s.supported){if(t.extensionsRequired&&t.extensionsRequired.indexOf(this.name)>=0)throw new Error("THREE.GLTFLoader: setMeshoptDecoder must be called before loading compressed files");return null}return i.then(function(a){const c=r.byteOffset||0,h=r.byteLength||0,f=r.count,d=r.byteStride,p=new Uint8Array(a,c,h);return s.decodeGltfBufferAsync?s.decodeGltfBufferAsync(f,d,p,r.mode,r.filter).then(function(m){return m.buffer}):s.ready.then(function(){const m=new ArrayBuffer(f*d);return s.decodeGltfBuffer(new Uint8Array(m),f,d,p,r.mode,r.filter),m})})}else return null}}class ua{constructor(e){this.name=we.EXT_MESH_GPU_INSTANCING,this.parser=e}createNodeMesh(e){const t=this.parser.json,n=t.nodes[e];if(!n.extensions||!n.extensions[this.name]||n.mesh===void 0)return null;const r=t.meshes[n.mesh];for(const h of r.primitives)if(h.mode!==Xe.TRIANGLES&&h.mode!==Xe.TRIANGLE_STRIP&&h.mode!==Xe.TRIANGLE_FAN&&h.mode!==void 0)return null;const s=n.extensions[this.name].attributes,a=[],c={};for(const h in s)a.push(this.parser.getDependency("accessor",s[h]).then(f=>(c[h]=f,c[h])));return a.length<1?null:(a.push(this.parser.createNodeMesh(e)),Promise.all(a).then(h=>{const f=h.pop(),d=f.isGroup?f.children:[f],p=h[0].count,m=[];for(const x of d){const b=new l.Matrix4,v=new l.Vector3,_=new l.Quaternion,T=new l.Vector3(1,1,1),w=new l.InstancedMesh(x.geometry,x.material,p);for(let M=0;M<p;M++)c.TRANSLATION&&v.fromBufferAttribute(c.TRANSLATION,M),c.ROTATION&&_.fromBufferAttribute(c.ROTATION,M),c.SCALE&&T.fromBufferAttribute(c.SCALE,M),w.setMatrixAt(M,b.compose(v,_,T));for(const M in c)M!=="TRANSLATION"&&M!=="ROTATION"&&M!=="SCALE"&&x.geometry.setAttribute(M,c[M]);l.Object3D.prototype.copy.call(w,x),this.parser.assignFinalMaterial(w),m.push(w)}return f.isGroup?(f.clear(),f.add(...m),f):m[0]}))}}const ai="glTF",Zt=12,li={JSON:1313821514,BIN:5130562};class ha{constructor(e){this.name=we.KHR_BINARY_GLTF,this.content=null,this.body=null;const t=new DataView(e,0,Zt);if(this.header={magic:l.LoaderUtils.decodeText(new Uint8Array(e.slice(0,4))),version:t.getUint32(4,!0),length:t.getUint32(8,!0)},this.header.magic!==ai)throw new Error("THREE.GLTFLoader: Unsupported glTF-Binary header.");if(this.header.version<2)throw new Error("THREE.GLTFLoader: Legacy binary file detected.");const n=this.header.length-Zt,r=new DataView(e,Zt);let i=0;for(;i<n;){const s=r.getUint32(i,!0);i+=4;const a=r.getUint32(i,!0);if(i+=4,a===li.JSON){const c=new Uint8Array(e,Zt+i,s);this.content=l.LoaderUtils.decodeText(c)}else if(a===li.BIN){const c=Zt+i;this.body=e.slice(c,c+s)}i+=s}if(this.content===null)throw new Error("THREE.GLTFLoader: JSON content not found.")}}class fa{constructor(e,t){if(!t)throw new Error("THREE.GLTFLoader: No DRACOLoader instance provided.");this.name=we.KHR_DRACO_MESH_COMPRESSION,this.json=e,this.dracoLoader=t,this.dracoLoader.preload()}decodePrimitive(e,t){const n=this.json,r=this.dracoLoader,i=e.extensions[this.name].bufferView,s=e.extensions[this.name].attributes,a={},c={},h={};for(const f in s){const d=Qn[f]||f.toLowerCase();a[d]=s[f]}for(const f in e.attributes){const d=Qn[f]||f.toLowerCase();if(s[f]!==void 0){const p=n.accessors[e.attributes[f]],m=Ot[p.componentType];h[d]=m.name,c[d]=p.normalized===!0}}return t.getDependency("bufferView",i).then(function(f){return new Promise(function(d){r.decodeDracoFile(f,function(p){for(const m in p.attributes){const x=p.attributes[m],b=c[m];b!==void 0&&(x.normalized=b)}d(p)},a,h)})})}}class da{constructor(){this.name=we.KHR_TEXTURE_TRANSFORM}extendTexture(e,t){return(t.texCoord===void 0||t.texCoord===e.channel)&&t.offset===void 0&&t.rotation===void 0&&t.scale===void 0||(e=e.clone(),t.texCoord!==void 0&&(e.channel=t.texCoord),t.offset!==void 0&&e.offset.fromArray(t.offset),t.rotation!==void 0&&(e.rotation=t.rotation),t.scale!==void 0&&e.repeat.fromArray(t.scale),e.needsUpdate=!0),e}}class pa{constructor(){this.name=we.KHR_MESH_QUANTIZATION}}class ci extends l.Interpolant{constructor(e,t,n,r){super(e,t,n,r)}copySampleValue_(e){const t=this.resultBuffer,n=this.sampleValues,r=this.valueSize,i=e*r*3+r;for(let s=0;s!==r;s++)t[s]=n[i+s];return t}interpolate_(e,t,n,r){const i=this.resultBuffer,s=this.sampleValues,a=this.valueSize,c=a*2,h=a*3,f=r-t,d=(n-t)/f,p=d*d,m=p*d,x=e*h,b=x-h,v=-2*m+3*p,_=m-p,T=1-v,w=_-p+d;for(let M=0;M!==a;M++){const D=s[b+M+a],S=s[b+M+c]*f,C=s[x+M+a],y=s[x+M]*f;i[M]=T*D+w*S+v*C+_*y}return i}}const ma=new l.Quaternion;class ga extends ci{interpolate_(e,t,n,r){const i=super.interpolate_(e,t,n,r);return ma.fromArray(i).normalize().toArray(i),i}}const Xe={FLOAT:5126,FLOAT_MAT3:35675,FLOAT_MAT4:35676,FLOAT_VEC2:35664,FLOAT_VEC3:35665,FLOAT_VEC4:35666,LINEAR:9729,REPEAT:10497,SAMPLER_2D:35678,POINTS:0,LINES:1,LINE_LOOP:2,LINE_STRIP:3,TRIANGLES:4,TRIANGLE_STRIP:5,TRIANGLE_FAN:6,UNSIGNED_BYTE:5121,UNSIGNED_SHORT:5123},Ot={5120:Int8Array,5121:Uint8Array,5122:Int16Array,5123:Uint16Array,5125:Uint32Array,5126:Float32Array},ui={9728:l.NearestFilter,9729:l.LinearFilter,9984:l.NearestMipmapNearestFilter,9985:l.LinearMipmapNearestFilter,9986:l.NearestMipmapLinearFilter,9987:l.LinearMipmapLinearFilter},hi={33071:l.ClampToEdgeWrapping,33648:l.MirroredRepeatWrapping,10497:l.RepeatWrapping},qn={SCALAR:1,VEC2:2,VEC3:3,VEC4:4,MAT2:4,MAT3:9,MAT4:16},Qn={POSITION:"position",NORMAL:"normal",TANGENT:"tangent",...jr>=152?{TEXCOORD_0:"uv",TEXCOORD_1:"uv1",TEXCOORD_2:"uv2",TEXCOORD_3:"uv3"}:{TEXCOORD_0:"uv",TEXCOORD_1:"uv2"},COLOR_0:"color",WEIGHTS_0:"skinWeight",JOINTS_0:"skinIndex"},pt={scale:"scale",translation:"position",rotation:"quaternion",weights:"morphTargetInfluences"},ya={CUBICSPLINE:void 0,LINEAR:l.InterpolateLinear,STEP:l.InterpolateDiscrete},Jn={OPAQUE:"OPAQUE",MASK:"MASK",BLEND:"BLEND"};function va(o){return o.DefaultMaterial===void 0&&(o.DefaultMaterial=new l.MeshStandardMaterial({color:16777215,emissive:0,metalness:1,roughness:1,transparent:!1,depthTest:!0,side:l.FrontSide})),o.DefaultMaterial}function bt(o,e,t){for(const n in t.extensions)o[n]===void 0&&(e.userData.gltfExtensions=e.userData.gltfExtensions||{},e.userData.gltfExtensions[n]=t.extensions[n])}function mt(o,e){e.extras!==void 0&&(typeof e.extras=="object"?Object.assign(o.userData,e.extras):console.warn("THREE.GLTFLoader: Ignoring primitive type .extras, "+e.extras))}function _a(o,e,t){let n=!1,r=!1,i=!1;for(let h=0,f=e.length;h<f;h++){const d=e[h];if(d.POSITION!==void 0&&(n=!0),d.NORMAL!==void 0&&(r=!0),d.COLOR_0!==void 0&&(i=!0),n&&r&&i)break}if(!n&&!r&&!i)return Promise.resolve(o);const s=[],a=[],c=[];for(let h=0,f=e.length;h<f;h++){const d=e[h];if(n){const p=d.POSITION!==void 0?t.getDependency("accessor",d.POSITION):o.attributes.position;s.push(p)}if(r){const p=d.NORMAL!==void 0?t.getDependency("accessor",d.NORMAL):o.attributes.normal;a.push(p)}if(i){const p=d.COLOR_0!==void 0?t.getDependency("accessor",d.COLOR_0):o.attributes.color;c.push(p)}}return Promise.all([Promise.all(s),Promise.all(a),Promise.all(c)]).then(function(h){const f=h[0],d=h[1],p=h[2];return n&&(o.morphAttributes.position=f),r&&(o.morphAttributes.normal=d),i&&(o.morphAttributes.color=p),o.morphTargetsRelative=!0,o})}function xa(o,e){if(o.updateMorphTargets(),e.weights!==void 0)for(let t=0,n=e.weights.length;t<n;t++)o.morphTargetInfluences[t]=e.weights[t];if(e.extras&&Array.isArray(e.extras.targetNames)){const t=e.extras.targetNames;if(o.morphTargetInfluences.length===t.length){o.morphTargetDictionary={};for(let n=0,r=t.length;n<r;n++)o.morphTargetDictionary[t[n]]=n}else console.warn("THREE.GLTFLoader: Invalid extras.targetNames length. Ignoring names.")}}function wa(o){let e;const t=o.extensions&&o.extensions[we.KHR_DRACO_MESH_COMPRESSION];if(t?e="draco:"+t.bufferView+":"+t.indices+":"+Hn(t.attributes):e=o.indices+":"+Hn(o.attributes)+":"+o.mode,o.targets!==void 0)for(let n=0,r=o.targets.length;n<r;n++)e+=":"+Hn(o.targets[n]);return e}function Hn(o){let e="";const t=Object.keys(o).sort();for(let n=0,r=t.length;n<r;n++)e+=t[n]+":"+o[t[n]]+";";return e}function $n(o){switch(o){case Int8Array:return 1/127;case Uint8Array:return 1/255;case Int16Array:return 1/32767;case Uint16Array:return 1/65535;default:throw new Error("THREE.GLTFLoader: Unsupported normalized accessor component type.")}}function ba(o){return o.search(/\.jpe?g($|\?)/i)>0||o.search(/^data\:image\/jpeg/)===0?"image/jpeg":o.search(/\.webp($|\?)/i)>0||o.search(/^data\:image\/webp/)===0?"image/webp":"image/png"}const Ma=new l.Matrix4;class Sa{constructor(e={},t={}){this.json=e,this.extensions={},this.plugins={},this.options=t,this.cache=new Ko,this.associations=new Map,this.primitiveCache={},this.nodeCache={},this.meshCache={refs:{},uses:{}},this.cameraCache={refs:{},uses:{}},this.lightCache={refs:{},uses:{}},this.sourceCache={},this.textureCache={},this.nodeNamesUsed={};let n=!1,r=!1,i=-1;typeof navigator<"u"&&typeof navigator.userAgent<"u"&&(n=/^((?!chrome|android).)*safari/i.test(navigator.userAgent)===!0,r=navigator.userAgent.indexOf("Firefox")>-1,i=r?navigator.userAgent.match(/Firefox\/([0-9]+)\./)[1]:-1),typeof createImageBitmap>"u"||n||r&&i<98?this.textureLoader=new l.TextureLoader(this.options.manager):this.textureLoader=new l.ImageBitmapLoader(this.options.manager),this.textureLoader.setCrossOrigin(this.options.crossOrigin),this.textureLoader.setRequestHeader(this.options.requestHeader),this.fileLoader=new l.FileLoader(this.options.manager),this.fileLoader.setResponseType("arraybuffer"),this.options.crossOrigin==="use-credentials"&&this.fileLoader.setWithCredentials(!0)}setExtensions(e){this.extensions=e}setPlugins(e){this.plugins=e}parse(e,t){const n=this,r=this.json,i=this.extensions;this.cache.removeAll(),this.nodeCache={},this._invokeAll(function(s){return s._markDefs&&s._markDefs()}),Promise.all(this._invokeAll(function(s){return s.beforeRoot&&s.beforeRoot()})).then(function(){return Promise.all([n.getDependencies("scene"),n.getDependencies("animation"),n.getDependencies("camera")])}).then(function(s){const a={scene:s[0][r.scene||0],scenes:s[0],animations:s[1],cameras:s[2],asset:r.asset,parser:n,userData:{}};bt(i,a,r),mt(a,r),Promise.all(n._invokeAll(function(c){return c.afterRoot&&c.afterRoot(a)})).then(function(){e(a)})}).catch(t)}_markDefs(){const e=this.json.nodes||[],t=this.json.skins||[],n=this.json.meshes||[];for(let r=0,i=t.length;r<i;r++){const s=t[r].joints;for(let a=0,c=s.length;a<c;a++)e[s[a]].isBone=!0}for(let r=0,i=e.length;r<i;r++){const s=e[r];s.mesh!==void 0&&(this._addNodeRef(this.meshCache,s.mesh),s.skin!==void 0&&(n[s.mesh].isSkinnedMesh=!0)),s.camera!==void 0&&this._addNodeRef(this.cameraCache,s.camera)}}_addNodeRef(e,t){t!==void 0&&(e.refs[t]===void 0&&(e.refs[t]=e.uses[t]=0),e.refs[t]++)}_getNodeRef(e,t,n){if(e.refs[t]<=1)return n;const r=n.clone(),i=(s,a)=>{const c=this.associations.get(s);c!=null&&this.associations.set(a,c);for(const[h,f]of s.children.entries())i(f,a.children[h])};return i(n,r),r.name+="_instance_"+e.uses[t]++,r}_invokeOne(e){const t=Object.values(this.plugins);t.push(this);for(let n=0;n<t.length;n++){const r=e(t[n]);if(r)return r}return null}_invokeAll(e){const t=Object.values(this.plugins);t.unshift(this);const n=[];for(let r=0;r<t.length;r++){const i=e(t[r]);i&&n.push(i)}return n}getDependency(e,t){const n=e+":"+t;let r=this.cache.get(n);if(!r){switch(e){case"scene":r=this.loadScene(t);break;case"node":r=this._invokeOne(function(i){return i.loadNode&&i.loadNode(t)});break;case"mesh":r=this._invokeOne(function(i){return i.loadMesh&&i.loadMesh(t)});break;case"accessor":r=this.loadAccessor(t);break;case"bufferView":r=this._invokeOne(function(i){return i.loadBufferView&&i.loadBufferView(t)});break;case"buffer":r=this.loadBuffer(t);break;case"material":r=this._invokeOne(function(i){return i.loadMaterial&&i.loadMaterial(t)});break;case"texture":r=this._invokeOne(function(i){return i.loadTexture&&i.loadTexture(t)});break;case"skin":r=this.loadSkin(t);break;case"animation":r=this._invokeOne(function(i){return i.loadAnimation&&i.loadAnimation(t)});break;case"camera":r=this.loadCamera(t);break;default:if(r=this._invokeOne(function(i){return i!=this&&i.getDependency&&i.getDependency(e,t)}),!r)throw new Error("Unknown type: "+e);break}this.cache.add(n,r)}return r}getDependencies(e){let t=this.cache.get(e);if(!t){const n=this,r=this.json[e+(e==="mesh"?"es":"s")]||[];t=Promise.all(r.map(function(i,s){return n.getDependency(e,s)})),this.cache.add(e,t)}return t}loadBuffer(e){const t=this.json.buffers[e],n=this.fileLoader;if(t.type&&t.type!=="arraybuffer")throw new Error("THREE.GLTFLoader: "+t.type+" buffer type is not supported.");if(t.uri===void 0&&e===0)return Promise.resolve(this.extensions[we.KHR_BINARY_GLTF].body);const r=this.options;return new Promise(function(i,s){n.load(l.LoaderUtils.resolveURL(t.uri,r.path),i,void 0,function(){s(new Error('THREE.GLTFLoader: Failed to load buffer "'+t.uri+'".'))})})}loadBufferView(e){const t=this.json.bufferViews[e];return this.getDependency("buffer",t.buffer).then(function(n){const r=t.byteLength||0,i=t.byteOffset||0;return n.slice(i,i+r)})}loadAccessor(e){const t=this,n=this.json,r=this.json.accessors[e];if(r.bufferView===void 0&&r.sparse===void 0){const s=qn[r.type],a=Ot[r.componentType],c=r.normalized===!0,h=new a(r.count*s);return Promise.resolve(new l.BufferAttribute(h,s,c))}const i=[];return r.bufferView!==void 0?i.push(this.getDependency("bufferView",r.bufferView)):i.push(null),r.sparse!==void 0&&(i.push(this.getDependency("bufferView",r.sparse.indices.bufferView)),i.push(this.getDependency("bufferView",r.sparse.values.bufferView))),Promise.all(i).then(function(s){const a=s[0],c=qn[r.type],h=Ot[r.componentType],f=h.BYTES_PER_ELEMENT,d=f*c,p=r.byteOffset||0,m=r.bufferView!==void 0?n.bufferViews[r.bufferView].byteStride:void 0,x=r.normalized===!0;let b,v;if(m&&m!==d){const _=Math.floor(p/m),T="InterleavedBuffer:"+r.bufferView+":"+r.componentType+":"+_+":"+r.count;let w=t.cache.get(T);w||(b=new h(a,_*m,r.count*m/f),w=new l.InterleavedBuffer(b,m/f),t.cache.add(T,w)),v=new l.InterleavedBufferAttribute(w,c,p%m/f,x)}else a===null?b=new h(r.count*c):b=new h(a,p,r.count*c),v=new l.BufferAttribute(b,c,x);if(r.sparse!==void 0){const _=qn.SCALAR,T=Ot[r.sparse.indices.componentType],w=r.sparse.indices.byteOffset||0,M=r.sparse.values.byteOffset||0,D=new T(s[1],w,r.sparse.count*_),S=new h(s[2],M,r.sparse.count*c);a!==null&&(v=new l.BufferAttribute(v.array.slice(),v.itemSize,v.normalized));for(let C=0,y=D.length;C<y;C++){const A=D[C];if(v.setX(A,S[C*c]),c>=2&&v.setY(A,S[C*c+1]),c>=3&&v.setZ(A,S[C*c+2]),c>=4&&v.setW(A,S[C*c+3]),c>=5)throw new Error("THREE.GLTFLoader: Unsupported itemSize in sparse BufferAttribute.")}}return v})}loadTexture(e){const t=this.json,n=this.options,i=t.textures[e].source,s=t.images[i];let a=this.textureLoader;if(s.uri){const c=n.manager.getHandler(s.uri);c!==null&&(a=c)}return this.loadTextureImage(e,i,a)}loadTextureImage(e,t,n){const r=this,i=this.json,s=i.textures[e],a=i.images[t],c=(a.uri||a.bufferView)+":"+s.sampler;if(this.textureCache[c])return this.textureCache[c];const h=this.loadImageSource(t,n).then(function(f){f.flipY=!1,f.name=s.name||a.name||"",f.name===""&&typeof a.uri=="string"&&a.uri.startsWith("data:image/")===!1&&(f.name=a.uri);const p=(i.samplers||{})[s.sampler]||{};return f.magFilter=ui[p.magFilter]||l.LinearFilter,f.minFilter=ui[p.minFilter]||l.LinearMipmapLinearFilter,f.wrapS=hi[p.wrapS]||l.RepeatWrapping,f.wrapT=hi[p.wrapT]||l.RepeatWrapping,r.associations.set(f,{textures:e}),f}).catch(function(){return null});return this.textureCache[c]=h,h}loadImageSource(e,t){const n=this,r=this.json,i=this.options;if(this.sourceCache[e]!==void 0)return this.sourceCache[e].then(d=>d.clone());const s=r.images[e],a=self.URL||self.webkitURL;let c=s.uri||"",h=!1;if(s.bufferView!==void 0)c=n.getDependency("bufferView",s.bufferView).then(function(d){h=!0;const p=new Blob([d],{type:s.mimeType});return c=a.createObjectURL(p),c});else if(s.uri===void 0)throw new Error("THREE.GLTFLoader: Image "+e+" is missing URI and bufferView");const f=Promise.resolve(c).then(function(d){return new Promise(function(p,m){let x=p;t.isImageBitmapLoader===!0&&(x=function(b){const v=new l.Texture(b);v.needsUpdate=!0,p(v)}),t.load(l.LoaderUtils.resolveURL(d,i.path),x,void 0,m)})}).then(function(d){return h===!0&&a.revokeObjectURL(c),d.userData.mimeType=s.mimeType||ba(s.uri),d}).catch(function(d){throw console.error("THREE.GLTFLoader: Couldn't load texture",c),d});return this.sourceCache[e]=f,f}assignTexture(e,t,n,r){const i=this;return this.getDependency("texture",n.index).then(function(s){if(!s)return null;if(n.texCoord!==void 0&&n.texCoord>0&&(s=s.clone(),s.channel=n.texCoord),i.extensions[we.KHR_TEXTURE_TRANSFORM]){const a=n.extensions!==void 0?n.extensions[we.KHR_TEXTURE_TRANSFORM]:void 0;if(a){const c=i.associations.get(s);s=i.extensions[we.KHR_TEXTURE_TRANSFORM].extendTexture(s,a),i.associations.set(s,c)}}return r!==void 0&&("colorSpace"in s?s.colorSpace=r===3001?"srgb":"srgb-linear":s.encoding=r),e[t]=s,s})}assignFinalMaterial(e){const t=e.geometry;let n=e.material;const r=t.attributes.tangent===void 0,i=t.attributes.color!==void 0,s=t.attributes.normal===void 0;if(e.isPoints){const a="PointsMaterial:"+n.uuid;let c=this.cache.get(a);c||(c=new l.PointsMaterial,l.Material.prototype.copy.call(c,n),c.color.copy(n.color),c.map=n.map,c.sizeAttenuation=!1,this.cache.add(a,c)),n=c}else if(e.isLine){const a="LineBasicMaterial:"+n.uuid;let c=this.cache.get(a);c||(c=new l.LineBasicMaterial,l.Material.prototype.copy.call(c,n),c.color.copy(n.color),c.map=n.map,this.cache.add(a,c)),n=c}if(r||i||s){let a="ClonedMaterial:"+n.uuid+":";r&&(a+="derivative-tangents:"),i&&(a+="vertex-colors:"),s&&(a+="flat-shading:");let c=this.cache.get(a);c||(c=n.clone(),i&&(c.vertexColors=!0),s&&(c.flatShading=!0),r&&(c.normalScale&&(c.normalScale.y*=-1),c.clearcoatNormalScale&&(c.clearcoatNormalScale.y*=-1)),this.cache.add(a,c),this.associations.set(c,this.associations.get(n))),n=c}e.material=n}getMaterialType(){return l.MeshStandardMaterial}loadMaterial(e){const t=this,n=this.json,r=this.extensions,i=n.materials[e];let s;const a={},c=i.extensions||{},h=[];if(c[we.KHR_MATERIALS_UNLIT]){const d=r[we.KHR_MATERIALS_UNLIT];s=d.getMaterialType(),h.push(d.extendParams(a,i,t))}else{const d=i.pbrMetallicRoughness||{};if(a.color=new l.Color(1,1,1),a.opacity=1,Array.isArray(d.baseColorFactor)){const p=d.baseColorFactor;a.color.fromArray(p),a.opacity=p[3]}d.baseColorTexture!==void 0&&h.push(t.assignTexture(a,"map",d.baseColorTexture,3001)),a.metalness=d.metallicFactor!==void 0?d.metallicFactor:1,a.roughness=d.roughnessFactor!==void 0?d.roughnessFactor:1,d.metallicRoughnessTexture!==void 0&&(h.push(t.assignTexture(a,"metalnessMap",d.metallicRoughnessTexture)),h.push(t.assignTexture(a,"roughnessMap",d.metallicRoughnessTexture))),s=this._invokeOne(function(p){return p.getMaterialType&&p.getMaterialType(e)}),h.push(Promise.all(this._invokeAll(function(p){return p.extendMaterialParams&&p.extendMaterialParams(e,a)})))}i.doubleSided===!0&&(a.side=l.DoubleSide);const f=i.alphaMode||Jn.OPAQUE;if(f===Jn.BLEND?(a.transparent=!0,a.depthWrite=!1):(a.transparent=!1,f===Jn.MASK&&(a.alphaTest=i.alphaCutoff!==void 0?i.alphaCutoff:.5)),i.normalTexture!==void 0&&s!==l.MeshBasicMaterial&&(h.push(t.assignTexture(a,"normalMap",i.normalTexture)),a.normalScale=new l.Vector2(1,1),i.normalTexture.scale!==void 0)){const d=i.normalTexture.scale;a.normalScale.set(d,d)}return i.occlusionTexture!==void 0&&s!==l.MeshBasicMaterial&&(h.push(t.assignTexture(a,"aoMap",i.occlusionTexture)),i.occlusionTexture.strength!==void 0&&(a.aoMapIntensity=i.occlusionTexture.strength)),i.emissiveFactor!==void 0&&s!==l.MeshBasicMaterial&&(a.emissive=new l.Color().fromArray(i.emissiveFactor)),i.emissiveTexture!==void 0&&s!==l.MeshBasicMaterial&&h.push(t.assignTexture(a,"emissiveMap",i.emissiveTexture,3001)),Promise.all(h).then(function(){const d=new s(a);return i.name&&(d.name=i.name),mt(d,i),t.associations.set(d,{materials:e}),i.extensions&&bt(r,d,i),d})}createUniqueName(e){const t=l.PropertyBinding.sanitizeNodeName(e||"");return t in this.nodeNamesUsed?t+"_"+ ++this.nodeNamesUsed[t]:(this.nodeNamesUsed[t]=0,t)}loadGeometries(e){const t=this,n=this.extensions,r=this.primitiveCache;function i(a){return n[we.KHR_DRACO_MESH_COMPRESSION].decodePrimitive(a,t).then(function(c){return fi(c,a,t)})}const s=[];for(let a=0,c=e.length;a<c;a++){const h=e[a],f=wa(h),d=r[f];if(d)s.push(d.promise);else{let p;h.extensions&&h.extensions[we.KHR_DRACO_MESH_COMPRESSION]?p=i(h):p=fi(new l.BufferGeometry,h,t),r[f]={primitive:h,promise:p},s.push(p)}}return Promise.all(s)}loadMesh(e){const t=this,n=this.json,r=this.extensions,i=n.meshes[e],s=i.primitives,a=[];for(let c=0,h=s.length;c<h;c++){const f=s[c].material===void 0?va(this.cache):this.getDependency("material",s[c].material);a.push(f)}return a.push(t.loadGeometries(s)),Promise.all(a).then(function(c){const h=c.slice(0,c.length-1),f=c[c.length-1],d=[];for(let m=0,x=f.length;m<x;m++){const b=f[m],v=s[m];let _;const T=h[m];if(v.mode===Xe.TRIANGLES||v.mode===Xe.TRIANGLE_STRIP||v.mode===Xe.TRIANGLE_FAN||v.mode===void 0)_=i.isSkinnedMesh===!0?new l.SkinnedMesh(b,T):new l.Mesh(b,T),_.isSkinnedMesh===!0&&_.normalizeSkinWeights(),v.mode===Xe.TRIANGLE_STRIP?_.geometry=Gr(_.geometry,l.TriangleStripDrawMode):v.mode===Xe.TRIANGLE_FAN&&(_.geometry=Gr(_.geometry,l.TriangleFanDrawMode));else if(v.mode===Xe.LINES)_=new l.LineSegments(b,T);else if(v.mode===Xe.LINE_STRIP)_=new l.Line(b,T);else if(v.mode===Xe.LINE_LOOP)_=new l.LineLoop(b,T);else if(v.mode===Xe.POINTS)_=new l.Points(b,T);else throw new Error("THREE.GLTFLoader: Primitive mode unsupported: "+v.mode);Object.keys(_.geometry.morphAttributes).length>0&&xa(_,i),_.name=t.createUniqueName(i.name||"mesh_"+e),mt(_,i),v.extensions&&bt(r,_,v),t.assignFinalMaterial(_),d.push(_)}for(let m=0,x=d.length;m<x;m++)t.associations.set(d[m],{meshes:e,primitives:m});if(d.length===1)return i.extensions&&bt(r,d[0],i),d[0];const p=new l.Group;i.extensions&&bt(r,p,i),t.associations.set(p,{meshes:e});for(let m=0,x=d.length;m<x;m++)p.add(d[m]);return p})}loadCamera(e){let t;const n=this.json.cameras[e],r=n[n.type];if(!r){console.warn("THREE.GLTFLoader: Missing camera parameters.");return}return n.type==="perspective"?t=new l.PerspectiveCamera(l.MathUtils.radToDeg(r.yfov),r.aspectRatio||1,r.znear||1,r.zfar||2e6):n.type==="orthographic"&&(t=new l.OrthographicCamera(-r.xmag,r.xmag,r.ymag,-r.ymag,r.znear,r.zfar)),n.name&&(t.name=this.createUniqueName(n.name)),mt(t,n),Promise.resolve(t)}loadSkin(e){const t=this.json.skins[e],n=[];for(let r=0,i=t.joints.length;r<i;r++)n.push(this._loadNodeShallow(t.joints[r]));return t.inverseBindMatrices!==void 0?n.push(this.getDependency("accessor",t.inverseBindMatrices)):n.push(null),Promise.all(n).then(function(r){const i=r.pop(),s=r,a=[],c=[];for(let h=0,f=s.length;h<f;h++){const d=s[h];if(d){a.push(d);const p=new l.Matrix4;i!==null&&p.fromArray(i.array,h*16),c.push(p)}else console.warn('THREE.GLTFLoader: Joint "%s" could not be found.',t.joints[h])}return new l.Skeleton(a,c)})}loadAnimation(e){const n=this.json.animations[e],r=n.name?n.name:"animation_"+e,i=[],s=[],a=[],c=[],h=[];for(let f=0,d=n.channels.length;f<d;f++){const p=n.channels[f],m=n.samplers[p.sampler],x=p.target,b=x.node,v=n.parameters!==void 0?n.parameters[m.input]:m.input,_=n.parameters!==void 0?n.parameters[m.output]:m.output;x.node!==void 0&&(i.push(this.getDependency("node",b)),s.push(this.getDependency("accessor",v)),a.push(this.getDependency("accessor",_)),c.push(m),h.push(x))}return Promise.all([Promise.all(i),Promise.all(s),Promise.all(a),Promise.all(c),Promise.all(h)]).then(function(f){const d=f[0],p=f[1],m=f[2],x=f[3],b=f[4],v=[];for(let _=0,T=d.length;_<T;_++){const w=d[_],M=p[_],D=m[_],S=x[_],C=b[_];if(w===void 0)continue;w.updateMatrix();let y;switch(pt[C.path]){case pt.weights:y=l.NumberKeyframeTrack;break;case pt.rotation:y=l.QuaternionKeyframeTrack;break;case pt.position:case pt.scale:default:y=l.VectorKeyframeTrack;break}const A=w.name?w.name:w.uuid,g=S.interpolation!==void 0?ya[S.interpolation]:l.InterpolateLinear,I=[];pt[C.path]===pt.weights?w.traverse(function(J){J.morphTargetInfluences&&I.push(J.name?J.name:J.uuid)}):I.push(A);let k=D.array;if(D.normalized){const J=$n(k.constructor),G=new Float32Array(k.length);for(let Z=0,X=k.length;Z<X;Z++)G[Z]=k[Z]*J;k=G}for(let J=0,G=I.length;J<G;J++){const Z=new y(I[J]+"."+pt[C.path],M.array,k,g);S.interpolation==="CUBICSPLINE"&&(Z.createInterpolant=function(K){const Y=this instanceof l.QuaternionKeyframeTrack?ga:ci;return new Y(this.times,this.values,this.getValueSize()/3,K)},Z.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline=!0),v.push(Z)}}return new l.AnimationClip(r,void 0,v)})}createNodeMesh(e){const t=this.json,n=this,r=t.nodes[e];return r.mesh===void 0?null:n.getDependency("mesh",r.mesh).then(function(i){const s=n._getNodeRef(n.meshCache,r.mesh,i);return r.weights!==void 0&&s.traverse(function(a){if(a.isMesh)for(let c=0,h=r.weights.length;c<h;c++)a.morphTargetInfluences[c]=r.weights[c]}),s})}loadNode(e){const t=this.json,n=this,r=t.nodes[e],i=n._loadNodeShallow(e),s=[],a=r.children||[];for(let h=0,f=a.length;h<f;h++)s.push(n.getDependency("node",a[h]));const c=r.skin===void 0?Promise.resolve(null):n.getDependency("skin",r.skin);return Promise.all([i,Promise.all(s),c]).then(function(h){const f=h[0],d=h[1],p=h[2];p!==null&&f.traverse(function(m){m.isSkinnedMesh&&m.bind(p,Ma)});for(let m=0,x=d.length;m<x;m++)f.add(d[m]);return f})}_loadNodeShallow(e){const t=this.json,n=this.extensions,r=this;if(this.nodeCache[e]!==void 0)return this.nodeCache[e];const i=t.nodes[e],s=i.name?r.createUniqueName(i.name):"",a=[],c=r._invokeOne(function(h){return h.createNodeMesh&&h.createNodeMesh(e)});return c&&a.push(c),i.camera!==void 0&&a.push(r.getDependency("camera",i.camera).then(function(h){return r._getNodeRef(r.cameraCache,i.camera,h)})),r._invokeAll(function(h){return h.createNodeAttachment&&h.createNodeAttachment(e)}).forEach(function(h){a.push(h)}),this.nodeCache[e]=Promise.all(a).then(function(h){let f;if(i.isBone===!0?f=new l.Bone:h.length>1?f=new l.Group:h.length===1?f=h[0]:f=new l.Object3D,f!==h[0])for(let d=0,p=h.length;d<p;d++)f.add(h[d]);if(i.name&&(f.userData.name=i.name,f.name=s),mt(f,i),i.extensions&&bt(n,f,i),i.matrix!==void 0){const d=new l.Matrix4;d.fromArray(i.matrix),f.applyMatrix4(d)}else i.translation!==void 0&&f.position.fromArray(i.translation),i.rotation!==void 0&&f.quaternion.fromArray(i.rotation),i.scale!==void 0&&f.scale.fromArray(i.scale);return r.associations.has(f)||r.associations.set(f,{}),r.associations.get(f).nodes=e,f}),this.nodeCache[e]}loadScene(e){const t=this.extensions,n=this.json.scenes[e],r=this,i=new l.Group;n.name&&(i.name=r.createUniqueName(n.name)),mt(i,n),n.extensions&&bt(t,i,n);const s=n.nodes||[],a=[];for(let c=0,h=s.length;c<h;c++)a.push(r.getDependency("node",s[c]));return Promise.all(a).then(function(c){for(let f=0,d=c.length;f<d;f++)i.add(c[f]);const h=f=>{const d=new Map;for(const[p,m]of r.associations)(p instanceof l.Material||p instanceof l.Texture)&&d.set(p,m);return f.traverse(p=>{const m=r.associations.get(p);m!=null&&d.set(p,m)}),d};return r.associations=h(i),i})}}function Aa(o,e,t){const n=e.attributes,r=new l.Box3;if(n.POSITION!==void 0){const a=t.json.accessors[n.POSITION],c=a.min,h=a.max;if(c!==void 0&&h!==void 0){if(r.set(new l.Vector3(c[0],c[1],c[2]),new l.Vector3(h[0],h[1],h[2])),a.normalized){const f=$n(Ot[a.componentType]);r.min.multiplyScalar(f),r.max.multiplyScalar(f)}}else{console.warn("THREE.GLTFLoader: Missing min/max properties for accessor POSITION.");return}}else return;const i=e.targets;if(i!==void 0){const a=new l.Vector3,c=new l.Vector3;for(let h=0,f=i.length;h<f;h++){const d=i[h];if(d.POSITION!==void 0){const p=t.json.accessors[d.POSITION],m=p.min,x=p.max;if(m!==void 0&&x!==void 0){if(c.setX(Math.max(Math.abs(m[0]),Math.abs(x[0]))),c.setY(Math.max(Math.abs(m[1]),Math.abs(x[1]))),c.setZ(Math.max(Math.abs(m[2]),Math.abs(x[2]))),p.normalized){const b=$n(Ot[p.componentType]);c.multiplyScalar(b)}a.max(c)}else console.warn("THREE.GLTFLoader: Missing min/max properties for accessor POSITION.")}}r.expandByVector(a)}o.boundingBox=r;const s=new l.Sphere;r.getCenter(s.center),s.radius=r.min.distanceTo(r.max)/2,o.boundingSphere=s}function fi(o,e,t){const n=e.attributes,r=[];function i(s,a){return t.getDependency("accessor",s).then(function(c){o.setAttribute(a,c)})}for(const s in n){const a=Qn[s]||s.toLowerCase();a in o.attributes||r.push(i(n[s],a))}if(e.indices!==void 0&&!o.index){const s=t.getDependency("accessor",e.indices).then(function(a){o.setIndex(a)});r.push(s)}return mt(o,e),Aa(o,e,t),Promise.all(r).then(function(){return e.targets!==void 0?_a(o,e.targets,t):o})}const Kt=new l.Vector3;function Ze(o,e,t,n,r,i){const s=2*Math.PI*r/4,a=Math.max(i-2*r,0),c=Math.PI/4;Kt.copy(e),Kt[n]=0,Kt.normalize();const h=.5*s/(s+a),f=1-Kt.angleTo(o)/c;return Math.sign(Kt[t])===1?f*h:a/(s+a)+h+h*(1-f)}class Ca extends l.BoxGeometry{constructor(e=1,t=1,n=1,r=2,i=.1){if(r=r*2+1,i=Math.min(e/2,t/2,n/2,i),super(1,1,1,r,r,r),r===1)return;const s=this.toNonIndexed();this.index=null,this.attributes.position=s.attributes.position,this.attributes.normal=s.attributes.normal,this.attributes.uv=s.attributes.uv;const a=new l.Vector3,c=new l.Vector3,h=new l.Vector3(e,t,n).divideScalar(2).subScalar(i),f=this.attributes.position.array,d=this.attributes.normal.array,p=this.attributes.uv.array,m=f.length/6,x=new l.Vector3,b=.5/r;for(let v=0,_=0;v<f.length;v+=3,_+=2)switch(a.fromArray(f,v),c.copy(a),c.x-=Math.sign(c.x)*b,c.y-=Math.sign(c.y)*b,c.z-=Math.sign(c.z)*b,c.normalize(),f[v+0]=h.x*Math.sign(a.x)+c.x*i,f[v+1]=h.y*Math.sign(a.y)+c.y*i,f[v+2]=h.z*Math.sign(a.z)+c.z*i,d[v+0]=c.x,d[v+1]=c.y,d[v+2]=c.z,Math.floor(v/m)){case 0:x.set(1,0,0),p[_+0]=Ze(x,c,"z","y",i,n),p[_+1]=1-Ze(x,c,"y","z",i,t);break;case 1:x.set(-1,0,0),p[_+0]=1-Ze(x,c,"z","y",i,n),p[_+1]=1-Ze(x,c,"y","z",i,t);break;case 2:x.set(0,1,0),p[_+0]=1-Ze(x,c,"x","z",i,e),p[_+1]=Ze(x,c,"z","x",i,n);break;case 3:x.set(0,-1,0),p[_+0]=1-Ze(x,c,"x","z",i,e),p[_+1]=1-Ze(x,c,"z","x",i,n);break;case 4:x.set(0,0,1),p[_+0]=1-Ze(x,c,"x","y",i,e),p[_+1]=1-Ze(x,c,"y","x",i,t);break;case 5:x.set(0,0,-1),p[_+0]=Ze(x,c,"x","y",i,e),p[_+1]=1-Ze(x,c,"y","x",i,t);break}}}class di extends l.ExtrudeGeometry{constructor(e,t={}){const{bevelEnabled:n=!1,bevelSize:r=8,bevelThickness:i=10,font:s,height:a=50,size:c=100,lineHeight:h=1,letterSpacing:f=0,...d}=t;if(s===void 0)super();else{const p=s.generateShapes(e,c,{lineHeight:h,letterSpacing:f});super(p,{...d,bevelEnabled:n,bevelSize:r,bevelThickness:i,depth:a})}this.type="TextGeometry"}}const Pa={uniforms:{tDiffuse:{value:null},h:{value:1/512}},vertexShader:`
       varying vec2 vUv;
 
       void main() {
@@ -56,7 +56,7 @@
     	gl_FragColor = sum;
 
     }
-  `},Ma={uniforms:{tDiffuse:{value:null},v:{value:1/512}},vertexShader:`
+  `},Ta={uniforms:{tDiffuse:{value:null},v:{value:1/512}},vertexShader:`
     varying vec2 vUv;
 
     void main() {
@@ -89,13 +89,13 @@
     gl_FragColor = sum;
 
   }
-  `};function hr(o,e,t){const n=t.length-o-1;if(e>=t[n])return n-1;if(e<=t[o])return o;let s=o,r=n,i=Math.floor((s+r)/2);for(;e<t[i]||e>=t[i+1];)e<t[i]?r=i:s=i,i=Math.floor((s+r)/2);return i}function Sa(o,e,t,n){const s=[],r=[],i=[];s[0]=1;for(let a=1;a<=t;++a){r[a]=e-n[o+1-a],i[a]=n[o+a]-e;let l=0;for(let u=0;u<a;++u){const h=i[u+1],d=r[a-u],y=s[u]/(h+d);s[u]=l+h*y,l=d*y}s[a]=l}return s}function Aa(o,e,t,n){const s=hr(o,n,e),r=Sa(s,n,o,e),i=new c.Vector4(0,0,0,0);for(let a=0;a<=o;++a){const l=t[s-o+a],u=r[a],h=l.w*u;i.x+=l.x*h,i.y+=l.y*h,i.z+=l.z*h,i.w+=l.w*u}return i}function Pa(o,e,t,n,s){const r=[];for(let d=0;d<=t;++d)r[d]=0;const i=[];for(let d=0;d<=n;++d)i[d]=r.slice(0);const a=[];for(let d=0;d<=t;++d)a[d]=r.slice(0);a[0][0]=1;const l=r.slice(0),u=r.slice(0);for(let d=1;d<=t;++d){l[d]=e-s[o+1-d],u[d]=s[o+d]-e;let y=0;for(let g=0;g<d;++g){const x=u[g+1],w=l[d-g];a[d][g]=x+w;const v=a[g][d-1]/a[d][g];a[g][d]=y+x*v,y=w*v}a[d][d]=y}for(let d=0;d<=t;++d)i[0][d]=a[d][t];for(let d=0;d<=t;++d){let y=0,g=1;const x=[];for(let w=0;w<=t;++w)x[w]=r.slice(0);x[0][0]=1;for(let w=1;w<=n;++w){let v=0;const P=d-w,D=t-w;d>=w&&(x[g][0]=x[y][0]/a[D+1][P],v=x[g][0]*a[P][D]);const S=P>=-1?1:-P,_=d-1<=D?w-1:t-d;for(let b=S;b<=_;++b)x[g][b]=(x[y][b]-x[y][b-1])/a[D+1][P+b],v+=x[g][b]*a[P+b][D];d<=D&&(x[g][w]=-x[y][w-1]/a[D+1][d],v+=x[g][w]*a[d][D]),i[w][d]=v;const L=y;y=g,g=L}}let h=t;for(let d=1;d<=n;++d){for(let y=0;y<=t;++y)i[d][y]*=h;h*=t-d}return i}function Ca(o,e,t,n,s){const r=s<o?s:o,i=[],a=hr(o,n,e),l=Pa(a,n,o,r,e),u=[];for(let h=0;h<t.length;++h){const d=t[h].clone(),y=d.w;d.x*=y,d.y*=y,d.z*=y,u[h]=d}for(let h=0;h<=r;++h){const d=u[a-o].clone().multiplyScalar(l[h][0]);for(let y=1;y<=o;++y)d.add(u[a-o+y].clone().multiplyScalar(l[h][y]));i[h]=d}for(let h=r+1;h<=s+1;++h)i[h]=new c.Vector4(0,0,0);return i}function Ta(o,e){let t=1;for(let s=2;s<=o;++s)t*=s;let n=1;for(let s=2;s<=e;++s)n*=s;for(let s=2;s<=o-e;++s)n*=s;return t/n}function La(o){const e=o.length,t=[],n=[];for(let r=0;r<e;++r){const i=o[r];t[r]=new c.Vector3(i.x,i.y,i.z),n[r]=i.w}const s=[];for(let r=0;r<e;++r){const i=t[r].clone();for(let a=1;a<=r;++a)i.sub(s[r-a].clone().multiplyScalar(Ta(r,a)*n[a]));s[r]=i.divideScalar(n[0])}return s}function Ia(o,e,t,n,s){const r=Ca(o,e,t,n,s);return La(r)}class fr extends c.Curve{constructor(e,t,n,s,r){super(),this.degree=e,this.knots=t,this.controlPoints=[],this.startKnot=s||0,this.endKnot=r||this.knots.length-1;for(let i=0;i<n.length;++i){const a=n[i];this.controlPoints[i]=new c.Vector4(a.x,a.y,a.z,a.w)}}getPoint(e,t){const n=t||new c.Vector3,s=this.knots[this.startKnot]+e*(this.knots[this.endKnot]-this.knots[this.startKnot]),r=Aa(this.degree,this.knots,this.controlPoints,s);return r.w!=1&&r.divideScalar(r.w),n.set(r.x,r.y,r.z)}getTangent(e,t){const n=t||new c.Vector3,s=this.knots[0]+e*(this.knots[this.knots.length-1]-this.knots[0]),r=Ia(this.degree,this.knots,this.controlPoints,s,1);return n.copy(r[1]).normalize(),n}}let ve,Ie,Ve;class Da extends c.Loader{constructor(e){super(e)}load(e,t,n,s){const r=this,i=r.path===""?c.LoaderUtils.extractUrlBase(e):r.path,a=new c.FileLoader(this.manager);a.setPath(r.path),a.setResponseType("arraybuffer"),a.setRequestHeader(r.requestHeader),a.setWithCredentials(r.withCredentials),a.load(e,function(l){try{t(r.parse(l,i))}catch(u){s?s(u):console.error(u),r.manager.itemError(e)}},n,s)}parse(e,t){if(Na(e))ve=new Ua().parse(e);else{const s=_r(e);if(!za(s))throw new Error("THREE.FBXLoader: Unknown format.");if(mr(s)<7e3)throw new Error("THREE.FBXLoader: FBX version not supported, FileVersion: "+mr(s));ve=new Ba().parse(s)}const n=new c.TextureLoader(this.manager).setPath(this.resourcePath||t).setCrossOrigin(this.crossOrigin);return new Oa(n,this.manager).parse(ve)}}class Oa{constructor(e,t){this.textureLoader=e,this.manager=t}parse(){Ie=this.parseConnections();const e=this.parseImages(),t=this.parseTextures(e),n=this.parseMaterials(t),s=this.parseDeformers(),r=new Fa().parse(s);return this.parseScene(s,r,n),Ve}parseConnections(){const e=new Map;return"Connections"in ve&&ve.Connections.connections.forEach(function(n){const s=n[0],r=n[1],i=n[2];e.has(s)||e.set(s,{parents:[],children:[]});const a={ID:r,relationship:i};e.get(s).parents.push(a),e.has(r)||e.set(r,{parents:[],children:[]});const l={ID:s,relationship:i};e.get(r).children.push(l)}),e}parseImages(){const e={},t={};if("Video"in ve.Objects){const n=ve.Objects.Video;for(const s in n){const r=n[s],i=parseInt(s);if(e[i]=r.RelativeFilename||r.Filename,"Content"in r){const a=r.Content instanceof ArrayBuffer&&r.Content.byteLength>0,l=typeof r.Content=="string"&&r.Content!=="";if(a||l){const u=this.parseImage(n[s]);t[r.RelativeFilename||r.Filename]=u}}}}for(const n in e){const s=e[n];t[s]!==void 0?e[n]=t[s]:e[n]=e[n].split("\\").pop()}return e}parseImage(e){const t=e.Content,n=e.RelativeFilename||e.Filename,s=n.slice(n.lastIndexOf(".")+1).toLowerCase();let r;switch(s){case"bmp":r="image/bmp";break;case"jpg":case"jpeg":r="image/jpeg";break;case"png":r="image/png";break;case"tif":r="image/tiff";break;case"tga":this.manager.getHandler(".tga")===null&&console.warn("FBXLoader: TGA loader not found, skipping ",n),r="image/tga";break;default:console.warn('FBXLoader: Image type "'+s+'" is not supported.');return}if(typeof t=="string")return"data:"+r+";base64,"+t;{const i=new Uint8Array(t);return window.URL.createObjectURL(new Blob([i],{type:r}))}}parseTextures(e){const t=new Map;if("Texture"in ve.Objects){const n=ve.Objects.Texture;for(const s in n){const r=this.parseTexture(n[s],e);t.set(parseInt(s),r)}}return t}parseTexture(e,t){const n=this.loadTexture(e,t);n.ID=e.id,n.name=e.attrName;const s=e.WrapModeU,r=e.WrapModeV,i=s!==void 0?s.value:0,a=r!==void 0?r.value:0;if(n.wrapS=i===0?c.RepeatWrapping:c.ClampToEdgeWrapping,n.wrapT=a===0?c.RepeatWrapping:c.ClampToEdgeWrapping,"Scaling"in e){const l=e.Scaling.value;n.repeat.x=l[0],n.repeat.y=l[1]}return n}loadTexture(e,t){let n;const s=this.textureLoader.path,r=Ie.get(e.id).children;r!==void 0&&r.length>0&&t[r[0].ID]!==void 0&&(n=t[r[0].ID],(n.indexOf("blob:")===0||n.indexOf("data:")===0)&&this.textureLoader.setPath(void 0));let i;const a=e.FileName.slice(-3).toLowerCase();if(a==="tga"){const l=this.manager.getHandler(".tga");l===null?(console.warn("FBXLoader: TGA loader not found, creating placeholder texture for",e.RelativeFilename),i=new c.Texture):(l.setPath(this.textureLoader.path),i=l.load(n))}else a==="psd"?(console.warn("FBXLoader: PSD textures are not supported, creating placeholder texture for",e.RelativeFilename),i=new c.Texture):i=this.textureLoader.load(n);return this.textureLoader.setPath(s),i}parseMaterials(e){const t=new Map;if("Material"in ve.Objects){const n=ve.Objects.Material;for(const s in n){const r=this.parseMaterial(n[s],e);r!==null&&t.set(parseInt(s),r)}}return t}parseMaterial(e,t){const n=e.id,s=e.attrName;let r=e.ShadingModel;if(typeof r=="object"&&(r=r.value),!Ie.has(n))return null;const i=this.parseParameters(e,t,n);let a;switch(r.toLowerCase()){case"phong":a=new c.MeshPhongMaterial;break;case"lambert":a=new c.MeshLambertMaterial;break;default:console.warn('THREE.FBXLoader: unknown material type "%s". Defaulting to MeshPhongMaterial.',r),a=new c.MeshPhongMaterial;break}return a.setValues(i),a.name=s,a}parseParameters(e,t,n){const s={};e.BumpFactor&&(s.bumpScale=e.BumpFactor.value),e.Diffuse?s.color=new c.Color().fromArray(e.Diffuse.value):e.DiffuseColor&&(e.DiffuseColor.type==="Color"||e.DiffuseColor.type==="ColorRGB")&&(s.color=new c.Color().fromArray(e.DiffuseColor.value)),e.DisplacementFactor&&(s.displacementScale=e.DisplacementFactor.value),e.Emissive?s.emissive=new c.Color().fromArray(e.Emissive.value):e.EmissiveColor&&(e.EmissiveColor.type==="Color"||e.EmissiveColor.type==="ColorRGB")&&(s.emissive=new c.Color().fromArray(e.EmissiveColor.value)),e.EmissiveFactor&&(s.emissiveIntensity=parseFloat(e.EmissiveFactor.value)),e.Opacity&&(s.opacity=parseFloat(e.Opacity.value)),s.opacity<1&&(s.transparent=!0),e.ReflectionFactor&&(s.reflectivity=e.ReflectionFactor.value),e.Shininess&&(s.shininess=e.Shininess.value),e.Specular?s.specular=new c.Color().fromArray(e.Specular.value):e.SpecularColor&&e.SpecularColor.type==="Color"&&(s.specular=new c.Color().fromArray(e.SpecularColor.value));const r=this;return Ie.get(n).children.forEach(function(i){const a=i.relationship;switch(a){case"Bump":s.bumpMap=r.getTexture(t,i.ID);break;case"Maya|TEX_ao_map":s.aoMap=r.getTexture(t,i.ID);break;case"DiffuseColor":case"Maya|TEX_color_map":s.map=r.getTexture(t,i.ID),s.map!==void 0&&("colorSpace"in s.map?s.map.colorSpace="srgb":s.map.encoding=3001);break;case"DisplacementColor":s.displacementMap=r.getTexture(t,i.ID);break;case"EmissiveColor":s.emissiveMap=r.getTexture(t,i.ID),s.emissiveMap!==void 0&&("colorSpace"in s.emissiveMap?s.emissiveMap.colorSpace="srgb":s.emissiveMap.encoding=3001);break;case"NormalMap":case"Maya|TEX_normal_map":s.normalMap=r.getTexture(t,i.ID);break;case"ReflectionColor":s.envMap=r.getTexture(t,i.ID),s.envMap!==void 0&&(s.envMap.mapping=c.EquirectangularReflectionMapping,"colorSpace"in s.envMap?s.envMap.colorSpace="srgb":s.envMap.encoding=3001);break;case"SpecularColor":s.specularMap=r.getTexture(t,i.ID),s.specularMap!==void 0&&("colorSpace"in s.specularMap?s.specularMap.colorSpace="srgb":s.specularMap.encoding=3001);break;case"TransparentColor":case"TransparencyFactor":s.alphaMap=r.getTexture(t,i.ID),s.transparent=!0;break;case"AmbientColor":case"ShininessExponent":case"SpecularFactor":case"VectorDisplacementColor":default:console.warn("THREE.FBXLoader: %s map is not supported in three.js, skipping texture.",a);break}}),s}getTexture(e,t){return"LayeredTexture"in ve.Objects&&t in ve.Objects.LayeredTexture&&(console.warn("THREE.FBXLoader: layered textures are not supported in three.js. Discarding all but first layer."),t=Ie.get(t).children[0].ID),e.get(t)}parseDeformers(){const e={},t={};if("Deformer"in ve.Objects){const n=ve.Objects.Deformer;for(const s in n){const r=n[s],i=Ie.get(parseInt(s));if(r.attrType==="Skin"){const a=this.parseSkeleton(i,n);a.ID=s,i.parents.length>1&&console.warn("THREE.FBXLoader: skeleton attached to more than one geometry is not supported."),a.geometryID=i.parents[0].ID,e[s]=a}else if(r.attrType==="BlendShape"){const a={id:s};a.rawTargets=this.parseMorphTargets(i,n),a.id=s,i.parents.length>1&&console.warn("THREE.FBXLoader: morph target attached to more than one geometry is not supported."),t[s]=a}}}return{skeletons:e,morphTargets:t}}parseSkeleton(e,t){const n=[];return e.children.forEach(function(s){const r=t[s.ID];if(r.attrType!=="Cluster")return;const i={ID:s.ID,indices:[],weights:[],transformLink:new c.Matrix4().fromArray(r.TransformLink.a)};"Indexes"in r&&(i.indices=r.Indexes.a,i.weights=r.Weights.a),n.push(i)}),{rawBones:n,bones:[]}}parseMorphTargets(e,t){const n=[];for(let s=0;s<e.children.length;s++){const r=e.children[s],i=t[r.ID],a={name:i.attrName,initialWeight:i.DeformPercent,id:i.id,fullWeights:i.FullWeights.a};if(i.attrType!=="BlendShapeChannel")return;a.geoID=Ie.get(parseInt(r.ID)).children.filter(function(l){return l.relationship===void 0})[0].ID,n.push(a)}return n}parseScene(e,t,n){Ve=new c.Group;const s=this.parseModels(e.skeletons,t,n),r=ve.Objects.Model,i=this;s.forEach(function(l){const u=r[l.ID];i.setLookAtProperties(l,u),Ie.get(l.ID).parents.forEach(function(d){const y=s.get(d.ID);y!==void 0&&y.add(l)}),l.parent===null&&Ve.add(l)}),this.bindSkeleton(e.skeletons,t,s),this.createAmbientLight(),Ve.traverse(function(l){if(l.userData.transformData){l.parent&&(l.userData.transformData.parentMatrix=l.parent.matrix,l.userData.transformData.parentMatrixWorld=l.parent.matrixWorld);const u=gr(l.userData.transformData);l.applyMatrix4(u),l.updateWorldMatrix()}});const a=new ka().parse();Ve.children.length===1&&Ve.children[0].isGroup&&(Ve.children[0].animations=a,Ve=Ve.children[0]),Ve.animations=a}parseModels(e,t,n){const s=new Map,r=ve.Objects.Model;for(const i in r){const a=parseInt(i),l=r[i],u=Ie.get(a);let h=this.buildSkeleton(u,e,a,l.attrName);if(!h){switch(l.attrType){case"Camera":h=this.createCamera(u);break;case"Light":h=this.createLight(u);break;case"Mesh":h=this.createMesh(u,t,n);break;case"NurbsCurve":h=this.createCurve(u,t);break;case"LimbNode":case"Root":h=new c.Bone;break;case"Null":default:h=new c.Group;break}h.name=l.attrName?c.PropertyBinding.sanitizeNodeName(l.attrName):"",h.ID=a}this.getTransformData(h,l),s.set(a,h)}return s}buildSkeleton(e,t,n,s){let r=null;return e.parents.forEach(function(i){for(const a in t){const l=t[a];l.rawBones.forEach(function(u,h){if(u.ID===i.ID){const d=r;r=new c.Bone,r.matrixWorld.copy(u.transformLink),r.name=s?c.PropertyBinding.sanitizeNodeName(s):"",r.ID=n,l.bones[h]=r,d!==null&&r.add(d)}})}}),r}createCamera(e){let t,n;if(e.children.forEach(function(s){const r=ve.Objects.NodeAttribute[s.ID];r!==void 0&&(n=r)}),n===void 0)t=new c.Object3D;else{let s=0;n.CameraProjectionType!==void 0&&n.CameraProjectionType.value===1&&(s=1);let r=1;n.NearPlane!==void 0&&(r=n.NearPlane.value/1e3);let i=1e3;n.FarPlane!==void 0&&(i=n.FarPlane.value/1e3);let a=window.innerWidth,l=window.innerHeight;n.AspectWidth!==void 0&&n.AspectHeight!==void 0&&(a=n.AspectWidth.value,l=n.AspectHeight.value);const u=a/l;let h=45;n.FieldOfView!==void 0&&(h=n.FieldOfView.value);const d=n.FocalLength?n.FocalLength.value:null;switch(s){case 0:t=new c.PerspectiveCamera(h,u,r,i),d!==null&&t.setFocalLength(d);break;case 1:t=new c.OrthographicCamera(-a/2,a/2,l/2,-l/2,r,i);break;default:console.warn("THREE.FBXLoader: Unknown camera type "+s+"."),t=new c.Object3D;break}}return t}createLight(e){let t,n;if(e.children.forEach(function(s){const r=ve.Objects.NodeAttribute[s.ID];r!==void 0&&(n=r)}),n===void 0)t=new c.Object3D;else{let s;n.LightType===void 0?s=0:s=n.LightType.value;let r=16777215;n.Color!==void 0&&(r=new c.Color().fromArray(n.Color.value));let i=n.Intensity===void 0?1:n.Intensity.value/100;n.CastLightOnObject!==void 0&&n.CastLightOnObject.value===0&&(i=0);let a=0;n.FarAttenuationEnd!==void 0&&(n.EnableFarAttenuation!==void 0&&n.EnableFarAttenuation.value===0?a=0:a=n.FarAttenuationEnd.value);const l=1;switch(s){case 0:t=new c.PointLight(r,i,a,l);break;case 1:t=new c.DirectionalLight(r,i);break;case 2:let u=Math.PI/3;n.InnerAngle!==void 0&&(u=c.MathUtils.degToRad(n.InnerAngle.value));let h=0;n.OuterAngle!==void 0&&(h=c.MathUtils.degToRad(n.OuterAngle.value),h=Math.max(h,1)),t=new c.SpotLight(r,i,a,u,h,l);break;default:console.warn("THREE.FBXLoader: Unknown light type "+n.LightType.value+", defaulting to a PointLight."),t=new c.PointLight(r,i);break}n.CastShadows!==void 0&&n.CastShadows.value===1&&(t.castShadow=!0)}return t}createMesh(e,t,n){let s,r=null,i=null;const a=[];return e.children.forEach(function(l){t.has(l.ID)&&(r=t.get(l.ID)),n.has(l.ID)&&a.push(n.get(l.ID))}),a.length>1?i=a:a.length>0?i=a[0]:(i=new c.MeshPhongMaterial({color:13421772}),a.push(i)),"color"in r.attributes&&a.forEach(function(l){l.vertexColors=!0}),r.FBX_Deformer?(s=new c.SkinnedMesh(r,i),s.normalizeSkinWeights()):s=new c.Mesh(r,i),s}createCurve(e,t){const n=e.children.reduce(function(r,i){return t.has(i.ID)&&(r=t.get(i.ID)),r},null),s=new c.LineBasicMaterial({color:3342591,linewidth:1});return new c.Line(n,s)}getTransformData(e,t){const n={};"InheritType"in t&&(n.inheritType=parseInt(t.InheritType.value)),"RotationOrder"in t?n.eulerOrder=yr(t.RotationOrder.value):n.eulerOrder="ZYX","Lcl_Translation"in t&&(n.translation=t.Lcl_Translation.value),"PreRotation"in t&&(n.preRotation=t.PreRotation.value),"Lcl_Rotation"in t&&(n.rotation=t.Lcl_Rotation.value),"PostRotation"in t&&(n.postRotation=t.PostRotation.value),"Lcl_Scaling"in t&&(n.scale=t.Lcl_Scaling.value),"ScalingOffset"in t&&(n.scalingOffset=t.ScalingOffset.value),"ScalingPivot"in t&&(n.scalingPivot=t.ScalingPivot.value),"RotationOffset"in t&&(n.rotationOffset=t.RotationOffset.value),"RotationPivot"in t&&(n.rotationPivot=t.RotationPivot.value),e.userData.transformData=n}setLookAtProperties(e,t){"LookAtProperty"in t&&Ie.get(e.ID).children.forEach(function(s){if(s.relationship==="LookAtProperty"){const r=ve.Objects.Model[s.ID];if("Lcl_Translation"in r){const i=r.Lcl_Translation.value;e.target!==void 0?(e.target.position.fromArray(i),Ve.add(e.target)):e.lookAt(new c.Vector3().fromArray(i))}}})}bindSkeleton(e,t,n){const s=this.parsePoseNodes();for(const r in e){const i=e[r];Ie.get(parseInt(i.ID)).parents.forEach(function(l){if(t.has(l.ID)){const u=l.ID;Ie.get(u).parents.forEach(function(d){n.has(d.ID)&&n.get(d.ID).bind(new c.Skeleton(i.bones),s[d.ID])})}})}}parsePoseNodes(){const e={};if("Pose"in ve.Objects){const t=ve.Objects.Pose;for(const n in t)if(t[n].attrType==="BindPose"&&t[n].NbPoseNodes>0){const s=t[n].PoseNode;Array.isArray(s)?s.forEach(function(r){e[r.Node]=new c.Matrix4().fromArray(r.Matrix.a)}):e[s.Node]=new c.Matrix4().fromArray(s.Matrix.a)}}return e}createAmbientLight(){if("GlobalSettings"in ve&&"AmbientColor"in ve.GlobalSettings){const e=ve.GlobalSettings.AmbientColor.value,t=e[0],n=e[1],s=e[2];if(t!==0||n!==0||s!==0){const r=new c.Color(t,n,s);Ve.add(new c.AmbientLight(r,1))}}}}class Fa{parse(e){const t=new Map;if("Geometry"in ve.Objects){const n=ve.Objects.Geometry;for(const s in n){const r=Ie.get(parseInt(s)),i=this.parseGeometry(r,n[s],e);t.set(parseInt(s),i)}}return t}parseGeometry(e,t,n){switch(t.attrType){case"Mesh":return this.parseMeshGeometry(e,t,n);case"NurbsCurve":return this.parseNurbsGeometry(t)}}parseMeshGeometry(e,t,n){const s=n.skeletons,r=[],i=e.parents.map(function(d){return ve.Objects.Model[d.ID]});if(i.length===0)return;const a=e.children.reduce(function(d,y){return s[y.ID]!==void 0&&(d=s[y.ID]),d},null);e.children.forEach(function(d){n.morphTargets[d.ID]!==void 0&&r.push(n.morphTargets[d.ID])});const l=i[0],u={};"RotationOrder"in l&&(u.eulerOrder=yr(l.RotationOrder.value)),"InheritType"in l&&(u.inheritType=parseInt(l.InheritType.value)),"GeometricTranslation"in l&&(u.translation=l.GeometricTranslation.value),"GeometricRotation"in l&&(u.rotation=l.GeometricRotation.value),"GeometricScaling"in l&&(u.scale=l.GeometricScaling.value);const h=gr(u);return this.genGeometry(t,a,r,h)}genGeometry(e,t,n,s){const r=new c.BufferGeometry;e.attrName&&(r.name=e.attrName);const i=this.parseGeoNode(e,t),a=this.genBuffers(i),l=new c.Float32BufferAttribute(a.vertex,3);if(l.applyMatrix4(s),r.setAttribute("position",l),a.colors.length>0&&r.setAttribute("color",new c.Float32BufferAttribute(a.colors,3)),t&&(r.setAttribute("skinIndex",new c.Uint16BufferAttribute(a.weightsIndices,4)),r.setAttribute("skinWeight",new c.Float32BufferAttribute(a.vertexWeights,4)),r.FBX_Deformer=t),a.normal.length>0){const u=new c.Matrix3().getNormalMatrix(s),h=new c.Float32BufferAttribute(a.normal,3);h.applyNormalMatrix(u),r.setAttribute("normal",h)}if(a.uvs.forEach(function(u,h){let d="uv"+(h+1).toString();h===0&&(d="uv"),r.setAttribute(d,new c.Float32BufferAttribute(a.uvs[h],2))}),i.material&&i.material.mappingType!=="AllSame"){let u=a.materialIndex[0],h=0;if(a.materialIndex.forEach(function(d,y){d!==u&&(r.addGroup(h,y-h,u),u=d,h=y)}),r.groups.length>0){const d=r.groups[r.groups.length-1],y=d.start+d.count;y!==a.materialIndex.length&&r.addGroup(y,a.materialIndex.length-y,u)}r.groups.length===0&&r.addGroup(0,a.materialIndex.length,a.materialIndex[0])}return this.addMorphTargets(r,e,n,s),r}parseGeoNode(e,t){const n={};if(n.vertexPositions=e.Vertices!==void 0?e.Vertices.a:[],n.vertexIndices=e.PolygonVertexIndex!==void 0?e.PolygonVertexIndex.a:[],e.LayerElementColor&&(n.color=this.parseVertexColors(e.LayerElementColor[0])),e.LayerElementMaterial&&(n.material=this.parseMaterialIndices(e.LayerElementMaterial[0])),e.LayerElementNormal&&(n.normal=this.parseNormals(e.LayerElementNormal[0])),e.LayerElementUV){n.uv=[];let s=0;for(;e.LayerElementUV[s];)e.LayerElementUV[s].UV&&n.uv.push(this.parseUVs(e.LayerElementUV[s])),s++}return n.weightTable={},t!==null&&(n.skeleton=t,t.rawBones.forEach(function(s,r){s.indices.forEach(function(i,a){n.weightTable[i]===void 0&&(n.weightTable[i]=[]),n.weightTable[i].push({id:r,weight:s.weights[a]})})})),n}genBuffers(e){const t={vertex:[],normal:[],colors:[],uvs:[],materialIndex:[],vertexWeights:[],weightsIndices:[]};let n=0,s=0,r=!1,i=[],a=[],l=[],u=[],h=[],d=[];const y=this;return e.vertexIndices.forEach(function(g,x){let w,v=!1;g<0&&(g=g^-1,v=!0);let P=[],D=[];if(i.push(g*3,g*3+1,g*3+2),e.color){const S=mn(x,n,g,e.color);l.push(S[0],S[1],S[2])}if(e.skeleton){if(e.weightTable[g]!==void 0&&e.weightTable[g].forEach(function(S){D.push(S.weight),P.push(S.id)}),D.length>4){r||(console.warn("THREE.FBXLoader: Vertex has more than 4 skinning weights assigned to vertex. Deleting additional weights."),r=!0);const S=[0,0,0,0],_=[0,0,0,0];D.forEach(function(L,b){let C=L,m=P[b];_.forEach(function(M,p,I){if(C>M){I[p]=C,C=M;const F=S[p];S[p]=m,m=F}})}),P=S,D=_}for(;D.length<4;)D.push(0),P.push(0);for(let S=0;S<4;++S)h.push(D[S]),d.push(P[S])}if(e.normal){const S=mn(x,n,g,e.normal);a.push(S[0],S[1],S[2])}e.material&&e.material.mappingType!=="AllSame"&&(w=mn(x,n,g,e.material)[0]),e.uv&&e.uv.forEach(function(S,_){const L=mn(x,n,g,S);u[_]===void 0&&(u[_]=[]),u[_].push(L[0]),u[_].push(L[1])}),s++,v&&(y.genFace(t,e,i,w,a,l,u,h,d,s),n++,s=0,i=[],a=[],l=[],u=[],h=[],d=[])}),t}genFace(e,t,n,s,r,i,a,l,u,h){for(let d=2;d<h;d++)e.vertex.push(t.vertexPositions[n[0]]),e.vertex.push(t.vertexPositions[n[1]]),e.vertex.push(t.vertexPositions[n[2]]),e.vertex.push(t.vertexPositions[n[(d-1)*3]]),e.vertex.push(t.vertexPositions[n[(d-1)*3+1]]),e.vertex.push(t.vertexPositions[n[(d-1)*3+2]]),e.vertex.push(t.vertexPositions[n[d*3]]),e.vertex.push(t.vertexPositions[n[d*3+1]]),e.vertex.push(t.vertexPositions[n[d*3+2]]),t.skeleton&&(e.vertexWeights.push(l[0]),e.vertexWeights.push(l[1]),e.vertexWeights.push(l[2]),e.vertexWeights.push(l[3]),e.vertexWeights.push(l[(d-1)*4]),e.vertexWeights.push(l[(d-1)*4+1]),e.vertexWeights.push(l[(d-1)*4+2]),e.vertexWeights.push(l[(d-1)*4+3]),e.vertexWeights.push(l[d*4]),e.vertexWeights.push(l[d*4+1]),e.vertexWeights.push(l[d*4+2]),e.vertexWeights.push(l[d*4+3]),e.weightsIndices.push(u[0]),e.weightsIndices.push(u[1]),e.weightsIndices.push(u[2]),e.weightsIndices.push(u[3]),e.weightsIndices.push(u[(d-1)*4]),e.weightsIndices.push(u[(d-1)*4+1]),e.weightsIndices.push(u[(d-1)*4+2]),e.weightsIndices.push(u[(d-1)*4+3]),e.weightsIndices.push(u[d*4]),e.weightsIndices.push(u[d*4+1]),e.weightsIndices.push(u[d*4+2]),e.weightsIndices.push(u[d*4+3])),t.color&&(e.colors.push(i[0]),e.colors.push(i[1]),e.colors.push(i[2]),e.colors.push(i[(d-1)*3]),e.colors.push(i[(d-1)*3+1]),e.colors.push(i[(d-1)*3+2]),e.colors.push(i[d*3]),e.colors.push(i[d*3+1]),e.colors.push(i[d*3+2])),t.material&&t.material.mappingType!=="AllSame"&&(e.materialIndex.push(s),e.materialIndex.push(s),e.materialIndex.push(s)),t.normal&&(e.normal.push(r[0]),e.normal.push(r[1]),e.normal.push(r[2]),e.normal.push(r[(d-1)*3]),e.normal.push(r[(d-1)*3+1]),e.normal.push(r[(d-1)*3+2]),e.normal.push(r[d*3]),e.normal.push(r[d*3+1]),e.normal.push(r[d*3+2])),t.uv&&t.uv.forEach(function(y,g){e.uvs[g]===void 0&&(e.uvs[g]=[]),e.uvs[g].push(a[g][0]),e.uvs[g].push(a[g][1]),e.uvs[g].push(a[g][(d-1)*2]),e.uvs[g].push(a[g][(d-1)*2+1]),e.uvs[g].push(a[g][d*2]),e.uvs[g].push(a[g][d*2+1])})}addMorphTargets(e,t,n,s){if(n.length===0)return;e.morphTargetsRelative=!0,e.morphAttributes.position=[];const r=this;n.forEach(function(i){i.rawTargets.forEach(function(a){const l=ve.Objects.Geometry[a.geoID];l!==void 0&&r.genMorphGeometry(e,t,l,s,a.name)})})}genMorphGeometry(e,t,n,s,r){const i=t.PolygonVertexIndex!==void 0?t.PolygonVertexIndex.a:[],a=n.Vertices!==void 0?n.Vertices.a:[],l=n.Indexes!==void 0?n.Indexes.a:[],u=e.attributes.position.count*3,h=new Float32Array(u);for(let x=0;x<l.length;x++){const w=l[x]*3;h[w]=a[x*3],h[w+1]=a[x*3+1],h[w+2]=a[x*3+2]}const d={vertexIndices:i,vertexPositions:h},y=this.genBuffers(d),g=new c.Float32BufferAttribute(y.vertex,3);g.name=r||n.attrName,g.applyMatrix4(s),e.morphAttributes.position.push(g)}parseNormals(e){const t=e.MappingInformationType,n=e.ReferenceInformationType,s=e.Normals.a;let r=[];return n==="IndexToDirect"&&("NormalIndex"in e?r=e.NormalIndex.a:"NormalsIndex"in e&&(r=e.NormalsIndex.a)),{dataSize:3,buffer:s,indices:r,mappingType:t,referenceType:n}}parseUVs(e){const t=e.MappingInformationType,n=e.ReferenceInformationType,s=e.UV.a;let r=[];return n==="IndexToDirect"&&(r=e.UVIndex.a),{dataSize:2,buffer:s,indices:r,mappingType:t,referenceType:n}}parseVertexColors(e){const t=e.MappingInformationType,n=e.ReferenceInformationType,s=e.Colors.a;let r=[];return n==="IndexToDirect"&&(r=e.ColorIndex.a),{dataSize:4,buffer:s,indices:r,mappingType:t,referenceType:n}}parseMaterialIndices(e){const t=e.MappingInformationType,n=e.ReferenceInformationType;if(t==="NoMappingInformation")return{dataSize:1,buffer:[0],indices:[0],mappingType:"AllSame",referenceType:n};const s=e.Materials.a,r=[];for(let i=0;i<s.length;++i)r.push(i);return{dataSize:1,buffer:s,indices:r,mappingType:t,referenceType:n}}parseNurbsGeometry(e){if(fr===void 0)return console.error("THREE.FBXLoader: The loader relies on NURBSCurve for any nurbs present in the model. Nurbs will show up as empty geometry."),new c.BufferGeometry;const t=parseInt(e.Order);if(isNaN(t))return console.error("THREE.FBXLoader: Invalid Order %s given for geometry ID: %s",e.Order,e.id),new c.BufferGeometry;const n=t-1,s=e.KnotVector.a,r=[],i=e.Points.a;for(let d=0,y=i.length;d<y;d+=4)r.push(new c.Vector4().fromArray(i,d));let a,l;if(e.Form==="Closed")r.push(r[0]);else if(e.Form==="Periodic"){a=n,l=s.length-1-a;for(let d=0;d<n;++d)r.push(r[d])}const h=new fr(n,s,r,a,l).getPoints(r.length*12);return new c.BufferGeometry().setFromPoints(h)}}class ka{parse(){const e=[],t=this.parseClips();if(t!==void 0)for(const n in t){const s=t[n],r=this.addClip(s);e.push(r)}return e}parseClips(){if(ve.Objects.AnimationCurve===void 0)return;const e=this.parseAnimationCurveNodes();this.parseAnimationCurves(e);const t=this.parseAnimationLayers(e);return this.parseAnimStacks(t)}parseAnimationCurveNodes(){const e=ve.Objects.AnimationCurveNode,t=new Map;for(const n in e){const s=e[n];if(s.attrName.match(/S|R|T|DeformPercent/)!==null){const r={id:s.id,attr:s.attrName,curves:{}};t.set(r.id,r)}}return t}parseAnimationCurves(e){const t=ve.Objects.AnimationCurve;for(const n in t){const s={id:t[n].id,times:t[n].KeyTime.a.map(Va),values:t[n].KeyValueFloat.a},r=Ie.get(s.id);if(r!==void 0){const i=r.parents[0].ID,a=r.parents[0].relationship;a.match(/X/)?e.get(i).curves.x=s:a.match(/Y/)?e.get(i).curves.y=s:a.match(/Z/)?e.get(i).curves.z=s:a.match(/d|DeformPercent/)&&e.has(i)&&(e.get(i).curves.morph=s)}}}parseAnimationLayers(e){const t=ve.Objects.AnimationLayer,n=new Map;for(const s in t){const r=[],i=Ie.get(parseInt(s));i!==void 0&&(i.children.forEach(function(l,u){if(e.has(l.ID)){const h=e.get(l.ID);if(h.curves.x!==void 0||h.curves.y!==void 0||h.curves.z!==void 0){if(r[u]===void 0){const d=Ie.get(l.ID).parents.filter(function(y){return y.relationship!==void 0})[0].ID;if(d!==void 0){const y=ve.Objects.Model[d.toString()];if(y===void 0){console.warn("THREE.FBXLoader: Encountered a unused curve.",l);return}const g={modelName:y.attrName?c.PropertyBinding.sanitizeNodeName(y.attrName):"",ID:y.id,initialPosition:[0,0,0],initialRotation:[0,0,0],initialScale:[1,1,1]};Ve.traverse(function(x){x.ID===y.id&&(g.transform=x.matrix,x.userData.transformData&&(g.eulerOrder=x.userData.transformData.eulerOrder))}),g.transform||(g.transform=new c.Matrix4),"PreRotation"in y&&(g.preRotation=y.PreRotation.value),"PostRotation"in y&&(g.postRotation=y.PostRotation.value),r[u]=g}}r[u]&&(r[u][h.attr]=h)}else if(h.curves.morph!==void 0){if(r[u]===void 0){const d=Ie.get(l.ID).parents.filter(function(P){return P.relationship!==void 0})[0].ID,y=Ie.get(d).parents[0].ID,g=Ie.get(y).parents[0].ID,x=Ie.get(g).parents[0].ID,w=ve.Objects.Model[x],v={modelName:w.attrName?c.PropertyBinding.sanitizeNodeName(w.attrName):"",morphName:ve.Objects.Deformer[d].attrName};r[u]=v}r[u][h.attr]=h}}}),n.set(parseInt(s),r))}return n}parseAnimStacks(e){const t=ve.Objects.AnimationStack,n={};for(const s in t){const r=Ie.get(parseInt(s)).children;r.length>1&&console.warn("THREE.FBXLoader: Encountered an animation stack with multiple layers, this is currently not supported. Ignoring subsequent layers.");const i=e.get(r[0].ID);n[s]={name:t[s].attrName,layer:i}}return n}addClip(e){let t=[];const n=this;return e.layer.forEach(function(s){t=t.concat(n.generateTracks(s))}),new c.AnimationClip(e.name,-1,t)}generateTracks(e){const t=[];let n=new c.Vector3,s=new c.Quaternion,r=new c.Vector3;if(e.transform&&e.transform.decompose(n,s,r),n=n.toArray(),s=new c.Euler().setFromQuaternion(s,e.eulerOrder).toArray(),r=r.toArray(),e.T!==void 0&&Object.keys(e.T.curves).length>0){const i=this.generateVectorTrack(e.modelName,e.T.curves,n,"position");i!==void 0&&t.push(i)}if(e.R!==void 0&&Object.keys(e.R.curves).length>0){const i=this.generateRotationTrack(e.modelName,e.R.curves,s,e.preRotation,e.postRotation,e.eulerOrder);i!==void 0&&t.push(i)}if(e.S!==void 0&&Object.keys(e.S.curves).length>0){const i=this.generateVectorTrack(e.modelName,e.S.curves,r,"scale");i!==void 0&&t.push(i)}if(e.DeformPercent!==void 0){const i=this.generateMorphTrack(e);i!==void 0&&t.push(i)}return t}generateVectorTrack(e,t,n,s){const r=this.getTimesForAllAxes(t),i=this.getKeyframeTrackValues(r,t,n);return new c.VectorKeyframeTrack(e+"."+s,r,i)}generateRotationTrack(e,t,n,s,r,i){t.x!==void 0&&(this.interpolateRotations(t.x),t.x.values=t.x.values.map(c.MathUtils.degToRad)),t.y!==void 0&&(this.interpolateRotations(t.y),t.y.values=t.y.values.map(c.MathUtils.degToRad)),t.z!==void 0&&(this.interpolateRotations(t.z),t.z.values=t.z.values.map(c.MathUtils.degToRad));const a=this.getTimesForAllAxes(t),l=this.getKeyframeTrackValues(a,t,n);s!==void 0&&(s=s.map(c.MathUtils.degToRad),s.push(i),s=new c.Euler().fromArray(s),s=new c.Quaternion().setFromEuler(s)),r!==void 0&&(r=r.map(c.MathUtils.degToRad),r.push(i),r=new c.Euler().fromArray(r),r=new c.Quaternion().setFromEuler(r).invert());const u=new c.Quaternion,h=new c.Euler,d=[];for(let y=0;y<l.length;y+=3)h.set(l[y],l[y+1],l[y+2],i),u.setFromEuler(h),s!==void 0&&u.premultiply(s),r!==void 0&&u.multiply(r),u.toArray(d,y/3*4);return new c.QuaternionKeyframeTrack(e+".quaternion",a,d)}generateMorphTrack(e){const t=e.DeformPercent.curves.morph,n=t.values.map(function(r){return r/100}),s=Ve.getObjectByName(e.modelName).morphTargetDictionary[e.morphName];return new c.NumberKeyframeTrack(e.modelName+".morphTargetInfluences["+s+"]",t.times,n)}getTimesForAllAxes(e){let t=[];if(e.x!==void 0&&(t=t.concat(e.x.times)),e.y!==void 0&&(t=t.concat(e.y.times)),e.z!==void 0&&(t=t.concat(e.z.times)),t=t.sort(function(n,s){return n-s}),t.length>1){let n=1,s=t[0];for(let r=1;r<t.length;r++){const i=t[r];i!==s&&(t[n]=i,s=i,n++)}t=t.slice(0,n)}return t}getKeyframeTrackValues(e,t,n){const s=n,r=[];let i=-1,a=-1,l=-1;return e.forEach(function(u){if(t.x&&(i=t.x.times.indexOf(u)),t.y&&(a=t.y.times.indexOf(u)),t.z&&(l=t.z.times.indexOf(u)),i!==-1){const h=t.x.values[i];r.push(h),s[0]=h}else r.push(s[0]);if(a!==-1){const h=t.y.values[a];r.push(h),s[1]=h}else r.push(s[1]);if(l!==-1){const h=t.z.values[l];r.push(h),s[2]=h}else r.push(s[2])}),r}interpolateRotations(e){for(let t=1;t<e.values.length;t++){const n=e.values[t-1],s=e.values[t]-n,r=Math.abs(s);if(r>=180){const i=r/180,a=s/i;let l=n+a;const u=e.times[t-1],d=(e.times[t]-u)/i;let y=u+d;const g=[],x=[];for(;y<e.times[t];)g.push(y),y+=d,x.push(l),l+=a;e.times=vr(e.times,t,g),e.values=vr(e.values,t,x)}}}}class Ba{getPrevNode(){return this.nodeStack[this.currentIndent-2]}getCurrentNode(){return this.nodeStack[this.currentIndent-1]}getCurrentProp(){return this.currentProp}pushStack(e){this.nodeStack.push(e),this.currentIndent+=1}popStack(){this.nodeStack.pop(),this.currentIndent-=1}setCurrentProp(e,t){this.currentProp=e,this.currentPropName=t}parse(e){this.currentIndent=0,this.allNodes=new pr,this.nodeStack=[],this.currentProp=[],this.currentPropName="";const t=this,n=e.split(/[\r\n]+/);return n.forEach(function(s,r){const i=s.match(/^[\s\t]*;/),a=s.match(/^[\s\t]*$/);if(i||a)return;const l=s.match("^\\t{"+t.currentIndent+"}(\\w+):(.*){",""),u=s.match("^\\t{"+t.currentIndent+"}(\\w+):[\\s\\t\\r\\n](.*)"),h=s.match("^\\t{"+(t.currentIndent-1)+"}}");l?t.parseNodeBegin(s,l):u?t.parseNodeProperty(s,u,n[++r]):h?t.popStack():s.match(/^[^\s\t}]/)&&t.parseNodePropertyContinued(s)}),this.allNodes}parseNodeBegin(e,t){const n=t[1].trim().replace(/^"/,"").replace(/"$/,""),s=t[2].split(",").map(function(l){return l.trim().replace(/^"/,"").replace(/"$/,"")}),r={name:n},i=this.parseNodeAttr(s),a=this.getCurrentNode();this.currentIndent===0?this.allNodes.add(n,r):n in a?(n==="PoseNode"?a.PoseNode.push(r):a[n].id!==void 0&&(a[n]={},a[n][a[n].id]=a[n]),i.id!==""&&(a[n][i.id]=r)):typeof i.id=="number"?(a[n]={},a[n][i.id]=r):n!=="Properties70"&&(n==="PoseNode"?a[n]=[r]:a[n]=r),typeof i.id=="number"&&(r.id=i.id),i.name!==""&&(r.attrName=i.name),i.type!==""&&(r.attrType=i.type),this.pushStack(r)}parseNodeAttr(e){let t=e[0];e[0]!==""&&(t=parseInt(e[0]),isNaN(t)&&(t=e[0]));let n="",s="";return e.length>1&&(n=e[1].replace(/^(\w+)::/,""),s=e[2]),{id:t,name:n,type:s}}parseNodeProperty(e,t,n){let s=t[1].replace(/^"/,"").replace(/"$/,"").trim(),r=t[2].replace(/^"/,"").replace(/"$/,"").trim();s==="Content"&&r===","&&(r=n.replace(/"/g,"").replace(/,$/,"").trim());const i=this.getCurrentNode();if(i.name==="Properties70"){this.parseNodeSpecialProperty(e,s,r);return}if(s==="C"){const l=r.split(",").slice(1),u=parseInt(l[0]),h=parseInt(l[1]);let d=r.split(",").slice(3);d=d.map(function(y){return y.trim().replace(/^"/,"")}),s="connections",r=[u,h],Ga(r,d),i[s]===void 0&&(i[s]=[])}s==="Node"&&(i.id=r),s in i&&Array.isArray(i[s])?i[s].push(r):s!=="a"?i[s]=r:i.a=r,this.setCurrentProp(i,s),s==="a"&&r.slice(-1)!==","&&(i.a=$n(r))}parseNodePropertyContinued(e){const t=this.getCurrentNode();t.a+=e,e.slice(-1)!==","&&(t.a=$n(t.a))}parseNodeSpecialProperty(e,t,n){const s=n.split('",').map(function(h){return h.trim().replace(/^\"/,"").replace(/\s/,"_")}),r=s[0],i=s[1],a=s[2],l=s[3];let u=s[4];switch(i){case"int":case"enum":case"bool":case"ULongLong":case"double":case"Number":case"FieldOfView":u=parseFloat(u);break;case"Color":case"ColorRGB":case"Vector3D":case"Lcl_Translation":case"Lcl_Rotation":case"Lcl_Scaling":u=$n(u);break}this.getPrevNode()[r]={type:i,type2:a,flag:l,value:u},this.setCurrentProp(this.getPrevNode(),r)}}class Ua{parse(e){const t=new dr(e);t.skip(23);const n=t.getUint32();if(n<6400)throw new Error("THREE.FBXLoader: FBX version not supported, FileVersion: "+n);const s=new pr;for(;!this.endOfContent(t);){const r=this.parseNode(t,n);r!==null&&s.add(r.name,r)}return s}endOfContent(e){return e.size()%16===0?(e.getOffset()+160+16&-16)>=e.size():e.getOffset()+160+16>=e.size()}parseNode(e,t){const n={},s=t>=7500?e.getUint64():e.getUint32(),r=t>=7500?e.getUint64():e.getUint32();t>=7500?e.getUint64():e.getUint32();const i=e.getUint8(),a=e.getString(i);if(s===0)return null;const l=[];for(let y=0;y<r;y++)l.push(this.parseProperty(e));const u=l.length>0?l[0]:"",h=l.length>1?l[1]:"",d=l.length>2?l[2]:"";for(n.singleProperty=r===1&&e.getOffset()===s;s>e.getOffset();){const y=this.parseNode(e,t);y!==null&&this.parseSubNode(a,n,y)}return n.propertyList=l,typeof u=="number"&&(n.id=u),h!==""&&(n.attrName=h),d!==""&&(n.attrType=d),a!==""&&(n.name=a),n}parseSubNode(e,t,n){if(n.singleProperty===!0){const s=n.propertyList[0];Array.isArray(s)?(t[n.name]=n,n.a=s):t[n.name]=s}else if(e==="Connections"&&n.name==="C"){const s=[];n.propertyList.forEach(function(r,i){i!==0&&s.push(r)}),t.connections===void 0&&(t.connections=[]),t.connections.push(s)}else if(n.name==="Properties70")Object.keys(n).forEach(function(r){t[r]=n[r]});else if(e==="Properties70"&&n.name==="P"){let s=n.propertyList[0],r=n.propertyList[1];const i=n.propertyList[2],a=n.propertyList[3];let l;s.indexOf("Lcl ")===0&&(s=s.replace("Lcl ","Lcl_")),r.indexOf("Lcl ")===0&&(r=r.replace("Lcl ","Lcl_")),r==="Color"||r==="ColorRGB"||r==="Vector"||r==="Vector3D"||r.indexOf("Lcl_")===0?l=[n.propertyList[4],n.propertyList[5],n.propertyList[6]]:l=n.propertyList[4],t[s]={type:r,type2:i,flag:a,value:l}}else t[n.name]===void 0?typeof n.id=="number"?(t[n.name]={},t[n.name][n.id]=n):t[n.name]=n:n.name==="PoseNode"?(Array.isArray(t[n.name])||(t[n.name]=[t[n.name]]),t[n.name].push(n)):t[n.name][n.id]===void 0&&(t[n.name][n.id]=n)}parseProperty(e){const t=e.getString(1);let n;switch(t){case"C":return e.getBoolean();case"D":return e.getFloat64();case"F":return e.getFloat32();case"I":return e.getInt32();case"L":return e.getInt64();case"R":return n=e.getUint32(),e.getArrayBuffer(n);case"S":return n=e.getUint32(),e.getString(n);case"Y":return e.getInt16();case"b":case"c":case"d":case"f":case"i":case"l":const s=e.getUint32(),r=e.getUint32(),i=e.getUint32();if(r===0)switch(t){case"b":case"c":return e.getBooleanArray(s);case"d":return e.getFloat64Array(s);case"f":return e.getFloat32Array(s);case"i":return e.getInt32Array(s);case"l":return e.getInt64Array(s)}const a=Ao(new Uint8Array(e.getArrayBuffer(i))),l=new dr(a.buffer);switch(t){case"b":case"c":return l.getBooleanArray(s);case"d":return l.getFloat64Array(s);case"f":return l.getFloat32Array(s);case"i":return l.getInt32Array(s);case"l":return l.getInt64Array(s)}default:throw new Error("THREE.FBXLoader: Unknown property type "+t)}}}class dr{constructor(e,t){this.dv=new DataView(e),this.offset=0,this.littleEndian=t!==void 0?t:!0}getOffset(){return this.offset}size(){return this.dv.buffer.byteLength}skip(e){this.offset+=e}getBoolean(){return(this.getUint8()&1)===1}getBooleanArray(e){const t=[];for(let n=0;n<e;n++)t.push(this.getBoolean());return t}getUint8(){const e=this.dv.getUint8(this.offset);return this.offset+=1,e}getInt16(){const e=this.dv.getInt16(this.offset,this.littleEndian);return this.offset+=2,e}getInt32(){const e=this.dv.getInt32(this.offset,this.littleEndian);return this.offset+=4,e}getInt32Array(e){const t=[];for(let n=0;n<e;n++)t.push(this.getInt32());return t}getUint32(){const e=this.dv.getUint32(this.offset,this.littleEndian);return this.offset+=4,e}getInt64(){let e,t;return this.littleEndian?(e=this.getUint32(),t=this.getUint32()):(t=this.getUint32(),e=this.getUint32()),t&2147483648?(t=~t&4294967295,e=~e&4294967295,e===4294967295&&(t=t+1&4294967295),e=e+1&4294967295,-(t*4294967296+e)):t*4294967296+e}getInt64Array(e){const t=[];for(let n=0;n<e;n++)t.push(this.getInt64());return t}getUint64(){let e,t;return this.littleEndian?(e=this.getUint32(),t=this.getUint32()):(t=this.getUint32(),e=this.getUint32()),t*4294967296+e}getFloat32(){const e=this.dv.getFloat32(this.offset,this.littleEndian);return this.offset+=4,e}getFloat32Array(e){const t=[];for(let n=0;n<e;n++)t.push(this.getFloat32());return t}getFloat64(){const e=this.dv.getFloat64(this.offset,this.littleEndian);return this.offset+=8,e}getFloat64Array(e){const t=[];for(let n=0;n<e;n++)t.push(this.getFloat64());return t}getArrayBuffer(e){const t=this.dv.buffer.slice(this.offset,this.offset+e);return this.offset+=e,t}getString(e){let t=[];for(let s=0;s<e;s++)t[s]=this.getUint8();const n=t.indexOf(0);return n>=0&&(t=t.slice(0,n)),c.LoaderUtils.decodeText(new Uint8Array(t))}}class pr{add(e,t){this[e]=t}}function Na(o){const e="Kaydara FBX Binary  \0";return o.byteLength>=e.length&&e===_r(o,0,e.length)}function za(o){const e=["K","a","y","d","a","r","a","\\","F","B","X","\\","B","i","n","a","r","y","\\","\\"];let t=0;function n(s){const r=o[s-1];return o=o.slice(t+s),t++,r}for(let s=0;s<e.length;++s)if(n(1)===e[s])return!1;return!0}function mr(o){const e=/FBXVersion: (\d+)/,t=o.match(e);if(t)return parseInt(t[1]);throw new Error("THREE.FBXLoader: Cannot find the version number for the file given.")}function Va(o){return o/46186158e3}const Ra=[];function mn(o,e,t,n){let s;switch(n.mappingType){case"ByPolygonVertex":s=o;break;case"ByPolygon":s=e;break;case"ByVertice":s=t;break;case"AllSame":s=n.indices[0];break;default:console.warn("THREE.FBXLoader: unknown attribute mapping type "+n.mappingType)}n.referenceType==="IndexToDirect"&&(s=n.indices[s]);const r=s*n.dataSize,i=r+n.dataSize;return ja(Ra,n.buffer,r,i)}const Hn=new c.Euler,Ot=new c.Vector3;function gr(o){const e=new c.Matrix4,t=new c.Matrix4,n=new c.Matrix4,s=new c.Matrix4,r=new c.Matrix4,i=new c.Matrix4,a=new c.Matrix4,l=new c.Matrix4,u=new c.Matrix4,h=new c.Matrix4,d=new c.Matrix4,y=new c.Matrix4,g=o.inheritType?o.inheritType:0;if(o.translation&&e.setPosition(Ot.fromArray(o.translation)),o.preRotation){const p=o.preRotation.map(c.MathUtils.degToRad);p.push(o.eulerOrder),t.makeRotationFromEuler(Hn.fromArray(p))}if(o.rotation){const p=o.rotation.map(c.MathUtils.degToRad);p.push(o.eulerOrder),n.makeRotationFromEuler(Hn.fromArray(p))}if(o.postRotation){const p=o.postRotation.map(c.MathUtils.degToRad);p.push(o.eulerOrder),s.makeRotationFromEuler(Hn.fromArray(p)),s.invert()}o.scale&&r.scale(Ot.fromArray(o.scale)),o.scalingOffset&&a.setPosition(Ot.fromArray(o.scalingOffset)),o.scalingPivot&&i.setPosition(Ot.fromArray(o.scalingPivot)),o.rotationOffset&&l.setPosition(Ot.fromArray(o.rotationOffset)),o.rotationPivot&&u.setPosition(Ot.fromArray(o.rotationPivot)),o.parentMatrixWorld&&(d.copy(o.parentMatrix),h.copy(o.parentMatrixWorld));const x=t.clone().multiply(n).multiply(s),w=new c.Matrix4;w.extractRotation(h);const v=new c.Matrix4;v.copyPosition(h);const P=v.clone().invert().multiply(h),D=w.clone().invert().multiply(P),S=r,_=new c.Matrix4;if(g===0)_.copy(w).multiply(x).multiply(D).multiply(S);else if(g===1)_.copy(w).multiply(D).multiply(x).multiply(S);else{const I=new c.Matrix4().scale(new c.Vector3().setFromMatrixScale(d)).clone().invert(),F=D.clone().multiply(I);_.copy(w).multiply(x).multiply(F).multiply(S)}const L=u.clone().invert(),b=i.clone().invert();let C=e.clone().multiply(l).multiply(u).multiply(t).multiply(n).multiply(s).multiply(L).multiply(a).multiply(i).multiply(r).multiply(b);const m=new c.Matrix4().copyPosition(C),M=h.clone().multiply(m);return y.copyPosition(M),C=y.clone().multiply(_),C.premultiply(h.invert()),C}function yr(o){o=o||0;const e=["ZYX","YZX","XZY","ZXY","YXZ","XYZ"];return o===6?(console.warn("THREE.FBXLoader: unsupported Euler Order: Spherical XYZ. Animations and rotations may be incorrect."),e[0]):e[o]}function $n(o){return o.split(",").map(function(t){return parseFloat(t)})}function _r(o,e,t){return e===void 0&&(e=0),t===void 0&&(t=o.byteLength),c.LoaderUtils.decodeText(new Uint8Array(o,e,t))}function Ga(o,e){for(let t=0,n=o.length,s=e.length;t<s;t++,n++)o[n]=e[t]}function ja(o,e,t,n){for(let s=t,r=0;s<n;s++,r++)o[r]=e[s];return o}function vr(o,e,t){return o.slice(0,e).concat(t).concat(o.slice(e))}var Ea=Object.defineProperty,Ya=(o,e,t)=>e in o?Ea(o,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):o[e]=t,es=(o,e,t)=>(Ya(o,typeof e!="symbol"?e+"":e,t),t);class Xa extends c.Loader{constructor(e){super(e)}load(e,t,n,s){const r=new c.FileLoader(this.manager);r.setPath(this.path),r.setRequestHeader(this.requestHeader),r.setWithCredentials(this.withCredentials),r.load(e,i=>{if(typeof i!="string")throw new Error("unsupported data type");const a=JSON.parse(i),l=this.parse(a);t&&t(l)},n,s)}loadAsync(e,t){return super.loadAsync(e,t)}parse(e){return new ts(e)}}class ts{constructor(e){es(this,"data"),this.data=e}generateShapes(e,t=100,n){const s=[],r={letterSpacing:0,lineHeight:1,...n},i=Wa(e,t,this.data,r);for(let a=0,l=i.length;a<l;a++)Array.prototype.push.apply(s,i[a].toShapes(!1));return s}}es(ts,"isFont"),es(ts,"type");function Wa(o,e,t,n){const s=Array.from(o),r=e/t.resolution,i=(t.boundingBox.yMax-t.boundingBox.yMin+t.underlineThickness)*r,a=[];let l=0,u=0;for(let h=0;h<s.length;h++){const d=s[h];if(d===`
-`)l=0,u-=i*n.lineHeight;else{const y=Za(d,r,l,u,t);y&&(l+=y.offsetX+n.letterSpacing,a.push(y.path))}}return a}function Za(o,e,t,n,s){const r=s.glyphs[o]||s.glyphs["?"];if(!r){console.error('THREE.Font: character "'+o+'" does not exists in font family '+s.familyName+".");return}const i=new c.ShapePath;let a,l,u,h,d,y,g,x;if(r.o){const w=r._cachedOutline||(r._cachedOutline=r.o.split(" "));for(let v=0,P=w.length;v<P;)switch(w[v++]){case"m":a=parseInt(w[v++])*e+t,l=parseInt(w[v++])*e+n,i.moveTo(a,l);break;case"l":a=parseInt(w[v++])*e+t,l=parseInt(w[v++])*e+n,i.lineTo(a,l);break;case"q":u=parseInt(w[v++])*e+t,h=parseInt(w[v++])*e+n,d=parseInt(w[v++])*e+t,y=parseInt(w[v++])*e+n,i.quadraticCurveTo(d,y,u,h);break;case"b":u=parseInt(w[v++])*e+t,h=parseInt(w[v++])*e+n,d=parseInt(w[v++])*e+t,y=parseInt(w[v++])*e+n,g=parseInt(w[v++])*e+t,x=parseInt(w[v++])*e+n,i.bezierCurveTo(d,y,g,x,u,h);break}}return{offsetX:r.ha*e,path:i}}class xr extends c.DataTextureLoader{constructor(e){super(e),this.type=c.HalfFloatType}parse(e){const a=function(S,_){switch(S){case 1:console.error("THREE.RGBELoader Read Error: "+(_||""));break;case 2:console.error("THREE.RGBELoader Write Error: "+(_||""));break;case 3:console.error("THREE.RGBELoader Bad File Format: "+(_||""));break;default:case 4:console.error("THREE.RGBELoader: Error: "+(_||""))}return-1},d=`
-`,y=function(S,_,L){_=_||1024;let C=S.pos,m=-1,M=0,p="",I=String.fromCharCode.apply(null,new Uint16Array(S.subarray(C,C+128)));for(;0>(m=I.indexOf(d))&&M<_&&C<S.byteLength;)p+=I,M+=I.length,C+=128,I+=String.fromCharCode.apply(null,new Uint16Array(S.subarray(C,C+128)));return-1<m?(L!==!1&&(S.pos+=M+m+1),p+I.slice(0,m)):!1},g=function(S){const _=/^#\?(\S+)/,L=/^\s*GAMMA\s*=\s*(\d+(\.\d+)?)\s*$/,b=/^\s*EXPOSURE\s*=\s*(\d+(\.\d+)?)\s*$/,C=/^\s*FORMAT=(\S+)\s*$/,m=/^\s*\-Y\s+(\d+)\s+\+X\s+(\d+)\s*$/,M={valid:0,string:"",comments:"",programtype:"RGBE",format:"",gamma:1,exposure:1,width:0,height:0};let p,I;if(S.pos>=S.byteLength||!(p=y(S)))return a(1,"no header found");if(!(I=p.match(_)))return a(3,"bad initial token");for(M.valid|=1,M.programtype=I[1],M.string+=p+`
-`;p=y(S),p!==!1;){if(M.string+=p+`
-`,p.charAt(0)==="#"){M.comments+=p+`
-`;continue}if((I=p.match(L))&&(M.gamma=parseFloat(I[1])),(I=p.match(b))&&(M.exposure=parseFloat(I[1])),(I=p.match(C))&&(M.valid|=2,M.format=I[1]),(I=p.match(m))&&(M.valid|=4,M.height=parseInt(I[1],10),M.width=parseInt(I[2],10)),M.valid&2&&M.valid&4)break}return M.valid&2?M.valid&4?M:a(3,"missing image size specifier"):a(3,"missing format specifier")},x=function(S,_,L){const b=_;if(b<8||b>32767||S[0]!==2||S[1]!==2||S[2]&128)return new Uint8Array(S);if(b!==(S[2]<<8|S[3]))return a(3,"wrong scanline width");const C=new Uint8Array(4*_*L);if(!C.length)return a(4,"unable to allocate buffer space");let m=0,M=0;const p=4*b,I=new Uint8Array(4),F=new Uint8Array(p);let J=L;for(;J>0&&M<S.byteLength;){if(M+4>S.byteLength)return a(1);if(I[0]=S[M++],I[1]=S[M++],I[2]=S[M++],I[3]=S[M++],I[0]!=2||I[1]!=2||(I[2]<<8|I[3])!=b)return a(3,"bad rgbe scanline format");let G=0,Q;for(;G<p&&M<S.byteLength;){Q=S[M++];const Z=Q>128;if(Z&&(Q-=128),Q===0||G+Q>p)return a(3,"bad scanline data");if(Z){const X=S[M++];for(let ne=0;ne<Q;ne++)F[G++]=X}else F.set(S.subarray(M,M+Q),G),G+=Q,M+=Q}const K=b;for(let Z=0;Z<K;Z++){let X=0;C[m]=F[Z+X],X+=b,C[m+1]=F[Z+X],X+=b,C[m+2]=F[Z+X],X+=b,C[m+3]=F[Z+X],m+=4}J--}return C},w=function(S,_,L,b){const C=S[_+3],m=Math.pow(2,C-128)/255;L[b+0]=S[_+0]*m,L[b+1]=S[_+1]*m,L[b+2]=S[_+2]*m,L[b+3]=1},v=function(S,_,L,b){const C=S[_+3],m=Math.pow(2,C-128)/255;L[b+0]=c.DataUtils.toHalfFloat(Math.min(S[_+0]*m,65504)),L[b+1]=c.DataUtils.toHalfFloat(Math.min(S[_+1]*m,65504)),L[b+2]=c.DataUtils.toHalfFloat(Math.min(S[_+2]*m,65504)),L[b+3]=c.DataUtils.toHalfFloat(1)},P=new Uint8Array(e);P.pos=0;const D=g(P);if(D!==-1){const S=D.width,_=D.height,L=x(P.subarray(P.pos),S,_);if(L!==-1){let b,C,m;switch(this.type){case c.FloatType:m=L.length/4;const M=new Float32Array(m*4);for(let I=0;I<m;I++)w(L,I*4,M,I*4);b=M,C=c.FloatType;break;case c.HalfFloatType:m=L.length/4;const p=new Uint16Array(m*4);for(let I=0;I<m;I++)v(L,I*4,p,I*4);b=p,C=c.HalfFloatType;break;default:console.error("THREE.RGBELoader: unsupported type: ",this.type);break}return{width:S,height:_,data:b,header:D.string,gamma:D.gamma,exposure:D.exposure,type:C}}}return null}setDataType(e){return this.type=e,this}load(e,t,n,s){function r(i,a){switch(i.type){case c.FloatType:case c.HalfFloatType:"colorSpace"in i?i.colorSpace="srgb-linear":i.encoding=3e3,i.minFilter=c.LinearFilter,i.magFilter=c.LinearFilter,i.generateMipmaps=!1,i.flipY=!0;break}t&&t(i,a)}return super.load(e,r,n,s)}}class Wt extends c.Loader{constructor(e){super(e),this.defaultDPI=90,this.defaultUnit="px"}load(e,t,n,s){const r=this,i=new c.FileLoader(r.manager);i.setPath(r.path),i.setRequestHeader(r.requestHeader),i.setWithCredentials(r.withCredentials),i.load(e,function(a){try{t(r.parse(a))}catch(l){s?s(l):console.error(l),r.manager.itemError(e)}},n,s)}parse(e){const t=this;function n(j,z){if(j.nodeType!==1)return;const A=_(j);let V=!0,ee=null;switch(j.nodeName){case"svg":break;case"style":r(j);break;case"g":z=x(j,z);break;case"path":z=x(j,z),j.hasAttribute("d")&&(ee=s(j));break;case"rect":z=x(j,z),ee=l(j);break;case"polygon":z=x(j,z),ee=u(j);break;case"polyline":z=x(j,z),ee=h(j);break;case"circle":z=x(j,z),ee=d(j);break;case"ellipse":z=x(j,z),ee=y(j);break;case"line":z=x(j,z),ee=g(j);break;case"defs":V=!1;break;case"mask":V=!1;break;case"use":z=x(j,z);const N=j.href.baseVal.substring(1),R=j.viewportElement.getElementById(N);R?n(R,z):console.warn("SVGLoader: 'use node' references non-existent node id: "+N);break}if(ee&&(z.fill!==void 0&&z.fill!=="none"&&ee.color.setStyle(z.fill),b(ee,ne),p.push(ee),ee.userData={node:j,style:z}),V){const N=j.childNodes;for(let R=0;R<N.length;R++)n(N[R],z)}A&&(F.pop(),F.length>0?ne.copy(F[F.length-1]):ne.identity())}function s(j){const z=new c.ShapePath,A=new c.Vector2,V=new c.Vector2,ee=new c.Vector2;let N=!0,R=!1;const O=j.getAttribute("d").match(/[a-df-z][^a-df-z]*/gi);for(let k=0,E=O.length;k<E;k++){const q=O[k],W=q.charAt(0),te=q.substr(1).trim();N===!0&&(R=!0,N=!1);let U;switch(W){case"M":U=v(te);for(let B=0,oe=U.length;B<oe;B+=2)A.x=U[B+0],A.y=U[B+1],V.x=A.x,V.y=A.y,B===0?z.moveTo(A.x,A.y):z.lineTo(A.x,A.y),B===0&&ee.copy(A);break;case"H":U=v(te);for(let B=0,oe=U.length;B<oe;B++)A.x=U[B],V.x=A.x,V.y=A.y,z.lineTo(A.x,A.y),B===0&&R===!0&&ee.copy(A);break;case"V":U=v(te);for(let B=0,oe=U.length;B<oe;B++)A.y=U[B],V.x=A.x,V.y=A.y,z.lineTo(A.x,A.y),B===0&&R===!0&&ee.copy(A);break;case"L":U=v(te);for(let B=0,oe=U.length;B<oe;B+=2)A.x=U[B+0],A.y=U[B+1],V.x=A.x,V.y=A.y,z.lineTo(A.x,A.y),B===0&&R===!0&&ee.copy(A);break;case"C":U=v(te);for(let B=0,oe=U.length;B<oe;B+=6)z.bezierCurveTo(U[B+0],U[B+1],U[B+2],U[B+3],U[B+4],U[B+5]),V.x=U[B+2],V.y=U[B+3],A.x=U[B+4],A.y=U[B+5],B===0&&R===!0&&ee.copy(A);break;case"S":U=v(te);for(let B=0,oe=U.length;B<oe;B+=4)z.bezierCurveTo(w(A.x,V.x),w(A.y,V.y),U[B+0],U[B+1],U[B+2],U[B+3]),V.x=U[B+0],V.y=U[B+1],A.x=U[B+2],A.y=U[B+3],B===0&&R===!0&&ee.copy(A);break;case"Q":U=v(te);for(let B=0,oe=U.length;B<oe;B+=4)z.quadraticCurveTo(U[B+0],U[B+1],U[B+2],U[B+3]),V.x=U[B+0],V.y=U[B+1],A.x=U[B+2],A.y=U[B+3],B===0&&R===!0&&ee.copy(A);break;case"T":U=v(te);for(let B=0,oe=U.length;B<oe;B+=2){const ce=w(A.x,V.x),ge=w(A.y,V.y);z.quadraticCurveTo(ce,ge,U[B+0],U[B+1]),V.x=ce,V.y=ge,A.x=U[B+0],A.y=U[B+1],B===0&&R===!0&&ee.copy(A)}break;case"A":U=v(te,[3,4],7);for(let B=0,oe=U.length;B<oe;B+=7){if(U[B+5]==A.x&&U[B+6]==A.y)continue;const ce=A.clone();A.x=U[B+5],A.y=U[B+6],V.x=A.x,V.y=A.y,i(z,U[B],U[B+1],U[B+2],U[B+3],U[B+4],ce,A),B===0&&R===!0&&ee.copy(A)}break;case"m":U=v(te);for(let B=0,oe=U.length;B<oe;B+=2)A.x+=U[B+0],A.y+=U[B+1],V.x=A.x,V.y=A.y,B===0?z.moveTo(A.x,A.y):z.lineTo(A.x,A.y),B===0&&ee.copy(A);break;case"h":U=v(te);for(let B=0,oe=U.length;B<oe;B++)A.x+=U[B],V.x=A.x,V.y=A.y,z.lineTo(A.x,A.y),B===0&&R===!0&&ee.copy(A);break;case"v":U=v(te);for(let B=0,oe=U.length;B<oe;B++)A.y+=U[B],V.x=A.x,V.y=A.y,z.lineTo(A.x,A.y),B===0&&R===!0&&ee.copy(A);break;case"l":U=v(te);for(let B=0,oe=U.length;B<oe;B+=2)A.x+=U[B+0],A.y+=U[B+1],V.x=A.x,V.y=A.y,z.lineTo(A.x,A.y),B===0&&R===!0&&ee.copy(A);break;case"c":U=v(te);for(let B=0,oe=U.length;B<oe;B+=6)z.bezierCurveTo(A.x+U[B+0],A.y+U[B+1],A.x+U[B+2],A.y+U[B+3],A.x+U[B+4],A.y+U[B+5]),V.x=A.x+U[B+2],V.y=A.y+U[B+3],A.x+=U[B+4],A.y+=U[B+5],B===0&&R===!0&&ee.copy(A);break;case"s":U=v(te);for(let B=0,oe=U.length;B<oe;B+=4)z.bezierCurveTo(w(A.x,V.x),w(A.y,V.y),A.x+U[B+0],A.y+U[B+1],A.x+U[B+2],A.y+U[B+3]),V.x=A.x+U[B+0],V.y=A.y+U[B+1],A.x+=U[B+2],A.y+=U[B+3],B===0&&R===!0&&ee.copy(A);break;case"q":U=v(te);for(let B=0,oe=U.length;B<oe;B+=4)z.quadraticCurveTo(A.x+U[B+0],A.y+U[B+1],A.x+U[B+2],A.y+U[B+3]),V.x=A.x+U[B+0],V.y=A.y+U[B+1],A.x+=U[B+2],A.y+=U[B+3],B===0&&R===!0&&ee.copy(A);break;case"t":U=v(te);for(let B=0,oe=U.length;B<oe;B+=2){const ce=w(A.x,V.x),ge=w(A.y,V.y);z.quadraticCurveTo(ce,ge,A.x+U[B+0],A.y+U[B+1]),V.x=ce,V.y=ge,A.x=A.x+U[B+0],A.y=A.y+U[B+1],B===0&&R===!0&&ee.copy(A)}break;case"a":U=v(te,[3,4],7);for(let B=0,oe=U.length;B<oe;B+=7){if(U[B+5]==0&&U[B+6]==0)continue;const ce=A.clone();A.x+=U[B+5],A.y+=U[B+6],V.x=A.x,V.y=A.y,i(z,U[B],U[B+1],U[B+2],U[B+3],U[B+4],ce,A),B===0&&R===!0&&ee.copy(A)}break;case"Z":case"z":z.currentPath.autoClose=!0,z.currentPath.curves.length>0&&(A.copy(ee),z.currentPath.currentPoint.copy(A),N=!0);break;default:console.warn(q)}R=!1}return z}function r(j){if(!(!j.sheet||!j.sheet.cssRules||!j.sheet.cssRules.length))for(let z=0;z<j.sheet.cssRules.length;z++){const A=j.sheet.cssRules[z];if(A.type!==1)continue;const V=A.selectorText.split(/,/gm).filter(Boolean).map(ee=>ee.trim());for(let ee=0;ee<V.length;ee++)I[V[ee]]=Object.assign(I[V[ee]]||{},A.style)}}function i(j,z,A,V,ee,N,R,T){if(z==0||A==0){j.lineTo(T.x,T.y);return}V=V*Math.PI/180,z=Math.abs(z),A=Math.abs(A);const O=(R.x-T.x)/2,k=(R.y-T.y)/2,E=Math.cos(V)*O+Math.sin(V)*k,q=-Math.sin(V)*O+Math.cos(V)*k;let W=z*z,te=A*A;const U=E*E,B=q*q,oe=U/W+B/te;if(oe>1){const Gt=Math.sqrt(oe);z=Gt*z,A=Gt*A,W=z*z,te=A*A}const ce=W*B+te*U,ge=(W*te-ce)/ce;let _e=Math.sqrt(Math.max(0,ge));ee===N&&(_e=-_e);const xe=_e*z*q/A,Oe=-_e*A*E/z,at=Math.cos(V)*xe-Math.sin(V)*Oe+(R.x+T.x)/2,an=Math.sin(V)*xe+Math.cos(V)*Oe+(R.y+T.y)/2,Rt=a(1,0,(E-xe)/z,(q-Oe)/A),Ke=a((E-xe)/z,(q-Oe)/A,(-E-xe)/z,(-q-Oe)/A)%(Math.PI*2);j.currentPath.absellipse(at,an,z,A,Rt,Rt+Ke,N===0,V)}function a(j,z,A,V){const ee=j*A+z*V,N=Math.sqrt(j*j+z*z)*Math.sqrt(A*A+V*V);let R=Math.acos(Math.max(-1,Math.min(1,ee/N)));return j*V-z*A<0&&(R=-R),R}function l(j){const z=S(j.getAttribute("x")||0),A=S(j.getAttribute("y")||0),V=S(j.getAttribute("rx")||j.getAttribute("ry")||0),ee=S(j.getAttribute("ry")||j.getAttribute("rx")||0),N=S(j.getAttribute("width")),R=S(j.getAttribute("height")),T=1-.551915024494,O=new c.ShapePath;return O.moveTo(z+V,A),O.lineTo(z+N-V,A),(V!==0||ee!==0)&&O.bezierCurveTo(z+N-V*T,A,z+N,A+ee*T,z+N,A+ee),O.lineTo(z+N,A+R-ee),(V!==0||ee!==0)&&O.bezierCurveTo(z+N,A+R-ee*T,z+N-V*T,A+R,z+N-V,A+R),O.lineTo(z+V,A+R),(V!==0||ee!==0)&&O.bezierCurveTo(z+V*T,A+R,z,A+R-ee*T,z,A+R-ee),O.lineTo(z,A+ee),(V!==0||ee!==0)&&O.bezierCurveTo(z,A+ee*T,z+V*T,A,z+V,A),O}function u(j){function z(N,R,T){const O=S(R),k=S(T);ee===0?V.moveTo(O,k):V.lineTo(O,k),ee++}const A=/(-?[\d\.?]+)[,|\s](-?[\d\.?]+)/g,V=new c.ShapePath;let ee=0;return j.getAttribute("points").replace(A,z),V.currentPath.autoClose=!0,V}function h(j){function z(N,R,T){const O=S(R),k=S(T);ee===0?V.moveTo(O,k):V.lineTo(O,k),ee++}const A=/(-?[\d\.?]+)[,|\s](-?[\d\.?]+)/g,V=new c.ShapePath;let ee=0;return j.getAttribute("points").replace(A,z),V.currentPath.autoClose=!1,V}function d(j){const z=S(j.getAttribute("cx")||0),A=S(j.getAttribute("cy")||0),V=S(j.getAttribute("r")||0),ee=new c.Path;ee.absarc(z,A,V,0,Math.PI*2);const N=new c.ShapePath;return N.subPaths.push(ee),N}function y(j){const z=S(j.getAttribute("cx")||0),A=S(j.getAttribute("cy")||0),V=S(j.getAttribute("rx")||0),ee=S(j.getAttribute("ry")||0),N=new c.Path;N.absellipse(z,A,V,ee,0,Math.PI*2);const R=new c.ShapePath;return R.subPaths.push(N),R}function g(j){const z=S(j.getAttribute("x1")||0),A=S(j.getAttribute("y1")||0),V=S(j.getAttribute("x2")||0),ee=S(j.getAttribute("y2")||0),N=new c.ShapePath;return N.moveTo(z,A),N.lineTo(V,ee),N.currentPath.autoClose=!1,N}function x(j,z){z=Object.assign({},z);let A={};if(j.hasAttribute("class")){const R=j.getAttribute("class").split(/\s/).filter(Boolean).map(T=>T.trim());for(let T=0;T<R.length;T++)A=Object.assign(A,I["."+R[T]])}j.hasAttribute("id")&&(A=Object.assign(A,I["#"+j.getAttribute("id")]));function V(R,T,O){O===void 0&&(O=function(E){return E.startsWith("url")&&console.warn("SVGLoader: url access in attributes is not implemented."),E}),j.hasAttribute(R)&&(z[T]=O(j.getAttribute(R))),A[R]&&(z[T]=O(A[R])),j.style&&j.style[R]!==""&&(z[T]=O(j.style[R]))}function ee(R){return Math.max(0,Math.min(1,S(R)))}function N(R){return Math.max(0,S(R))}return V("fill","fill"),V("fill-opacity","fillOpacity",ee),V("fill-rule","fillRule"),V("opacity","opacity",ee),V("stroke","stroke"),V("stroke-opacity","strokeOpacity",ee),V("stroke-width","strokeWidth",N),V("stroke-linejoin","strokeLineJoin"),V("stroke-linecap","strokeLineCap"),V("stroke-miterlimit","strokeMiterLimit",N),V("visibility","visibility"),z}function w(j,z){return j-(z-j)}function v(j,z,A){if(typeof j!="string")throw new TypeError("Invalid input: "+typeof j);const V={SEPARATOR:/[ \t\r\n\,.\-+]/,WHITESPACE:/[ \t\r\n]/,DIGIT:/[\d]/,SIGN:/[-+]/,POINT:/\./,COMMA:/,/,EXP:/e/i,FLAGS:/[01]/},ee=0,N=1,R=2,T=3;let O=ee,k=!0,E="",q="";const W=[];function te(ce,ge,_e){const xe=new SyntaxError('Unexpected character "'+ce+'" at index '+ge+".");throw xe.partial=_e,xe}function U(){E!==""&&(q===""?W.push(Number(E)):W.push(Number(E)*Math.pow(10,Number(q)))),E="",q=""}let B;const oe=j.length;for(let ce=0;ce<oe;ce++){if(B=j[ce],Array.isArray(z)&&z.includes(W.length%A)&&V.FLAGS.test(B)){O=N,E=B,U();continue}if(O===ee){if(V.WHITESPACE.test(B))continue;if(V.DIGIT.test(B)||V.SIGN.test(B)){O=N,E=B;continue}if(V.POINT.test(B)){O=R,E=B;continue}V.COMMA.test(B)&&(k&&te(B,ce,W),k=!0)}if(O===N){if(V.DIGIT.test(B)){E+=B;continue}if(V.POINT.test(B)){E+=B,O=R;continue}if(V.EXP.test(B)){O=T;continue}V.SIGN.test(B)&&E.length===1&&V.SIGN.test(E[0])&&te(B,ce,W)}if(O===R){if(V.DIGIT.test(B)){E+=B;continue}if(V.EXP.test(B)){O=T;continue}V.POINT.test(B)&&E[E.length-1]==="."&&te(B,ce,W)}if(O===T){if(V.DIGIT.test(B)){q+=B;continue}if(V.SIGN.test(B)){if(q===""){q+=B;continue}q.length===1&&V.SIGN.test(q)&&te(B,ce,W)}}V.WHITESPACE.test(B)?(U(),O=ee,k=!1):V.COMMA.test(B)?(U(),O=ee,k=!0):V.SIGN.test(B)?(U(),O=N,E=B):V.POINT.test(B)?(U(),O=R,E=B):te(B,ce,W)}return U(),W}const P=["mm","cm","in","pt","pc","px"],D={mm:{mm:1,cm:.1,in:1/25.4,pt:72/25.4,pc:6/25.4,px:-1},cm:{mm:10,cm:1,in:1/2.54,pt:72/2.54,pc:6/2.54,px:-1},in:{mm:25.4,cm:2.54,in:1,pt:72,pc:6,px:-1},pt:{mm:25.4/72,cm:2.54/72,in:1/72,pt:1,pc:6/72,px:-1},pc:{mm:25.4/6,cm:2.54/6,in:1/6,pt:72/6,pc:1,px:-1},px:{px:1}};function S(j){let z="px";if(typeof j=="string"||j instanceof String)for(let V=0,ee=P.length;V<ee;V++){const N=P[V];if(j.endsWith(N)){z=N,j=j.substring(0,j.length-N.length);break}}let A;return z==="px"&&t.defaultUnit!=="px"?A=D.in[t.defaultUnit]/t.defaultDPI:(A=D[z][t.defaultUnit],A<0&&(A=D[z].in*t.defaultDPI)),A*parseFloat(j)}function _(j){if(!(j.hasAttribute("transform")||j.nodeName==="use"&&(j.hasAttribute("x")||j.hasAttribute("y"))))return null;const z=L(j);return F.length>0&&z.premultiply(F[F.length-1]),ne.copy(z),F.push(z),z}function L(j){const z=new c.Matrix3,A=J;if(j.nodeName==="use"&&(j.hasAttribute("x")||j.hasAttribute("y"))){const V=S(j.getAttribute("x")),ee=S(j.getAttribute("y"));z.translate(V,ee)}if(j.hasAttribute("transform")){const V=j.getAttribute("transform").split(")");for(let ee=V.length-1;ee>=0;ee--){const N=V[ee].trim();if(N==="")continue;const R=N.indexOf("("),T=N.length;if(R>0&&R<T){const O=N.substr(0,R),k=v(N.substr(R+1,T-R-1));switch(A.identity(),O){case"translate":if(k.length>=1){const E=k[0];let q=E;k.length>=2&&(q=k[1]),A.translate(E,q)}break;case"rotate":if(k.length>=1){let E=0,q=0,W=0;E=-k[0]*Math.PI/180,k.length>=3&&(q=k[1],W=k[2]),G.identity().translate(-q,-W),Q.identity().rotate(E),K.multiplyMatrices(Q,G),G.identity().translate(q,W),A.multiplyMatrices(G,K)}break;case"scale":if(k.length>=1){const E=k[0];let q=E;k.length>=2&&(q=k[1]),A.scale(E,q)}break;case"skewX":k.length===1&&A.set(1,Math.tan(k[0]*Math.PI/180),0,0,1,0,0,0,1);break;case"skewY":k.length===1&&A.set(1,0,0,Math.tan(k[0]*Math.PI/180),1,0,0,0,1);break;case"matrix":k.length===6&&A.set(k[0],k[2],k[4],k[1],k[3],k[5],0,0,1);break}}z.premultiply(A)}}return z}function b(j,z){function A(N){X.set(N.x,N.y,1).applyMatrix3(z),N.set(X.x,X.y)}const V=C(z),ee=j.subPaths;for(let N=0,R=ee.length;N<R;N++){const O=ee[N].curves;for(let k=0;k<O.length;k++){const E=O[k];E.isLineCurve?(A(E.v1),A(E.v2)):E.isCubicBezierCurve?(A(E.v0),A(E.v1),A(E.v2),A(E.v3)):E.isQuadraticBezierCurve?(A(E.v0),A(E.v1),A(E.v2)):E.isEllipseCurve&&(V&&console.warn("SVGLoader: Elliptic arc or ellipse rotation or skewing is not implemented."),Z.set(E.aX,E.aY),A(Z),E.aX=Z.x,E.aY=Z.y,E.xRadius*=m(z),E.yRadius*=M(z))}}}function C(j){return j.elements[1]!==0||j.elements[3]!==0}function m(j){const z=j.elements;return Math.sqrt(z[0]*z[0]+z[1]*z[1])}function M(j){const z=j.elements;return Math.sqrt(z[3]*z[3]+z[4]*z[4])}const p=[],I={},F=[],J=new c.Matrix3,G=new c.Matrix3,Q=new c.Matrix3,K=new c.Matrix3,Z=new c.Vector2,X=new c.Vector3,ne=new c.Matrix3,se=new DOMParser().parseFromString(e,"image/svg+xml");return n(se.documentElement,{fill:"#000",fillOpacity:1,strokeOpacity:1,strokeWidth:1,strokeLineJoin:"miter",strokeLineCap:"butt",strokeMiterLimit:4}),{paths:p,xml:se.documentElement}}static createShapes(e){const n={ORIGIN:0,DESTINATION:1,BETWEEN:2,LEFT:3,RIGHT:4,BEHIND:5,BEYOND:6},s={loc:n.ORIGIN,t:0};function r(v,P,D,S){const _=v.x,L=P.x,b=D.x,C=S.x,m=v.y,M=P.y,p=D.y,I=S.y,F=(C-b)*(m-p)-(I-p)*(_-b),J=(L-_)*(m-p)-(M-m)*(_-b),G=(I-p)*(L-_)-(C-b)*(M-m),Q=F/G,K=J/G;if(G===0&&F!==0||Q<=0||Q>=1||K<0||K>1)return null;if(F===0&&G===0){for(let Z=0;Z<2;Z++)if(i(Z===0?D:S,v,P),s.loc==n.ORIGIN){const X=Z===0?D:S;return{x:X.x,y:X.y,t:s.t}}else if(s.loc==n.BETWEEN){const X=+(_+s.t*(L-_)).toPrecision(10),ne=+(m+s.t*(M-m)).toPrecision(10);return{x:X,y:ne,t:s.t}}return null}else{for(let ne=0;ne<2;ne++)if(i(ne===0?D:S,v,P),s.loc==n.ORIGIN){const se=ne===0?D:S;return{x:se.x,y:se.y,t:s.t}}const Z=+(_+Q*(L-_)).toPrecision(10),X=+(m+Q*(M-m)).toPrecision(10);return{x:Z,y:X,t:Q}}}function i(v,P,D){const S=D.x-P.x,_=D.y-P.y,L=v.x-P.x,b=v.y-P.y,C=S*b-L*_;if(v.x===P.x&&v.y===P.y){s.loc=n.ORIGIN,s.t=0;return}if(v.x===D.x&&v.y===D.y){s.loc=n.DESTINATION,s.t=1;return}if(C<-Number.EPSILON){s.loc=n.LEFT;return}if(C>Number.EPSILON){s.loc=n.RIGHT;return}if(S*L<0||_*b<0){s.loc=n.BEHIND;return}if(Math.sqrt(S*S+_*_)<Math.sqrt(L*L+b*b)){s.loc=n.BEYOND;return}let m;S!==0?m=L/S:m=b/_,s.loc=n.BETWEEN,s.t=m}function a(v,P){const D=[],S=[];for(let _=1;_<v.length;_++){const L=v[_-1],b=v[_];for(let C=1;C<P.length;C++){const m=P[C-1],M=P[C],p=r(L,b,m,M);p!==null&&D.find(I=>I.t<=p.t+Number.EPSILON&&I.t>=p.t-Number.EPSILON)===void 0&&(D.push(p),S.push(new c.Vector2(p.x,p.y)))}}return S}function l(v,P,D){const S=new c.Vector2;P.getCenter(S);const _=[];return D.forEach(L=>{L.boundingBox.containsPoint(S)&&a(v,L.points).forEach(C=>{_.push({identifier:L.identifier,isCW:L.isCW,point:C})})}),_.sort((L,b)=>L.point.x-b.point.x),_}function u(v,P,D,S,_){(_==null||_==="")&&(_="nonzero");const L=new c.Vector2;v.boundingBox.getCenter(L);const b=[new c.Vector2(D,L.y),new c.Vector2(S,L.y)],C=l(b,v.boundingBox,P);C.sort((J,G)=>J.point.x-G.point.x);const m=[],M=[];C.forEach(J=>{J.identifier===v.identifier?m.push(J):M.push(J)});const p=m[0].point.x,I=[];let F=0;for(;F<M.length&&M[F].point.x<p;)I.length>0&&I[I.length-1]===M[F].identifier?I.pop():I.push(M[F].identifier),F++;if(I.push(v.identifier),_==="evenodd"){const J=I.length%2===0,G=I[I.length-2];return{identifier:v.identifier,isHole:J,for:G}}else if(_==="nonzero"){let J=!0,G=null,Q=null;for(let K=0;K<I.length;K++){const Z=I[K];J?(Q=P[Z].isCW,J=!1,G=Z):Q!==P[Z].isCW&&(Q=P[Z].isCW,J=!0)}return{identifier:v.identifier,isHole:J,for:G}}else console.warn('fill-rule: "'+_+'" is currently not implemented.')}let h=0,d=999999999,y=-999999999,g=e.subPaths.map(v=>{const P=v.getPoints();let D=-999999999,S=999999999,_=-999999999,L=999999999;for(let b=0;b<P.length;b++){const C=P[b];C.y>D&&(D=C.y),C.y<S&&(S=C.y),C.x>_&&(_=C.x),C.x<L&&(L=C.x)}return y<=_&&(y=_+1),d>=L&&(d=L-1),{curves:v.curves,points:P,isCW:c.ShapeUtils.isClockWise(P),identifier:h++,boundingBox:new c.Box2(new c.Vector2(L,S),new c.Vector2(_,D))}});g=g.filter(v=>v.points.length>1);const x=g.map(v=>u(v,g,d,y,e.userData.style.fillRule)),w=[];return g.forEach(v=>{if(!x[v.identifier].isHole){const D=new c.Shape;D.curves=v.curves,x.filter(_=>_.isHole&&_.for===v.identifier).forEach(_=>{const L=g[_.identifier],b=new c.Path;b.curves=L.curves,D.holes.push(b)}),w.push(D)}}),w}static getStrokeStyle(e,t,n,s,r){return e=e!==void 0?e:1,t=t!==void 0?t:"#000",n=n!==void 0?n:"miter",s=s!==void 0?s:"butt",r=r!==void 0?r:4,{strokeColor:t,strokeWidth:e,strokeLineJoin:n,strokeLineCap:s,strokeMiterLimit:r}}static pointsToStroke(e,t,n,s){const r=[],i=[],a=[];if(Wt.pointsToStrokeWithBuffers(e,t,n,s,r,i,a)===0)return null;const l=new c.BufferGeometry;return l.setAttribute("position",new c.Float32BufferAttribute(r,3)),l.setAttribute("normal",new c.Float32BufferAttribute(i,3)),l.setAttribute("uv",new c.Float32BufferAttribute(a,2)),l}static pointsToStrokeWithBuffers(e,t,n,s,r,i,a,l){const u=new c.Vector2,h=new c.Vector2,d=new c.Vector2,y=new c.Vector2,g=new c.Vector2,x=new c.Vector2,w=new c.Vector2,v=new c.Vector2,P=new c.Vector2,D=new c.Vector2,S=new c.Vector2,_=new c.Vector2,L=new c.Vector2,b=new c.Vector2,C=new c.Vector2,m=new c.Vector2,M=new c.Vector2;n=n!==void 0?n:12,s=s!==void 0?s:.001,l=l!==void 0?l:0,e=q(e);const p=e.length;if(p<2)return 0;const I=e[0].equals(e[p-1]);let F,J=e[0],G;const Q=t.strokeWidth/2,K=1/(p-1);let Z=0,X,ne,se,ue,j=!1,z=0,A=l*3,V=l*2;ee(e[0],e[1],u).multiplyScalar(Q),v.copy(e[0]).sub(u),P.copy(e[0]).add(u),D.copy(v),S.copy(P);for(let W=1;W<p;W++){F=e[W],W===p-1?I?G=e[1]:G=void 0:G=e[W+1];const te=u;if(ee(J,F,te),d.copy(te).multiplyScalar(Q),_.copy(F).sub(d),L.copy(F).add(d),X=Z+K,ne=!1,G!==void 0){ee(F,G,h),d.copy(h).multiplyScalar(Q),b.copy(F).sub(d),C.copy(F).add(d),se=!0,d.subVectors(G,J),te.dot(d)<0&&(se=!1),W===1&&(j=se),d.subVectors(G,F),d.normalize();const U=Math.abs(te.dot(d));if(U!==0){const B=Q/U;d.multiplyScalar(-B),y.subVectors(F,J),g.copy(y).setLength(B).add(d),m.copy(g).negate();const oe=g.length(),ce=y.length();y.divideScalar(ce),x.subVectors(G,F);const ge=x.length();switch(x.divideScalar(ge),y.dot(m)<ce&&x.dot(m)<ge&&(ne=!0),M.copy(g).add(F),m.add(F),ue=!1,ne?se?(C.copy(m),L.copy(m)):(b.copy(m),_.copy(m)):T(),t.strokeLineJoin){case"bevel":O(se,ne,X);break;case"round":k(se,ne),se?R(F,_,b,X,0):R(F,C,L,X,1);break;case"miter":case"miter-clip":default:const _e=Q*t.strokeMiterLimit/oe;if(_e<1)if(t.strokeLineJoin!=="miter-clip"){O(se,ne,X);break}else k(se,ne),se?(x.subVectors(M,_).multiplyScalar(_e).add(_),w.subVectors(M,b).multiplyScalar(_e).add(b),N(_,X,0),N(x,X,0),N(F,X,.5),N(F,X,.5),N(x,X,0),N(w,X,0),N(F,X,.5),N(w,X,0),N(b,X,0)):(x.subVectors(M,L).multiplyScalar(_e).add(L),w.subVectors(M,C).multiplyScalar(_e).add(C),N(L,X,1),N(x,X,1),N(F,X,.5),N(F,X,.5),N(x,X,1),N(w,X,1),N(F,X,.5),N(w,X,1),N(C,X,1));else ne?(se?(N(P,Z,1),N(v,Z,0),N(M,X,0),N(P,Z,1),N(M,X,0),N(m,X,1)):(N(P,Z,1),N(v,Z,0),N(M,X,1),N(v,Z,0),N(m,X,0),N(M,X,1)),se?b.copy(M):C.copy(M)):se?(N(_,X,0),N(M,X,0),N(F,X,.5),N(F,X,.5),N(M,X,0),N(b,X,0)):(N(L,X,1),N(M,X,1),N(F,X,.5),N(F,X,.5),N(M,X,1),N(C,X,1)),ue=!0;break}}else T()}else T();!I&&W===p-1&&E(e[0],D,S,se,!0,Z),Z=X,J=F,v.copy(b),P.copy(C)}if(!I)E(F,_,L,se,!1,X);else if(ne&&r){let W=M,te=m;j!==se&&(W=m,te=M),se?(ue||j)&&(te.toArray(r,0*3),te.toArray(r,3*3),ue&&W.toArray(r,1*3)):(ue||!j)&&(te.toArray(r,1*3),te.toArray(r,3*3),ue&&W.toArray(r,0*3))}return z;function ee(W,te,U){return U.subVectors(te,W),U.set(-U.y,U.x).normalize()}function N(W,te,U){r&&(r[A]=W.x,r[A+1]=W.y,r[A+2]=0,i&&(i[A]=0,i[A+1]=0,i[A+2]=1),A+=3,a&&(a[V]=te,a[V+1]=U,V+=2)),z+=3}function R(W,te,U,B,oe){u.copy(te).sub(W).normalize(),h.copy(U).sub(W).normalize();let ce=Math.PI;const ge=u.dot(h);Math.abs(ge)<1&&(ce=Math.abs(Math.acos(ge))),ce/=n,d.copy(te);for(let _e=0,xe=n-1;_e<xe;_e++)y.copy(d).rotateAround(W,ce),N(d,B,oe),N(y,B,oe),N(W,B,.5),d.copy(y);N(y,B,oe),N(U,B,oe),N(W,B,.5)}function T(){N(P,Z,1),N(v,Z,0),N(_,X,0),N(P,Z,1),N(_,X,1),N(L,X,0)}function O(W,te,U){te?W?(N(P,Z,1),N(v,Z,0),N(_,X,0),N(P,Z,1),N(_,X,0),N(m,X,1),N(_,U,0),N(b,U,0),N(m,U,.5)):(N(P,Z,1),N(v,Z,0),N(L,X,1),N(v,Z,0),N(m,X,0),N(L,X,1),N(L,U,1),N(C,U,0),N(m,U,.5)):W?(N(_,U,0),N(b,U,0),N(F,U,.5)):(N(L,U,1),N(C,U,0),N(F,U,.5))}function k(W,te){te&&(W?(N(P,Z,1),N(v,Z,0),N(_,X,0),N(P,Z,1),N(_,X,0),N(m,X,1),N(_,Z,0),N(F,X,.5),N(m,X,1),N(F,X,.5),N(b,Z,0),N(m,X,1)):(N(P,Z,1),N(v,Z,0),N(L,X,1),N(v,Z,0),N(m,X,0),N(L,X,1),N(L,Z,1),N(m,X,0),N(F,X,.5),N(F,X,.5),N(m,X,0),N(C,Z,1)))}function E(W,te,U,B,oe,ce){switch(t.strokeLineCap){case"round":oe?R(W,U,te,ce,.5):R(W,te,U,ce,.5);break;case"square":if(oe)u.subVectors(te,W),h.set(u.y,-u.x),d.addVectors(u,h).add(W),y.subVectors(h,u).add(W),B?(d.toArray(r,1*3),y.toArray(r,0*3),y.toArray(r,3*3)):(d.toArray(r,1*3),d.toArray(r,3*3),y.toArray(r,0*3));else{u.subVectors(U,W),h.set(u.y,-u.x),d.addVectors(u,h).add(W),y.subVectors(h,u).add(W);const ge=r.length;B?(d.toArray(r,ge-1*3),y.toArray(r,ge-2*3),y.toArray(r,ge-4*3)):(d.toArray(r,ge-2*3),y.toArray(r,ge-1*3),y.toArray(r,ge-4*3))}break}}function q(W){let te=!1;for(let B=1,oe=W.length-1;B<oe;B++)if(W[B].distanceTo(W[B+1])<s){te=!0;break}if(!te)return W;const U=[];U.push(W[0]);for(let B=1,oe=W.length-1;B<oe;B++)W[B].distanceTo(W[B+1])>=s&&U.push(W[B]);return U.push(W[W.length-1]),U}}}const ns=new WeakMap;class Ka extends c.Loader{constructor(e){super(e),this.decoderPath="",this.decoderConfig={},this.decoderBinary=null,this.decoderPending=null,this.workerLimit=4,this.workerPool=[],this.workerNextTaskID=1,this.workerSourceURL="",this.defaultAttributeIDs={position:"POSITION",normal:"NORMAL",color:"COLOR",uv:"TEX_COORD"},this.defaultAttributeTypes={position:"Float32Array",normal:"Float32Array",color:"Float32Array",uv:"Float32Array"}}setDecoderPath(e){return this.decoderPath=e,this}setDecoderConfig(e){return this.decoderConfig=e,this}setWorkerLimit(e){return this.workerLimit=e,this}load(e,t,n,s){const r=new c.FileLoader(this.manager);r.setPath(this.path),r.setResponseType("arraybuffer"),r.setRequestHeader(this.requestHeader),r.setWithCredentials(this.withCredentials),r.load(e,i=>{const a={attributeIDs:this.defaultAttributeIDs,attributeTypes:this.defaultAttributeTypes,useUniqueIDs:!1};this.decodeGeometry(i,a).then(t).catch(s)},n,s)}decodeDracoFile(e,t,n,s){const r={attributeIDs:n||this.defaultAttributeIDs,attributeTypes:s||this.defaultAttributeTypes,useUniqueIDs:!!n};this.decodeGeometry(e,r).then(t)}decodeGeometry(e,t){for(const l in t.attributeTypes){const u=t.attributeTypes[l];u.BYTES_PER_ELEMENT!==void 0&&(t.attributeTypes[l]=u.name)}const n=JSON.stringify(t);if(ns.has(e)){const l=ns.get(e);if(l.key===n)return l.promise;if(e.byteLength===0)throw new Error("THREE.DRACOLoader: Unable to re-decode a buffer with different settings. Buffer has already been transferred.")}let s;const r=this.workerNextTaskID++,i=e.byteLength,a=this._getWorker(r,i).then(l=>(s=l,new Promise((u,h)=>{s._callbacks[r]={resolve:u,reject:h},s.postMessage({type:"decode",id:r,taskConfig:t,buffer:e},[e])}))).then(l=>this._createGeometry(l.geometry));return a.catch(()=>!0).then(()=>{s&&r&&this._releaseTask(s,r)}),ns.set(e,{key:n,promise:a}),a}_createGeometry(e){const t=new c.BufferGeometry;e.index&&t.setIndex(new c.BufferAttribute(e.index.array,1));for(let n=0;n<e.attributes.length;n++){const s=e.attributes[n],r=s.name,i=s.array,a=s.itemSize;t.setAttribute(r,new c.BufferAttribute(i,a))}return t}_loadLibrary(e,t){const n=new c.FileLoader(this.manager);return n.setPath(this.decoderPath),n.setResponseType(t),n.setWithCredentials(this.withCredentials),new Promise((s,r)=>{n.load(e,s,void 0,r)})}preload(){return this._initDecoder(),this}_initDecoder(){if(this.decoderPending)return this.decoderPending;const e=typeof WebAssembly!="object"||this.decoderConfig.type==="js",t=[];return e?t.push(this._loadLibrary("draco_decoder.js","text")):(t.push(this._loadLibrary("draco_wasm_wrapper.js","text")),t.push(this._loadLibrary("draco_decoder.wasm","arraybuffer"))),this.decoderPending=Promise.all(t).then(n=>{const s=n[0];e||(this.decoderConfig.wasmBinary=n[1]);const r=qa.toString(),i=["/* draco decoder */",s,"","/* worker */",r.substring(r.indexOf("{")+1,r.lastIndexOf("}"))].join(`
-`);this.workerSourceURL=URL.createObjectURL(new Blob([i]))}),this.decoderPending}_getWorker(e,t){return this._initDecoder().then(()=>{if(this.workerPool.length<this.workerLimit){const s=new Worker(this.workerSourceURL);s._callbacks={},s._taskCosts={},s._taskLoad=0,s.postMessage({type:"init",decoderConfig:this.decoderConfig}),s.onmessage=function(r){const i=r.data;switch(i.type){case"decode":s._callbacks[i.id].resolve(i);break;case"error":s._callbacks[i.id].reject(i);break;default:console.error('THREE.DRACOLoader: Unexpected message, "'+i.type+'"')}},this.workerPool.push(s)}else this.workerPool.sort(function(s,r){return s._taskLoad>r._taskLoad?-1:1});const n=this.workerPool[this.workerPool.length-1];return n._taskCosts[e]=t,n._taskLoad+=t,n})}_releaseTask(e,t){e._taskLoad-=e._taskCosts[t],delete e._callbacks[t],delete e._taskCosts[t]}debug(){console.log("Task load: ",this.workerPool.map(e=>e._taskLoad))}dispose(){for(let e=0;e<this.workerPool.length;++e)this.workerPool[e].terminate();return this.workerPool.length=0,this}}function qa(){let o,e;onmessage=function(i){const a=i.data;switch(a.type){case"init":o=a.decoderConfig,e=new Promise(function(h){o.onModuleLoaded=function(d){h({draco:d})},DracoDecoderModule(o)});break;case"decode":const l=a.buffer,u=a.taskConfig;e.then(h=>{const d=h.draco,y=new d.Decoder,g=new d.DecoderBuffer;g.Init(new Int8Array(l),l.byteLength);try{const x=t(d,y,g,u),w=x.attributes.map(v=>v.array.buffer);x.index&&w.push(x.index.array.buffer),self.postMessage({type:"decode",id:a.id,geometry:x},w)}catch(x){console.error(x),self.postMessage({type:"error",id:a.id,error:x.message})}finally{d.destroy(g),d.destroy(y)}});break}};function t(i,a,l,u){const h=u.attributeIDs,d=u.attributeTypes;let y,g;const x=a.GetEncodedGeometryType(l);if(x===i.TRIANGULAR_MESH)y=new i.Mesh,g=a.DecodeBufferToMesh(l,y);else if(x===i.POINT_CLOUD)y=new i.PointCloud,g=a.DecodeBufferToPointCloud(l,y);else throw new Error("THREE.DRACOLoader: Unexpected geometry type.");if(!g.ok()||y.ptr===0)throw new Error("THREE.DRACOLoader: Decoding failed: "+g.error_msg());const w={index:null,attributes:[]};for(const v in h){const P=self[d[v]];let D,S;if(u.useUniqueIDs)S=h[v],D=a.GetAttributeByUniqueId(y,S);else{if(S=a.GetAttributeId(y,i[h[v]]),S===-1)continue;D=a.GetAttribute(y,S)}w.attributes.push(s(i,a,y,v,P,D))}return x===i.TRIANGULAR_MESH&&(w.index=n(i,a,y)),i.destroy(y),w}function n(i,a,l){const h=l.num_faces()*3,d=h*4,y=i._malloc(d);a.GetTrianglesUInt32Array(l,d,y);const g=new Uint32Array(i.HEAPF32.buffer,y,h).slice();return i._free(y),{array:g,itemSize:1}}function s(i,a,l,u,h,d){const y=d.num_components(),x=l.num_points()*y,w=x*h.BYTES_PER_ELEMENT,v=r(i,h),P=i._malloc(w);a.GetAttributeDataArrayForAllPoints(l,d,v,w,P);const D=new h(i.HEAPF32.buffer,P,x).slice();return i._free(P),{name:u,array:D,itemSize:y}}function r(i,a){switch(a){case Float32Array:return i.DT_FLOAT32;case Int8Array:return i.DT_INT8;case Int16Array:return i.DT_INT16;case Int32Array:return i.DT_INT32;case Uint8Array:return i.DT_UINT8;case Uint16Array:return i.DT_UINT16;case Uint32Array:return i.DT_UINT32}}}class wr extends c.Line{constructor(e,t){const n=[1,1,0,-1,1,0,-1,-1,0,1,-1,0,1,1,0],s=new c.BufferGeometry;s.setAttribute("position",new c.Float32BufferAttribute(n,3)),s.computeBoundingSphere();const r=new c.LineBasicMaterial({fog:!1});super(s,r),this.light=e,this.color=t,this.type="RectAreaLightHelper";const i=[1,1,0,-1,1,0,-1,-1,0,1,1,0,-1,-1,0,1,-1,0],a=new c.BufferGeometry;a.setAttribute("position",new c.Float32BufferAttribute(i,3)),a.computeBoundingSphere(),this.add(new c.Mesh(a,new c.MeshBasicMaterial({side:c.BackSide,fog:!1})))}updateMatrixWorld(){if(this.scale.set(.5*this.light.width,.5*this.light.height,1),this.color!==void 0)this.material.color.set(this.color),this.children[0].material.color.set(this.color);else{this.material.color.copy(this.light.color).multiplyScalar(this.light.intensity);const e=this.material.color,t=Math.max(e.r,e.g,e.b);t>1&&e.multiplyScalar(1/t),this.children[0].material.color.copy(this.material.color)}this.matrixWorld.extractRotation(this.light.matrixWorld).scale(this.scale).copyPosition(this.light.matrixWorld),this.children[0].matrixWorld.copy(this.matrixWorld)}dispose(){this.geometry.dispose(),this.material.dispose(),this.children[0].geometry.dispose(),this.children[0].material.dispose()}}const Qa=["args","center"],Ja=f.defineComponent({__name:"Text3D",props:{font:{},text:{},size:{default:.5},height:{default:.2},curveSegments:{default:5},bevelEnabled:{type:Boolean,default:!0},bevelThickness:{default:.05},bevelSize:{default:.02},bevelOffset:{default:0},bevelSegments:{default:4},center:{type:Boolean,default:!1},needUpdates:{type:Boolean,default:!1}},async setup(o,{expose:e}){let t,n;const s=o,{center:r,font:i,text:a,needUpdates:l,size:u,height:h,curveSegments:d,bevelEnabled:y,bevelThickness:g,bevelSize:x,bevelOffset:w,bevelSegments:v}=f.toRefs(s),{extend:P}=ae.useTresContext();P({TextGeometry:ur});const D=new Xa,S=f.useSlots(),_=f.computed(()=>{var m;return a!=null&&a.value?a.value:S.default?(m=S.default()[0].children)==null?void 0:m.trim():l.value?"":"TresJS"}),L=f.shallowRef();e({value:L});const b=([t,n]=f.withAsyncContext(()=>new Promise((m,M)=>{try{typeof i.value=="string"?D.load(i.value,p=>{m(p)}):m(i.value)}catch(p){M(console.error("cientos",p))}})),t=await t,n(),t),C=f.computed(()=>({font:b,size:f.toValue(u),height:f.toValue(h),curveSegments:f.toValue(d),bevelEnabled:f.toValue(y),bevelThickness:f.toValue(g),bevelSize:f.toValue(x),bevelOffset:f.toValue(w),bevelSegments:f.toValue(v)}));return f.watchEffect(()=>{L.value&&l.value&&(L.value.geometry.dispose(),L.value.geometry=new ur(_.value,C.value),r.value&&L.value.geometry.center())}),(m,M)=>f.unref(i)?(f.openBlock(),f.createElementBlock("TresMesh",{key:0,ref_key:"text3DRef",ref:L},[_.value?(f.openBlock(),f.createElementBlock("TresTextGeometry",{key:0,args:[_.value,C.value],center:f.unref(r)},null,8,Qa)):f.createCommentVNode("",!0),f.renderSlot(m.$slots,"default")],512)):f.createCommentVNode("",!0)}});function Ha(o,e){const t=f.ref(e),n=new c.AnimationMixer(t.value),s=f.shallowReactive({});o.forEach(i=>{const a=n.clipAction(i,t.value);s[i.name]=a});const{onLoop:r}=ae.useRenderLoop();return r(({delta:i})=>{n.update(i)}),{actions:s,mixer:n}}const $a=f.defineComponent({__name:"Levioso",props:{speed:{default:1},rotationFactor:{default:1},floatFactor:{default:1},range:{default:()=>[-.1,.1]}},setup(o,{expose:e}){const t=o,n=f.shallowRef();e({value:n});{const l=Math.random()*1e4,{onLoop:u}=ae.useRenderLoop();let h=l;u(({delta:d})=>{if(!n.value)return;h+=d*t.speed;const y=h*.25,g=n.value;g.rotation.x=Math.cos(y)*.125*t.rotationFactor,g.rotation.y=Math.sin(y)*.125*t.rotationFactor,g.rotation.z=Math.sin(y)*.05*t.rotationFactor,g.position.y=c.MathUtils.mapLinear(Math.sin(y),-1,1,t.range[0],t.range[1])*t.floatFactor})}return(s,r)=>(f.openBlock(),f.createElementBlock("TresGroup",f.mergeProps(s.$attrs,{ref_key:"groupRef",ref:n}),[f.renderSlot(s.$slots,"default")],16))}});class Zt extends c.Mesh{constructor(e,t={}){super(e),this.isReflector=!0,this.type="Reflector",this.camera=new c.PerspectiveCamera;const n=this,s=t.color!==void 0?new c.Color(t.color):new c.Color(8355711),r=t.textureWidth||512,i=t.textureHeight||512,a=t.clipBias||0,l=t.shader||Zt.ReflectorShader,u=t.multisample!==void 0?t.multisample:4,h=new c.Plane,d=new c.Vector3,y=new c.Vector3,g=new c.Vector3,x=new c.Matrix4,w=new c.Vector3(0,0,-1),v=new c.Vector4,P=new c.Vector3,D=new c.Vector3,S=new c.Vector4,_=new c.Matrix4,L=this.camera,b=new c.WebGLRenderTarget(r,i,{samples:u,type:c.HalfFloatType}),C=new c.ShaderMaterial({name:l.name!==void 0?l.name:"unspecified",uniforms:c.UniformsUtils.clone(l.uniforms),fragmentShader:l.fragmentShader,vertexShader:l.vertexShader});C.uniforms.tDiffuse.value=b.texture,C.uniforms.color.value=s,C.uniforms.textureMatrix.value=_,this.material=C,this.onBeforeRender=function(m,M,p){if(y.setFromMatrixPosition(n.matrixWorld),g.setFromMatrixPosition(p.matrixWorld),x.extractRotation(n.matrixWorld),d.set(0,0,1),d.applyMatrix4(x),P.subVectors(y,g),P.dot(d)>0)return;P.reflect(d).negate(),P.add(y),x.extractRotation(p.matrixWorld),w.set(0,0,-1),w.applyMatrix4(x),w.add(g),D.subVectors(y,w),D.reflect(d).negate(),D.add(y),L.position.copy(P),L.up.set(0,1,0),L.up.applyMatrix4(x),L.up.reflect(d),L.lookAt(D),L.far=p.far,L.updateMatrixWorld(),L.projectionMatrix.copy(p.projectionMatrix),_.set(.5,0,0,.5,0,.5,0,.5,0,0,.5,.5,0,0,0,1),_.multiply(L.projectionMatrix),_.multiply(L.matrixWorldInverse),_.multiply(n.matrixWorld),h.setFromNormalAndCoplanarPoint(d,y),h.applyMatrix4(L.matrixWorldInverse),v.set(h.normal.x,h.normal.y,h.normal.z,h.constant);const I=L.projectionMatrix;S.x=(Math.sign(v.x)+I.elements[8])/I.elements[0],S.y=(Math.sign(v.y)+I.elements[9])/I.elements[5],S.z=-1,S.w=(1+I.elements[10])/I.elements[14],v.multiplyScalar(2/v.dot(S)),I.elements[2]=v.x,I.elements[6]=v.y,I.elements[10]=v.z+1-a,I.elements[14]=v.w,n.visible=!1;const F=m.getRenderTarget(),J=m.xr.enabled,G=m.shadowMap.autoUpdate;m.xr.enabled=!1,m.shadowMap.autoUpdate=!1,m.setRenderTarget(b),m.state.buffers.depth.setMask(!0),m.autoClear===!1&&m.clear(),m.render(M,L),m.xr.enabled=J,m.shadowMap.autoUpdate=G,m.setRenderTarget(F);const Q=p.viewport;Q!==void 0&&m.state.viewport(Q),n.visible=!0},this.getRenderTarget=function(){return b},this.dispose=function(){b.dispose(),n.material.dispose()}}}Zt.ReflectorShader={name:"ReflectorShader",uniforms:{color:{value:null},tDiffuse:{value:null},textureMatrix:{value:null}},vertexShader:`
+  `};function pi(o,e,t){const n=t.length-o-1;if(e>=t[n])return n-1;if(e<=t[o])return o;let r=o,i=n,s=Math.floor((r+i)/2);for(;e<t[s]||e>=t[s+1];)e<t[s]?i=s:r=s,s=Math.floor((r+i)/2);return s}function La(o,e,t,n){const r=[],i=[],s=[];r[0]=1;for(let a=1;a<=t;++a){i[a]=e-n[o+1-a],s[a]=n[o+a]-e;let c=0;for(let h=0;h<a;++h){const f=s[h+1],d=i[a-h],p=r[h]/(f+d);r[h]=c+f*p,c=d*p}r[a]=c}return r}function Da(o,e,t,n){const r=pi(o,n,e),i=La(r,n,o,e),s=new l.Vector4(0,0,0,0);for(let a=0;a<=o;++a){const c=t[r-o+a],h=i[a],f=c.w*h;s.x+=c.x*f,s.y+=c.y*f,s.z+=c.z*f,s.w+=c.w*h}return s}function Ia(o,e,t,n,r){const i=[];for(let d=0;d<=t;++d)i[d]=0;const s=[];for(let d=0;d<=n;++d)s[d]=i.slice(0);const a=[];for(let d=0;d<=t;++d)a[d]=i.slice(0);a[0][0]=1;const c=i.slice(0),h=i.slice(0);for(let d=1;d<=t;++d){c[d]=e-r[o+1-d],h[d]=r[o+d]-e;let p=0;for(let m=0;m<d;++m){const x=h[m+1],b=c[d-m];a[d][m]=x+b;const v=a[m][d-1]/a[d][m];a[m][d]=p+x*v,p=b*v}a[d][d]=p}for(let d=0;d<=t;++d)s[0][d]=a[d][t];for(let d=0;d<=t;++d){let p=0,m=1;const x=[];for(let b=0;b<=t;++b)x[b]=i.slice(0);x[0][0]=1;for(let b=1;b<=n;++b){let v=0;const _=d-b,T=t-b;d>=b&&(x[m][0]=x[p][0]/a[T+1][_],v=x[m][0]*a[_][T]);const w=_>=-1?1:-_,M=d-1<=T?b-1:t-d;for(let S=w;S<=M;++S)x[m][S]=(x[p][S]-x[p][S-1])/a[T+1][_+S],v+=x[m][S]*a[_+S][T];d<=T&&(x[m][b]=-x[p][b-1]/a[T+1][d],v+=x[m][b]*a[d][T]),s[b][d]=v;const D=p;p=m,m=D}}let f=t;for(let d=1;d<=n;++d){for(let p=0;p<=t;++p)s[d][p]*=f;f*=t-d}return s}function Oa(o,e,t,n,r){const i=r<o?r:o,s=[],a=pi(o,n,e),c=Ia(a,n,o,i,e),h=[];for(let f=0;f<t.length;++f){const d=t[f].clone(),p=d.w;d.x*=p,d.y*=p,d.z*=p,h[f]=d}for(let f=0;f<=i;++f){const d=h[a-o].clone().multiplyScalar(c[f][0]);for(let p=1;p<=o;++p)d.add(h[a-o+p].clone().multiplyScalar(c[f][p]));s[f]=d}for(let f=i+1;f<=r+1;++f)s[f]=new l.Vector4(0,0,0);return s}function ka(o,e){let t=1;for(let r=2;r<=o;++r)t*=r;let n=1;for(let r=2;r<=e;++r)n*=r;for(let r=2;r<=o-e;++r)n*=r;return t/n}function Ba(o){const e=o.length,t=[],n=[];for(let i=0;i<e;++i){const s=o[i];t[i]=new l.Vector3(s.x,s.y,s.z),n[i]=s.w}const r=[];for(let i=0;i<e;++i){const s=t[i].clone();for(let a=1;a<=i;++a)s.sub(r[i-a].clone().multiplyScalar(ka(i,a)*n[a]));r[i]=s.divideScalar(n[0])}return r}function Fa(o,e,t,n,r){const i=Oa(o,e,t,n,r);return Ba(i)}class mi extends l.Curve{constructor(e,t,n,r,i){super(),this.degree=e,this.knots=t,this.controlPoints=[],this.startKnot=r||0,this.endKnot=i||this.knots.length-1;for(let s=0;s<n.length;++s){const a=n[s];this.controlPoints[s]=new l.Vector4(a.x,a.y,a.z,a.w)}}getPoint(e,t){const n=t||new l.Vector3,r=this.knots[this.startKnot]+e*(this.knots[this.endKnot]-this.knots[this.startKnot]),i=Da(this.degree,this.knots,this.controlPoints,r);return i.w!=1&&i.divideScalar(i.w),n.set(i.x,i.y,i.z)}getTangent(e,t){const n=t||new l.Vector3,r=this.knots[0]+e*(this.knots[this.knots.length-1]-this.knots[0]),i=Fa(this.degree,this.knots,this.controlPoints,r,1);return n.copy(i[1]).normalize(),n}}let ve,De,Ve;class Ua extends l.Loader{constructor(e){super(e)}load(e,t,n,r){const i=this,s=i.path===""?l.LoaderUtils.extractUrlBase(e):i.path,a=new l.FileLoader(this.manager);a.setPath(i.path),a.setResponseType("arraybuffer"),a.setRequestHeader(i.requestHeader),a.setWithCredentials(i.withCredentials),a.load(e,function(c){try{t(i.parse(c,s))}catch(h){r?r(h):console.error(h),i.manager.itemError(e)}},n,r)}parse(e,t){if(ja(e))ve=new Ga().parse(e);else{const r=wi(e);if(!Ea(r))throw new Error("THREE.FBXLoader: Unknown format.");if(vi(r)<7e3)throw new Error("THREE.FBXLoader: FBX version not supported, FileVersion: "+vi(r));ve=new Ra().parse(r)}const n=new l.TextureLoader(this.manager).setPath(this.resourcePath||t).setCrossOrigin(this.crossOrigin);return new Na(n,this.manager).parse(ve)}}class Na{constructor(e,t){this.textureLoader=e,this.manager=t}parse(){De=this.parseConnections();const e=this.parseImages(),t=this.parseTextures(e),n=this.parseMaterials(t),r=this.parseDeformers(),i=new za().parse(r);return this.parseScene(r,i,n),Ve}parseConnections(){const e=new Map;return"Connections"in ve&&ve.Connections.connections.forEach(function(n){const r=n[0],i=n[1],s=n[2];e.has(r)||e.set(r,{parents:[],children:[]});const a={ID:i,relationship:s};e.get(r).parents.push(a),e.has(i)||e.set(i,{parents:[],children:[]});const c={ID:r,relationship:s};e.get(i).children.push(c)}),e}parseImages(){const e={},t={};if("Video"in ve.Objects){const n=ve.Objects.Video;for(const r in n){const i=n[r],s=parseInt(r);if(e[s]=i.RelativeFilename||i.Filename,"Content"in i){const a=i.Content instanceof ArrayBuffer&&i.Content.byteLength>0,c=typeof i.Content=="string"&&i.Content!=="";if(a||c){const h=this.parseImage(n[r]);t[i.RelativeFilename||i.Filename]=h}}}}for(const n in e){const r=e[n];t[r]!==void 0?e[n]=t[r]:e[n]=e[n].split("\\").pop()}return e}parseImage(e){const t=e.Content,n=e.RelativeFilename||e.Filename,r=n.slice(n.lastIndexOf(".")+1).toLowerCase();let i;switch(r){case"bmp":i="image/bmp";break;case"jpg":case"jpeg":i="image/jpeg";break;case"png":i="image/png";break;case"tif":i="image/tiff";break;case"tga":this.manager.getHandler(".tga")===null&&console.warn("FBXLoader: TGA loader not found, skipping ",n),i="image/tga";break;default:console.warn('FBXLoader: Image type "'+r+'" is not supported.');return}if(typeof t=="string")return"data:"+i+";base64,"+t;{const s=new Uint8Array(t);return window.URL.createObjectURL(new Blob([s],{type:i}))}}parseTextures(e){const t=new Map;if("Texture"in ve.Objects){const n=ve.Objects.Texture;for(const r in n){const i=this.parseTexture(n[r],e);t.set(parseInt(r),i)}}return t}parseTexture(e,t){const n=this.loadTexture(e,t);n.ID=e.id,n.name=e.attrName;const r=e.WrapModeU,i=e.WrapModeV,s=r!==void 0?r.value:0,a=i!==void 0?i.value:0;if(n.wrapS=s===0?l.RepeatWrapping:l.ClampToEdgeWrapping,n.wrapT=a===0?l.RepeatWrapping:l.ClampToEdgeWrapping,"Scaling"in e){const c=e.Scaling.value;n.repeat.x=c[0],n.repeat.y=c[1]}return n}loadTexture(e,t){let n;const r=this.textureLoader.path,i=De.get(e.id).children;i!==void 0&&i.length>0&&t[i[0].ID]!==void 0&&(n=t[i[0].ID],(n.indexOf("blob:")===0||n.indexOf("data:")===0)&&this.textureLoader.setPath(void 0));let s;const a=e.FileName.slice(-3).toLowerCase();if(a==="tga"){const c=this.manager.getHandler(".tga");c===null?(console.warn("FBXLoader: TGA loader not found, creating placeholder texture for",e.RelativeFilename),s=new l.Texture):(c.setPath(this.textureLoader.path),s=c.load(n))}else a==="psd"?(console.warn("FBXLoader: PSD textures are not supported, creating placeholder texture for",e.RelativeFilename),s=new l.Texture):s=this.textureLoader.load(n);return this.textureLoader.setPath(r),s}parseMaterials(e){const t=new Map;if("Material"in ve.Objects){const n=ve.Objects.Material;for(const r in n){const i=this.parseMaterial(n[r],e);i!==null&&t.set(parseInt(r),i)}}return t}parseMaterial(e,t){const n=e.id,r=e.attrName;let i=e.ShadingModel;if(typeof i=="object"&&(i=i.value),!De.has(n))return null;const s=this.parseParameters(e,t,n);let a;switch(i.toLowerCase()){case"phong":a=new l.MeshPhongMaterial;break;case"lambert":a=new l.MeshLambertMaterial;break;default:console.warn('THREE.FBXLoader: unknown material type "%s". Defaulting to MeshPhongMaterial.',i),a=new l.MeshPhongMaterial;break}return a.setValues(s),a.name=r,a}parseParameters(e,t,n){const r={};e.BumpFactor&&(r.bumpScale=e.BumpFactor.value),e.Diffuse?r.color=new l.Color().fromArray(e.Diffuse.value):e.DiffuseColor&&(e.DiffuseColor.type==="Color"||e.DiffuseColor.type==="ColorRGB")&&(r.color=new l.Color().fromArray(e.DiffuseColor.value)),e.DisplacementFactor&&(r.displacementScale=e.DisplacementFactor.value),e.Emissive?r.emissive=new l.Color().fromArray(e.Emissive.value):e.EmissiveColor&&(e.EmissiveColor.type==="Color"||e.EmissiveColor.type==="ColorRGB")&&(r.emissive=new l.Color().fromArray(e.EmissiveColor.value)),e.EmissiveFactor&&(r.emissiveIntensity=parseFloat(e.EmissiveFactor.value)),e.Opacity&&(r.opacity=parseFloat(e.Opacity.value)),r.opacity<1&&(r.transparent=!0),e.ReflectionFactor&&(r.reflectivity=e.ReflectionFactor.value),e.Shininess&&(r.shininess=e.Shininess.value),e.Specular?r.specular=new l.Color().fromArray(e.Specular.value):e.SpecularColor&&e.SpecularColor.type==="Color"&&(r.specular=new l.Color().fromArray(e.SpecularColor.value));const i=this;return De.get(n).children.forEach(function(s){const a=s.relationship;switch(a){case"Bump":r.bumpMap=i.getTexture(t,s.ID);break;case"Maya|TEX_ao_map":r.aoMap=i.getTexture(t,s.ID);break;case"DiffuseColor":case"Maya|TEX_color_map":r.map=i.getTexture(t,s.ID),r.map!==void 0&&("colorSpace"in r.map?r.map.colorSpace="srgb":r.map.encoding=3001);break;case"DisplacementColor":r.displacementMap=i.getTexture(t,s.ID);break;case"EmissiveColor":r.emissiveMap=i.getTexture(t,s.ID),r.emissiveMap!==void 0&&("colorSpace"in r.emissiveMap?r.emissiveMap.colorSpace="srgb":r.emissiveMap.encoding=3001);break;case"NormalMap":case"Maya|TEX_normal_map":r.normalMap=i.getTexture(t,s.ID);break;case"ReflectionColor":r.envMap=i.getTexture(t,s.ID),r.envMap!==void 0&&(r.envMap.mapping=l.EquirectangularReflectionMapping,"colorSpace"in r.envMap?r.envMap.colorSpace="srgb":r.envMap.encoding=3001);break;case"SpecularColor":r.specularMap=i.getTexture(t,s.ID),r.specularMap!==void 0&&("colorSpace"in r.specularMap?r.specularMap.colorSpace="srgb":r.specularMap.encoding=3001);break;case"TransparentColor":case"TransparencyFactor":r.alphaMap=i.getTexture(t,s.ID),r.transparent=!0;break;case"AmbientColor":case"ShininessExponent":case"SpecularFactor":case"VectorDisplacementColor":default:console.warn("THREE.FBXLoader: %s map is not supported in three.js, skipping texture.",a);break}}),r}getTexture(e,t){return"LayeredTexture"in ve.Objects&&t in ve.Objects.LayeredTexture&&(console.warn("THREE.FBXLoader: layered textures are not supported in three.js. Discarding all but first layer."),t=De.get(t).children[0].ID),e.get(t)}parseDeformers(){const e={},t={};if("Deformer"in ve.Objects){const n=ve.Objects.Deformer;for(const r in n){const i=n[r],s=De.get(parseInt(r));if(i.attrType==="Skin"){const a=this.parseSkeleton(s,n);a.ID=r,s.parents.length>1&&console.warn("THREE.FBXLoader: skeleton attached to more than one geometry is not supported."),a.geometryID=s.parents[0].ID,e[r]=a}else if(i.attrType==="BlendShape"){const a={id:r};a.rawTargets=this.parseMorphTargets(s,n),a.id=r,s.parents.length>1&&console.warn("THREE.FBXLoader: morph target attached to more than one geometry is not supported."),t[r]=a}}}return{skeletons:e,morphTargets:t}}parseSkeleton(e,t){const n=[];return e.children.forEach(function(r){const i=t[r.ID];if(i.attrType!=="Cluster")return;const s={ID:r.ID,indices:[],weights:[],transformLink:new l.Matrix4().fromArray(i.TransformLink.a)};"Indexes"in i&&(s.indices=i.Indexes.a,s.weights=i.Weights.a),n.push(s)}),{rawBones:n,bones:[]}}parseMorphTargets(e,t){const n=[];for(let r=0;r<e.children.length;r++){const i=e.children[r],s=t[i.ID],a={name:s.attrName,initialWeight:s.DeformPercent,id:s.id,fullWeights:s.FullWeights.a};if(s.attrType!=="BlendShapeChannel")return;a.geoID=De.get(parseInt(i.ID)).children.filter(function(c){return c.relationship===void 0})[0].ID,n.push(a)}return n}parseScene(e,t,n){Ve=new l.Group;const r=this.parseModels(e.skeletons,t,n),i=ve.Objects.Model,s=this;r.forEach(function(c){const h=i[c.ID];s.setLookAtProperties(c,h),De.get(c.ID).parents.forEach(function(d){const p=r.get(d.ID);p!==void 0&&p.add(c)}),c.parent===null&&Ve.add(c)}),this.bindSkeleton(e.skeletons,t,r),this.createAmbientLight(),Ve.traverse(function(c){if(c.userData.transformData){c.parent&&(c.userData.transformData.parentMatrix=c.parent.matrix,c.userData.transformData.parentMatrixWorld=c.parent.matrixWorld);const h=_i(c.userData.transformData);c.applyMatrix4(h),c.updateWorldMatrix()}});const a=new Va().parse();Ve.children.length===1&&Ve.children[0].isGroup&&(Ve.children[0].animations=a,Ve=Ve.children[0]),Ve.animations=a}parseModels(e,t,n){const r=new Map,i=ve.Objects.Model;for(const s in i){const a=parseInt(s),c=i[s],h=De.get(a);let f=this.buildSkeleton(h,e,a,c.attrName);if(!f){switch(c.attrType){case"Camera":f=this.createCamera(h);break;case"Light":f=this.createLight(h);break;case"Mesh":f=this.createMesh(h,t,n);break;case"NurbsCurve":f=this.createCurve(h,t);break;case"LimbNode":case"Root":f=new l.Bone;break;case"Null":default:f=new l.Group;break}f.name=c.attrName?l.PropertyBinding.sanitizeNodeName(c.attrName):"",f.ID=a}this.getTransformData(f,c),r.set(a,f)}return r}buildSkeleton(e,t,n,r){let i=null;return e.parents.forEach(function(s){for(const a in t){const c=t[a];c.rawBones.forEach(function(h,f){if(h.ID===s.ID){const d=i;i=new l.Bone,i.matrixWorld.copy(h.transformLink),i.name=r?l.PropertyBinding.sanitizeNodeName(r):"",i.ID=n,c.bones[f]=i,d!==null&&i.add(d)}})}}),i}createCamera(e){let t,n;if(e.children.forEach(function(r){const i=ve.Objects.NodeAttribute[r.ID];i!==void 0&&(n=i)}),n===void 0)t=new l.Object3D;else{let r=0;n.CameraProjectionType!==void 0&&n.CameraProjectionType.value===1&&(r=1);let i=1;n.NearPlane!==void 0&&(i=n.NearPlane.value/1e3);let s=1e3;n.FarPlane!==void 0&&(s=n.FarPlane.value/1e3);let a=window.innerWidth,c=window.innerHeight;n.AspectWidth!==void 0&&n.AspectHeight!==void 0&&(a=n.AspectWidth.value,c=n.AspectHeight.value);const h=a/c;let f=45;n.FieldOfView!==void 0&&(f=n.FieldOfView.value);const d=n.FocalLength?n.FocalLength.value:null;switch(r){case 0:t=new l.PerspectiveCamera(f,h,i,s),d!==null&&t.setFocalLength(d);break;case 1:t=new l.OrthographicCamera(-a/2,a/2,c/2,-c/2,i,s);break;default:console.warn("THREE.FBXLoader: Unknown camera type "+r+"."),t=new l.Object3D;break}}return t}createLight(e){let t,n;if(e.children.forEach(function(r){const i=ve.Objects.NodeAttribute[r.ID];i!==void 0&&(n=i)}),n===void 0)t=new l.Object3D;else{let r;n.LightType===void 0?r=0:r=n.LightType.value;let i=16777215;n.Color!==void 0&&(i=new l.Color().fromArray(n.Color.value));let s=n.Intensity===void 0?1:n.Intensity.value/100;n.CastLightOnObject!==void 0&&n.CastLightOnObject.value===0&&(s=0);let a=0;n.FarAttenuationEnd!==void 0&&(n.EnableFarAttenuation!==void 0&&n.EnableFarAttenuation.value===0?a=0:a=n.FarAttenuationEnd.value);const c=1;switch(r){case 0:t=new l.PointLight(i,s,a,c);break;case 1:t=new l.DirectionalLight(i,s);break;case 2:let h=Math.PI/3;n.InnerAngle!==void 0&&(h=l.MathUtils.degToRad(n.InnerAngle.value));let f=0;n.OuterAngle!==void 0&&(f=l.MathUtils.degToRad(n.OuterAngle.value),f=Math.max(f,1)),t=new l.SpotLight(i,s,a,h,f,c);break;default:console.warn("THREE.FBXLoader: Unknown light type "+n.LightType.value+", defaulting to a PointLight."),t=new l.PointLight(i,s);break}n.CastShadows!==void 0&&n.CastShadows.value===1&&(t.castShadow=!0)}return t}createMesh(e,t,n){let r,i=null,s=null;const a=[];return e.children.forEach(function(c){t.has(c.ID)&&(i=t.get(c.ID)),n.has(c.ID)&&a.push(n.get(c.ID))}),a.length>1?s=a:a.length>0?s=a[0]:(s=new l.MeshPhongMaterial({color:13421772}),a.push(s)),"color"in i.attributes&&a.forEach(function(c){c.vertexColors=!0}),i.FBX_Deformer?(r=new l.SkinnedMesh(i,s),r.normalizeSkinWeights()):r=new l.Mesh(i,s),r}createCurve(e,t){const n=e.children.reduce(function(i,s){return t.has(s.ID)&&(i=t.get(s.ID)),i},null),r=new l.LineBasicMaterial({color:3342591,linewidth:1});return new l.Line(n,r)}getTransformData(e,t){const n={};"InheritType"in t&&(n.inheritType=parseInt(t.InheritType.value)),"RotationOrder"in t?n.eulerOrder=xi(t.RotationOrder.value):n.eulerOrder="ZYX","Lcl_Translation"in t&&(n.translation=t.Lcl_Translation.value),"PreRotation"in t&&(n.preRotation=t.PreRotation.value),"Lcl_Rotation"in t&&(n.rotation=t.Lcl_Rotation.value),"PostRotation"in t&&(n.postRotation=t.PostRotation.value),"Lcl_Scaling"in t&&(n.scale=t.Lcl_Scaling.value),"ScalingOffset"in t&&(n.scalingOffset=t.ScalingOffset.value),"ScalingPivot"in t&&(n.scalingPivot=t.ScalingPivot.value),"RotationOffset"in t&&(n.rotationOffset=t.RotationOffset.value),"RotationPivot"in t&&(n.rotationPivot=t.RotationPivot.value),e.userData.transformData=n}setLookAtProperties(e,t){"LookAtProperty"in t&&De.get(e.ID).children.forEach(function(r){if(r.relationship==="LookAtProperty"){const i=ve.Objects.Model[r.ID];if("Lcl_Translation"in i){const s=i.Lcl_Translation.value;e.target!==void 0?(e.target.position.fromArray(s),Ve.add(e.target)):e.lookAt(new l.Vector3().fromArray(s))}}})}bindSkeleton(e,t,n){const r=this.parsePoseNodes();for(const i in e){const s=e[i];De.get(parseInt(s.ID)).parents.forEach(function(c){if(t.has(c.ID)){const h=c.ID;De.get(h).parents.forEach(function(d){n.has(d.ID)&&n.get(d.ID).bind(new l.Skeleton(s.bones),r[d.ID])})}})}}parsePoseNodes(){const e={};if("Pose"in ve.Objects){const t=ve.Objects.Pose;for(const n in t)if(t[n].attrType==="BindPose"&&t[n].NbPoseNodes>0){const r=t[n].PoseNode;Array.isArray(r)?r.forEach(function(i){e[i.Node]=new l.Matrix4().fromArray(i.Matrix.a)}):e[r.Node]=new l.Matrix4().fromArray(r.Matrix.a)}}return e}createAmbientLight(){if("GlobalSettings"in ve&&"AmbientColor"in ve.GlobalSettings){const e=ve.GlobalSettings.AmbientColor.value,t=e[0],n=e[1],r=e[2];if(t!==0||n!==0||r!==0){const i=new l.Color(t,n,r);Ve.add(new l.AmbientLight(i,1))}}}}class za{parse(e){const t=new Map;if("Geometry"in ve.Objects){const n=ve.Objects.Geometry;for(const r in n){const i=De.get(parseInt(r)),s=this.parseGeometry(i,n[r],e);t.set(parseInt(r),s)}}return t}parseGeometry(e,t,n){switch(t.attrType){case"Mesh":return this.parseMeshGeometry(e,t,n);case"NurbsCurve":return this.parseNurbsGeometry(t)}}parseMeshGeometry(e,t,n){const r=n.skeletons,i=[],s=e.parents.map(function(d){return ve.Objects.Model[d.ID]});if(s.length===0)return;const a=e.children.reduce(function(d,p){return r[p.ID]!==void 0&&(d=r[p.ID]),d},null);e.children.forEach(function(d){n.morphTargets[d.ID]!==void 0&&i.push(n.morphTargets[d.ID])});const c=s[0],h={};"RotationOrder"in c&&(h.eulerOrder=xi(c.RotationOrder.value)),"InheritType"in c&&(h.inheritType=parseInt(c.InheritType.value)),"GeometricTranslation"in c&&(h.translation=c.GeometricTranslation.value),"GeometricRotation"in c&&(h.rotation=c.GeometricRotation.value),"GeometricScaling"in c&&(h.scale=c.GeometricScaling.value);const f=_i(h);return this.genGeometry(t,a,i,f)}genGeometry(e,t,n,r){const i=new l.BufferGeometry;e.attrName&&(i.name=e.attrName);const s=this.parseGeoNode(e,t),a=this.genBuffers(s),c=new l.Float32BufferAttribute(a.vertex,3);if(c.applyMatrix4(r),i.setAttribute("position",c),a.colors.length>0&&i.setAttribute("color",new l.Float32BufferAttribute(a.colors,3)),t&&(i.setAttribute("skinIndex",new l.Uint16BufferAttribute(a.weightsIndices,4)),i.setAttribute("skinWeight",new l.Float32BufferAttribute(a.vertexWeights,4)),i.FBX_Deformer=t),a.normal.length>0){const h=new l.Matrix3().getNormalMatrix(r),f=new l.Float32BufferAttribute(a.normal,3);f.applyNormalMatrix(h),i.setAttribute("normal",f)}if(a.uvs.forEach(function(h,f){let d="uv"+(f+1).toString();f===0&&(d="uv"),i.setAttribute(d,new l.Float32BufferAttribute(a.uvs[f],2))}),s.material&&s.material.mappingType!=="AllSame"){let h=a.materialIndex[0],f=0;if(a.materialIndex.forEach(function(d,p){d!==h&&(i.addGroup(f,p-f,h),h=d,f=p)}),i.groups.length>0){const d=i.groups[i.groups.length-1],p=d.start+d.count;p!==a.materialIndex.length&&i.addGroup(p,a.materialIndex.length-p,h)}i.groups.length===0&&i.addGroup(0,a.materialIndex.length,a.materialIndex[0])}return this.addMorphTargets(i,e,n,r),i}parseGeoNode(e,t){const n={};if(n.vertexPositions=e.Vertices!==void 0?e.Vertices.a:[],n.vertexIndices=e.PolygonVertexIndex!==void 0?e.PolygonVertexIndex.a:[],e.LayerElementColor&&(n.color=this.parseVertexColors(e.LayerElementColor[0])),e.LayerElementMaterial&&(n.material=this.parseMaterialIndices(e.LayerElementMaterial[0])),e.LayerElementNormal&&(n.normal=this.parseNormals(e.LayerElementNormal[0])),e.LayerElementUV){n.uv=[];let r=0;for(;e.LayerElementUV[r];)e.LayerElementUV[r].UV&&n.uv.push(this.parseUVs(e.LayerElementUV[r])),r++}return n.weightTable={},t!==null&&(n.skeleton=t,t.rawBones.forEach(function(r,i){r.indices.forEach(function(s,a){n.weightTable[s]===void 0&&(n.weightTable[s]=[]),n.weightTable[s].push({id:i,weight:r.weights[a]})})})),n}genBuffers(e){const t={vertex:[],normal:[],colors:[],uvs:[],materialIndex:[],vertexWeights:[],weightsIndices:[]};let n=0,r=0,i=!1,s=[],a=[],c=[],h=[],f=[],d=[];const p=this;return e.vertexIndices.forEach(function(m,x){let b,v=!1;m<0&&(m=m^-1,v=!0);let _=[],T=[];if(s.push(m*3,m*3+1,m*3+2),e.color){const w=vn(x,n,m,e.color);c.push(w[0],w[1],w[2])}if(e.skeleton){if(e.weightTable[m]!==void 0&&e.weightTable[m].forEach(function(w){T.push(w.weight),_.push(w.id)}),T.length>4){i||(console.warn("THREE.FBXLoader: Vertex has more than 4 skinning weights assigned to vertex. Deleting additional weights."),i=!0);const w=[0,0,0,0],M=[0,0,0,0];T.forEach(function(D,S){let C=D,y=_[S];M.forEach(function(A,g,I){if(C>A){I[g]=C,C=A;const k=w[g];w[g]=y,y=k}})}),_=w,T=M}for(;T.length<4;)T.push(0),_.push(0);for(let w=0;w<4;++w)f.push(T[w]),d.push(_[w])}if(e.normal){const w=vn(x,n,m,e.normal);a.push(w[0],w[1],w[2])}e.material&&e.material.mappingType!=="AllSame"&&(b=vn(x,n,m,e.material)[0]),e.uv&&e.uv.forEach(function(w,M){const D=vn(x,n,m,w);h[M]===void 0&&(h[M]=[]),h[M].push(D[0]),h[M].push(D[1])}),r++,v&&(p.genFace(t,e,s,b,a,c,h,f,d,r),n++,r=0,s=[],a=[],c=[],h=[],f=[],d=[])}),t}genFace(e,t,n,r,i,s,a,c,h,f){for(let d=2;d<f;d++)e.vertex.push(t.vertexPositions[n[0]]),e.vertex.push(t.vertexPositions[n[1]]),e.vertex.push(t.vertexPositions[n[2]]),e.vertex.push(t.vertexPositions[n[(d-1)*3]]),e.vertex.push(t.vertexPositions[n[(d-1)*3+1]]),e.vertex.push(t.vertexPositions[n[(d-1)*3+2]]),e.vertex.push(t.vertexPositions[n[d*3]]),e.vertex.push(t.vertexPositions[n[d*3+1]]),e.vertex.push(t.vertexPositions[n[d*3+2]]),t.skeleton&&(e.vertexWeights.push(c[0]),e.vertexWeights.push(c[1]),e.vertexWeights.push(c[2]),e.vertexWeights.push(c[3]),e.vertexWeights.push(c[(d-1)*4]),e.vertexWeights.push(c[(d-1)*4+1]),e.vertexWeights.push(c[(d-1)*4+2]),e.vertexWeights.push(c[(d-1)*4+3]),e.vertexWeights.push(c[d*4]),e.vertexWeights.push(c[d*4+1]),e.vertexWeights.push(c[d*4+2]),e.vertexWeights.push(c[d*4+3]),e.weightsIndices.push(h[0]),e.weightsIndices.push(h[1]),e.weightsIndices.push(h[2]),e.weightsIndices.push(h[3]),e.weightsIndices.push(h[(d-1)*4]),e.weightsIndices.push(h[(d-1)*4+1]),e.weightsIndices.push(h[(d-1)*4+2]),e.weightsIndices.push(h[(d-1)*4+3]),e.weightsIndices.push(h[d*4]),e.weightsIndices.push(h[d*4+1]),e.weightsIndices.push(h[d*4+2]),e.weightsIndices.push(h[d*4+3])),t.color&&(e.colors.push(s[0]),e.colors.push(s[1]),e.colors.push(s[2]),e.colors.push(s[(d-1)*3]),e.colors.push(s[(d-1)*3+1]),e.colors.push(s[(d-1)*3+2]),e.colors.push(s[d*3]),e.colors.push(s[d*3+1]),e.colors.push(s[d*3+2])),t.material&&t.material.mappingType!=="AllSame"&&(e.materialIndex.push(r),e.materialIndex.push(r),e.materialIndex.push(r)),t.normal&&(e.normal.push(i[0]),e.normal.push(i[1]),e.normal.push(i[2]),e.normal.push(i[(d-1)*3]),e.normal.push(i[(d-1)*3+1]),e.normal.push(i[(d-1)*3+2]),e.normal.push(i[d*3]),e.normal.push(i[d*3+1]),e.normal.push(i[d*3+2])),t.uv&&t.uv.forEach(function(p,m){e.uvs[m]===void 0&&(e.uvs[m]=[]),e.uvs[m].push(a[m][0]),e.uvs[m].push(a[m][1]),e.uvs[m].push(a[m][(d-1)*2]),e.uvs[m].push(a[m][(d-1)*2+1]),e.uvs[m].push(a[m][d*2]),e.uvs[m].push(a[m][d*2+1])})}addMorphTargets(e,t,n,r){if(n.length===0)return;e.morphTargetsRelative=!0,e.morphAttributes.position=[];const i=this;n.forEach(function(s){s.rawTargets.forEach(function(a){const c=ve.Objects.Geometry[a.geoID];c!==void 0&&i.genMorphGeometry(e,t,c,r,a.name)})})}genMorphGeometry(e,t,n,r,i){const s=t.PolygonVertexIndex!==void 0?t.PolygonVertexIndex.a:[],a=n.Vertices!==void 0?n.Vertices.a:[],c=n.Indexes!==void 0?n.Indexes.a:[],h=e.attributes.position.count*3,f=new Float32Array(h);for(let x=0;x<c.length;x++){const b=c[x]*3;f[b]=a[x*3],f[b+1]=a[x*3+1],f[b+2]=a[x*3+2]}const d={vertexIndices:s,vertexPositions:f},p=this.genBuffers(d),m=new l.Float32BufferAttribute(p.vertex,3);m.name=i||n.attrName,m.applyMatrix4(r),e.morphAttributes.position.push(m)}parseNormals(e){const t=e.MappingInformationType,n=e.ReferenceInformationType,r=e.Normals.a;let i=[];return n==="IndexToDirect"&&("NormalIndex"in e?i=e.NormalIndex.a:"NormalsIndex"in e&&(i=e.NormalsIndex.a)),{dataSize:3,buffer:r,indices:i,mappingType:t,referenceType:n}}parseUVs(e){const t=e.MappingInformationType,n=e.ReferenceInformationType,r=e.UV.a;let i=[];return n==="IndexToDirect"&&(i=e.UVIndex.a),{dataSize:2,buffer:r,indices:i,mappingType:t,referenceType:n}}parseVertexColors(e){const t=e.MappingInformationType,n=e.ReferenceInformationType,r=e.Colors.a;let i=[];return n==="IndexToDirect"&&(i=e.ColorIndex.a),{dataSize:4,buffer:r,indices:i,mappingType:t,referenceType:n}}parseMaterialIndices(e){const t=e.MappingInformationType,n=e.ReferenceInformationType;if(t==="NoMappingInformation")return{dataSize:1,buffer:[0],indices:[0],mappingType:"AllSame",referenceType:n};const r=e.Materials.a,i=[];for(let s=0;s<r.length;++s)i.push(s);return{dataSize:1,buffer:r,indices:i,mappingType:t,referenceType:n}}parseNurbsGeometry(e){if(mi===void 0)return console.error("THREE.FBXLoader: The loader relies on NURBSCurve for any nurbs present in the model. Nurbs will show up as empty geometry."),new l.BufferGeometry;const t=parseInt(e.Order);if(isNaN(t))return console.error("THREE.FBXLoader: Invalid Order %s given for geometry ID: %s",e.Order,e.id),new l.BufferGeometry;const n=t-1,r=e.KnotVector.a,i=[],s=e.Points.a;for(let d=0,p=s.length;d<p;d+=4)i.push(new l.Vector4().fromArray(s,d));let a,c;if(e.Form==="Closed")i.push(i[0]);else if(e.Form==="Periodic"){a=n,c=r.length-1-a;for(let d=0;d<n;++d)i.push(i[d])}const f=new mi(n,r,i,a,c).getPoints(i.length*12);return new l.BufferGeometry().setFromPoints(f)}}class Va{parse(){const e=[],t=this.parseClips();if(t!==void 0)for(const n in t){const r=t[n],i=this.addClip(r);e.push(i)}return e}parseClips(){if(ve.Objects.AnimationCurve===void 0)return;const e=this.parseAnimationCurveNodes();this.parseAnimationCurves(e);const t=this.parseAnimationLayers(e);return this.parseAnimStacks(t)}parseAnimationCurveNodes(){const e=ve.Objects.AnimationCurveNode,t=new Map;for(const n in e){const r=e[n];if(r.attrName.match(/S|R|T|DeformPercent/)!==null){const i={id:r.id,attr:r.attrName,curves:{}};t.set(i.id,i)}}return t}parseAnimationCurves(e){const t=ve.Objects.AnimationCurve;for(const n in t){const r={id:t[n].id,times:t[n].KeyTime.a.map(Wa),values:t[n].KeyValueFloat.a},i=De.get(r.id);if(i!==void 0){const s=i.parents[0].ID,a=i.parents[0].relationship;a.match(/X/)?e.get(s).curves.x=r:a.match(/Y/)?e.get(s).curves.y=r:a.match(/Z/)?e.get(s).curves.z=r:a.match(/d|DeformPercent/)&&e.has(s)&&(e.get(s).curves.morph=r)}}}parseAnimationLayers(e){const t=ve.Objects.AnimationLayer,n=new Map;for(const r in t){const i=[],s=De.get(parseInt(r));s!==void 0&&(s.children.forEach(function(c,h){if(e.has(c.ID)){const f=e.get(c.ID);if(f.curves.x!==void 0||f.curves.y!==void 0||f.curves.z!==void 0){if(i[h]===void 0){const d=De.get(c.ID).parents.filter(function(p){return p.relationship!==void 0})[0].ID;if(d!==void 0){const p=ve.Objects.Model[d.toString()];if(p===void 0){console.warn("THREE.FBXLoader: Encountered a unused curve.",c);return}const m={modelName:p.attrName?l.PropertyBinding.sanitizeNodeName(p.attrName):"",ID:p.id,initialPosition:[0,0,0],initialRotation:[0,0,0],initialScale:[1,1,1]};Ve.traverse(function(x){x.ID===p.id&&(m.transform=x.matrix,x.userData.transformData&&(m.eulerOrder=x.userData.transformData.eulerOrder))}),m.transform||(m.transform=new l.Matrix4),"PreRotation"in p&&(m.preRotation=p.PreRotation.value),"PostRotation"in p&&(m.postRotation=p.PostRotation.value),i[h]=m}}i[h]&&(i[h][f.attr]=f)}else if(f.curves.morph!==void 0){if(i[h]===void 0){const d=De.get(c.ID).parents.filter(function(_){return _.relationship!==void 0})[0].ID,p=De.get(d).parents[0].ID,m=De.get(p).parents[0].ID,x=De.get(m).parents[0].ID,b=ve.Objects.Model[x],v={modelName:b.attrName?l.PropertyBinding.sanitizeNodeName(b.attrName):"",morphName:ve.Objects.Deformer[d].attrName};i[h]=v}i[h][f.attr]=f}}}),n.set(parseInt(r),i))}return n}parseAnimStacks(e){const t=ve.Objects.AnimationStack,n={};for(const r in t){const i=De.get(parseInt(r)).children;i.length>1&&console.warn("THREE.FBXLoader: Encountered an animation stack with multiple layers, this is currently not supported. Ignoring subsequent layers.");const s=e.get(i[0].ID);n[r]={name:t[r].attrName,layer:s}}return n}addClip(e){let t=[];const n=this;return e.layer.forEach(function(r){t=t.concat(n.generateTracks(r))}),new l.AnimationClip(e.name,-1,t)}generateTracks(e){const t=[];let n=new l.Vector3,r=new l.Quaternion,i=new l.Vector3;if(e.transform&&e.transform.decompose(n,r,i),n=n.toArray(),r=new l.Euler().setFromQuaternion(r,e.eulerOrder).toArray(),i=i.toArray(),e.T!==void 0&&Object.keys(e.T.curves).length>0){const s=this.generateVectorTrack(e.modelName,e.T.curves,n,"position");s!==void 0&&t.push(s)}if(e.R!==void 0&&Object.keys(e.R.curves).length>0){const s=this.generateRotationTrack(e.modelName,e.R.curves,r,e.preRotation,e.postRotation,e.eulerOrder);s!==void 0&&t.push(s)}if(e.S!==void 0&&Object.keys(e.S.curves).length>0){const s=this.generateVectorTrack(e.modelName,e.S.curves,i,"scale");s!==void 0&&t.push(s)}if(e.DeformPercent!==void 0){const s=this.generateMorphTrack(e);s!==void 0&&t.push(s)}return t}generateVectorTrack(e,t,n,r){const i=this.getTimesForAllAxes(t),s=this.getKeyframeTrackValues(i,t,n);return new l.VectorKeyframeTrack(e+"."+r,i,s)}generateRotationTrack(e,t,n,r,i,s){t.x!==void 0&&(this.interpolateRotations(t.x),t.x.values=t.x.values.map(l.MathUtils.degToRad)),t.y!==void 0&&(this.interpolateRotations(t.y),t.y.values=t.y.values.map(l.MathUtils.degToRad)),t.z!==void 0&&(this.interpolateRotations(t.z),t.z.values=t.z.values.map(l.MathUtils.degToRad));const a=this.getTimesForAllAxes(t),c=this.getKeyframeTrackValues(a,t,n);r!==void 0&&(r=r.map(l.MathUtils.degToRad),r.push(s),r=new l.Euler().fromArray(r),r=new l.Quaternion().setFromEuler(r)),i!==void 0&&(i=i.map(l.MathUtils.degToRad),i.push(s),i=new l.Euler().fromArray(i),i=new l.Quaternion().setFromEuler(i).invert());const h=new l.Quaternion,f=new l.Euler,d=[];for(let p=0;p<c.length;p+=3)f.set(c[p],c[p+1],c[p+2],s),h.setFromEuler(f),r!==void 0&&h.premultiply(r),i!==void 0&&h.multiply(i),h.toArray(d,p/3*4);return new l.QuaternionKeyframeTrack(e+".quaternion",a,d)}generateMorphTrack(e){const t=e.DeformPercent.curves.morph,n=t.values.map(function(i){return i/100}),r=Ve.getObjectByName(e.modelName).morphTargetDictionary[e.morphName];return new l.NumberKeyframeTrack(e.modelName+".morphTargetInfluences["+r+"]",t.times,n)}getTimesForAllAxes(e){let t=[];if(e.x!==void 0&&(t=t.concat(e.x.times)),e.y!==void 0&&(t=t.concat(e.y.times)),e.z!==void 0&&(t=t.concat(e.z.times)),t=t.sort(function(n,r){return n-r}),t.length>1){let n=1,r=t[0];for(let i=1;i<t.length;i++){const s=t[i];s!==r&&(t[n]=s,r=s,n++)}t=t.slice(0,n)}return t}getKeyframeTrackValues(e,t,n){const r=n,i=[];let s=-1,a=-1,c=-1;return e.forEach(function(h){if(t.x&&(s=t.x.times.indexOf(h)),t.y&&(a=t.y.times.indexOf(h)),t.z&&(c=t.z.times.indexOf(h)),s!==-1){const f=t.x.values[s];i.push(f),r[0]=f}else i.push(r[0]);if(a!==-1){const f=t.y.values[a];i.push(f),r[1]=f}else i.push(r[1]);if(c!==-1){const f=t.z.values[c];i.push(f),r[2]=f}else i.push(r[2])}),i}interpolateRotations(e){for(let t=1;t<e.values.length;t++){const n=e.values[t-1],r=e.values[t]-n,i=Math.abs(r);if(i>=180){const s=i/180,a=r/s;let c=n+a;const h=e.times[t-1],d=(e.times[t]-h)/s;let p=h+d;const m=[],x=[];for(;p<e.times[t];)m.push(p),p+=d,x.push(c),c+=a;e.times=bi(e.times,t,m),e.values=bi(e.values,t,x)}}}}class Ra{getPrevNode(){return this.nodeStack[this.currentIndent-2]}getCurrentNode(){return this.nodeStack[this.currentIndent-1]}getCurrentProp(){return this.currentProp}pushStack(e){this.nodeStack.push(e),this.currentIndent+=1}popStack(){this.nodeStack.pop(),this.currentIndent-=1}setCurrentProp(e,t){this.currentProp=e,this.currentPropName=t}parse(e){this.currentIndent=0,this.allNodes=new yi,this.nodeStack=[],this.currentProp=[],this.currentPropName="";const t=this,n=e.split(/[\r\n]+/);return n.forEach(function(r,i){const s=r.match(/^[\s\t]*;/),a=r.match(/^[\s\t]*$/);if(s||a)return;const c=r.match("^\\t{"+t.currentIndent+"}(\\w+):(.*){",""),h=r.match("^\\t{"+t.currentIndent+"}(\\w+):[\\s\\t\\r\\n](.*)"),f=r.match("^\\t{"+(t.currentIndent-1)+"}}");c?t.parseNodeBegin(r,c):h?t.parseNodeProperty(r,h,n[++i]):f?t.popStack():r.match(/^[^\s\t}]/)&&t.parseNodePropertyContinued(r)}),this.allNodes}parseNodeBegin(e,t){const n=t[1].trim().replace(/^"/,"").replace(/"$/,""),r=t[2].split(",").map(function(c){return c.trim().replace(/^"/,"").replace(/"$/,"")}),i={name:n},s=this.parseNodeAttr(r),a=this.getCurrentNode();this.currentIndent===0?this.allNodes.add(n,i):n in a?(n==="PoseNode"?a.PoseNode.push(i):a[n].id!==void 0&&(a[n]={},a[n][a[n].id]=a[n]),s.id!==""&&(a[n][s.id]=i)):typeof s.id=="number"?(a[n]={},a[n][s.id]=i):n!=="Properties70"&&(n==="PoseNode"?a[n]=[i]:a[n]=i),typeof s.id=="number"&&(i.id=s.id),s.name!==""&&(i.attrName=s.name),s.type!==""&&(i.attrType=s.type),this.pushStack(i)}parseNodeAttr(e){let t=e[0];e[0]!==""&&(t=parseInt(e[0]),isNaN(t)&&(t=e[0]));let n="",r="";return e.length>1&&(n=e[1].replace(/^(\w+)::/,""),r=e[2]),{id:t,name:n,type:r}}parseNodeProperty(e,t,n){let r=t[1].replace(/^"/,"").replace(/"$/,"").trim(),i=t[2].replace(/^"/,"").replace(/"$/,"").trim();r==="Content"&&i===","&&(i=n.replace(/"/g,"").replace(/,$/,"").trim());const s=this.getCurrentNode();if(s.name==="Properties70"){this.parseNodeSpecialProperty(e,r,i);return}if(r==="C"){const c=i.split(",").slice(1),h=parseInt(c[0]),f=parseInt(c[1]);let d=i.split(",").slice(3);d=d.map(function(p){return p.trim().replace(/^"/,"")}),r="connections",i=[h,f],Xa(i,d),s[r]===void 0&&(s[r]=[])}r==="Node"&&(s.id=i),r in s&&Array.isArray(s[r])?s[r].push(i):r!=="a"?s[r]=i:s.a=i,this.setCurrentProp(s,r),r==="a"&&i.slice(-1)!==","&&(s.a=tr(i))}parseNodePropertyContinued(e){const t=this.getCurrentNode();t.a+=e,e.slice(-1)!==","&&(t.a=tr(t.a))}parseNodeSpecialProperty(e,t,n){const r=n.split('",').map(function(f){return f.trim().replace(/^\"/,"").replace(/\s/,"_")}),i=r[0],s=r[1],a=r[2],c=r[3];let h=r[4];switch(s){case"int":case"enum":case"bool":case"ULongLong":case"double":case"Number":case"FieldOfView":h=parseFloat(h);break;case"Color":case"ColorRGB":case"Vector3D":case"Lcl_Translation":case"Lcl_Rotation":case"Lcl_Scaling":h=tr(h);break}this.getPrevNode()[i]={type:s,type2:a,flag:c,value:h},this.setCurrentProp(this.getPrevNode(),i)}}class Ga{parse(e){const t=new gi(e);t.skip(23);const n=t.getUint32();if(n<6400)throw new Error("THREE.FBXLoader: FBX version not supported, FileVersion: "+n);const r=new yi;for(;!this.endOfContent(t);){const i=this.parseNode(t,n);i!==null&&r.add(i.name,i)}return r}endOfContent(e){return e.size()%16===0?(e.getOffset()+160+16&-16)>=e.size():e.getOffset()+160+16>=e.size()}parseNode(e,t){const n={},r=t>=7500?e.getUint64():e.getUint32(),i=t>=7500?e.getUint64():e.getUint32();t>=7500?e.getUint64():e.getUint32();const s=e.getUint8(),a=e.getString(s);if(r===0)return null;const c=[];for(let p=0;p<i;p++)c.push(this.parseProperty(e));const h=c.length>0?c[0]:"",f=c.length>1?c[1]:"",d=c.length>2?c[2]:"";for(n.singleProperty=i===1&&e.getOffset()===r;r>e.getOffset();){const p=this.parseNode(e,t);p!==null&&this.parseSubNode(a,n,p)}return n.propertyList=c,typeof h=="number"&&(n.id=h),f!==""&&(n.attrName=f),d!==""&&(n.attrType=d),a!==""&&(n.name=a),n}parseSubNode(e,t,n){if(n.singleProperty===!0){const r=n.propertyList[0];Array.isArray(r)?(t[n.name]=n,n.a=r):t[n.name]=r}else if(e==="Connections"&&n.name==="C"){const r=[];n.propertyList.forEach(function(i,s){s!==0&&r.push(i)}),t.connections===void 0&&(t.connections=[]),t.connections.push(r)}else if(n.name==="Properties70")Object.keys(n).forEach(function(i){t[i]=n[i]});else if(e==="Properties70"&&n.name==="P"){let r=n.propertyList[0],i=n.propertyList[1];const s=n.propertyList[2],a=n.propertyList[3];let c;r.indexOf("Lcl ")===0&&(r=r.replace("Lcl ","Lcl_")),i.indexOf("Lcl ")===0&&(i=i.replace("Lcl ","Lcl_")),i==="Color"||i==="ColorRGB"||i==="Vector"||i==="Vector3D"||i.indexOf("Lcl_")===0?c=[n.propertyList[4],n.propertyList[5],n.propertyList[6]]:c=n.propertyList[4],t[r]={type:i,type2:s,flag:a,value:c}}else t[n.name]===void 0?typeof n.id=="number"?(t[n.name]={},t[n.name][n.id]=n):t[n.name]=n:n.name==="PoseNode"?(Array.isArray(t[n.name])||(t[n.name]=[t[n.name]]),t[n.name].push(n)):t[n.name][n.id]===void 0&&(t[n.name][n.id]=n)}parseProperty(e){const t=e.getString(1);let n;switch(t){case"C":return e.getBoolean();case"D":return e.getFloat64();case"F":return e.getFloat32();case"I":return e.getInt32();case"L":return e.getInt64();case"R":return n=e.getUint32(),e.getArrayBuffer(n);case"S":return n=e.getUint32(),e.getString(n);case"Y":return e.getInt16();case"b":case"c":case"d":case"f":case"i":case"l":const r=e.getUint32(),i=e.getUint32(),s=e.getUint32();if(i===0)switch(t){case"b":case"c":return e.getBooleanArray(r);case"d":return e.getFloat64Array(r);case"f":return e.getFloat32Array(r);case"i":return e.getInt32Array(r);case"l":return e.getInt64Array(r)}const a=Lo(new Uint8Array(e.getArrayBuffer(s))),c=new gi(a.buffer);switch(t){case"b":case"c":return c.getBooleanArray(r);case"d":return c.getFloat64Array(r);case"f":return c.getFloat32Array(r);case"i":return c.getInt32Array(r);case"l":return c.getInt64Array(r)}default:throw new Error("THREE.FBXLoader: Unknown property type "+t)}}}class gi{constructor(e,t){this.dv=new DataView(e),this.offset=0,this.littleEndian=t!==void 0?t:!0}getOffset(){return this.offset}size(){return this.dv.buffer.byteLength}skip(e){this.offset+=e}getBoolean(){return(this.getUint8()&1)===1}getBooleanArray(e){const t=[];for(let n=0;n<e;n++)t.push(this.getBoolean());return t}getUint8(){const e=this.dv.getUint8(this.offset);return this.offset+=1,e}getInt16(){const e=this.dv.getInt16(this.offset,this.littleEndian);return this.offset+=2,e}getInt32(){const e=this.dv.getInt32(this.offset,this.littleEndian);return this.offset+=4,e}getInt32Array(e){const t=[];for(let n=0;n<e;n++)t.push(this.getInt32());return t}getUint32(){const e=this.dv.getUint32(this.offset,this.littleEndian);return this.offset+=4,e}getInt64(){let e,t;return this.littleEndian?(e=this.getUint32(),t=this.getUint32()):(t=this.getUint32(),e=this.getUint32()),t&2147483648?(t=~t&4294967295,e=~e&4294967295,e===4294967295&&(t=t+1&4294967295),e=e+1&4294967295,-(t*4294967296+e)):t*4294967296+e}getInt64Array(e){const t=[];for(let n=0;n<e;n++)t.push(this.getInt64());return t}getUint64(){let e,t;return this.littleEndian?(e=this.getUint32(),t=this.getUint32()):(t=this.getUint32(),e=this.getUint32()),t*4294967296+e}getFloat32(){const e=this.dv.getFloat32(this.offset,this.littleEndian);return this.offset+=4,e}getFloat32Array(e){const t=[];for(let n=0;n<e;n++)t.push(this.getFloat32());return t}getFloat64(){const e=this.dv.getFloat64(this.offset,this.littleEndian);return this.offset+=8,e}getFloat64Array(e){const t=[];for(let n=0;n<e;n++)t.push(this.getFloat64());return t}getArrayBuffer(e){const t=this.dv.buffer.slice(this.offset,this.offset+e);return this.offset+=e,t}getString(e){let t=[];for(let r=0;r<e;r++)t[r]=this.getUint8();const n=t.indexOf(0);return n>=0&&(t=t.slice(0,n)),l.LoaderUtils.decodeText(new Uint8Array(t))}}class yi{add(e,t){this[e]=t}}function ja(o){const e="Kaydara FBX Binary  \0";return o.byteLength>=e.length&&e===wi(o,0,e.length)}function Ea(o){const e=["K","a","y","d","a","r","a","\\","F","B","X","\\","B","i","n","a","r","y","\\","\\"];let t=0;function n(r){const i=o[r-1];return o=o.slice(t+r),t++,i}for(let r=0;r<e.length;++r)if(n(1)===e[r])return!1;return!0}function vi(o){const e=/FBXVersion: (\d+)/,t=o.match(e);if(t)return parseInt(t[1]);throw new Error("THREE.FBXLoader: Cannot find the version number for the file given.")}function Wa(o){return o/46186158e3}const Ya=[];function vn(o,e,t,n){let r;switch(n.mappingType){case"ByPolygonVertex":r=o;break;case"ByPolygon":r=e;break;case"ByVertice":r=t;break;case"AllSame":r=n.indices[0];break;default:console.warn("THREE.FBXLoader: unknown attribute mapping type "+n.mappingType)}n.referenceType==="IndexToDirect"&&(r=n.indices[r]);const i=r*n.dataSize,s=i+n.dataSize;return Za(Ya,n.buffer,i,s)}const er=new l.Euler,kt=new l.Vector3;function _i(o){const e=new l.Matrix4,t=new l.Matrix4,n=new l.Matrix4,r=new l.Matrix4,i=new l.Matrix4,s=new l.Matrix4,a=new l.Matrix4,c=new l.Matrix4,h=new l.Matrix4,f=new l.Matrix4,d=new l.Matrix4,p=new l.Matrix4,m=o.inheritType?o.inheritType:0;if(o.translation&&e.setPosition(kt.fromArray(o.translation)),o.preRotation){const g=o.preRotation.map(l.MathUtils.degToRad);g.push(o.eulerOrder),t.makeRotationFromEuler(er.fromArray(g))}if(o.rotation){const g=o.rotation.map(l.MathUtils.degToRad);g.push(o.eulerOrder),n.makeRotationFromEuler(er.fromArray(g))}if(o.postRotation){const g=o.postRotation.map(l.MathUtils.degToRad);g.push(o.eulerOrder),r.makeRotationFromEuler(er.fromArray(g)),r.invert()}o.scale&&i.scale(kt.fromArray(o.scale)),o.scalingOffset&&a.setPosition(kt.fromArray(o.scalingOffset)),o.scalingPivot&&s.setPosition(kt.fromArray(o.scalingPivot)),o.rotationOffset&&c.setPosition(kt.fromArray(o.rotationOffset)),o.rotationPivot&&h.setPosition(kt.fromArray(o.rotationPivot)),o.parentMatrixWorld&&(d.copy(o.parentMatrix),f.copy(o.parentMatrixWorld));const x=t.clone().multiply(n).multiply(r),b=new l.Matrix4;b.extractRotation(f);const v=new l.Matrix4;v.copyPosition(f);const _=v.clone().invert().multiply(f),T=b.clone().invert().multiply(_),w=i,M=new l.Matrix4;if(m===0)M.copy(b).multiply(x).multiply(T).multiply(w);else if(m===1)M.copy(b).multiply(T).multiply(x).multiply(w);else{const I=new l.Matrix4().scale(new l.Vector3().setFromMatrixScale(d)).clone().invert(),k=T.clone().multiply(I);M.copy(b).multiply(x).multiply(k).multiply(w)}const D=h.clone().invert(),S=s.clone().invert();let C=e.clone().multiply(c).multiply(h).multiply(t).multiply(n).multiply(r).multiply(D).multiply(a).multiply(s).multiply(i).multiply(S);const y=new l.Matrix4().copyPosition(C),A=f.clone().multiply(y);return p.copyPosition(A),C=p.clone().multiply(M),C.premultiply(f.invert()),C}function xi(o){o=o||0;const e=["ZYX","YZX","XZY","ZXY","YXZ","XYZ"];return o===6?(console.warn("THREE.FBXLoader: unsupported Euler Order: Spherical XYZ. Animations and rotations may be incorrect."),e[0]):e[o]}function tr(o){return o.split(",").map(function(t){return parseFloat(t)})}function wi(o,e,t){return e===void 0&&(e=0),t===void 0&&(t=o.byteLength),l.LoaderUtils.decodeText(new Uint8Array(o,e,t))}function Xa(o,e){for(let t=0,n=o.length,r=e.length;t<r;t++,n++)o[n]=e[t]}function Za(o,e,t,n){for(let r=t,i=0;r<n;r++,i++)o[i]=e[r];return o}function bi(o,e,t){return o.slice(0,e).concat(t).concat(o.slice(e))}var Ka=Object.defineProperty,qa=(o,e,t)=>e in o?Ka(o,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):o[e]=t,nr=(o,e,t)=>(qa(o,typeof e!="symbol"?e+"":e,t),t);class Qa extends l.Loader{constructor(e){super(e)}load(e,t,n,r){const i=new l.FileLoader(this.manager);i.setPath(this.path),i.setRequestHeader(this.requestHeader),i.setWithCredentials(this.withCredentials),i.load(e,s=>{if(typeof s!="string")throw new Error("unsupported data type");const a=JSON.parse(s),c=this.parse(a);t&&t(c)},n,r)}loadAsync(e,t){return super.loadAsync(e,t)}parse(e){return new rr(e)}}class rr{constructor(e){nr(this,"data"),this.data=e}generateShapes(e,t=100,n){const r=[],i={letterSpacing:0,lineHeight:1,...n},s=Ja(e,t,this.data,i);for(let a=0,c=s.length;a<c;a++)Array.prototype.push.apply(r,s[a].toShapes(!1));return r}}nr(rr,"isFont"),nr(rr,"type");function Ja(o,e,t,n){const r=Array.from(o),i=e/t.resolution,s=(t.boundingBox.yMax-t.boundingBox.yMin+t.underlineThickness)*i,a=[];let c=0,h=0;for(let f=0;f<r.length;f++){const d=r[f];if(d===`
+`)c=0,h-=s*n.lineHeight;else{const p=Ha(d,i,c,h,t);p&&(c+=p.offsetX+n.letterSpacing,a.push(p.path))}}return a}function Ha(o,e,t,n,r){const i=r.glyphs[o]||r.glyphs["?"];if(!i){console.error('THREE.Font: character "'+o+'" does not exists in font family '+r.familyName+".");return}const s=new l.ShapePath;let a,c,h,f,d,p,m,x;if(i.o){const b=i._cachedOutline||(i._cachedOutline=i.o.split(" "));for(let v=0,_=b.length;v<_;)switch(b[v++]){case"m":a=parseInt(b[v++])*e+t,c=parseInt(b[v++])*e+n,s.moveTo(a,c);break;case"l":a=parseInt(b[v++])*e+t,c=parseInt(b[v++])*e+n,s.lineTo(a,c);break;case"q":h=parseInt(b[v++])*e+t,f=parseInt(b[v++])*e+n,d=parseInt(b[v++])*e+t,p=parseInt(b[v++])*e+n,s.quadraticCurveTo(d,p,h,f);break;case"b":h=parseInt(b[v++])*e+t,f=parseInt(b[v++])*e+n,d=parseInt(b[v++])*e+t,p=parseInt(b[v++])*e+n,m=parseInt(b[v++])*e+t,x=parseInt(b[v++])*e+n,s.bezierCurveTo(d,p,m,x,h,f);break}}return{offsetX:i.ha*e,path:s}}class Mi extends l.DataTextureLoader{constructor(e){super(e),this.type=l.HalfFloatType}parse(e){const a=function(w,M){switch(w){case 1:console.error("THREE.RGBELoader Read Error: "+(M||""));break;case 2:console.error("THREE.RGBELoader Write Error: "+(M||""));break;case 3:console.error("THREE.RGBELoader Bad File Format: "+(M||""));break;default:case 4:console.error("THREE.RGBELoader: Error: "+(M||""))}return-1},d=`
+`,p=function(w,M,D){M=M||1024;let C=w.pos,y=-1,A=0,g="",I=String.fromCharCode.apply(null,new Uint16Array(w.subarray(C,C+128)));for(;0>(y=I.indexOf(d))&&A<M&&C<w.byteLength;)g+=I,A+=I.length,C+=128,I+=String.fromCharCode.apply(null,new Uint16Array(w.subarray(C,C+128)));return-1<y?(D!==!1&&(w.pos+=A+y+1),g+I.slice(0,y)):!1},m=function(w){const M=/^#\?(\S+)/,D=/^\s*GAMMA\s*=\s*(\d+(\.\d+)?)\s*$/,S=/^\s*EXPOSURE\s*=\s*(\d+(\.\d+)?)\s*$/,C=/^\s*FORMAT=(\S+)\s*$/,y=/^\s*\-Y\s+(\d+)\s+\+X\s+(\d+)\s*$/,A={valid:0,string:"",comments:"",programtype:"RGBE",format:"",gamma:1,exposure:1,width:0,height:0};let g,I;if(w.pos>=w.byteLength||!(g=p(w)))return a(1,"no header found");if(!(I=g.match(M)))return a(3,"bad initial token");for(A.valid|=1,A.programtype=I[1],A.string+=g+`
+`;g=p(w),g!==!1;){if(A.string+=g+`
+`,g.charAt(0)==="#"){A.comments+=g+`
+`;continue}if((I=g.match(D))&&(A.gamma=parseFloat(I[1])),(I=g.match(S))&&(A.exposure=parseFloat(I[1])),(I=g.match(C))&&(A.valid|=2,A.format=I[1]),(I=g.match(y))&&(A.valid|=4,A.height=parseInt(I[1],10),A.width=parseInt(I[2],10)),A.valid&2&&A.valid&4)break}return A.valid&2?A.valid&4?A:a(3,"missing image size specifier"):a(3,"missing format specifier")},x=function(w,M,D){const S=M;if(S<8||S>32767||w[0]!==2||w[1]!==2||w[2]&128)return new Uint8Array(w);if(S!==(w[2]<<8|w[3]))return a(3,"wrong scanline width");const C=new Uint8Array(4*M*D);if(!C.length)return a(4,"unable to allocate buffer space");let y=0,A=0;const g=4*S,I=new Uint8Array(4),k=new Uint8Array(g);let J=D;for(;J>0&&A<w.byteLength;){if(A+4>w.byteLength)return a(1);if(I[0]=w[A++],I[1]=w[A++],I[2]=w[A++],I[3]=w[A++],I[0]!=2||I[1]!=2||(I[2]<<8|I[3])!=S)return a(3,"bad rgbe scanline format");let G=0,Z;for(;G<g&&A<w.byteLength;){Z=w[A++];const K=Z>128;if(K&&(Z-=128),Z===0||G+Z>g)return a(3,"bad scanline data");if(K){const Y=w[A++];for(let te=0;te<Z;te++)k[G++]=Y}else k.set(w.subarray(A,A+Z),G),G+=Z,A+=Z}const X=S;for(let K=0;K<X;K++){let Y=0;C[y]=k[K+Y],Y+=S,C[y+1]=k[K+Y],Y+=S,C[y+2]=k[K+Y],Y+=S,C[y+3]=k[K+Y],y+=4}J--}return C},b=function(w,M,D,S){const C=w[M+3],y=Math.pow(2,C-128)/255;D[S+0]=w[M+0]*y,D[S+1]=w[M+1]*y,D[S+2]=w[M+2]*y,D[S+3]=1},v=function(w,M,D,S){const C=w[M+3],y=Math.pow(2,C-128)/255;D[S+0]=l.DataUtils.toHalfFloat(Math.min(w[M+0]*y,65504)),D[S+1]=l.DataUtils.toHalfFloat(Math.min(w[M+1]*y,65504)),D[S+2]=l.DataUtils.toHalfFloat(Math.min(w[M+2]*y,65504)),D[S+3]=l.DataUtils.toHalfFloat(1)},_=new Uint8Array(e);_.pos=0;const T=m(_);if(T!==-1){const w=T.width,M=T.height,D=x(_.subarray(_.pos),w,M);if(D!==-1){let S,C,y;switch(this.type){case l.FloatType:y=D.length/4;const A=new Float32Array(y*4);for(let I=0;I<y;I++)b(D,I*4,A,I*4);S=A,C=l.FloatType;break;case l.HalfFloatType:y=D.length/4;const g=new Uint16Array(y*4);for(let I=0;I<y;I++)v(D,I*4,g,I*4);S=g,C=l.HalfFloatType;break;default:console.error("THREE.RGBELoader: unsupported type: ",this.type);break}return{width:w,height:M,data:S,header:T.string,gamma:T.gamma,exposure:T.exposure,type:C}}}return null}setDataType(e){return this.type=e,this}load(e,t,n,r){function i(s,a){switch(s.type){case l.FloatType:case l.HalfFloatType:"colorSpace"in s?s.colorSpace="srgb-linear":s.encoding=3e3,s.minFilter=l.LinearFilter,s.magFilter=l.LinearFilter,s.generateMipmaps=!1,s.flipY=!0;break}t&&t(s,a)}return super.load(e,i,n,r)}}class qt extends l.Loader{constructor(e){super(e),this.defaultDPI=90,this.defaultUnit="px"}load(e,t,n,r){const i=this,s=new l.FileLoader(i.manager);s.setPath(i.path),s.setRequestHeader(i.requestHeader),s.setWithCredentials(i.withCredentials),s.load(e,function(a){try{t(i.parse(a))}catch(c){r?r(c):console.error(c),i.manager.itemError(e)}},n,r)}parse(e){const t=this;function n(j,z){if(j.nodeType!==1)return;const P=M(j);let V=!0,ee=null;switch(j.nodeName){case"svg":break;case"style":i(j);break;case"g":z=x(j,z);break;case"path":z=x(j,z),j.hasAttribute("d")&&(ee=r(j));break;case"rect":z=x(j,z),ee=c(j);break;case"polygon":z=x(j,z),ee=h(j);break;case"polyline":z=x(j,z),ee=f(j);break;case"circle":z=x(j,z),ee=d(j);break;case"ellipse":z=x(j,z),ee=p(j);break;case"line":z=x(j,z),ee=m(j);break;case"defs":V=!1;break;case"mask":V=!1;break;case"use":z=x(j,z);const N=j.href.baseVal.substring(1),R=j.viewportElement.getElementById(N);R?n(R,z):console.warn("SVGLoader: 'use node' references non-existent node id: "+N);break}if(ee&&(z.fill!==void 0&&z.fill!=="none"&&ee.color.setStyle(z.fill),S(ee,te),g.push(ee),ee.userData={node:j,style:z}),V){const N=j.childNodes;for(let R=0;R<N.length;R++)n(N[R],z)}P&&(k.pop(),k.length>0?te.copy(k[k.length-1]):te.identity())}function r(j){const z=new l.ShapePath,P=new l.Vector2,V=new l.Vector2,ee=new l.Vector2;let N=!0,R=!1;const O=j.getAttribute("d").match(/[a-df-z][^a-df-z]*/gi);for(let B=0,E=O.length;B<E;B++){const Q=O[B],q=Q.charAt(0),ne=Q.substr(1).trim();N===!0&&(R=!0,N=!1);let U;switch(q){case"M":U=v(ne);for(let F=0,ae=U.length;F<ae;F+=2)P.x=U[F+0],P.y=U[F+1],V.x=P.x,V.y=P.y,F===0?z.moveTo(P.x,P.y):z.lineTo(P.x,P.y),F===0&&ee.copy(P);break;case"H":U=v(ne);for(let F=0,ae=U.length;F<ae;F++)P.x=U[F],V.x=P.x,V.y=P.y,z.lineTo(P.x,P.y),F===0&&R===!0&&ee.copy(P);break;case"V":U=v(ne);for(let F=0,ae=U.length;F<ae;F++)P.y=U[F],V.x=P.x,V.y=P.y,z.lineTo(P.x,P.y),F===0&&R===!0&&ee.copy(P);break;case"L":U=v(ne);for(let F=0,ae=U.length;F<ae;F+=2)P.x=U[F+0],P.y=U[F+1],V.x=P.x,V.y=P.y,z.lineTo(P.x,P.y),F===0&&R===!0&&ee.copy(P);break;case"C":U=v(ne);for(let F=0,ae=U.length;F<ae;F+=6)z.bezierCurveTo(U[F+0],U[F+1],U[F+2],U[F+3],U[F+4],U[F+5]),V.x=U[F+2],V.y=U[F+3],P.x=U[F+4],P.y=U[F+5],F===0&&R===!0&&ee.copy(P);break;case"S":U=v(ne);for(let F=0,ae=U.length;F<ae;F+=4)z.bezierCurveTo(b(P.x,V.x),b(P.y,V.y),U[F+0],U[F+1],U[F+2],U[F+3]),V.x=U[F+0],V.y=U[F+1],P.x=U[F+2],P.y=U[F+3],F===0&&R===!0&&ee.copy(P);break;case"Q":U=v(ne);for(let F=0,ae=U.length;F<ae;F+=4)z.quadraticCurveTo(U[F+0],U[F+1],U[F+2],U[F+3]),V.x=U[F+0],V.y=U[F+1],P.x=U[F+2],P.y=U[F+3],F===0&&R===!0&&ee.copy(P);break;case"T":U=v(ne);for(let F=0,ae=U.length;F<ae;F+=2){const ue=b(P.x,V.x),me=b(P.y,V.y);z.quadraticCurveTo(ue,me,U[F+0],U[F+1]),V.x=ue,V.y=me,P.x=U[F+0],P.y=U[F+1],F===0&&R===!0&&ee.copy(P)}break;case"A":U=v(ne,[3,4],7);for(let F=0,ae=U.length;F<ae;F+=7){if(U[F+5]==P.x&&U[F+6]==P.y)continue;const ue=P.clone();P.x=U[F+5],P.y=U[F+6],V.x=P.x,V.y=P.y,s(z,U[F],U[F+1],U[F+2],U[F+3],U[F+4],ue,P),F===0&&R===!0&&ee.copy(P)}break;case"m":U=v(ne);for(let F=0,ae=U.length;F<ae;F+=2)P.x+=U[F+0],P.y+=U[F+1],V.x=P.x,V.y=P.y,F===0?z.moveTo(P.x,P.y):z.lineTo(P.x,P.y),F===0&&ee.copy(P);break;case"h":U=v(ne);for(let F=0,ae=U.length;F<ae;F++)P.x+=U[F],V.x=P.x,V.y=P.y,z.lineTo(P.x,P.y),F===0&&R===!0&&ee.copy(P);break;case"v":U=v(ne);for(let F=0,ae=U.length;F<ae;F++)P.y+=U[F],V.x=P.x,V.y=P.y,z.lineTo(P.x,P.y),F===0&&R===!0&&ee.copy(P);break;case"l":U=v(ne);for(let F=0,ae=U.length;F<ae;F+=2)P.x+=U[F+0],P.y+=U[F+1],V.x=P.x,V.y=P.y,z.lineTo(P.x,P.y),F===0&&R===!0&&ee.copy(P);break;case"c":U=v(ne);for(let F=0,ae=U.length;F<ae;F+=6)z.bezierCurveTo(P.x+U[F+0],P.y+U[F+1],P.x+U[F+2],P.y+U[F+3],P.x+U[F+4],P.y+U[F+5]),V.x=P.x+U[F+2],V.y=P.y+U[F+3],P.x+=U[F+4],P.y+=U[F+5],F===0&&R===!0&&ee.copy(P);break;case"s":U=v(ne);for(let F=0,ae=U.length;F<ae;F+=4)z.bezierCurveTo(b(P.x,V.x),b(P.y,V.y),P.x+U[F+0],P.y+U[F+1],P.x+U[F+2],P.y+U[F+3]),V.x=P.x+U[F+0],V.y=P.y+U[F+1],P.x+=U[F+2],P.y+=U[F+3],F===0&&R===!0&&ee.copy(P);break;case"q":U=v(ne);for(let F=0,ae=U.length;F<ae;F+=4)z.quadraticCurveTo(P.x+U[F+0],P.y+U[F+1],P.x+U[F+2],P.y+U[F+3]),V.x=P.x+U[F+0],V.y=P.y+U[F+1],P.x+=U[F+2],P.y+=U[F+3],F===0&&R===!0&&ee.copy(P);break;case"t":U=v(ne);for(let F=0,ae=U.length;F<ae;F+=2){const ue=b(P.x,V.x),me=b(P.y,V.y);z.quadraticCurveTo(ue,me,P.x+U[F+0],P.y+U[F+1]),V.x=ue,V.y=me,P.x=P.x+U[F+0],P.y=P.y+U[F+1],F===0&&R===!0&&ee.copy(P)}break;case"a":U=v(ne,[3,4],7);for(let F=0,ae=U.length;F<ae;F+=7){if(U[F+5]==0&&U[F+6]==0)continue;const ue=P.clone();P.x+=U[F+5],P.y+=U[F+6],V.x=P.x,V.y=P.y,s(z,U[F],U[F+1],U[F+2],U[F+3],U[F+4],ue,P),F===0&&R===!0&&ee.copy(P)}break;case"Z":case"z":z.currentPath.autoClose=!0,z.currentPath.curves.length>0&&(P.copy(ee),z.currentPath.currentPoint.copy(P),N=!0);break;default:console.warn(Q)}R=!1}return z}function i(j){if(!(!j.sheet||!j.sheet.cssRules||!j.sheet.cssRules.length))for(let z=0;z<j.sheet.cssRules.length;z++){const P=j.sheet.cssRules[z];if(P.type!==1)continue;const V=P.selectorText.split(/,/gm).filter(Boolean).map(ee=>ee.trim());for(let ee=0;ee<V.length;ee++)I[V[ee]]=Object.assign(I[V[ee]]||{},P.style)}}function s(j,z,P,V,ee,N,R,L){if(z==0||P==0){j.lineTo(L.x,L.y);return}V=V*Math.PI/180,z=Math.abs(z),P=Math.abs(P);const O=(R.x-L.x)/2,B=(R.y-L.y)/2,E=Math.cos(V)*O+Math.sin(V)*B,Q=-Math.sin(V)*O+Math.cos(V)*B;let q=z*z,ne=P*P;const U=E*E,F=Q*Q,ae=U/q+F/ne;if(ae>1){const jt=Math.sqrt(ae);z=jt*z,P=jt*P,q=z*z,ne=P*P}const ue=q*F+ne*U,me=(q*ne-ue)/ue;let ye=Math.sqrt(Math.max(0,me));ee===N&&(ye=-ye);const _e=ye*z*Q/P,Oe=-ye*P*E/z,lt=Math.cos(V)*_e-Math.sin(V)*Oe+(R.x+L.x)/2,un=Math.sin(V)*_e+Math.cos(V)*Oe+(R.y+L.y)/2,Gt=a(1,0,(E-_e)/z,(Q-Oe)/P),qe=a((E-_e)/z,(Q-Oe)/P,(-E-_e)/z,(-Q-Oe)/P)%(Math.PI*2);j.currentPath.absellipse(lt,un,z,P,Gt,Gt+qe,N===0,V)}function a(j,z,P,V){const ee=j*P+z*V,N=Math.sqrt(j*j+z*z)*Math.sqrt(P*P+V*V);let R=Math.acos(Math.max(-1,Math.min(1,ee/N)));return j*V-z*P<0&&(R=-R),R}function c(j){const z=w(j.getAttribute("x")||0),P=w(j.getAttribute("y")||0),V=w(j.getAttribute("rx")||j.getAttribute("ry")||0),ee=w(j.getAttribute("ry")||j.getAttribute("rx")||0),N=w(j.getAttribute("width")),R=w(j.getAttribute("height")),L=1-.551915024494,O=new l.ShapePath;return O.moveTo(z+V,P),O.lineTo(z+N-V,P),(V!==0||ee!==0)&&O.bezierCurveTo(z+N-V*L,P,z+N,P+ee*L,z+N,P+ee),O.lineTo(z+N,P+R-ee),(V!==0||ee!==0)&&O.bezierCurveTo(z+N,P+R-ee*L,z+N-V*L,P+R,z+N-V,P+R),O.lineTo(z+V,P+R),(V!==0||ee!==0)&&O.bezierCurveTo(z+V*L,P+R,z,P+R-ee*L,z,P+R-ee),O.lineTo(z,P+ee),(V!==0||ee!==0)&&O.bezierCurveTo(z,P+ee*L,z+V*L,P,z+V,P),O}function h(j){function z(N,R,L){const O=w(R),B=w(L);ee===0?V.moveTo(O,B):V.lineTo(O,B),ee++}const P=/(-?[\d\.?]+)[,|\s](-?[\d\.?]+)/g,V=new l.ShapePath;let ee=0;return j.getAttribute("points").replace(P,z),V.currentPath.autoClose=!0,V}function f(j){function z(N,R,L){const O=w(R),B=w(L);ee===0?V.moveTo(O,B):V.lineTo(O,B),ee++}const P=/(-?[\d\.?]+)[,|\s](-?[\d\.?]+)/g,V=new l.ShapePath;let ee=0;return j.getAttribute("points").replace(P,z),V.currentPath.autoClose=!1,V}function d(j){const z=w(j.getAttribute("cx")||0),P=w(j.getAttribute("cy")||0),V=w(j.getAttribute("r")||0),ee=new l.Path;ee.absarc(z,P,V,0,Math.PI*2);const N=new l.ShapePath;return N.subPaths.push(ee),N}function p(j){const z=w(j.getAttribute("cx")||0),P=w(j.getAttribute("cy")||0),V=w(j.getAttribute("rx")||0),ee=w(j.getAttribute("ry")||0),N=new l.Path;N.absellipse(z,P,V,ee,0,Math.PI*2);const R=new l.ShapePath;return R.subPaths.push(N),R}function m(j){const z=w(j.getAttribute("x1")||0),P=w(j.getAttribute("y1")||0),V=w(j.getAttribute("x2")||0),ee=w(j.getAttribute("y2")||0),N=new l.ShapePath;return N.moveTo(z,P),N.lineTo(V,ee),N.currentPath.autoClose=!1,N}function x(j,z){z=Object.assign({},z);let P={};if(j.hasAttribute("class")){const R=j.getAttribute("class").split(/\s/).filter(Boolean).map(L=>L.trim());for(let L=0;L<R.length;L++)P=Object.assign(P,I["."+R[L]])}j.hasAttribute("id")&&(P=Object.assign(P,I["#"+j.getAttribute("id")]));function V(R,L,O){O===void 0&&(O=function(E){return E.startsWith("url")&&console.warn("SVGLoader: url access in attributes is not implemented."),E}),j.hasAttribute(R)&&(z[L]=O(j.getAttribute(R))),P[R]&&(z[L]=O(P[R])),j.style&&j.style[R]!==""&&(z[L]=O(j.style[R]))}function ee(R){return Math.max(0,Math.min(1,w(R)))}function N(R){return Math.max(0,w(R))}return V("fill","fill"),V("fill-opacity","fillOpacity",ee),V("fill-rule","fillRule"),V("opacity","opacity",ee),V("stroke","stroke"),V("stroke-opacity","strokeOpacity",ee),V("stroke-width","strokeWidth",N),V("stroke-linejoin","strokeLineJoin"),V("stroke-linecap","strokeLineCap"),V("stroke-miterlimit","strokeMiterLimit",N),V("visibility","visibility"),z}function b(j,z){return j-(z-j)}function v(j,z,P){if(typeof j!="string")throw new TypeError("Invalid input: "+typeof j);const V={SEPARATOR:/[ \t\r\n\,.\-+]/,WHITESPACE:/[ \t\r\n]/,DIGIT:/[\d]/,SIGN:/[-+]/,POINT:/\./,COMMA:/,/,EXP:/e/i,FLAGS:/[01]/},ee=0,N=1,R=2,L=3;let O=ee,B=!0,E="",Q="";const q=[];function ne(ue,me,ye){const _e=new SyntaxError('Unexpected character "'+ue+'" at index '+me+".");throw _e.partial=ye,_e}function U(){E!==""&&(Q===""?q.push(Number(E)):q.push(Number(E)*Math.pow(10,Number(Q)))),E="",Q=""}let F;const ae=j.length;for(let ue=0;ue<ae;ue++){if(F=j[ue],Array.isArray(z)&&z.includes(q.length%P)&&V.FLAGS.test(F)){O=N,E=F,U();continue}if(O===ee){if(V.WHITESPACE.test(F))continue;if(V.DIGIT.test(F)||V.SIGN.test(F)){O=N,E=F;continue}if(V.POINT.test(F)){O=R,E=F;continue}V.COMMA.test(F)&&(B&&ne(F,ue,q),B=!0)}if(O===N){if(V.DIGIT.test(F)){E+=F;continue}if(V.POINT.test(F)){E+=F,O=R;continue}if(V.EXP.test(F)){O=L;continue}V.SIGN.test(F)&&E.length===1&&V.SIGN.test(E[0])&&ne(F,ue,q)}if(O===R){if(V.DIGIT.test(F)){E+=F;continue}if(V.EXP.test(F)){O=L;continue}V.POINT.test(F)&&E[E.length-1]==="."&&ne(F,ue,q)}if(O===L){if(V.DIGIT.test(F)){Q+=F;continue}if(V.SIGN.test(F)){if(Q===""){Q+=F;continue}Q.length===1&&V.SIGN.test(Q)&&ne(F,ue,q)}}V.WHITESPACE.test(F)?(U(),O=ee,B=!1):V.COMMA.test(F)?(U(),O=ee,B=!0):V.SIGN.test(F)?(U(),O=N,E=F):V.POINT.test(F)?(U(),O=R,E=F):ne(F,ue,q)}return U(),q}const _=["mm","cm","in","pt","pc","px"],T={mm:{mm:1,cm:.1,in:1/25.4,pt:72/25.4,pc:6/25.4,px:-1},cm:{mm:10,cm:1,in:1/2.54,pt:72/2.54,pc:6/2.54,px:-1},in:{mm:25.4,cm:2.54,in:1,pt:72,pc:6,px:-1},pt:{mm:25.4/72,cm:2.54/72,in:1/72,pt:1,pc:6/72,px:-1},pc:{mm:25.4/6,cm:2.54/6,in:1/6,pt:72/6,pc:1,px:-1},px:{px:1}};function w(j){let z="px";if(typeof j=="string"||j instanceof String)for(let V=0,ee=_.length;V<ee;V++){const N=_[V];if(j.endsWith(N)){z=N,j=j.substring(0,j.length-N.length);break}}let P;return z==="px"&&t.defaultUnit!=="px"?P=T.in[t.defaultUnit]/t.defaultDPI:(P=T[z][t.defaultUnit],P<0&&(P=T[z].in*t.defaultDPI)),P*parseFloat(j)}function M(j){if(!(j.hasAttribute("transform")||j.nodeName==="use"&&(j.hasAttribute("x")||j.hasAttribute("y"))))return null;const z=D(j);return k.length>0&&z.premultiply(k[k.length-1]),te.copy(z),k.push(z),z}function D(j){const z=new l.Matrix3,P=J;if(j.nodeName==="use"&&(j.hasAttribute("x")||j.hasAttribute("y"))){const V=w(j.getAttribute("x")),ee=w(j.getAttribute("y"));z.translate(V,ee)}if(j.hasAttribute("transform")){const V=j.getAttribute("transform").split(")");for(let ee=V.length-1;ee>=0;ee--){const N=V[ee].trim();if(N==="")continue;const R=N.indexOf("("),L=N.length;if(R>0&&R<L){const O=N.substr(0,R),B=v(N.substr(R+1,L-R-1));switch(P.identity(),O){case"translate":if(B.length>=1){const E=B[0];let Q=E;B.length>=2&&(Q=B[1]),P.translate(E,Q)}break;case"rotate":if(B.length>=1){let E=0,Q=0,q=0;E=-B[0]*Math.PI/180,B.length>=3&&(Q=B[1],q=B[2]),G.identity().translate(-Q,-q),Z.identity().rotate(E),X.multiplyMatrices(Z,G),G.identity().translate(Q,q),P.multiplyMatrices(G,X)}break;case"scale":if(B.length>=1){const E=B[0];let Q=E;B.length>=2&&(Q=B[1]),P.scale(E,Q)}break;case"skewX":B.length===1&&P.set(1,Math.tan(B[0]*Math.PI/180),0,0,1,0,0,0,1);break;case"skewY":B.length===1&&P.set(1,0,0,Math.tan(B[0]*Math.PI/180),1,0,0,0,1);break;case"matrix":B.length===6&&P.set(B[0],B[2],B[4],B[1],B[3],B[5],0,0,1);break}}z.premultiply(P)}}return z}function S(j,z){function P(N){Y.set(N.x,N.y,1).applyMatrix3(z),N.set(Y.x,Y.y)}const V=C(z),ee=j.subPaths;for(let N=0,R=ee.length;N<R;N++){const O=ee[N].curves;for(let B=0;B<O.length;B++){const E=O[B];E.isLineCurve?(P(E.v1),P(E.v2)):E.isCubicBezierCurve?(P(E.v0),P(E.v1),P(E.v2),P(E.v3)):E.isQuadraticBezierCurve?(P(E.v0),P(E.v1),P(E.v2)):E.isEllipseCurve&&(V&&console.warn("SVGLoader: Elliptic arc or ellipse rotation or skewing is not implemented."),K.set(E.aX,E.aY),P(K),E.aX=K.x,E.aY=K.y,E.xRadius*=y(z),E.yRadius*=A(z))}}}function C(j){return j.elements[1]!==0||j.elements[3]!==0}function y(j){const z=j.elements;return Math.sqrt(z[0]*z[0]+z[1]*z[1])}function A(j){const z=j.elements;return Math.sqrt(z[3]*z[3]+z[4]*z[4])}const g=[],I={},k=[],J=new l.Matrix3,G=new l.Matrix3,Z=new l.Matrix3,X=new l.Matrix3,K=new l.Vector2,Y=new l.Vector3,te=new l.Matrix3,re=new DOMParser().parseFromString(e,"image/svg+xml");return n(re.documentElement,{fill:"#000",fillOpacity:1,strokeOpacity:1,strokeWidth:1,strokeLineJoin:"miter",strokeLineCap:"butt",strokeMiterLimit:4}),{paths:g,xml:re.documentElement}}static createShapes(e){const n={ORIGIN:0,DESTINATION:1,BETWEEN:2,LEFT:3,RIGHT:4,BEHIND:5,BEYOND:6},r={loc:n.ORIGIN,t:0};function i(v,_,T,w){const M=v.x,D=_.x,S=T.x,C=w.x,y=v.y,A=_.y,g=T.y,I=w.y,k=(C-S)*(y-g)-(I-g)*(M-S),J=(D-M)*(y-g)-(A-y)*(M-S),G=(I-g)*(D-M)-(C-S)*(A-y),Z=k/G,X=J/G;if(G===0&&k!==0||Z<=0||Z>=1||X<0||X>1)return null;if(k===0&&G===0){for(let K=0;K<2;K++)if(s(K===0?T:w,v,_),r.loc==n.ORIGIN){const Y=K===0?T:w;return{x:Y.x,y:Y.y,t:r.t}}else if(r.loc==n.BETWEEN){const Y=+(M+r.t*(D-M)).toPrecision(10),te=+(y+r.t*(A-y)).toPrecision(10);return{x:Y,y:te,t:r.t}}return null}else{for(let te=0;te<2;te++)if(s(te===0?T:w,v,_),r.loc==n.ORIGIN){const re=te===0?T:w;return{x:re.x,y:re.y,t:r.t}}const K=+(M+Z*(D-M)).toPrecision(10),Y=+(y+Z*(A-y)).toPrecision(10);return{x:K,y:Y,t:Z}}}function s(v,_,T){const w=T.x-_.x,M=T.y-_.y,D=v.x-_.x,S=v.y-_.y,C=w*S-D*M;if(v.x===_.x&&v.y===_.y){r.loc=n.ORIGIN,r.t=0;return}if(v.x===T.x&&v.y===T.y){r.loc=n.DESTINATION,r.t=1;return}if(C<-Number.EPSILON){r.loc=n.LEFT;return}if(C>Number.EPSILON){r.loc=n.RIGHT;return}if(w*D<0||M*S<0){r.loc=n.BEHIND;return}if(Math.sqrt(w*w+M*M)<Math.sqrt(D*D+S*S)){r.loc=n.BEYOND;return}let y;w!==0?y=D/w:y=S/M,r.loc=n.BETWEEN,r.t=y}function a(v,_){const T=[],w=[];for(let M=1;M<v.length;M++){const D=v[M-1],S=v[M];for(let C=1;C<_.length;C++){const y=_[C-1],A=_[C],g=i(D,S,y,A);g!==null&&T.find(I=>I.t<=g.t+Number.EPSILON&&I.t>=g.t-Number.EPSILON)===void 0&&(T.push(g),w.push(new l.Vector2(g.x,g.y)))}}return w}function c(v,_,T){const w=new l.Vector2;_.getCenter(w);const M=[];return T.forEach(D=>{D.boundingBox.containsPoint(w)&&a(v,D.points).forEach(C=>{M.push({identifier:D.identifier,isCW:D.isCW,point:C})})}),M.sort((D,S)=>D.point.x-S.point.x),M}function h(v,_,T,w,M){(M==null||M==="")&&(M="nonzero");const D=new l.Vector2;v.boundingBox.getCenter(D);const S=[new l.Vector2(T,D.y),new l.Vector2(w,D.y)],C=c(S,v.boundingBox,_);C.sort((J,G)=>J.point.x-G.point.x);const y=[],A=[];C.forEach(J=>{J.identifier===v.identifier?y.push(J):A.push(J)});const g=y[0].point.x,I=[];let k=0;for(;k<A.length&&A[k].point.x<g;)I.length>0&&I[I.length-1]===A[k].identifier?I.pop():I.push(A[k].identifier),k++;if(I.push(v.identifier),M==="evenodd"){const J=I.length%2===0,G=I[I.length-2];return{identifier:v.identifier,isHole:J,for:G}}else if(M==="nonzero"){let J=!0,G=null,Z=null;for(let X=0;X<I.length;X++){const K=I[X];J?(Z=_[K].isCW,J=!1,G=K):Z!==_[K].isCW&&(Z=_[K].isCW,J=!0)}return{identifier:v.identifier,isHole:J,for:G}}else console.warn('fill-rule: "'+M+'" is currently not implemented.')}let f=0,d=999999999,p=-999999999,m=e.subPaths.map(v=>{const _=v.getPoints();let T=-999999999,w=999999999,M=-999999999,D=999999999;for(let S=0;S<_.length;S++){const C=_[S];C.y>T&&(T=C.y),C.y<w&&(w=C.y),C.x>M&&(M=C.x),C.x<D&&(D=C.x)}return p<=M&&(p=M+1),d>=D&&(d=D-1),{curves:v.curves,points:_,isCW:l.ShapeUtils.isClockWise(_),identifier:f++,boundingBox:new l.Box2(new l.Vector2(D,w),new l.Vector2(M,T))}});m=m.filter(v=>v.points.length>1);const x=m.map(v=>h(v,m,d,p,e.userData.style.fillRule)),b=[];return m.forEach(v=>{if(!x[v.identifier].isHole){const T=new l.Shape;T.curves=v.curves,x.filter(M=>M.isHole&&M.for===v.identifier).forEach(M=>{const D=m[M.identifier],S=new l.Path;S.curves=D.curves,T.holes.push(S)}),b.push(T)}}),b}static getStrokeStyle(e,t,n,r,i){return e=e!==void 0?e:1,t=t!==void 0?t:"#000",n=n!==void 0?n:"miter",r=r!==void 0?r:"butt",i=i!==void 0?i:4,{strokeColor:t,strokeWidth:e,strokeLineJoin:n,strokeLineCap:r,strokeMiterLimit:i}}static pointsToStroke(e,t,n,r){const i=[],s=[],a=[];if(qt.pointsToStrokeWithBuffers(e,t,n,r,i,s,a)===0)return null;const c=new l.BufferGeometry;return c.setAttribute("position",new l.Float32BufferAttribute(i,3)),c.setAttribute("normal",new l.Float32BufferAttribute(s,3)),c.setAttribute("uv",new l.Float32BufferAttribute(a,2)),c}static pointsToStrokeWithBuffers(e,t,n,r,i,s,a,c){const h=new l.Vector2,f=new l.Vector2,d=new l.Vector2,p=new l.Vector2,m=new l.Vector2,x=new l.Vector2,b=new l.Vector2,v=new l.Vector2,_=new l.Vector2,T=new l.Vector2,w=new l.Vector2,M=new l.Vector2,D=new l.Vector2,S=new l.Vector2,C=new l.Vector2,y=new l.Vector2,A=new l.Vector2;n=n!==void 0?n:12,r=r!==void 0?r:.001,c=c!==void 0?c:0,e=Q(e);const g=e.length;if(g<2)return 0;const I=e[0].equals(e[g-1]);let k,J=e[0],G;const Z=t.strokeWidth/2,X=1/(g-1);let K=0,Y,te,re,ce,j=!1,z=0,P=c*3,V=c*2;ee(e[0],e[1],h).multiplyScalar(Z),v.copy(e[0]).sub(h),_.copy(e[0]).add(h),T.copy(v),w.copy(_);for(let q=1;q<g;q++){k=e[q],q===g-1?I?G=e[1]:G=void 0:G=e[q+1];const ne=h;if(ee(J,k,ne),d.copy(ne).multiplyScalar(Z),M.copy(k).sub(d),D.copy(k).add(d),Y=K+X,te=!1,G!==void 0){ee(k,G,f),d.copy(f).multiplyScalar(Z),S.copy(k).sub(d),C.copy(k).add(d),re=!0,d.subVectors(G,J),ne.dot(d)<0&&(re=!1),q===1&&(j=re),d.subVectors(G,k),d.normalize();const U=Math.abs(ne.dot(d));if(U!==0){const F=Z/U;d.multiplyScalar(-F),p.subVectors(k,J),m.copy(p).setLength(F).add(d),y.copy(m).negate();const ae=m.length(),ue=p.length();p.divideScalar(ue),x.subVectors(G,k);const me=x.length();switch(x.divideScalar(me),p.dot(y)<ue&&x.dot(y)<me&&(te=!0),A.copy(m).add(k),y.add(k),ce=!1,te?re?(C.copy(y),D.copy(y)):(S.copy(y),M.copy(y)):L(),t.strokeLineJoin){case"bevel":O(re,te,Y);break;case"round":B(re,te),re?R(k,M,S,Y,0):R(k,C,D,Y,1);break;case"miter":case"miter-clip":default:const ye=Z*t.strokeMiterLimit/ae;if(ye<1)if(t.strokeLineJoin!=="miter-clip"){O(re,te,Y);break}else B(re,te),re?(x.subVectors(A,M).multiplyScalar(ye).add(M),b.subVectors(A,S).multiplyScalar(ye).add(S),N(M,Y,0),N(x,Y,0),N(k,Y,.5),N(k,Y,.5),N(x,Y,0),N(b,Y,0),N(k,Y,.5),N(b,Y,0),N(S,Y,0)):(x.subVectors(A,D).multiplyScalar(ye).add(D),b.subVectors(A,C).multiplyScalar(ye).add(C),N(D,Y,1),N(x,Y,1),N(k,Y,.5),N(k,Y,.5),N(x,Y,1),N(b,Y,1),N(k,Y,.5),N(b,Y,1),N(C,Y,1));else te?(re?(N(_,K,1),N(v,K,0),N(A,Y,0),N(_,K,1),N(A,Y,0),N(y,Y,1)):(N(_,K,1),N(v,K,0),N(A,Y,1),N(v,K,0),N(y,Y,0),N(A,Y,1)),re?S.copy(A):C.copy(A)):re?(N(M,Y,0),N(A,Y,0),N(k,Y,.5),N(k,Y,.5),N(A,Y,0),N(S,Y,0)):(N(D,Y,1),N(A,Y,1),N(k,Y,.5),N(k,Y,.5),N(A,Y,1),N(C,Y,1)),ce=!0;break}}else L()}else L();!I&&q===g-1&&E(e[0],T,w,re,!0,K),K=Y,J=k,v.copy(S),_.copy(C)}if(!I)E(k,M,D,re,!1,Y);else if(te&&i){let q=A,ne=y;j!==re&&(q=y,ne=A),re?(ce||j)&&(ne.toArray(i,0*3),ne.toArray(i,3*3),ce&&q.toArray(i,1*3)):(ce||!j)&&(ne.toArray(i,1*3),ne.toArray(i,3*3),ce&&q.toArray(i,0*3))}return z;function ee(q,ne,U){return U.subVectors(ne,q),U.set(-U.y,U.x).normalize()}function N(q,ne,U){i&&(i[P]=q.x,i[P+1]=q.y,i[P+2]=0,s&&(s[P]=0,s[P+1]=0,s[P+2]=1),P+=3,a&&(a[V]=ne,a[V+1]=U,V+=2)),z+=3}function R(q,ne,U,F,ae){h.copy(ne).sub(q).normalize(),f.copy(U).sub(q).normalize();let ue=Math.PI;const me=h.dot(f);Math.abs(me)<1&&(ue=Math.abs(Math.acos(me))),ue/=n,d.copy(ne);for(let ye=0,_e=n-1;ye<_e;ye++)p.copy(d).rotateAround(q,ue),N(d,F,ae),N(p,F,ae),N(q,F,.5),d.copy(p);N(p,F,ae),N(U,F,ae),N(q,F,.5)}function L(){N(_,K,1),N(v,K,0),N(M,Y,0),N(_,K,1),N(M,Y,1),N(D,Y,0)}function O(q,ne,U){ne?q?(N(_,K,1),N(v,K,0),N(M,Y,0),N(_,K,1),N(M,Y,0),N(y,Y,1),N(M,U,0),N(S,U,0),N(y,U,.5)):(N(_,K,1),N(v,K,0),N(D,Y,1),N(v,K,0),N(y,Y,0),N(D,Y,1),N(D,U,1),N(C,U,0),N(y,U,.5)):q?(N(M,U,0),N(S,U,0),N(k,U,.5)):(N(D,U,1),N(C,U,0),N(k,U,.5))}function B(q,ne){ne&&(q?(N(_,K,1),N(v,K,0),N(M,Y,0),N(_,K,1),N(M,Y,0),N(y,Y,1),N(M,K,0),N(k,Y,.5),N(y,Y,1),N(k,Y,.5),N(S,K,0),N(y,Y,1)):(N(_,K,1),N(v,K,0),N(D,Y,1),N(v,K,0),N(y,Y,0),N(D,Y,1),N(D,K,1),N(y,Y,0),N(k,Y,.5),N(k,Y,.5),N(y,Y,0),N(C,K,1)))}function E(q,ne,U,F,ae,ue){switch(t.strokeLineCap){case"round":ae?R(q,U,ne,ue,.5):R(q,ne,U,ue,.5);break;case"square":if(ae)h.subVectors(ne,q),f.set(h.y,-h.x),d.addVectors(h,f).add(q),p.subVectors(f,h).add(q),F?(d.toArray(i,1*3),p.toArray(i,0*3),p.toArray(i,3*3)):(d.toArray(i,1*3),d.toArray(i,3*3),p.toArray(i,0*3));else{h.subVectors(U,q),f.set(h.y,-h.x),d.addVectors(h,f).add(q),p.subVectors(f,h).add(q);const me=i.length;F?(d.toArray(i,me-1*3),p.toArray(i,me-2*3),p.toArray(i,me-4*3)):(d.toArray(i,me-2*3),p.toArray(i,me-1*3),p.toArray(i,me-4*3))}break}}function Q(q){let ne=!1;for(let F=1,ae=q.length-1;F<ae;F++)if(q[F].distanceTo(q[F+1])<r){ne=!0;break}if(!ne)return q;const U=[];U.push(q[0]);for(let F=1,ae=q.length-1;F<ae;F++)q[F].distanceTo(q[F+1])>=r&&U.push(q[F]);return U.push(q[q.length-1]),U}}}const ir=new WeakMap;class $a extends l.Loader{constructor(e){super(e),this.decoderPath="",this.decoderConfig={},this.decoderBinary=null,this.decoderPending=null,this.workerLimit=4,this.workerPool=[],this.workerNextTaskID=1,this.workerSourceURL="",this.defaultAttributeIDs={position:"POSITION",normal:"NORMAL",color:"COLOR",uv:"TEX_COORD"},this.defaultAttributeTypes={position:"Float32Array",normal:"Float32Array",color:"Float32Array",uv:"Float32Array"}}setDecoderPath(e){return this.decoderPath=e,this}setDecoderConfig(e){return this.decoderConfig=e,this}setWorkerLimit(e){return this.workerLimit=e,this}load(e,t,n,r){const i=new l.FileLoader(this.manager);i.setPath(this.path),i.setResponseType("arraybuffer"),i.setRequestHeader(this.requestHeader),i.setWithCredentials(this.withCredentials),i.load(e,s=>{const a={attributeIDs:this.defaultAttributeIDs,attributeTypes:this.defaultAttributeTypes,useUniqueIDs:!1};this.decodeGeometry(s,a).then(t).catch(r)},n,r)}decodeDracoFile(e,t,n,r){const i={attributeIDs:n||this.defaultAttributeIDs,attributeTypes:r||this.defaultAttributeTypes,useUniqueIDs:!!n};this.decodeGeometry(e,i).then(t)}decodeGeometry(e,t){for(const c in t.attributeTypes){const h=t.attributeTypes[c];h.BYTES_PER_ELEMENT!==void 0&&(t.attributeTypes[c]=h.name)}const n=JSON.stringify(t);if(ir.has(e)){const c=ir.get(e);if(c.key===n)return c.promise;if(e.byteLength===0)throw new Error("THREE.DRACOLoader: Unable to re-decode a buffer with different settings. Buffer has already been transferred.")}let r;const i=this.workerNextTaskID++,s=e.byteLength,a=this._getWorker(i,s).then(c=>(r=c,new Promise((h,f)=>{r._callbacks[i]={resolve:h,reject:f},r.postMessage({type:"decode",id:i,taskConfig:t,buffer:e},[e])}))).then(c=>this._createGeometry(c.geometry));return a.catch(()=>!0).then(()=>{r&&i&&this._releaseTask(r,i)}),ir.set(e,{key:n,promise:a}),a}_createGeometry(e){const t=new l.BufferGeometry;e.index&&t.setIndex(new l.BufferAttribute(e.index.array,1));for(let n=0;n<e.attributes.length;n++){const r=e.attributes[n],i=r.name,s=r.array,a=r.itemSize;t.setAttribute(i,new l.BufferAttribute(s,a))}return t}_loadLibrary(e,t){const n=new l.FileLoader(this.manager);return n.setPath(this.decoderPath),n.setResponseType(t),n.setWithCredentials(this.withCredentials),new Promise((r,i)=>{n.load(e,r,void 0,i)})}preload(){return this._initDecoder(),this}_initDecoder(){if(this.decoderPending)return this.decoderPending;const e=typeof WebAssembly!="object"||this.decoderConfig.type==="js",t=[];return e?t.push(this._loadLibrary("draco_decoder.js","text")):(t.push(this._loadLibrary("draco_wasm_wrapper.js","text")),t.push(this._loadLibrary("draco_decoder.wasm","arraybuffer"))),this.decoderPending=Promise.all(t).then(n=>{const r=n[0];e||(this.decoderConfig.wasmBinary=n[1]);const i=el.toString(),s=["/* draco decoder */",r,"","/* worker */",i.substring(i.indexOf("{")+1,i.lastIndexOf("}"))].join(`
+`);this.workerSourceURL=URL.createObjectURL(new Blob([s]))}),this.decoderPending}_getWorker(e,t){return this._initDecoder().then(()=>{if(this.workerPool.length<this.workerLimit){const r=new Worker(this.workerSourceURL);r._callbacks={},r._taskCosts={},r._taskLoad=0,r.postMessage({type:"init",decoderConfig:this.decoderConfig}),r.onmessage=function(i){const s=i.data;switch(s.type){case"decode":r._callbacks[s.id].resolve(s);break;case"error":r._callbacks[s.id].reject(s);break;default:console.error('THREE.DRACOLoader: Unexpected message, "'+s.type+'"')}},this.workerPool.push(r)}else this.workerPool.sort(function(r,i){return r._taskLoad>i._taskLoad?-1:1});const n=this.workerPool[this.workerPool.length-1];return n._taskCosts[e]=t,n._taskLoad+=t,n})}_releaseTask(e,t){e._taskLoad-=e._taskCosts[t],delete e._callbacks[t],delete e._taskCosts[t]}debug(){console.log("Task load: ",this.workerPool.map(e=>e._taskLoad))}dispose(){for(let e=0;e<this.workerPool.length;++e)this.workerPool[e].terminate();return this.workerPool.length=0,this}}function el(){let o,e;onmessage=function(s){const a=s.data;switch(a.type){case"init":o=a.decoderConfig,e=new Promise(function(f){o.onModuleLoaded=function(d){f({draco:d})},DracoDecoderModule(o)});break;case"decode":const c=a.buffer,h=a.taskConfig;e.then(f=>{const d=f.draco,p=new d.Decoder,m=new d.DecoderBuffer;m.Init(new Int8Array(c),c.byteLength);try{const x=t(d,p,m,h),b=x.attributes.map(v=>v.array.buffer);x.index&&b.push(x.index.array.buffer),self.postMessage({type:"decode",id:a.id,geometry:x},b)}catch(x){console.error(x),self.postMessage({type:"error",id:a.id,error:x.message})}finally{d.destroy(m),d.destroy(p)}});break}};function t(s,a,c,h){const f=h.attributeIDs,d=h.attributeTypes;let p,m;const x=a.GetEncodedGeometryType(c);if(x===s.TRIANGULAR_MESH)p=new s.Mesh,m=a.DecodeBufferToMesh(c,p);else if(x===s.POINT_CLOUD)p=new s.PointCloud,m=a.DecodeBufferToPointCloud(c,p);else throw new Error("THREE.DRACOLoader: Unexpected geometry type.");if(!m.ok()||p.ptr===0)throw new Error("THREE.DRACOLoader: Decoding failed: "+m.error_msg());const b={index:null,attributes:[]};for(const v in f){const _=self[d[v]];let T,w;if(h.useUniqueIDs)w=f[v],T=a.GetAttributeByUniqueId(p,w);else{if(w=a.GetAttributeId(p,s[f[v]]),w===-1)continue;T=a.GetAttribute(p,w)}b.attributes.push(r(s,a,p,v,_,T))}return x===s.TRIANGULAR_MESH&&(b.index=n(s,a,p)),s.destroy(p),b}function n(s,a,c){const f=c.num_faces()*3,d=f*4,p=s._malloc(d);a.GetTrianglesUInt32Array(c,d,p);const m=new Uint32Array(s.HEAPF32.buffer,p,f).slice();return s._free(p),{array:m,itemSize:1}}function r(s,a,c,h,f,d){const p=d.num_components(),x=c.num_points()*p,b=x*f.BYTES_PER_ELEMENT,v=i(s,f),_=s._malloc(b);a.GetAttributeDataArrayForAllPoints(c,d,v,b,_);const T=new f(s.HEAPF32.buffer,_,x).slice();return s._free(_),{name:h,array:T,itemSize:p}}function i(s,a){switch(a){case Float32Array:return s.DT_FLOAT32;case Int8Array:return s.DT_INT8;case Int16Array:return s.DT_INT16;case Int32Array:return s.DT_INT32;case Uint8Array:return s.DT_UINT8;case Uint16Array:return s.DT_UINT16;case Uint32Array:return s.DT_UINT32}}}class Si extends l.Line{constructor(e,t){const n=[1,1,0,-1,1,0,-1,-1,0,1,-1,0,1,1,0],r=new l.BufferGeometry;r.setAttribute("position",new l.Float32BufferAttribute(n,3)),r.computeBoundingSphere();const i=new l.LineBasicMaterial({fog:!1});super(r,i),this.light=e,this.color=t,this.type="RectAreaLightHelper";const s=[1,1,0,-1,1,0,-1,-1,0,1,1,0,-1,-1,0,1,-1,0],a=new l.BufferGeometry;a.setAttribute("position",new l.Float32BufferAttribute(s,3)),a.computeBoundingSphere(),this.add(new l.Mesh(a,new l.MeshBasicMaterial({side:l.BackSide,fog:!1})))}updateMatrixWorld(){if(this.scale.set(.5*this.light.width,.5*this.light.height,1),this.color!==void 0)this.material.color.set(this.color),this.children[0].material.color.set(this.color);else{this.material.color.copy(this.light.color).multiplyScalar(this.light.intensity);const e=this.material.color,t=Math.max(e.r,e.g,e.b);t>1&&e.multiplyScalar(1/t),this.children[0].material.color.copy(this.material.color)}this.matrixWorld.extractRotation(this.light.matrixWorld).scale(this.scale).copyPosition(this.light.matrixWorld),this.children[0].matrixWorld.copy(this.matrixWorld)}dispose(){this.geometry.dispose(),this.material.dispose(),this.children[0].geometry.dispose(),this.children[0].material.dispose()}}const tl=["args","center"],nl=u.defineComponent({__name:"Text3D",props:{font:{},text:{},size:{default:.5},height:{default:.2},curveSegments:{default:5},bevelEnabled:{type:Boolean,default:!0},bevelThickness:{default:.05},bevelSize:{default:.02},bevelOffset:{default:0},bevelSegments:{default:4},center:{type:Boolean,default:!1},needUpdates:{type:Boolean,default:!1}},async setup(o,{expose:e}){let t,n;const r=o,{center:i,font:s,text:a,needUpdates:c,size:h,height:f,curveSegments:d,bevelEnabled:p,bevelThickness:m,bevelSize:x,bevelOffset:b,bevelSegments:v}=u.toRefs(r),{extend:_}=oe.useTresContext();_({TextGeometry:di});const T=new Qa,w=u.useSlots(),M=u.computed(()=>{var y;return a!=null&&a.value?a.value:w.default?(y=w.default()[0].children)==null?void 0:y.trim():c.value?"":"TresJS"}),D=u.shallowRef();e({value:D});const S=([t,n]=u.withAsyncContext(()=>new Promise((y,A)=>{try{typeof s.value=="string"?T.load(s.value,g=>{y(g)}):y(s.value)}catch(g){A(console.error("cientos",g))}})),t=await t,n(),t),C=u.computed(()=>({font:S,size:u.toValue(h),height:u.toValue(f),curveSegments:u.toValue(d),bevelEnabled:u.toValue(p),bevelThickness:u.toValue(m),bevelSize:u.toValue(x),bevelOffset:u.toValue(b),bevelSegments:u.toValue(v)}));return u.watchEffect(()=>{D.value&&c.value&&(D.value.geometry.dispose(),D.value.geometry=new di(M.value,C.value),i.value&&D.value.geometry.center())}),(y,A)=>u.unref(s)?(u.openBlock(),u.createElementBlock("TresMesh",{key:0,ref_key:"text3DRef",ref:D},[M.value?(u.openBlock(),u.createElementBlock("TresTextGeometry",{key:0,args:[M.value,C.value],center:u.unref(i)},null,8,tl)):u.createCommentVNode("",!0),u.renderSlot(y.$slots,"default")],512)):u.createCommentVNode("",!0)}});function rl(o,e){const t=u.ref(e),n=new l.AnimationMixer(t.value),r=u.shallowReactive({});o.forEach(s=>{const a=n.clipAction(s,t.value);r[s.name]=a});const{onLoop:i}=oe.useRenderLoop();return i(({delta:s})=>{n.update(s)}),{actions:r,mixer:n}}const il=u.defineComponent({__name:"Levioso",props:{speed:{default:1},rotationFactor:{default:1},floatFactor:{default:1},range:{default:()=>[-.1,.1]}},setup(o,{expose:e}){const t=o,n=u.shallowRef();e({value:n});{const c=Math.random()*1e4,{onLoop:h}=oe.useRenderLoop();let f=c;h(({delta:d})=>{if(!n.value)return;f+=d*t.speed;const p=f*.25,m=n.value;m.rotation.x=Math.cos(p)*.125*t.rotationFactor,m.rotation.y=Math.sin(p)*.125*t.rotationFactor,m.rotation.z=Math.sin(p)*.05*t.rotationFactor,m.position.y=l.MathUtils.mapLinear(Math.sin(p),-1,1,t.range[0],t.range[1])*t.floatFactor})}return(r,i)=>(u.openBlock(),u.createElementBlock("TresGroup",u.mergeProps(r.$attrs,{ref_key:"groupRef",ref:n}),[u.renderSlot(r.$slots,"default")],16))}});class Qt extends l.Mesh{constructor(e,t={}){super(e),this.isReflector=!0,this.type="Reflector",this.camera=new l.PerspectiveCamera;const n=this,r=t.color!==void 0?new l.Color(t.color):new l.Color(8355711),i=t.textureWidth||512,s=t.textureHeight||512,a=t.clipBias||0,c=t.shader||Qt.ReflectorShader,h=t.multisample!==void 0?t.multisample:4,f=new l.Plane,d=new l.Vector3,p=new l.Vector3,m=new l.Vector3,x=new l.Matrix4,b=new l.Vector3(0,0,-1),v=new l.Vector4,_=new l.Vector3,T=new l.Vector3,w=new l.Vector4,M=new l.Matrix4,D=this.camera,S=new l.WebGLRenderTarget(i,s,{samples:h,type:l.HalfFloatType}),C=new l.ShaderMaterial({name:c.name!==void 0?c.name:"unspecified",uniforms:l.UniformsUtils.clone(c.uniforms),fragmentShader:c.fragmentShader,vertexShader:c.vertexShader});C.uniforms.tDiffuse.value=S.texture,C.uniforms.color.value=r,C.uniforms.textureMatrix.value=M,this.material=C,this.onBeforeRender=function(y,A,g){if(p.setFromMatrixPosition(n.matrixWorld),m.setFromMatrixPosition(g.matrixWorld),x.extractRotation(n.matrixWorld),d.set(0,0,1),d.applyMatrix4(x),_.subVectors(p,m),_.dot(d)>0)return;_.reflect(d).negate(),_.add(p),x.extractRotation(g.matrixWorld),b.set(0,0,-1),b.applyMatrix4(x),b.add(m),T.subVectors(p,b),T.reflect(d).negate(),T.add(p),D.position.copy(_),D.up.set(0,1,0),D.up.applyMatrix4(x),D.up.reflect(d),D.lookAt(T),D.far=g.far,D.updateMatrixWorld(),D.projectionMatrix.copy(g.projectionMatrix),M.set(.5,0,0,.5,0,.5,0,.5,0,0,.5,.5,0,0,0,1),M.multiply(D.projectionMatrix),M.multiply(D.matrixWorldInverse),M.multiply(n.matrixWorld),f.setFromNormalAndCoplanarPoint(d,p),f.applyMatrix4(D.matrixWorldInverse),v.set(f.normal.x,f.normal.y,f.normal.z,f.constant);const I=D.projectionMatrix;w.x=(Math.sign(v.x)+I.elements[8])/I.elements[0],w.y=(Math.sign(v.y)+I.elements[9])/I.elements[5],w.z=-1,w.w=(1+I.elements[10])/I.elements[14],v.multiplyScalar(2/v.dot(w)),I.elements[2]=v.x,I.elements[6]=v.y,I.elements[10]=v.z+1-a,I.elements[14]=v.w,n.visible=!1;const k=y.getRenderTarget(),J=y.xr.enabled,G=y.shadowMap.autoUpdate;y.xr.enabled=!1,y.shadowMap.autoUpdate=!1,y.setRenderTarget(S),y.state.buffers.depth.setMask(!0),y.autoClear===!1&&y.clear(),y.render(A,D),y.xr.enabled=J,y.shadowMap.autoUpdate=G,y.setRenderTarget(k);const Z=g.viewport;Z!==void 0&&y.state.viewport(Z),n.visible=!0},this.getRenderTarget=function(){return S},this.dispose=function(){S.dispose(),n.material.dispose()}}}Qt.ReflectorShader={name:"ReflectorShader",uniforms:{color:{value:null},tDiffuse:{value:null},textureMatrix:{value:null}},vertexShader:`
 		uniform mat4 textureMatrix;
 		varying vec4 vUv;
 
@@ -139,7 +139,7 @@
 			#include <tonemapping_fragment>
 			#include <colorspace_fragment>
 
-		}`};const el=["args","material-uniforms-color-value"],tl=f.createElementVNode("TresPlaneGeometry",{args:[5,5]},null,-1),nl=f.defineComponent({__name:"Reflector",props:{color:{default:"#333"},textureWidth:{default:512},textureHeight:{default:512},clipBias:{default:0},multisample:{default:4},shader:{default:Zt.ReflectorShader}},setup(o,{expose:e}){const t=o,{extend:n}=ae.useTresContext(),s=f.shallowRef();n({Reflector:Zt});const{color:r,textureWidth:i,textureHeight:a,clipBias:l,multisample:u,shader:h}=f.toRefs(t);return e({reflectorRef:s}),(d,y)=>(f.openBlock(),f.createElementBlock("TresReflector",{ref_key:"reflectorRef",ref:s,args:[void 0,{textureWidth:f.unref(i),textureHeight:f.unref(a),clipBias:f.unref(l),multisample:f.unref(u),shader:f.unref(h)}],"material-uniforms-color-value":f.unref(r)},[f.renderSlot(d.$slots,"default",{},()=>[tl])],8,el))}});function br(o){return f.getCurrentScope()?(f.onScopeDispose(o),!0):!1}function Ye(o){return typeof o=="function"?o():f.unref(o)}const sl=typeof window<"u"&&typeof document<"u";typeof WorkerGlobalScope<"u"&&globalThis instanceof WorkerGlobalScope;const rl=Object.prototype.toString,il=o=>rl.call(o)==="[object Object]",bt=()=>{};function ss(o,e){function t(...n){return new Promise((s,r)=>{Promise.resolve(o(()=>e.apply(this,n),{fn:e,thisArg:this,args:n})).then(s).catch(r)})}return t}const ol=o=>o();function al(o,e={}){let t,n,s=bt;const r=a=>{clearTimeout(a),s(),s=bt};return a=>{const l=Ye(o),u=Ye(e.maxWait);return t&&r(t),l<=0||u!==void 0&&u<=0?(n&&(r(n),n=null),Promise.resolve(a())):new Promise((h,d)=>{s=e.rejectOnCancel?d:h,u&&!n&&(n=setTimeout(()=>{t&&r(t),n=null,h(a())},u)),t=setTimeout(()=>{n&&r(n),n=null,h(a())},l)})}}function Mr(o,e=!0,t=!0,n=!1){let s=0,r,i=!0,a=bt,l;const u=()=>{r&&(clearTimeout(r),r=void 0,a(),a=bt)};return d=>{const y=Ye(o),g=Date.now()-s,x=()=>l=d();return u(),y<=0?(s=Date.now(),x()):(g>y&&(t||!i)?(s=Date.now(),x()):e&&(l=new Promise((w,v)=>{a=n?v:w,r=setTimeout(()=>{s=Date.now(),i=!0,w(x()),u()},Math.max(0,y-g))})),!t&&!r&&(r=setTimeout(()=>i=!0,y)),i=!1,l)}}function ll(o){return o||f.getCurrentInstance()}function cl(o,e=200,t={}){return ss(al(e,t),o)}function ul(o,e=200,t=!1,n=!0,s=!1){return ss(Mr(e,t,n,s),o)}function hl(o,e,t={}){const{eventFilter:n=ol,...s}=t;return f.watch(o,ss(n,e),s)}function Sr(o,e=!0,t){ll()?f.onMounted(o,t):e?o():f.nextTick(o)}function fl(o,e,t={}){const{throttle:n=0,trailing:s=!0,leading:r=!0,...i}=t;return hl(o,e,{...i,eventFilter:Mr(n,s,r)})}function dl(o){var e;const t=Ye(o);return(e=t==null?void 0:t.$el)!=null?e:t}const Mt=sl?window:void 0;function Le(...o){let e,t,n,s;if(typeof o[0]=="string"||Array.isArray(o[0])?([t,n,s]=o,e=Mt):[e,t,n,s]=o,!e)return bt;Array.isArray(t)||(t=[t]),Array.isArray(n)||(n=[n]);const r=[],i=()=>{r.forEach(h=>h()),r.length=0},a=(h,d,y,g)=>(h.addEventListener(d,y,g),()=>h.removeEventListener(d,y,g)),l=f.watch(()=>[dl(e),Ye(s)],([h,d])=>{if(i(),!h)return;const y=il(d)?{...d}:d;r.push(...t.flatMap(g=>n.map(x=>a(h,g,x,y))))},{immediate:!0,flush:"post"}),u=()=>{l(),i()};return br(u),u}function pl(o){return typeof o=="function"?o:typeof o=="string"?e=>e.key===o:Array.isArray(o)?e=>o.includes(e.key):()=>!0}function St(...o){let e,t,n={};o.length===3?(e=o[0],t=o[1],n=o[2]):o.length===2?typeof o[1]=="object"?(e=!0,t=o[0],n=o[1]):(e=o[0],t=o[1]):(e=!0,t=o[0]);const{target:s=Mt,eventName:r="keydown",passive:i=!1,dedupe:a=!1}=n,l=pl(e);return Le(s,r,h=>{h.repeat&&Ye(a)||l(h)&&t(h)},i)}function ml(){const o=f.ref(!1);return f.getCurrentInstance()&&f.onMounted(()=>{o.value=!0}),o}function gl(o){const e=ml();return f.computed(()=>(e.value,!!o()))}function yl(o,e={}){const{window:t=Mt}=e,n=gl(()=>t&&"matchMedia"in t&&typeof t.matchMedia=="function");let s;const r=f.ref(!1),i=u=>{r.value=u.matches},a=()=>{s&&("removeEventListener"in s?s.removeEventListener("change",i):s.removeListener(i))},l=f.watchEffect(()=>{n.value&&(a(),s=t.matchMedia(Ye(o)),"addEventListener"in s?s.addEventListener("change",i):s.addListener(i),r.value=s.matches)});return br(()=>{l(),a(),s=void 0}),r}const Ar=1;function _l(o,e={}){const{throttle:t=0,idle:n=200,onStop:s=bt,onScroll:r=bt,offset:i={left:0,right:0,top:0,bottom:0},eventListenerOptions:a={capture:!1,passive:!0},behavior:l="auto",window:u=Mt}=e,h=f.ref(0),d=f.ref(0),y=f.computed({get(){return h.value},set(b){x(b,void 0)}}),g=f.computed({get(){return d.value},set(b){x(void 0,b)}});function x(b,C){var m,M,p;if(!u)return;const I=Ye(o);I&&((p=I instanceof Document?u.document.body:I)==null||p.scrollTo({top:(m=Ye(C))!=null?m:g.value,left:(M=Ye(b))!=null?M:y.value,behavior:Ye(l)}))}const w=f.ref(!1),v=f.reactive({left:!0,right:!1,top:!0,bottom:!1}),P=f.reactive({left:!1,right:!1,top:!1,bottom:!1}),D=b=>{w.value&&(w.value=!1,P.left=!1,P.right=!1,P.top=!1,P.bottom=!1,s(b))},S=cl(D,t+n),_=b=>{var C;if(!u)return;const m=b.document?b.document.documentElement:(C=b.documentElement)!=null?C:b,{display:M,flexDirection:p}=getComputedStyle(m),I=m.scrollLeft;P.left=I<h.value,P.right=I>h.value;const F=Math.abs(I)<=0+(i.left||0),J=Math.abs(I)+m.clientWidth>=m.scrollWidth-(i.right||0)-Ar;M==="flex"&&p==="row-reverse"?(v.left=J,v.right=F):(v.left=F,v.right=J),h.value=I;let G=m.scrollTop;b===u.document&&!G&&(G=u.document.body.scrollTop),P.top=G<d.value,P.bottom=G>d.value;const Q=Math.abs(G)<=0+(i.top||0),K=Math.abs(G)+m.clientHeight>=m.scrollHeight-(i.bottom||0)-Ar;M==="flex"&&p==="column-reverse"?(v.top=K,v.bottom=Q):(v.top=Q,v.bottom=K),d.value=G},L=b=>{var C;if(!u)return;const m=(C=b.target.documentElement)!=null?C:b.target;_(m),w.value=!0,S(b),r(b)};return Le(o,"scroll",t?ul(L,t,!0,!1):L,a),Sr(()=>{const b=Ye(o);b&&_(b)}),Le(o,"scrollend",D,a),{x:y,y:g,isScrolling:w,arrivedState:v,directions:P,measure(){const b=Ye(o);u&&b&&_(b)}}}const vl={page:o=>[o.pageX,o.pageY],client:o=>[o.clientX,o.clientY],screen:o=>[o.screenX,o.screenY],movement:o=>o instanceof Touch?null:[o.movementX,o.movementY]};function xl(o={}){const{type:e="page",touch:t=!0,resetOnTouchEnds:n=!1,initialValue:s={x:0,y:0},window:r=Mt,target:i=r,scroll:a=!0,eventFilter:l}=o;let u=null;const h=f.ref(s.x),d=f.ref(s.y),y=f.ref(null),g=typeof e=="function"?e:vl[e],x=L=>{const b=g(L);u=L,b&&([h.value,d.value]=b,y.value="mouse")},w=L=>{if(L.touches.length>0){const b=g(L.touches[0]);b&&([h.value,d.value]=b,y.value="touch")}},v=()=>{if(!u||!r)return;const L=g(u);u instanceof MouseEvent&&L&&(h.value=L[0]+r.scrollX,d.value=L[1]+r.scrollY)},P=()=>{h.value=s.x,d.value=s.y},D=l?L=>l(()=>x(L),{}):L=>x(L),S=l?L=>l(()=>w(L),{}):L=>w(L),_=l?()=>l(()=>v(),{}):()=>v();if(i){const L={passive:!0};Le(i,["mousemove","dragover"],D,L),t&&e!=="movement"&&(Le(i,["touchstart","touchmove"],S,L),n&&Le(i,"touchend",P,L)),a&&e==="page"&&Le(r,"scroll",_,{passive:!0})}return{x:h,y:d,sourceType:y}}function wl(o={}){const{window:e=Mt,behavior:t="auto"}=o;if(!e)return{x:f.ref(0),y:f.ref(0)};const n=f.ref(e.scrollX),s=f.ref(e.scrollY),r=f.computed({get(){return n.value},set(a){scrollTo({left:a,behavior:t})}}),i=f.computed({get(){return s.value},set(a){scrollTo({top:a,behavior:t})}});return Le(e,"scroll",()=>{n.value=e.scrollX,s.value=e.scrollY},{capture:!1,passive:!0}),{x:r,y:i}}function Pr(o={}){const{window:e=Mt,initialWidth:t=Number.POSITIVE_INFINITY,initialHeight:n=Number.POSITIVE_INFINITY,listenOrientation:s=!0,includeScrollbar:r=!0}=o,i=f.ref(t),a=f.ref(n),l=()=>{e&&(r?(i.value=e.innerWidth,a.value=e.innerHeight):(i.value=e.document.documentElement.clientWidth,a.value=e.document.documentElement.clientHeight))};if(l(),Sr(l),Le("resize",l,{passive:!0}),s){const u=yl("(orientation: portrait)");f.watch(u,()=>l())}return{width:i,height:a}}const bl=f.defineComponent({__name:"MouseParallax",props:{disabled:{type:Boolean,default:!1},factor:{default:2.5},ease:{default:.1}},setup(o){const e=o,{camera:t}=ae.useTresContext(),{disabled:n,factor:s,ease:r}=f.toRefs(e),{x:i,y:a}=xl(),{width:l,height:u}=Pr(),h=f.ref(),d=f.computed(()=>(i.value/l.value-.5)*s.value),y=f.computed(()=>-(a.value/u.value-.5)*s.value),{onLoop:g}=ae.useRenderLoop();return g(({delta:x})=>{n.value||!h.value||(h.value.position.x+=(d.value-h.value.position.x)*r.value*x,h.value.position.y+=(y.value-h.value.position.y)*r.value*x)}),f.watch(()=>h.value,x=>x==null?void 0:x.add(t.value)),(x,w)=>(f.openBlock(),f.createElementBlock("TresGroup",{ref_key:"cameraGroupRef",ref:h},null,512))}}),Ml=f.defineComponent({name:"GlobalAudio",props:["src","loop","volume","playbackRate","playTrigger","stopTrigger"],async setup(o,{expose:e,emit:t}){var d;const{camera:n,renderer:s}=ae.useTresContext(),r=new c.AudioListener;(d=n.value)==null||d.add(r);const i=new c.Audio(r),a=new c.AudioLoader;e({sound:i}),f.onUnmounted(()=>{i&&i.disconnect()}),f.watch(()=>[o.playbackRate],()=>i.setPlaybackRate(o.playbackRate??1),{immediate:!0}),f.watch(()=>[o.volume],()=>i.setVolume(o.volume??.5),{immediate:!0}),f.watch(()=>[o.loop],()=>i.setLoop(o.loop??!1),{immediate:!0}),f.watch(()=>[o.src],async()=>{const y=await a.loadAsync(o.src);i.setBuffer(y)},{immediate:!0});const l=document.getElementById(o.playTrigger??""),u=l||s.value.domElement;Le(u,"click",()=>{i.isPlaying?i.pause():i.play(),t("isPlaying",i.isPlaying)});const h=document.getElementById(o.stopTrigger??"");return h&&Le(h,"click",()=>{i.stop(),t("isPlaying",i.isPlaying)}),null}});class Kt extends c.Mesh{constructor(){super(Kt.Geometry,new c.MeshBasicMaterial({opacity:0,transparent:!0})),this.isLensflare=!0,this.type="Lensflare",this.frustumCulled=!1,this.renderOrder=1/0;const e=new c.Vector3,t=new c.Vector3,n=new c.FramebufferTexture(16,16),s=new c.FramebufferTexture(16,16);let r=c.UnsignedByteType;const i=Kt.Geometry,a=new c.RawShaderMaterial({uniforms:{scale:{value:null},screenPosition:{value:null}},vertexShader:`
+		}`};const sl=["args","material-uniforms-color-value"],ol=u.createElementVNode("TresPlaneGeometry",{args:[5,5]},null,-1),al=u.defineComponent({__name:"Reflector",props:{color:{default:"#333"},textureWidth:{default:512},textureHeight:{default:512},clipBias:{default:0},multisample:{default:4},shader:{default:Qt.ReflectorShader}},setup(o,{expose:e}){const t=o,{extend:n}=oe.useTresContext(),r=u.shallowRef();n({Reflector:Qt});const{color:i,textureWidth:s,textureHeight:a,clipBias:c,multisample:h,shader:f}=u.toRefs(t);return e({reflectorRef:r}),(d,p)=>(u.openBlock(),u.createElementBlock("TresReflector",{ref_key:"reflectorRef",ref:r,args:[void 0,{textureWidth:u.unref(s),textureHeight:u.unref(a),clipBias:u.unref(c),multisample:u.unref(h),shader:u.unref(f)}],"material-uniforms-color-value":u.unref(i)},[u.renderSlot(d.$slots,"default",{},()=>[ol])],8,sl))}});function Ai(o){return u.getCurrentScope()?(u.onScopeDispose(o),!0):!1}function We(o){return typeof o=="function"?o():u.unref(o)}const ll=typeof window<"u"&&typeof document<"u";typeof WorkerGlobalScope<"u"&&globalThis instanceof WorkerGlobalScope;const cl=Object.prototype.toString,ul=o=>cl.call(o)==="[object Object]",Mt=()=>{};function sr(o,e){function t(...n){return new Promise((r,i)=>{Promise.resolve(o(()=>e.apply(this,n),{fn:e,thisArg:this,args:n})).then(r).catch(i)})}return t}const hl=o=>o();function fl(o,e={}){let t,n,r=Mt;const i=a=>{clearTimeout(a),r(),r=Mt};return a=>{const c=We(o),h=We(e.maxWait);return t&&i(t),c<=0||h!==void 0&&h<=0?(n&&(i(n),n=null),Promise.resolve(a())):new Promise((f,d)=>{r=e.rejectOnCancel?d:f,h&&!n&&(n=setTimeout(()=>{t&&i(t),n=null,f(a())},h)),t=setTimeout(()=>{n&&i(n),n=null,f(a())},c)})}}function Ci(...o){let e=0,t,n=!0,r=Mt,i,s,a,c,h;!u.isRef(o[0])&&typeof o[0]=="object"?{delay:s,trailing:a=!0,leading:c=!0,rejectOnCancel:h=!1}=o[0]:[s,a=!0,c=!0,h=!1]=o;const f=()=>{t&&(clearTimeout(t),t=void 0,r(),r=Mt)};return p=>{const m=We(s),x=Date.now()-e,b=()=>i=p();return f(),m<=0?(e=Date.now(),b()):(x>m&&(c||!n)?(e=Date.now(),b()):a&&(i=new Promise((v,_)=>{r=h?_:v,t=setTimeout(()=>{e=Date.now(),n=!0,v(b()),f()},Math.max(0,m-x))})),!c&&!t&&(t=setTimeout(()=>n=!0,m)),n=!1,i)}}function dl(o){return o||u.getCurrentInstance()}function pl(o,e=200,t={}){return sr(fl(e,t),o)}function ml(o,e=200,t=!1,n=!0,r=!1){return sr(Ci(e,t,n,r),o)}function gl(o,e,t={}){const{eventFilter:n=hl,...r}=t;return u.watch(o,sr(n,e),r)}function Pi(o,e=!0,t){dl()?u.onMounted(o,t):e?o():u.nextTick(o)}function yl(o,e,t={}){const{throttle:n=0,trailing:r=!0,leading:i=!0,...s}=t;return gl(o,e,{...s,eventFilter:Ci(n,r,i)})}function Ti(o){var e;const t=We(o);return(e=t==null?void 0:t.$el)!=null?e:t}const St=ll?window:void 0;function Te(...o){let e,t,n,r;if(typeof o[0]=="string"||Array.isArray(o[0])?([t,n,r]=o,e=St):[e,t,n,r]=o,!e)return Mt;Array.isArray(t)||(t=[t]),Array.isArray(n)||(n=[n]);const i=[],s=()=>{i.forEach(f=>f()),i.length=0},a=(f,d,p,m)=>(f.addEventListener(d,p,m),()=>f.removeEventListener(d,p,m)),c=u.watch(()=>[Ti(e),We(r)],([f,d])=>{if(s(),!f)return;const p=ul(d)?{...d}:d;i.push(...t.flatMap(m=>n.map(x=>a(f,m,x,p))))},{immediate:!0,flush:"post"}),h=()=>{c(),s()};return Ai(h),h}function vl(o){return typeof o=="function"?o:typeof o=="string"?e=>e.key===o:Array.isArray(o)?e=>o.includes(e.key):()=>!0}function At(...o){let e,t,n={};o.length===3?(e=o[0],t=o[1],n=o[2]):o.length===2?typeof o[1]=="object"?(e=!0,t=o[0],n=o[1]):(e=o[0],t=o[1]):(e=!0,t=o[0]);const{target:r=St,eventName:i="keydown",passive:s=!1,dedupe:a=!1}=n,c=vl(e);return Te(r,i,f=>{f.repeat&&We(a)||c(f)&&t(f)},s)}function _l(){const o=u.ref(!1),e=u.getCurrentInstance();return e&&u.onMounted(()=>{o.value=!0},e),o}function xl(o){const e=_l();return u.computed(()=>(e.value,!!o()))}function wl(o,e={}){const{window:t=St}=e,n=xl(()=>t&&"matchMedia"in t&&typeof t.matchMedia=="function");let r;const i=u.ref(!1),s=h=>{i.value=h.matches},a=()=>{r&&("removeEventListener"in r?r.removeEventListener("change",s):r.removeListener(s))},c=u.watchEffect(()=>{n.value&&(a(),r=t.matchMedia(We(o)),"addEventListener"in r?r.addEventListener("change",s):r.addListener(s),i.value=r.matches)});return Ai(()=>{c(),a(),r=void 0}),i}const Li=1;function bl(o,e={}){const{throttle:t=0,idle:n=200,onStop:r=Mt,onScroll:i=Mt,offset:s={left:0,right:0,top:0,bottom:0},eventListenerOptions:a={capture:!1,passive:!0},behavior:c="auto",window:h=St,onError:f=C=>{console.error(C)}}=e,d=u.ref(0),p=u.ref(0),m=u.computed({get(){return d.value},set(C){b(C,void 0)}}),x=u.computed({get(){return p.value},set(C){b(void 0,C)}});function b(C,y){var A,g,I;if(!h)return;const k=We(o);k&&((I=k instanceof Document?h.document.body:k)==null||I.scrollTo({top:(A=We(y))!=null?A:x.value,left:(g=We(C))!=null?g:m.value,behavior:We(c)}))}const v=u.ref(!1),_=u.reactive({left:!0,right:!1,top:!0,bottom:!1}),T=u.reactive({left:!1,right:!1,top:!1,bottom:!1}),w=C=>{v.value&&(v.value=!1,T.left=!1,T.right=!1,T.top=!1,T.bottom=!1,r(C))},M=pl(w,t+n),D=C=>{var y;if(!h)return;const A=((y=C==null?void 0:C.document)==null?void 0:y.documentElement)||(C==null?void 0:C.documentElement)||Ti(C),{display:g,flexDirection:I}=getComputedStyle(A),k=A.scrollLeft;T.left=k<d.value,T.right=k>d.value;const J=Math.abs(k)<=(s.left||0),G=Math.abs(k)+A.clientWidth>=A.scrollWidth-(s.right||0)-Li;g==="flex"&&I==="row-reverse"?(_.left=G,_.right=J):(_.left=J,_.right=G),d.value=k;let Z=A.scrollTop;C===h.document&&!Z&&(Z=h.document.body.scrollTop),T.top=Z<p.value,T.bottom=Z>p.value;const X=Math.abs(Z)<=(s.top||0),K=Math.abs(Z)+A.clientHeight>=A.scrollHeight-(s.bottom||0)-Li;g==="flex"&&I==="column-reverse"?(_.top=K,_.bottom=X):(_.top=X,_.bottom=K),p.value=Z},S=C=>{var y;if(!h)return;const A=(y=C.target.documentElement)!=null?y:C.target;D(A),v.value=!0,M(C),i(C)};return Te(o,"scroll",t?ml(S,t,!0,!1):S,a),Pi(()=>{try{const C=We(o);if(!C)return;D(C)}catch(C){f(C)}}),Te(o,"scrollend",w,a),{x:m,y:x,isScrolling:v,arrivedState:_,directions:T,measure(){const C=We(o);h&&C&&D(C)}}}const Ml={page:o=>[o.pageX,o.pageY],client:o=>[o.clientX,o.clientY],screen:o=>[o.screenX,o.screenY],movement:o=>o instanceof Touch?null:[o.movementX,o.movementY]};function Sl(o={}){const{type:e="page",touch:t=!0,resetOnTouchEnds:n=!1,initialValue:r={x:0,y:0},window:i=St,target:s=i,scroll:a=!0,eventFilter:c}=o;let h=null;const f=u.ref(r.x),d=u.ref(r.y),p=u.ref(null),m=typeof e=="function"?e:Ml[e],x=D=>{const S=m(D);h=D,S&&([f.value,d.value]=S,p.value="mouse")},b=D=>{if(D.touches.length>0){const S=m(D.touches[0]);S&&([f.value,d.value]=S,p.value="touch")}},v=()=>{if(!h||!i)return;const D=m(h);h instanceof MouseEvent&&D&&(f.value=D[0]+i.scrollX,d.value=D[1]+i.scrollY)},_=()=>{f.value=r.x,d.value=r.y},T=c?D=>c(()=>x(D),{}):D=>x(D),w=c?D=>c(()=>b(D),{}):D=>b(D),M=c?()=>c(()=>v(),{}):()=>v();if(s){const D={passive:!0};Te(s,["mousemove","dragover"],T,D),t&&e!=="movement"&&(Te(s,["touchstart","touchmove"],w,D),n&&Te(s,"touchend",_,D)),a&&e==="page"&&Te(i,"scroll",M,{passive:!0})}return{x:f,y:d,sourceType:p}}function Al(o={}){const{window:e=St,behavior:t="auto"}=o;if(!e)return{x:u.ref(0),y:u.ref(0)};const n=u.ref(e.scrollX),r=u.ref(e.scrollY),i=u.computed({get(){return n.value},set(a){scrollTo({left:a,behavior:t})}}),s=u.computed({get(){return r.value},set(a){scrollTo({top:a,behavior:t})}});return Te(e,"scroll",()=>{n.value=e.scrollX,r.value=e.scrollY},{capture:!1,passive:!0}),{x:i,y:s}}function Di(o={}){const{window:e=St,initialWidth:t=Number.POSITIVE_INFINITY,initialHeight:n=Number.POSITIVE_INFINITY,listenOrientation:r=!0,includeScrollbar:i=!0}=o,s=u.ref(t),a=u.ref(n),c=()=>{e&&(i?(s.value=e.innerWidth,a.value=e.innerHeight):(s.value=e.document.documentElement.clientWidth,a.value=e.document.documentElement.clientHeight))};if(c(),Pi(c),Te("resize",c,{passive:!0}),r){const h=wl("(orientation: portrait)");u.watch(h,()=>c())}return{width:s,height:a}}const Cl=u.defineComponent({__name:"MouseParallax",props:{disabled:{type:Boolean,default:!1},factor:{default:2.5},ease:{default:.1}},setup(o){const e=o,{camera:t}=oe.useTresContext(),{disabled:n,factor:r,ease:i}=u.toRefs(e),{x:s,y:a}=Sl(),{width:c,height:h}=Di(),f=u.ref(),d=u.computed(()=>(s.value/c.value-.5)*r.value),p=u.computed(()=>-(a.value/h.value-.5)*r.value),{onLoop:m}=oe.useRenderLoop();return m(({delta:x})=>{n.value||!f.value||(f.value.position.x+=(d.value-f.value.position.x)*i.value*x,f.value.position.y+=(p.value-f.value.position.y)*i.value*x)}),u.watch(()=>f.value,x=>x==null?void 0:x.add(t.value)),(x,b)=>(u.openBlock(),u.createElementBlock("TresGroup",{ref_key:"cameraGroupRef",ref:f},null,512))}}),Pl=u.defineComponent({name:"GlobalAudio",props:["src","loop","volume","playbackRate","playTrigger","stopTrigger"],async setup(o,{expose:e,emit:t}){var d;const{camera:n,renderer:r}=oe.useTresContext(),i=new l.AudioListener;(d=n.value)==null||d.add(i);const s=new l.Audio(i),a=new l.AudioLoader;e({sound:s}),u.onUnmounted(()=>{s&&s.disconnect()}),u.watch(()=>[o.playbackRate],()=>s.setPlaybackRate(o.playbackRate??1),{immediate:!0}),u.watch(()=>[o.volume],()=>s.setVolume(o.volume??.5),{immediate:!0}),u.watch(()=>[o.loop],()=>s.setLoop(o.loop??!1),{immediate:!0}),u.watch(()=>[o.src],async()=>{const p=await a.loadAsync(o.src);s.setBuffer(p)},{immediate:!0});const c=document.getElementById(o.playTrigger??""),h=c||r.value.domElement;Te(h,"click",()=>{s.isPlaying?s.pause():s.play(),t("isPlaying",s.isPlaying)});const f=document.getElementById(o.stopTrigger??"");return f&&Te(f,"click",()=>{s.stop(),t("isPlaying",s.isPlaying)}),null}});class Jt extends l.Mesh{constructor(){super(Jt.Geometry,new l.MeshBasicMaterial({opacity:0,transparent:!0})),this.isLensflare=!0,this.type="Lensflare",this.frustumCulled=!1,this.renderOrder=1/0;const e=new l.Vector3,t=new l.Vector3,n=new l.FramebufferTexture(16,16),r=new l.FramebufferTexture(16,16);let i=l.UnsignedByteType;const s=Jt.Geometry,a=new l.RawShaderMaterial({uniforms:{scale:{value:null},screenPosition:{value:null}},vertexShader:`
 
 				precision highp float;
 
@@ -160,7 +160,7 @@
 
 					gl_FragColor = vec4( 1.0, 0.0, 1.0, 1.0 );
 
-				}`,depthTest:!0,depthWrite:!1,transparent:!1}),l=new c.RawShaderMaterial({uniforms:{map:{value:n},scale:{value:null},screenPosition:{value:null}},vertexShader:`
+				}`,depthTest:!0,depthWrite:!1,transparent:!1}),c=new l.RawShaderMaterial({uniforms:{map:{value:n},scale:{value:null},screenPosition:{value:null}},vertexShader:`
 
 				precision highp float;
 
@@ -190,7 +190,7 @@
 
 					gl_FragColor = texture2D( map, vUV );
 
-				}`,depthTest:!1,depthWrite:!1,transparent:!1}),u=new c.Mesh(i,a),h=[],d=Cr.Shader,y=new c.RawShaderMaterial({name:d.name,uniforms:{map:{value:null},occlusionMap:{value:s},color:{value:new c.Color(16777215)},scale:{value:new c.Vector2},screenPosition:{value:new c.Vector3}},vertexShader:d.vertexShader,fragmentShader:d.fragmentShader,blending:c.AdditiveBlending,transparent:!0,depthWrite:!1}),g=new c.Mesh(i,y);this.addElement=function(D){h.push(D)};const x=new c.Vector2,w=new c.Vector2,v=new c.Box2,P=new c.Vector4;this.onBeforeRender=function(D,S,_){D.getCurrentViewport(P);const L=D.getRenderTarget(),b=L!==null?L.texture.type:c.UnsignedByteType;r!==b&&(n.dispose(),s.dispose(),n.type=s.type=b,r=b);const C=P.w/P.z,m=P.z/2,M=P.w/2;let p=16/P.w;if(x.set(p*C,p),v.min.set(P.x,P.y),v.max.set(P.x+(P.z-16),P.y+(P.w-16)),t.setFromMatrixPosition(this.matrixWorld),t.applyMatrix4(_.matrixWorldInverse),!(t.z>0)&&(e.copy(t).applyMatrix4(_.projectionMatrix),w.x=P.x+e.x*m+m-8,w.y=P.y+e.y*M+M-8,v.containsPoint(w))){D.copyFramebufferToTexture(w,n);let I=a.uniforms;I.scale.value=x,I.screenPosition.value=e,D.renderBufferDirect(_,null,i,a,u,null),D.copyFramebufferToTexture(w,s),I=l.uniforms,I.scale.value=x,I.screenPosition.value=e,D.renderBufferDirect(_,null,i,l,u,null);const F=-e.x*2,J=-e.y*2;for(let G=0,Q=h.length;G<Q;G++){const K=h[G],Z=y.uniforms;Z.color.value.copy(K.color),Z.map.value=K.texture,Z.screenPosition.value.x=e.x+F*K.distance,Z.screenPosition.value.y=e.y+J*K.distance,p=K.size/P.w;const X=P.w/P.z;Z.scale.value.set(p*X,p),y.uniformsNeedUpdate=!0,D.renderBufferDirect(_,null,i,y,g,null)}}},this.dispose=function(){a.dispose(),l.dispose(),y.dispose(),n.dispose(),s.dispose();for(let D=0,S=h.length;D<S;D++)h[D].texture.dispose()}}}class Cr{constructor(e,t=1,n=0,s=new c.Color(16777215)){this.texture=e,this.size=t,this.distance=n,this.color=s}}Cr.Shader={name:"LensflareElementShader",uniforms:{map:{value:null},occlusionMap:{value:null},color:{value:null},scale:{value:null},screenPosition:{value:null}},vertexShader:`
+				}`,depthTest:!1,depthWrite:!1,transparent:!1}),h=new l.Mesh(s,a),f=[],d=Ii.Shader,p=new l.RawShaderMaterial({name:d.name,uniforms:{map:{value:null},occlusionMap:{value:r},color:{value:new l.Color(16777215)},scale:{value:new l.Vector2},screenPosition:{value:new l.Vector3}},vertexShader:d.vertexShader,fragmentShader:d.fragmentShader,blending:l.AdditiveBlending,transparent:!0,depthWrite:!1}),m=new l.Mesh(s,p);this.addElement=function(T){f.push(T)};const x=new l.Vector2,b=new l.Vector2,v=new l.Box2,_=new l.Vector4;this.onBeforeRender=function(T,w,M){T.getCurrentViewport(_);const D=T.getRenderTarget(),S=D!==null?D.texture.type:l.UnsignedByteType;i!==S&&(n.dispose(),r.dispose(),n.type=r.type=S,i=S);const C=_.w/_.z,y=_.z/2,A=_.w/2;let g=16/_.w;if(x.set(g*C,g),v.min.set(_.x,_.y),v.max.set(_.x+(_.z-16),_.y+(_.w-16)),t.setFromMatrixPosition(this.matrixWorld),t.applyMatrix4(M.matrixWorldInverse),!(t.z>0)&&(e.copy(t).applyMatrix4(M.projectionMatrix),b.x=_.x+e.x*y+y-8,b.y=_.y+e.y*A+A-8,v.containsPoint(b))){T.copyFramebufferToTexture(b,n);let I=a.uniforms;I.scale.value=x,I.screenPosition.value=e,T.renderBufferDirect(M,null,s,a,h,null),T.copyFramebufferToTexture(b,r),I=c.uniforms,I.scale.value=x,I.screenPosition.value=e,T.renderBufferDirect(M,null,s,c,h,null);const k=-e.x*2,J=-e.y*2;for(let G=0,Z=f.length;G<Z;G++){const X=f[G],K=p.uniforms;K.color.value.copy(X.color),K.map.value=X.texture,K.screenPosition.value.x=e.x+k*X.distance,K.screenPosition.value.y=e.y+J*X.distance,g=X.size/_.w;const Y=_.w/_.z;K.scale.value.set(g*Y,g),p.uniformsNeedUpdate=!0,T.renderBufferDirect(M,null,s,p,m,null)}}},this.dispose=function(){a.dispose(),c.dispose(),p.dispose(),n.dispose(),r.dispose();for(let T=0,w=f.length;T<w;T++)f[T].texture.dispose()}}}class Ii{constructor(e,t=1,n=0,r=new l.Color(16777215)){this.texture=e,this.size=t,this.distance=n,this.color=r}}Ii.Shader={name:"LensflareElementShader",uniforms:{map:{value:null},occlusionMap:{value:null},color:{value:null},scale:{value:null},screenPosition:{value:null}},vertexShader:`
 
 		precision highp float;
 
@@ -244,12 +244,12 @@
 			gl_FragColor = texture;
 			gl_FragColor.rgb *= color;
 
-		}`},Kt.Geometry=function(){const o=new c.BufferGeometry,e=new Float32Array([-1,-1,0,0,0,1,-1,0,1,0,1,1,0,1,1,-1,1,0,0,1]),t=new c.InterleavedBuffer(e,5);return o.setIndex([0,1,2,0,2,3]),o.setAttribute("position",new c.InterleavedBufferAttribute(t,3,0,!1)),o.setAttribute("uv",new c.InterleavedBufferAttribute(t,2,3,!1)),o}();function Sl(o){return o}function Al(o){return o*o*o}function Pl(o){return o<.5?4*o*o*o:1-(-2*o+2)**3/2}function Cl(o){return o*o*o*o}function Tl(o){return o<1/2.75?7.5625*o*o:o<2/2.75?7.5625*(o-=1.5/2.75)*o+.75:o<2.5/2.75?7.5625*(o-=2.25/2.75)*o+.9375:7.5625*(o-=2.625/2.75)*o+.984375}const Tr=c.MathUtils.clamp;class Lr{constructor(e=0,t){le(this,"_getNext");le(this,"_getGenerator");this._getGenerator=t??this.getMulberry32,this._getNext=this._getGenerator(e)}seed(e){this._getNext=this._getGenerator(e)}rand(){return this._getNext()}float(e,t){return e+this._getNext()*(t-e)}floatSpread(e){return this.float(-.5*e,.5*e)}int(e,t){return e+Math.floor(this._getNext()*(t-e+1))}choice(e){return e.length?e[Math.floor(this._getNext()*e.length)]:null}defaultChoice(e,t){return e.length?e[Math.floor(this._getNext()*e.length)]:t}sample(e,t,n){const s=e.length;t=Tr(t,0,s-1),n=Tr(n??s-1,0,s-1);const r=this.int(t,n),i=this.shuffle(e.map((l,u)=>u)),a=Math.min(e.length,r);return i.slice(0,a).sort().map(l=>e[l])}shuffle(e){return e.map(t=>({value:t,sort:this._getNext()})).sort((t,n)=>t.sort-n.sort).map(({value:t})=>t)}getMulberry32(e=0){return 0<e&&e<1&&(e=Math.floor(e*2**16)),()=>{e+=1831565813;let t=e;return t=Math.imul(t^t>>>15,t|1),t^=t+Math.imul(t^t>>>7,t|61),((t^t>>>14)>>>0)/4294967296}}}const rt="https://raw.githubusercontent.com/Tresjs/assets/93976c7d63ac83d4a254a41a10b2362bc17e90c9/textures/lensflare/",rs=`${rt}circle.png`,gn=`${rt}circleBlur.png`,Ll=`${rt}circleRainbow.png`,Il=`${rt}line.png`,Ir=`${rt}poly6.png`,Dr=`${rt}polyStroke6.png`,Dl=`${rt}rays.png`,yn=`${rt}ring.png`,Ol=`${rt}starThin6.png`,Fl={texture:[Il,yn],color:["white"],distance:[0,0],size:[750,1024],length:[0,2]},kl={texture:[gn],color:["white"],distance:[0,0],size:[180,512],length:[1,1]},Bl={texture:[Dl],color:["white"],distance:[0,0],size:[180,512],length:[1,1]},Ul={texture:[rs,Ll,yn,Ol],color:["white"],distance:[0,0],size:[180,512],length:[2,3]},[Or,Fr]=[3679071,132442],is=[Fl,kl,Bl,Ul,{texture:[gn,rs,yn,Ir,Dr],color:["dimgray","gray","darkgray",Or,Fr],distance:[.5,2.5],size:[20,180],length:[5,21]},{texture:[gn,rs,yn,Ir,Dr],color:["dimgray","gray","darkgray",Or,Fr],distance:[-.6,-.1],size:[180,360],length:[0,5]}],_n={color:"white",distance:0,size:512,texture:gn},kr=(o,e,t=void 0,n=void 0,s=_n)=>{if(o!==void 0&&o.length>0&&(typeof t=="number"||typeof n<"u")){const a=Ur(t??0,n??is),l=a.length,u=o.length;return l>=u?a.map((h,d)=>Object.assign(h,e,d<u?o[d]:{})):o.map((h,d)=>Object.assign({},s,d<l?a[d]:{},e,h))}if(o!==void 0&&o.length>0){const a=Object.assign({},s,e);return o.map(l=>Object.assign({},a,l))}const r=n===void 0||n.length===0?is:n;return Ur(t??0,r).map(a=>Object.assign({},a,e))},Nl=[Sl,Al,Pl,Cl,Tl],Br=c.MathUtils.lerp,Ur=(o=0,e=is)=>{const n=new Lr(o).choice(Nl);return e.map((s,r)=>{const i=new Lr(o*(r*7907+1)+(typeof s.seed=="number"?s.seed:0)),a=i.int(s.length[0],s.length[1]);return new Array(a).fill(0).map(()=>{const l=n(i.rand());return{texture:i.defaultChoice(s.texture,_n.texture),size:Br(s.size[0],s.size[1],n(1-l)),distance:Br(s.distance[0],s.distance[1],l),color:i.defaultChoice(s.color,_n.color)}})}).flat()};function zl(o){return Vl(o,(e,t)=>t in _n&&e!==void 0)}function Vl(o,e){const t={};return Object.keys(o).forEach(n=>{e(o[n],n)&&(t[n]=o[n])}),t}const Rl=f.defineComponent({__name:"component",props:{scale:{default:1},elements:{default:void 0},seed:{default:void 0},seedProps:{default:void 0},color:{default:void 0},distance:{default:void 0},size:{default:void 0},texture:{default:void 0}},setup(o,{expose:e}){const t=o,n=f.shallowRef(),s=f.shallowRef([]),r=f.shallowRef(zl(t));e({value:n});const i=new c.TextureLoader,a=new Kt,l=[],u=()=>{var g,x,w;for(;l.length;)l.pop();(g=n.value)==null||g.children.forEach(v=>{"dispose"in v&&v.dispose()}),(x=n.value)==null||x.remove(...n.value.children),(w=n.value)==null||w.dispose()},h=g=>{if(typeof g.texture=="string"){const x=g.texture;g.texture=i.load(x),g.texture.name=x}return g.color=ae.normalizeColor(g.color),g},d=()=>{for(;s.value.length>l.length;){const x={...h(s.value[l.length])};l.push(x),a.addElement(x)}s.value.forEach((g,x)=>{const w=l[x],{texture:v,size:P,distance:D,color:S}=g;if(typeof v=="string"){if(w.texture.name!==v){w.texture.dispose();const _=v;w.texture=i.load(_),w.texture.name=_}}else w.texture!==v&&(w.texture.dispose(),w.texture=v);w.size=P,w.distance=D,w.color=ae.normalizeColor(S)}),y()},y=()=>{for(let g=s.value.length-1;g<l.length;g++)l[g].size=0;s.value.forEach((g,x)=>{l[x].size=g.size*t.scale})};return f.onUnmounted(()=>{u()}),f.onMounted(()=>{var g;(g=n.value)==null||g.add(a),s.value=kr(t.elements,r.value,t.seed,t.seedProps)}),f.watch(()=>[t.color,t.distance,t.size,t.texture],()=>{r.value={color:t.color,distance:t.distance,size:t.size,texture:t.texture}}),f.watch(()=>[r.value,t.elements,t.seed,t.seedProps],()=>{s.value=kr(t.elements,r.value,t.seed,t.seedProps)}),f.watch(()=>t.scale,()=>{y()}),f.watch(()=>s.value,()=>{d()}),(g,x)=>(f.openBlock(),f.createElementBlock("TresGroup",{ref_key:"lensflareRef",ref:n},null,512))}});function Nr(o){const e=f.ref(null),{height:t,width:n,settings:s,depth:r}=f.isReactive(o)?f.toRefs(o):f.toRefs(f.reactive(o)),{onLoop:i}=ae.useRenderLoop(),{camera:a,renderer:l,scene:u,sizes:h}=ae.useTresContext();return f.watchEffect(()=>{var d;(d=e.value)==null||d.dispose(),e.value=new c.WebGLRenderTarget((n==null?void 0:n.value)||h.width.value,(t==null?void 0:t.value)||h.height.value,{minFilter:c.LinearFilter,magFilter:c.LinearFilter,type:c.HalfFloatType,...s==null?void 0:s.value}),r!=null&&r.value&&(e.value.depthTexture=new c.DepthTexture((n==null?void 0:n.value)||h.width.value,(t==null?void 0:t.value)||h.height.value,c.FloatType))}),i(()=>{l.value.setRenderTarget(e.value),l.value.clear(),l.value.render(u.value,a.value),l.value.setRenderTarget(null)}),f.onBeforeUnmount(()=>{var d;(d=e.value)==null||d.dispose()}),e}const Gl=f.defineComponent({__name:"component",props:{width:{},height:{},depth:{type:Boolean,default:!1},settings:{default:void 0}},setup(o,{expose:e}){const n=Nr(o);return e({value:n}),()=>{}}}),zr=(o,e=16,t,n,s)=>{const r=new Float32Array(e*16),i=f.ref(new c.InterleavedBuffer(r,16));return(()=>{if(!o)return;const l=new To(o);n&&l.setWeightAttribute(n),l.build();const u=new c.Vector3,h=new c.Vector3,d=new c.Color,y=new c.Object3D;o.updateMatrixWorld(!0);for(let g=0;g<e;g++)l.sample(u,h,d),typeof s=="function"?s({dummy:y,sampledMesh:o,position:u,normal:h,color:d},g):y.position.copy(u),y.updateMatrix(),t&&t.setMatrixAt(g,y.matrix),y.matrix.toArray(i.value.array,g*16);t&&(t.instanceMatrix.needsUpdate=!0),i.value.needsUpdate=!0})(),{buffer:i}},jl=f.defineComponent({__name:"component",props:{transform:{type:Function},weight:{},count:{},mesh:{},instanceMesh:{}},setup(o,{expose:e}){const t=o,n=f.ref(),s=f.ref(),r=f.ref();return f.watchEffect(()=>{var i,a;s.value=t.instanceMesh??((i=n.value)==null?void 0:i.children.find(l=>l.hasOwnProperty("instanceMatrix"))),r.value=t.mesh??((a=n.value)==null?void 0:a.children.find(l=>l.type==="Mesh")),zr(r.value,t.count,s.value,t.weight,t.transform)}),e({samplerRef:n}),(i,a)=>(f.openBlock(),f.createElementBlock("TresGroup",{ref_key:"samplerRef",ref:n},[f.renderSlot(i.$slots,"default")],512))}}),vn={sunset:"venice/venice_sunset_1k.hdr",studio:"studio/poly_haven_studio_1k.hdr",city:"city/canary_wharf_1k.hdr",umbrellas:"outdoor/outdoor_umbrellas_1k.hdr",night:"outdoor/satara_night_1k.hdr",forest:"outood/mossy_forest_1k.hdr",snow:"outdoor/snowy_forest_path_01_1k.hdr",dawn:"kiara/kiara_1_dawn_1k.hdr",hangar:"indoor/small_hangar_01_1k.hdr",urban:"indoor/abandoned_games_room_02_1k.hdr",modern:"city/modern_buildings_2_1k.hdr",shangai:"city/shanghai_bund_1k.hdr"},El="https://raw.githubusercontent.com/Tresjs/assets/main/textures/hdr/";async function Vr(o){const{scene:e}=ae.useTresContext(),{preset:t,blur:n,files:s=[],path:r="",background:i}=f.toRefs(o),a=f.ref(),l=f.computed(()=>Array.isArray(s.value)),u=f.computed(()=>l.value?c.CubeTextureLoader:xr),h=f.ref(null);return f.watch(()=>[s,r],async([d,y])=>{if(d.value.length>0&&!t.value){try{h.value=await ae.useLoader(f.unref(u),l.value?[f.unref(d)]:f.unref(d),g=>{y.value&&g.setPath(f.unref(y))})}catch(g){throw new Error(`Failed to load environment map: ${g}`)}h.value&&(a.value=l.value?h.value[0]:h.value,a.value.mapping=l.value?c.CubeReflectionMapping:c.EquirectangularReflectionMapping)}},{immediate:!0}),f.watch(()=>a.value,d=>{e.value&&(e.value.environment=d)},{immediate:!0}),f.watch(()=>[i.value,a.value],([d,y])=>{e.value&&(e.value.background=d?y:void 0)},{immediate:!0}),f.watch(()=>n==null?void 0:n.value,d=>{e.value&&(e.value.backgroundBlurriness=d)},{immediate:!0}),f.watch(t,async d=>{if(d&&d in vn){const y=El,g=vn[d];try{h.value=await ae.useLoader(xr,g,x=>{y&&x.setPath(y)})}catch(x){throw new Error(`Failed to load environment map: ${x}`)}h.value&&(a.value=h.value,a.value.mapping=c.EquirectangularReflectionMapping)}else if(d&&!(d in vn))throw new Error(`Preset must be one of: ${Object.keys(vn).join(", ")}`)},{immediate:!0}),{texture:a}}let xn=null;function Yl(o,e){return t=>{e&&e(t),o.draco&&(xn||(xn=new Ka),xn.setDecoderPath(o.decoderPath||"https://www.gstatic.com/draco/versioned/decoders/1.4.3/"),t.setDRACOLoader(xn))}}async function Rr(o,e={draco:!1},t){return await ae.useLoader(Eo,o,Yl(e,t))}const Xl=["object"],Wl=f.defineComponent({__name:"component",props:{path:{},draco:{type:Boolean,default:!1},decoderPath:{default:"https://www.gstatic.com/draco/versioned/decoders/1.4.1/"},castShadow:{type:Boolean,default:!1},receiveShadow:{type:Boolean,default:!1}},async setup(o,{expose:e}){let t,n;const s=o,r=f.ref();e({value:r});const{scene:i}=([t,n]=f.withAsyncContext(()=>Rr(s.path,{draco:s.draco,decoderPath:s.decoderPath})),t=await t,n(),t);return(s.castShadow||s.receiveShadow)&&i.traverse(a=>{a.isMesh&&(a.castShadow=s.castShadow,a.receiveShadow=s.receiveShadow)}),(a,l)=>(f.openBlock(),f.createElementBlock("primitive",f.mergeProps({ref_key:"modelRef",ref:r,object:f.unref(i)},a.$attrs),null,16,Xl))}});async function Gr(o){return await ae.useLoader(Da,o)}const Zl=["object"],Kl=f.defineComponent({__name:"component",props:{path:{},castShadow:{type:Boolean,default:!1},receiveShadow:{type:Boolean,default:!1}},async setup(o,{expose:e}){let t,n;const s=o,r=f.ref();e({value:r});const i=([t,n]=f.withAsyncContext(()=>Gr(s.path)),t=await t,n(),t);return(s.castShadow||s.receiveShadow)&&i.traverse(a=>{a.isMesh&&(a.castShadow=s.castShadow,a.receiveShadow=s.receiveShadow)}),(a,l)=>(f.openBlock(),f.createElementBlock("primitive",f.mergeProps({ref_key:"modelRef",ref:r,object:f.unref(i)},a.$attrs),null,16,Zl))}}),ql=["geometry","render-order"],Ql=f.defineComponent({__name:"component",props:{src:{},skipStrokes:{type:Boolean,default:!1},skipFills:{type:Boolean,default:!1},fillMaterial:{},strokeMaterial:{},fillMeshProps:{},strokeMeshProps:{},depth:{default:"renderOrder"}},setup(o,{expose:e}){const t=o,{src:n,skipStrokes:s,skipFills:r,fillMaterial:i,strokeMaterial:a,fillMeshProps:l,strokeMeshProps:u,depth:h}=f.toRefs(t),d=f.shallowRef(),y=f.shallowRef([]),g=f.shallowRef([]);e({value:d}),f.watchEffect(async()=>x(n.value).then(P=>g.value=P.paths)),f.watch([r,s,i,a,g],v);async function x(P){const D=P.startsWith("<svg")?encodeURI(`data:image/svg+xml;utf8,${P}`):P;return ae.useLoader(Wt,D)}f.onUnmounted(w);function w(){y.value.forEach(P=>P.geometry.dispose())}function v(){var L,b,C;w();const P=[],[D,S]=(()=>{const m={flat:!1,renderOrder:!1,offsetZ:!0},M={flat:0,renderOrder:0,offsetZ:.025},p=h.value;return typeof p=="number"?[!0,p]:[m[p],M[p]]})();let _=0;for(const m of g.value){const M=((L=m.userData)==null?void 0:L.style)??{},p=Object.assign({color:M.fill,opacity:M.fillOpacity,transparent:!0,side:c.DoubleSide,depthWrite:D},t.fillMaterial);if(!r.value&&M.fill!==void 0&&M.fill!=="none")for(const I of Wt.createShapes(m)){const F=new c.ShapeGeometry(I);F.scale(1,-1,1),S&&F.translate(0,0,_++*S),P.push({geometry:F,material:p,isStroke:!1})}if(!s.value&&M.stroke!==void 0&&M.stroke!=="none"){const I=Object.assign({color:(b=m.userData)==null?void 0:b.style.stroke,opacity:(C=m.userData)==null?void 0:C.style.strokeOpacity,transparent:!0,side:c.DoubleSide,depthWrite:D},t.strokeMaterial);for(const F of m.subPaths){const J=F.getPoints().map(Q=>new c.Vector2(Q.x,-Q.y)),G=Wt.pointsToStroke(J,M||"none");S&&G.translate(0,0,_++*S),P.push({geometry:G,material:I,isStroke:!0})}}}y.value=P}return(P,D)=>(f.openBlock(),f.createElementBlock("TresGroup",{ref_key:"svgRef",ref:d},[(f.openBlock(!0),f.createElementBlock(f.Fragment,null,f.renderList(y.value,({geometry:S,material:_,isStroke:L},b)=>(f.openBlock(),f.createElementBlock("TresMesh",f.mergeProps({key:`${b}`},L?f.unref(u):f.unref(l),{geometry:S,"render-order":f.unref(h)==="renderOrder"?b:0}),[f.createElementVNode("TresMeshBasicMaterial",f.normalizeProps(f.guardReactiveProps(_)),null,16)],16,ql))),128))],512))}}),jr="[TresJS - Cientos ▲ ■ ♥] ";function os(){function o(n,s){console.error(`${jr} ${n}`,s||"")}function e(n){console.warn(`${jr} ${n}`)}function t(n,s){}return{logError:o,logWarning:e,logMessage:t}}let as=0;function Jl(){const o=f.ref(!1),e=f.ref(0),t=f.ref([]),{logError:n}=os();return new Promise(s=>{c.DefaultLoadingManager.onStart=()=>{o.value=!1},c.DefaultLoadingManager.onLoad=()=>{o.value=!0},c.DefaultLoadingManager.onProgress=(r,i,a)=>{i===a&&(as=a,o.value=!0,t.value.push(r)),e.value=Math.round((i-as)/(a-as)*100||100,2)},c.DefaultLoadingManager.onError=r=>{n("Error loading assets",new Error(r)),o.value=!0},s({items:t,hasFinishLoading:o,progress:e})})}async function Hl(o,e){const{logError:t}=os();if(!o)return t("Error no path provided");const{unsuspend:n,start:s,crossOrigin:r,muted:i,loop:a,...l}={unsuspend:"loadedmetadata",crossOrigin:"Anonymous",muted:!0,loop:!0,start:!0,playsInline:!0,...e};function u(){return new Promise((h,d)=>{const y=Object.assign(document.createElement("video"),{src:typeof o=="string"&&o||void 0,crossOrigin:r,loop:a,muted:i,autoplay:!0,...l}),g=new c.VideoTexture(y);return y.addEventListener(n,()=>h(g)),y.addEventListener("error",()=>d()),g})}try{const h=await u();return s&&h.image&&h.image.play(),h}catch{t("Error loading resource")}}const $l=["target","auto-rotate","auto-rotate-speed","enable-damping","damping-factor","enable-pan","key-pan-speed","keys","max-azimuth-angle","min-azimuth-angle","max-polar-angle","min-polar-angle","min-distance","max-distance","min-zoom","max-zoom","touches","enable-zoom","zoom-speed","enable-rotate","rotate-speed","args"],ec=f.defineComponent({__name:"OrbitControls",props:{makeDefault:{type:Boolean,default:!1},camera:{},domElement:{},target:{default:()=>[0,0,0]},enableDamping:{type:Boolean,default:!0},dampingFactor:{default:.05},autoRotate:{type:Boolean,default:!1},autoRotateSpeed:{default:2},enablePan:{type:Boolean,default:!0},keyPanSpeed:{default:7},keys:{},maxAzimuthAngle:{default:1/0},minAzimuthAngle:{default:-1/0},maxPolarAngle:{default:Math.PI},minPolarAngle:{default:0},minDistance:{default:0},maxDistance:{default:1/0},minZoom:{default:0},maxZoom:{default:1/0},touches:{default:()=>({ONE:c.TOUCH.ROTATE,TWO:c.TOUCH.DOLLY_PAN})},enableZoom:{type:Boolean,default:!0},zoomSpeed:{default:1},enableRotate:{type:Boolean,default:!0},rotateSpeed:{default:1}},emits:["change","start","end"],setup(o,{expose:e,emit:t}){const n=o,s=t,{makeDefault:r,autoRotate:i,autoRotateSpeed:a,enableDamping:l,dampingFactor:u,enablePan:h,keyPanSpeed:d,maxAzimuthAngle:y,minAzimuthAngle:g,maxPolarAngle:x,minPolarAngle:w,minDistance:v,maxDistance:P,minZoom:D,maxZoom:S,enableZoom:_,zoomSpeed:L,enableRotate:b,touches:C,rotateSpeed:m,target:M}=f.toRefs(n),{camera:p,renderer:I,extend:F,controls:J}=ae.useTresContext(),G=f.ref(null);F({OrbitControls:sr}),f.watch(G,Z=>{Q(),Z&&r.value?J.value=Z:J.value=null});function Q(){Le(G.value,"change",()=>s("change",G.value)),Le(G.value,"start",()=>s("start",G.value)),Le(G.value,"end",()=>s("end",G.value))}const{onLoop:K}=ae.useRenderLoop();return K(()=>{G.value&&(l.value||i.value)&&G.value.update()}),f.onUnmounted(()=>{G.value&&G.value.dispose()}),e({value:G}),(Z,X)=>(Z.camera||f.unref(p))&&(Z.domElement||f.unref(I))?(f.openBlock(),f.createElementBlock("TresOrbitControls",{key:0,ref_key:"controlsRef",ref:G,target:f.unref(M),"auto-rotate":f.unref(i),"auto-rotate-speed":f.unref(a),"enable-damping":f.unref(l),"damping-factor":f.unref(u),"enable-pan":f.unref(h),"key-pan-speed":f.unref(d),keys:Z.keys,"max-azimuth-angle":f.unref(y),"min-azimuth-angle":f.unref(g),"max-polar-angle":f.unref(x),"min-polar-angle":f.unref(w),"min-distance":f.unref(v),"max-distance":f.unref(P),"min-zoom":f.unref(D),"max-zoom":f.unref(S),touches:f.unref(C),"enable-zoom":f.unref(_),"zoom-speed":f.unref(L),"enable-rotate":f.unref(b),"rotate-speed":f.unref(m),args:[Z.camera||f.unref(p),Z.domElement||f.unref(I).domElement]},null,8,$l)):f.createCommentVNode("",!0)}}),tc=5,nc=6,sc=.3,rc=f.defineComponent({__name:"KeyboardControls",props:{forward:{default:()=>["w","W"]},back:{default:()=>["s","S"]},left:{default:()=>["a","A"]},right:{default:()=>["d","D"]},jump:{default:()=>[" "]},gravity:{default:9.8},moveSpeed:{default:.1},headBobbing:{type:Boolean,default:!1},is2D:{type:Boolean,default:!1}},setup(o){var p;const e=o,{forward:t,back:n,left:s,right:r,jump:i,gravity:a,moveSpeed:l,headBobbing:u,is2D:h}=f.toRefs(e),{camera:d,controls:y}=ae.useTresContext(),g=f.ref(0),x=f.ref(0),w=f.ref(!1),v=f.ref(!1),P=f.ref(0),D=f.shallowRef(),S=h.value?"y":"z",_=((p=d.value.position)==null?void 0:p.y)||0;St(t.value,()=>{w.value=!0,x.value=l.value},{eventName:"keydown"}),St(n.value,()=>{w.value=!0,x.value=-l.value},{eventName:"keydown"}),St([...t.value,...n.value],()=>{w.value=!1,x.value=0},{eventName:"keyup"}),St(s.value,()=>{w.value=!0,g.value=-l.value},{eventName:"keydown"}),St(r.value,()=>{w.value=!0,g.value=l.value},{eventName:"keydown"}),St([...s.value,...r.value],()=>{w.value=!1,g.value=0},{eventName:"keyup"}),St(i.value,()=>{v.value||(P.value=Date.now()),v.value=!0});const L=I=>w.value?Math.sin(I*tc)*sc+_:_,b=()=>(Date.now()-P.value)/1e3*3,C=I=>_+nc*I-.5*a.value*I**2,m=()=>{if(v.value){const I=C(b());return I<=_&&(v.value=!1),I}return 0},{onLoop:M}=ae.useRenderLoop();return M(({elapsed:I})=>{var F;y.value instanceof Wn&&((F=y.value)!=null&&F.isLocked)?(y.value.moveForward(x.value),y.value.moveRight(g.value),d.value.position&&(d.value.position.y=u.value?L(I):_,d.value.position.y+=m())):D.value.children.length>0&&!(y.value instanceof Wn)&&(D.value.position.x+=g.value,D.value.position[S]+=h.value?x.value:-x.value)}),(I,F)=>(f.openBlock(),f.createElementBlock("TresGroup",{ref_key:"wrapperRef",ref:D},[f.renderSlot(I.$slots,"default")],512))}}),ic=["object","args","mode","enabled","axis","translation-snap","rotation-snap","scale-snap","space","size","show-x","show-y","show-z"],oc=f.defineComponent({__name:"TransformControls",props:{object:{},mode:{default:"translate"},enabled:{type:Boolean,default:!0},axis:{default:"XYZ"},translationSnap:{},rotationSnap:{},scaleSnap:{},space:{default:"world"},size:{default:1},showX:{type:Boolean,default:!0},showY:{type:Boolean,default:!0},showZ:{type:Boolean,default:!0}},emits:["dragging","change","mouseDown","mouseUp","objectChange"],setup(o,{emit:e}){const t=o,n=e,{object:s,mode:r,enabled:i,axis:a,translationSnap:l,rotationSnap:u,scaleSnap:h,space:d,size:y,showX:g,showY:x,showZ:w}=f.toRefs(t),v=f.shallowRef(),{controls:P,camera:D,renderer:S,extend:_}=ae.useTresContext();_({TransformControls:Do});const L=C=>{P.value&&(P.value.enabled=!C.value),n("dragging",C.value)};function b(){Le(v.value,"change",()=>n("change")),Le(v.value,"dragging-changed",L),Le(v.value,"mouseDown",()=>n("mouseDown")),Le(v.value,"mouseUp",()=>n("mouseUp")),Le(v.value,"objectChange",()=>n("objectChange"))}return f.watchEffect(()=>{v.value&&b()}),f.onUnmounted(()=>{v.value&&v.value.dispose()}),(C,m)=>f.unref(D)&&f.unref(S)?(f.openBlock(),f.createElementBlock("TresTransformControls",{key:0,ref_key:"controlsRef",ref:v,object:f.unref(s),args:[f.unref(D),f.unref(S).domElement],mode:f.unref(r),enabled:f.unref(i),axis:f.unref(a),"translation-snap":f.unref(l),"rotation-snap":f.unref(u),"scale-snap":f.unref(h),space:f.unref(d),size:f.unref(y),"show-x":f.unref(g),"show-y":f.unref(x),"show-z":f.unref(w),visible:!0},null,8,ic)):f.createCommentVNode("",!0)}}),ac=["args"],lc=f.defineComponent({__name:"PointerLockControls",props:{makeDefault:{type:Boolean,default:!1},camera:{},domElement:{},selector:{}},emits:["isLock","change"],setup(o,{expose:e,emit:t}){const n=o,s=t,{camera:r,renderer:i,extend:a,controls:l}=ae.useTresContext(),u=f.ref(null);let h;a({PointerLockControls:Wn});const d=y=>{s("isLock",y)};return f.watch(u,y=>{y&&n.makeDefault?l.value=y:l.value=null;const g=document.getElementById(n.selector||"");h=g||i.value.domElement,Le(l.value,"change",()=>s("change",l.value)),Le(h,"click",()=>{var x,w,v;(x=l.value)==null||x.lock(),(w=l.value)==null||w.addEventListener("lock",()=>d(!0)),(v=l.value)==null||v.addEventListener("unlock",()=>d(!1))})}),f.onUnmounted(()=>{var y,g;(y=l.value)==null||y.removeEventListener("lock",()=>d(!0)),(g=l.value)==null||g.removeEventListener("unlock",()=>d(!1)),u.value&&u.value.dispose()}),e({value:l}),(y,g)=>(y.camera||f.unref(r))&&(y.domElement||f.unref(i))?(f.openBlock(),f.createElementBlock("TresPointerLockControls",{key:0,ref_key:"controlsRef",ref:u,args:[y.camera||f.unref(r),y.domElement||f.unref(i).domElement]},null,8,ac)):f.createCommentVNode("",!0)}}),cc=["args"],uc=f.defineComponent({__name:"MapControls",props:{makeDefault:{type:Boolean,default:!1},camera:{},domElement:{}},setup(o){const e=o,{camera:t,renderer:n,extend:s,controls:r}=ae.useTresContext(),i=f.ref(null);return s({MapControls:jo}),f.watch(r,a=>{a&&e.makeDefault?r.value=a:r.value=null}),f.onUnmounted(()=>{i.value&&i.value.dispose()}),(a,l)=>(a.camera||f.unref(t))&&(a.domElement||f.unref(n))?(f.openBlock(),f.createElementBlock("TresMapControls",{key:0,ref_key:"controlsRef",ref:i,args:[a.camera||f.unref(t),a.domElement||f.unref(n).domElement]},null,8,cc)):f.createCommentVNode("",!0)}}),hc=f.defineComponent({__name:"ScrollControls",props:{pages:{default:4},distance:{default:4},smoothScroll:{default:.1},horizontal:{type:Boolean,default:!1},htmlScroll:{type:Boolean,default:!1}},emits:["update:modelValue"],setup(o,{emit:e}){const t=o,n=e,{logWarning:s}=ae.useLogger();t.smoothScroll<0&&s("SmoothControl must be greater than zero"),t.pages<0&&s("Pages must be greater than zero");const{camera:r,controls:i,renderer:a}=ae.useTresContext(),l=f.shallowRef(),u=document.createElement("div"),{y:h}=wl(),{x:d,y,isScrolling:g}=_l(u),{height:x,width:w}=Pr();let v=0;const P=f.ref(!1),D=f.ref(0),S=f.ref(0),_=f.ref(0),L=t.horizontal?"x":"y",b=f.watch(r,m=>{if(P.value){b();return}v=t.horizontal?(m==null?void 0:m.position.x)||0:(m==null?void 0:m.position.y)||0,P.value=!0},{immediate:!0});f.watch(g,m=>{i.value&&(i.value.enabled=!m)},{immediate:!0}),f.watch(h,m=>{!g.value&&!t.htmlScroll||(S.value=m/x.value/(_.value/x.value-1),D.value=-1*S.value,n("update:modelValue",S.value))}),f.watch(y,m=>{S.value=m/x.value/(_.value/x.value),D.value=-1*S.value,n("update:modelValue",S.value)}),f.watch(d,m=>{S.value=m/w.value/(_.value/w.value-1),D.value=+S.value,n("update:modelValue",S.value)}),f.watch(a,m=>{var p,I;const M=m==null?void 0:m.domElement;if(t.htmlScroll&&(m!=null&&m.domElement))M!=null&&M.style.width&&(M!=null&&M.style.position)&&(M!=null&&M.style.top)&&(M!=null&&M.style.left)&&(M.style.width="100%",M.style.position="fixed",M.style.zIndex=" -99999",M.style.top="0",M.style.left="0"),_.value=document.body.scrollHeight;else{const F=document.createElement("div"),J=document.createElement("div");u.style[t.horizontal?"overflowX":"overflowY"]="auto",u.style[t.horizontal?"overflowY":"overflowX"]="hidden",u.style.position="absolute",u.style.width="100%",u.style.height=" 100%",u.style.top="0",u.style.left="0",u.classList.add("scrollContainer"),F.style.position="sticky",F.style.top="0px",F.style.left="0px",F.style.width="100%",F.style.height="100%",F.style.overflow="hidden",u.appendChild(F),J.style.height=t.horizontal?"100%":`${x.value*t.pages}px`,J.style.width=t.horizontal?`${w.value*t.pages}px`:"100vw",J.style.pointerEvents="none",M.style.position="fixed",M.style.zIndex="0",M!=null&&M.style.width&&(M.style.width="100%"),u.appendChild(J),m.domElement.parentNode.style.position="relative",(I=(p=m==null?void 0:m.domElement)==null?void 0:p.parentNode)==null||I.appendChild(u),_.value=t.horizontal?w.value*t.pages:x.value*t.pages}},{immediate:!0});const{onLoop:C}=ae.useRenderLoop();return C(()=>{var m;if((m=r.value)!=null&&m.position){const M=(D.value*t.distance-r.value.position[L]+v)*t.smoothScroll;r.value.position[L]+=M,l.value.children.length>0&&(l.value.position[L]+=M)}}),(m,M)=>(f.openBlock(),f.createElementBlock("TresGroup",{ref_key:"wrapperRef",ref:l},[f.renderSlot(m.$slots,"default")],512))}});/*!
+		}`},Jt.Geometry=function(){const o=new l.BufferGeometry,e=new Float32Array([-1,-1,0,0,0,1,-1,0,1,0,1,1,0,1,1,-1,1,0,0,1]),t=new l.InterleavedBuffer(e,5);return o.setIndex([0,1,2,0,2,3]),o.setAttribute("position",new l.InterleavedBufferAttribute(t,3,0,!1)),o.setAttribute("uv",new l.InterleavedBufferAttribute(t,2,3,!1)),o}();function Tl(o){return o}function Ll(o){return o*o*o}function Dl(o){return o<.5?4*o*o*o:1-(-2*o+2)**3/2}function Il(o){return o*o*o*o}function Ol(o){return o<1/2.75?7.5625*o*o:o<2/2.75?7.5625*(o-=1.5/2.75)*o+.75:o<2.5/2.75?7.5625*(o-=2.25/2.75)*o+.9375:7.5625*(o-=2.625/2.75)*o+.984375}const Oi=l.MathUtils.clamp;class ki{constructor(e=0,t){le(this,"_getNext");le(this,"_getGenerator");this._getGenerator=t??this.getMulberry32,this._getNext=this._getGenerator(e)}seed(e){this._getNext=this._getGenerator(e)}rand(){return this._getNext()}float(e,t){return e+this._getNext()*(t-e)}floatSpread(e){return this.float(-.5*e,.5*e)}int(e,t){return e+Math.floor(this._getNext()*(t-e+1))}choice(e){return e.length?e[Math.floor(this._getNext()*e.length)]:null}defaultChoice(e,t){return e.length?e[Math.floor(this._getNext()*e.length)]:t}sample(e,t,n){const r=e.length;t=Oi(t,0,r-1),n=Oi(n??r-1,0,r-1);const i=this.int(t,n),s=this.shuffle(e.map((c,h)=>h)),a=Math.min(e.length,i);return s.slice(0,a).sort().map(c=>e[c])}shuffle(e){return e.map(t=>({value:t,sort:this._getNext()})).sort((t,n)=>t.sort-n.sort).map(({value:t})=>t)}getMulberry32(e=0){return 0<e&&e<1&&(e=Math.floor(e*2**16)),()=>{e+=1831565813;let t=e;return t=Math.imul(t^t>>>15,t|1),t^=t+Math.imul(t^t>>>7,t|61),((t^t>>>14)>>>0)/4294967296}}}const st="https://raw.githubusercontent.com/Tresjs/assets/93976c7d63ac83d4a254a41a10b2362bc17e90c9/textures/lensflare/",or=`${st}circle.png`,_n=`${st}circleBlur.png`,kl=`${st}circleRainbow.png`,Bl=`${st}line.png`,Bi=`${st}poly6.png`,Fi=`${st}polyStroke6.png`,Fl=`${st}rays.png`,xn=`${st}ring.png`,Ul=`${st}starThin6.png`,Nl={texture:[Bl,xn],color:["white"],distance:[0,0],size:[750,1024],length:[0,2]},zl={texture:[_n],color:["white"],distance:[0,0],size:[180,512],length:[1,1]},Vl={texture:[Fl],color:["white"],distance:[0,0],size:[180,512],length:[1,1]},Rl={texture:[or,kl,xn,Ul],color:["white"],distance:[0,0],size:[180,512],length:[2,3]},[Ui,Ni]=[3679071,132442],ar=[Nl,zl,Vl,Rl,{texture:[_n,or,xn,Bi,Fi],color:["dimgray","gray","darkgray",Ui,Ni],distance:[.5,2.5],size:[20,180],length:[5,21]},{texture:[_n,or,xn,Bi,Fi],color:["dimgray","gray","darkgray",Ui,Ni],distance:[-.6,-.1],size:[180,360],length:[0,5]}],wn={color:"white",distance:0,size:512,texture:_n},zi=(o,e,t=void 0,n=void 0,r=wn)=>{if(o!==void 0&&o.length>0&&(typeof t=="number"||typeof n<"u")){const a=Ri(t??0,n??ar),c=a.length,h=o.length;return c>=h?a.map((f,d)=>Object.assign(f,e,d<h?o[d]:{})):o.map((f,d)=>Object.assign({},r,d<c?a[d]:{},e,f))}if(o!==void 0&&o.length>0){const a=Object.assign({},r,e);return o.map(c=>Object.assign({},a,c))}const i=n===void 0||n.length===0?ar:n;return Ri(t??0,i).map(a=>Object.assign({},a,e))},Gl=[Tl,Ll,Dl,Il,Ol],Vi=l.MathUtils.lerp,Ri=(o=0,e=ar)=>{const n=new ki(o).choice(Gl);return e.map((r,i)=>{const s=new ki(o*(i*7907+1)+(typeof r.seed=="number"?r.seed:0)),a=s.int(r.length[0],r.length[1]);return new Array(a).fill(0).map(()=>{const c=n(s.rand());return{texture:s.defaultChoice(r.texture,wn.texture),size:Vi(r.size[0],r.size[1],n(1-c)),distance:Vi(r.distance[0],r.distance[1],c),color:s.defaultChoice(r.color,wn.color)}})}).flat()};function jl(o){return El(o,(e,t)=>t in wn&&e!==void 0)}function El(o,e){const t={};return Object.keys(o).forEach(n=>{e(o[n],n)&&(t[n]=o[n])}),t}const Wl=u.defineComponent({__name:"component",props:{scale:{default:1},elements:{default:void 0},seed:{default:void 0},seedProps:{default:void 0},color:{default:void 0},distance:{default:void 0},size:{default:void 0},texture:{default:void 0}},setup(o,{expose:e}){const t=o,n=u.shallowRef(),r=u.shallowRef([]),i=u.shallowRef(jl(t));e({value:n});const s=new l.TextureLoader,a=new Jt,c=[],h=()=>{var m,x,b;for(;c.length;)c.pop();(m=n.value)==null||m.children.forEach(v=>{"dispose"in v&&v.dispose()}),(x=n.value)==null||x.remove(...n.value.children),(b=n.value)==null||b.dispose()},f=m=>{if(typeof m.texture=="string"){const x=m.texture;m.texture=s.load(x),m.texture.name=x}return m.color=oe.normalizeColor(m.color),m},d=()=>{for(;r.value.length>c.length;){const x={...f(r.value[c.length])};c.push(x),a.addElement(x)}r.value.forEach((m,x)=>{const b=c[x],{texture:v,size:_,distance:T,color:w}=m;if(typeof v=="string"){if(b.texture.name!==v){b.texture.dispose();const M=v;b.texture=s.load(M),b.texture.name=M}}else b.texture!==v&&(b.texture.dispose(),b.texture=v);b.size=_,b.distance=T,b.color=oe.normalizeColor(w)}),p()},p=()=>{for(let m=r.value.length-1;m<c.length;m++)c[m].size=0;r.value.forEach((m,x)=>{c[x].size=m.size*t.scale})};return u.onUnmounted(()=>{h()}),u.onMounted(()=>{var m;(m=n.value)==null||m.add(a),r.value=zi(t.elements,i.value,t.seed,t.seedProps)}),u.watch(()=>[t.color,t.distance,t.size,t.texture],()=>{i.value={color:t.color,distance:t.distance,size:t.size,texture:t.texture}}),u.watch(()=>[i.value,t.elements,t.seed,t.seedProps],()=>{r.value=zi(t.elements,i.value,t.seed,t.seedProps)}),u.watch(()=>t.scale,()=>{p()}),u.watch(()=>r.value,()=>{d()}),(m,x)=>(u.openBlock(),u.createElementBlock("TresGroup",{ref_key:"lensflareRef",ref:n},null,512))}});function Gi(o){const e=u.ref(null),{height:t,width:n,settings:r,depth:i}=u.isReactive(o)?u.toRefs(o):u.toRefs(u.reactive(o)),{onLoop:s}=oe.useRenderLoop(),{camera:a,renderer:c,scene:h,sizes:f}=oe.useTresContext();return u.watchEffect(()=>{var d;(d=e.value)==null||d.dispose(),e.value=new l.WebGLRenderTarget((n==null?void 0:n.value)||f.width.value,(t==null?void 0:t.value)||f.height.value,{minFilter:l.LinearFilter,magFilter:l.LinearFilter,type:l.HalfFloatType,...r==null?void 0:r.value}),i!=null&&i.value&&(e.value.depthTexture=new l.DepthTexture((n==null?void 0:n.value)||f.width.value,(t==null?void 0:t.value)||f.height.value,l.FloatType))}),s(()=>{c.value.setRenderTarget(e.value),c.value.clear(),c.value.render(h.value,a.value),c.value.setRenderTarget(null)}),u.onBeforeUnmount(()=>{var d;(d=e.value)==null||d.dispose()}),e}const Yl=u.defineComponent({__name:"component",props:{width:{},height:{},depth:{type:Boolean,default:!1},settings:{default:void 0}},setup(o,{expose:e}){const n=Gi(o);return e({value:n}),()=>{}}}),ji=(o,e=16,t,n,r)=>{const i=new Float32Array(e*16),s=u.ref(new l.InterleavedBuffer(i,16));return(()=>{if(!o)return;const c=new Oo(o);n&&c.setWeightAttribute(n),c.build();const h=new l.Vector3,f=new l.Vector3,d=new l.Color,p=new l.Object3D;o.updateMatrixWorld(!0);for(let m=0;m<e;m++)c.sample(h,f,d),typeof r=="function"?r({dummy:p,sampledMesh:o,position:h,normal:f,color:d},m):p.position.copy(h),p.updateMatrix(),t&&t.setMatrixAt(m,p.matrix),p.matrix.toArray(s.value.array,m*16);t&&(t.instanceMatrix.needsUpdate=!0),s.value.needsUpdate=!0})(),{buffer:s}},Xl=u.defineComponent({__name:"component",props:{transform:{type:Function},weight:{},count:{},mesh:{},instanceMesh:{}},setup(o,{expose:e}){const t=o,n=u.ref(),r=u.ref(),i=u.ref();return u.watchEffect(()=>{var s,a;r.value=t.instanceMesh??((s=n.value)==null?void 0:s.children.find(c=>c.hasOwnProperty("instanceMatrix"))),i.value=t.mesh??((a=n.value)==null?void 0:a.children.find(c=>c.type==="Mesh")),ji(i.value,t.count,r.value,t.weight,t.transform)}),e({samplerRef:n}),(s,a)=>(u.openBlock(),u.createElementBlock("TresGroup",{ref_key:"samplerRef",ref:n},[u.renderSlot(s.$slots,"default")],512))}}),bn={sunset:"venice/venice_sunset_1k.hdr",studio:"studio/poly_haven_studio_1k.hdr",city:"city/canary_wharf_1k.hdr",umbrellas:"outdoor/outdoor_umbrellas_1k.hdr",night:"outdoor/satara_night_1k.hdr",forest:"outood/mossy_forest_1k.hdr",snow:"outdoor/snowy_forest_path_01_1k.hdr",dawn:"kiara/kiara_1_dawn_1k.hdr",hangar:"indoor/small_hangar_01_1k.hdr",urban:"indoor/abandoned_games_room_02_1k.hdr",modern:"city/modern_buildings_2_1k.hdr",shangai:"city/shanghai_bund_1k.hdr"},Zl="https://raw.githubusercontent.com/Tresjs/assets/main/textures/hdr/";async function Ei(o,e){const{scene:t}=oe.useTresContext(),{preset:n,blur:r,files:i=[],path:s="",background:a}=u.toRefs(o),c=u.ref(),h=u.computed(()=>Array.isArray(i.value)),f=u.computed(()=>h.value?l.CubeTextureLoader:Mi),d=u.ref(null);return u.watch(()=>[i,s],async([p,m])=>{if(p.value.length>0&&!n.value){try{d.value=await oe.useLoader(u.unref(f),h.value?[u.unref(p)]:u.unref(p),x=>{m.value&&x.setPath(u.unref(m))})}catch(x){throw new Error(`Failed to load environment map: ${x}`)}d.value&&(c.value=h.value?d.value[0]:d.value,c.value.mapping=h.value?l.CubeReflectionMapping:l.EquirectangularReflectionMapping)}},{immediate:!0}),u.watch(()=>c.value,p=>{t.value&&(t.value.environment=p)},{immediate:!0}),u.watch(()=>[a.value,c.value],([p,m])=>{if(t.value){let x=e!=null&&e.value?e.value.texture:m;t.value.background=p?x:void 0}},{immediate:!0}),u.watch(()=>r==null?void 0:r.value,p=>{t.value&&(t.value.backgroundBlurriness=p)},{immediate:!0}),u.watch(n,async p=>{if(p&&p in bn){const m=Zl,x=bn[p];try{d.value=await oe.useLoader(Mi,x,b=>{m&&b.setPath(m)})}catch(b){throw new Error(`Failed to load environment map: ${b}`)}d.value&&(c.value=d.value,c.value.mapping=l.EquirectangularReflectionMapping)}else if(p&&!(p in bn))throw new Error(`Preset must be one of: ${Object.keys(bn).join(", ")}`)},{immediate:!0}),{texture:c}}let Mn=null;function Kl(o,e){return t=>{e&&e(t),o.draco&&(Mn||(Mn=new $a),Mn.setDecoderPath(o.decoderPath||"https://www.gstatic.com/draco/versioned/decoders/1.4.3/"),t.setDRACOLoader(Mn))}}async function Wi(o,e={draco:!1},t){return await oe.useLoader(Zo,o,Kl(e,t))}const ql=["object"],Ql=u.defineComponent({__name:"component",props:{path:{},draco:{type:Boolean,default:!1},decoderPath:{default:"https://www.gstatic.com/draco/versioned/decoders/1.4.1/"},castShadow:{type:Boolean,default:!1},receiveShadow:{type:Boolean,default:!1}},async setup(o,{expose:e}){let t,n;const r=o,i=u.ref();e({value:i});const{scene:s}=([t,n]=u.withAsyncContext(()=>Wi(r.path,{draco:r.draco,decoderPath:r.decoderPath})),t=await t,n(),t);return(r.castShadow||r.receiveShadow)&&s.traverse(a=>{a.isMesh&&(a.castShadow=r.castShadow,a.receiveShadow=r.receiveShadow)}),(a,c)=>(u.openBlock(),u.createElementBlock("primitive",u.mergeProps({ref_key:"modelRef",ref:i,object:u.unref(s)},a.$attrs),null,16,ql))}});async function Yi(o){return await oe.useLoader(Ua,o)}const Jl=["object"],Hl=u.defineComponent({__name:"component",props:{path:{},castShadow:{type:Boolean,default:!1},receiveShadow:{type:Boolean,default:!1}},async setup(o,{expose:e}){let t,n;const r=o,i=u.ref();e({value:i});const s=([t,n]=u.withAsyncContext(()=>Yi(r.path)),t=await t,n(),t);return(r.castShadow||r.receiveShadow)&&s.traverse(a=>{a.isMesh&&(a.castShadow=r.castShadow,a.receiveShadow=r.receiveShadow)}),(a,c)=>(u.openBlock(),u.createElementBlock("primitive",u.mergeProps({ref_key:"modelRef",ref:i,object:u.unref(s)},a.$attrs),null,16,Jl))}}),$l=["geometry","render-order"],ec=u.defineComponent({__name:"component",props:{src:{},skipStrokes:{type:Boolean,default:!1},skipFills:{type:Boolean,default:!1},fillMaterial:{},strokeMaterial:{},fillMeshProps:{},strokeMeshProps:{},depth:{default:"renderOrder"}},setup(o,{expose:e}){const t=o,{src:n,skipStrokes:r,skipFills:i,fillMaterial:s,strokeMaterial:a,fillMeshProps:c,strokeMeshProps:h,depth:f}=u.toRefs(t),d=u.shallowRef(),p=u.shallowRef([]),m=u.shallowRef([]);e({value:d}),u.watchEffect(async()=>x(n.value).then(_=>m.value=_.paths)),u.watch([i,r,s,a,m],v);async function x(_){const T=_.startsWith("<svg")?encodeURI(`data:image/svg+xml;utf8,${_}`):_;return oe.useLoader(qt,T)}u.onUnmounted(b);function b(){p.value.forEach(_=>_.geometry.dispose())}function v(){var D,S,C;b();const _=[],[T,w]=(()=>{const y={flat:!1,renderOrder:!1,offsetZ:!0},A={flat:0,renderOrder:0,offsetZ:.025},g=f.value;return typeof g=="number"?[!0,g]:[y[g],A[g]]})();let M=0;for(const y of m.value){const A=((D=y.userData)==null?void 0:D.style)??{},g=Object.assign({color:A.fill,opacity:A.fillOpacity,transparent:!0,side:l.DoubleSide,depthWrite:T},t.fillMaterial);if(!i.value&&A.fill!==void 0&&A.fill!=="none")for(const I of qt.createShapes(y)){const k=new l.ShapeGeometry(I);k.scale(1,-1,1),w&&k.translate(0,0,M++*w),_.push({geometry:k,material:g,isStroke:!1})}if(!r.value&&A.stroke!==void 0&&A.stroke!=="none"){const I=Object.assign({color:(S=y.userData)==null?void 0:S.style.stroke,opacity:(C=y.userData)==null?void 0:C.style.strokeOpacity,transparent:!0,side:l.DoubleSide,depthWrite:T},t.strokeMaterial);for(const k of y.subPaths){const J=k.getPoints().map(Z=>new l.Vector2(Z.x,-Z.y)),G=qt.pointsToStroke(J,A||"none");w&&G.translate(0,0,M++*w),_.push({geometry:G,material:I,isStroke:!0})}}}p.value=_}return(_,T)=>(u.openBlock(),u.createElementBlock("TresGroup",{ref_key:"svgRef",ref:d},[(u.openBlock(!0),u.createElementBlock(u.Fragment,null,u.renderList(p.value,({geometry:w,material:M,isStroke:D},S)=>(u.openBlock(),u.createElementBlock("TresMesh",u.mergeProps({key:`${S}`},D?u.unref(h):u.unref(c),{geometry:w,"render-order":u.unref(f)==="renderOrder"?S:0}),[u.createElementVNode("TresMeshBasicMaterial",u.normalizeProps(u.guardReactiveProps(M)),null,16)],16,$l))),128))],512))}}),Xi="[TresJS - Cientos ▲ ■ ♥] ";function lr(){function o(n,r){console.error(`${Xi} ${n}`,r||"")}function e(n){console.warn(`${Xi} ${n}`)}function t(n,r){}return{logError:o,logWarning:e,logMessage:t}}let cr=0;function tc(){const o=u.ref(!1),e=u.ref(0),t=u.ref([]),{logError:n}=lr();return new Promise(r=>{l.DefaultLoadingManager.onStart=()=>{o.value=!1},l.DefaultLoadingManager.onLoad=()=>{o.value=!0},l.DefaultLoadingManager.onProgress=(i,s,a)=>{s===a&&(cr=a,o.value=!0,t.value.push(i)),e.value=Math.round((s-cr)/(a-cr)*100||100,2)},l.DefaultLoadingManager.onError=i=>{n("Error loading assets",new Error(i)),o.value=!0},r({items:t,hasFinishLoading:o,progress:e})})}async function nc(o,e){const{logError:t}=lr();if(!o)return t("Error no path provided");const{unsuspend:n,start:r,crossOrigin:i,muted:s,loop:a,...c}={unsuspend:"loadedmetadata",crossOrigin:"Anonymous",muted:!0,loop:!0,start:!0,playsInline:!0,...e};function h(){return new Promise((f,d)=>{const p=Object.assign(document.createElement("video"),{src:typeof o=="string"&&o||void 0,crossOrigin:i,loop:a,muted:s,autoplay:!0,...c}),m=new l.VideoTexture(p);return p.addEventListener(n,()=>f(m)),p.addEventListener("error",()=>d()),m})}try{const f=await h();return r&&f.image&&f.image.play(),f}catch{t("Error loading resource")}}const rc=["target","auto-rotate","auto-rotate-speed","enable-damping","damping-factor","enable-pan","key-pan-speed","keys","max-azimuth-angle","min-azimuth-angle","max-polar-angle","min-polar-angle","min-distance","max-distance","min-zoom","max-zoom","touches","enable-zoom","zoom-speed","enable-rotate","rotate-speed","args"],ic=u.defineComponent({__name:"OrbitControls",props:{makeDefault:{type:Boolean,default:!1},camera:{},domElement:{},target:{default:()=>[0,0,0]},enableDamping:{type:Boolean,default:!0},dampingFactor:{default:.05},autoRotate:{type:Boolean,default:!1},autoRotateSpeed:{default:2},enablePan:{type:Boolean,default:!0},keyPanSpeed:{default:7},keys:{},maxAzimuthAngle:{default:1/0},minAzimuthAngle:{default:-1/0},maxPolarAngle:{default:Math.PI},minPolarAngle:{default:0},minDistance:{default:0},maxDistance:{default:1/0},minZoom:{default:0},maxZoom:{default:1/0},touches:{default:()=>({ONE:l.TOUCH.ROTATE,TWO:l.TOUCH.DOLLY_PAN})},enableZoom:{type:Boolean,default:!0},zoomSpeed:{default:1},enableRotate:{type:Boolean,default:!0},rotateSpeed:{default:1}},emits:["change","start","end"],setup(o,{expose:e,emit:t}){const n=o,r=t,{makeDefault:i,autoRotate:s,autoRotateSpeed:a,enableDamping:c,dampingFactor:h,enablePan:f,keyPanSpeed:d,maxAzimuthAngle:p,minAzimuthAngle:m,maxPolarAngle:x,minPolarAngle:b,minDistance:v,maxDistance:_,minZoom:T,maxZoom:w,enableZoom:M,zoomSpeed:D,enableRotate:S,touches:C,rotateSpeed:y,target:A}=u.toRefs(n),{camera:g,renderer:I,extend:k,controls:J}=oe.useTresContext(),G=u.ref(null);k({OrbitControls:oi}),u.watch(G,K=>{Z(),K&&i.value?J.value=K:J.value=null});function Z(){Te(G.value,"change",()=>r("change",G.value)),Te(G.value,"start",()=>r("start",G.value)),Te(G.value,"end",()=>r("end",G.value))}const{onLoop:X}=oe.useRenderLoop();return X(()=>{G.value&&(c.value||s.value)&&G.value.update()}),u.onUnmounted(()=>{G.value&&G.value.dispose()}),e({value:G}),(K,Y)=>(K.camera||u.unref(g))&&(K.domElement||u.unref(I))?(u.openBlock(),u.createElementBlock("TresOrbitControls",{key:0,ref_key:"controlsRef",ref:G,target:u.unref(A),"auto-rotate":u.unref(s),"auto-rotate-speed":u.unref(a),"enable-damping":u.unref(c),"damping-factor":u.unref(h),"enable-pan":u.unref(f),"key-pan-speed":u.unref(d),keys:K.keys,"max-azimuth-angle":u.unref(p),"min-azimuth-angle":u.unref(m),"max-polar-angle":u.unref(x),"min-polar-angle":u.unref(b),"min-distance":u.unref(v),"max-distance":u.unref(_),"min-zoom":u.unref(T),"max-zoom":u.unref(w),touches:u.unref(C),"enable-zoom":u.unref(M),"zoom-speed":u.unref(D),"enable-rotate":u.unref(S),"rotate-speed":u.unref(y),args:[K.camera||u.unref(g),K.domElement||u.unref(I).domElement]},null,8,rc)):u.createCommentVNode("",!0)}}),sc=5,oc=6,ac=.3,lc=u.defineComponent({__name:"KeyboardControls",props:{forward:{default:()=>["w","W"]},back:{default:()=>["s","S"]},left:{default:()=>["a","A"]},right:{default:()=>["d","D"]},jump:{default:()=>[" "]},gravity:{default:9.8},moveSpeed:{default:.1},headBobbing:{type:Boolean,default:!1},is2D:{type:Boolean,default:!1}},setup(o){var g;const e=o,{forward:t,back:n,left:r,right:i,jump:s,gravity:a,moveSpeed:c,headBobbing:h,is2D:f}=u.toRefs(e),{camera:d,controls:p}=oe.useTresContext(),m=u.ref(0),x=u.ref(0),b=u.ref(!1),v=u.ref(!1),_=u.ref(0),T=u.shallowRef(),w=f.value?"y":"z",M=((g=d.value.position)==null?void 0:g.y)||0;At(t.value,()=>{b.value=!0,x.value=c.value},{eventName:"keydown"}),At(n.value,()=>{b.value=!0,x.value=-c.value},{eventName:"keydown"}),At([...t.value,...n.value],()=>{b.value=!1,x.value=0},{eventName:"keyup"}),At(r.value,()=>{b.value=!0,m.value=-c.value},{eventName:"keydown"}),At(i.value,()=>{b.value=!0,m.value=c.value},{eventName:"keydown"}),At([...r.value,...i.value],()=>{b.value=!1,m.value=0},{eventName:"keyup"}),At(s.value,()=>{v.value||(_.value=Date.now()),v.value=!0});const D=I=>b.value?Math.sin(I*sc)*ac+M:M,S=()=>(Date.now()-_.value)/1e3*3,C=I=>M+oc*I-.5*a.value*I**2,y=()=>{if(v.value){const I=C(S());return I<=M&&(v.value=!1),I}return 0},{onLoop:A}=oe.useRenderLoop();return A(({elapsed:I})=>{var k;p.value instanceof Kn&&((k=p.value)!=null&&k.isLocked)?(p.value.moveForward(x.value),p.value.moveRight(m.value),d.value.position&&(d.value.position.y=h.value?D(I):M,d.value.position.y+=y())):T.value.children.length>0&&!(p.value instanceof Kn)&&(T.value.position.x+=m.value,T.value.position[w]+=f.value?x.value:-x.value)}),(I,k)=>(u.openBlock(),u.createElementBlock("TresGroup",{ref_key:"wrapperRef",ref:T},[u.renderSlot(I.$slots,"default")],512))}}),cc=["object","args","mode","enabled","axis","translation-snap","rotation-snap","scale-snap","space","size","show-x","show-y","show-z"],uc=u.defineComponent({__name:"TransformControls",props:{object:{},camera:{},mode:{default:"translate"},enabled:{type:Boolean,default:!0},axis:{default:"XYZ"},translationSnap:{},rotationSnap:{},scaleSnap:{},space:{default:"world"},size:{default:1},showX:{type:Boolean,default:!0},showY:{type:Boolean,default:!0},showZ:{type:Boolean,default:!0}},emits:["dragging","change","mouseDown","mouseUp","objectChange"],setup(o,{emit:e}){const t=o,n=e,{object:r,mode:i,enabled:s,axis:a,translationSnap:c,rotationSnap:h,scaleSnap:f,space:d,size:p,showX:m,showY:x,showZ:b}=u.toRefs(t),v=u.shallowRef(),{controls:_,camera:T,renderer:w,extend:M}=oe.useTresContext();M({TransformControls:Fo});const D=C=>{_.value&&(_.value.enabled=!C.value),n("dragging",C.value)};function S(){Te(v.value,"change",()=>n("change")),Te(v.value,"dragging-changed",D),Te(v.value,"mouseDown",()=>n("mouseDown")),Te(v.value,"mouseUp",()=>n("mouseUp")),Te(v.value,"objectChange",()=>n("objectChange"))}return u.watchEffect(()=>{v.value&&S()}),u.onUnmounted(()=>{v.value&&v.value.dispose()}),(C,y)=>{var A;return(C.camera||u.unref(T))&&u.unref(w)?(u.openBlock(),u.createElementBlock("TresTransformControls",{ref_key:"controlsRef",ref:v,key:(A=C.camera||u.unref(T))==null?void 0:A.uuid,object:u.unref(r),args:[C.camera||u.unref(T),u.unref(w).domElement],mode:u.unref(i),enabled:u.unref(s),axis:u.unref(a),"translation-snap":u.unref(c),"rotation-snap":u.unref(h),"scale-snap":u.unref(f),space:u.unref(d),size:u.unref(p),"show-x":u.unref(m),"show-y":u.unref(x),"show-z":u.unref(b),visible:!0},null,8,cc)):u.createCommentVNode("",!0)}}}),hc=["args"],fc=u.defineComponent({__name:"PointerLockControls",props:{makeDefault:{type:Boolean,default:!1},camera:{},domElement:{},selector:{}},emits:["isLock","change"],setup(o,{expose:e,emit:t}){const n=o,r=t,{camera:i,renderer:s,extend:a,controls:c}=oe.useTresContext(),h=u.ref(null);let f;a({PointerLockControls:Kn});const d=p=>{r("isLock",p)};return u.watch(h,p=>{p&&n.makeDefault?c.value=p:c.value=null;const m=document.getElementById(n.selector||"");f=m||s.value.domElement,Te(c.value,"change",()=>r("change",c.value)),Te(f,"click",()=>{var x,b,v;(x=c.value)==null||x.lock(),(b=c.value)==null||b.addEventListener("lock",()=>d(!0)),(v=c.value)==null||v.addEventListener("unlock",()=>d(!1))})}),u.onUnmounted(()=>{var p,m;(p=c.value)==null||p.removeEventListener("lock",()=>d(!0)),(m=c.value)==null||m.removeEventListener("unlock",()=>d(!1)),h.value&&h.value.dispose()}),e({value:c}),(p,m)=>(p.camera||u.unref(i))&&(p.domElement||u.unref(s))?(u.openBlock(),u.createElementBlock("TresPointerLockControls",{key:0,ref_key:"controlsRef",ref:h,args:[p.camera||u.unref(i),p.domElement||u.unref(s).domElement]},null,8,hc)):u.createCommentVNode("",!0)}}),dc=["args"],pc=u.defineComponent({__name:"MapControls",props:{makeDefault:{type:Boolean,default:!1},camera:{},domElement:{}},setup(o){const e=o,{camera:t,renderer:n,extend:r,controls:i}=oe.useTresContext(),s=u.ref(null);return r({MapControls:Xo}),u.watch(i,a=>{a&&e.makeDefault?i.value=a:i.value=null}),u.onUnmounted(()=>{s.value&&s.value.dispose()}),(a,c)=>(a.camera||u.unref(t))&&(a.domElement||u.unref(n))?(u.openBlock(),u.createElementBlock("TresMapControls",{key:0,ref_key:"controlsRef",ref:s,args:[a.camera||u.unref(t),a.domElement||u.unref(n).domElement]},null,8,dc)):u.createCommentVNode("",!0)}}),mc=u.defineComponent({__name:"ScrollControls",props:{pages:{default:4},distance:{default:4},smoothScroll:{default:.1},horizontal:{type:Boolean,default:!1},htmlScroll:{type:Boolean,default:!1}},emits:["update:modelValue"],setup(o,{emit:e}){const t=o,n=e,{logWarning:r}=oe.useLogger();t.smoothScroll<0&&r("SmoothControl must be greater than zero"),t.pages<0&&r("Pages must be greater than zero");const{camera:i,controls:s,renderer:a}=oe.useTresContext(),c=u.shallowRef(),h=document.createElement("div"),{y:f}=Al(),{x:d,y:p,isScrolling:m}=bl(h),{height:x,width:b}=Di();let v=0;const _=u.ref(!1),T=u.ref(0),w=u.ref(0),M=u.ref(0),D=t.horizontal?"x":"y",S=u.watch(i,y=>{if(_.value){S();return}v=t.horizontal?(y==null?void 0:y.position.x)||0:(y==null?void 0:y.position.y)||0,_.value=!0},{immediate:!0});u.watch(m,y=>{s.value&&(s.value.enabled=!y)},{immediate:!0}),u.watch(f,y=>{!m.value&&!t.htmlScroll||(w.value=y/x.value/(M.value/x.value-1),T.value=-1*w.value,n("update:modelValue",w.value))}),u.watch(p,y=>{w.value=y/x.value/(M.value/x.value),T.value=-1*w.value,n("update:modelValue",w.value)}),u.watch(d,y=>{w.value=y/b.value/(M.value/b.value-1),T.value=+w.value,n("update:modelValue",w.value)}),u.watch(a,y=>{var g,I;const A=y==null?void 0:y.domElement;if(t.htmlScroll&&(y!=null&&y.domElement))A!=null&&A.style.width&&(A!=null&&A.style.position)&&(A!=null&&A.style.top)&&(A!=null&&A.style.left)&&(A.style.width="100%",A.style.position="fixed",A.style.zIndex=" -99999",A.style.top="0",A.style.left="0"),M.value=document.body.scrollHeight;else{const k=document.createElement("div"),J=document.createElement("div");h.style[t.horizontal?"overflowX":"overflowY"]="auto",h.style[t.horizontal?"overflowY":"overflowX"]="hidden",h.style.position="absolute",h.style.width="100%",h.style.height=" 100%",h.style.top="0",h.style.left="0",h.classList.add("scrollContainer"),k.style.position="sticky",k.style.top="0px",k.style.left="0px",k.style.width="100%",k.style.height="100%",k.style.overflow="hidden",h.appendChild(k),J.style.height=t.horizontal?"100%":`${x.value*t.pages}px`,J.style.width=t.horizontal?`${b.value*t.pages}px`:"100vw",J.style.pointerEvents="none",A.style.position="fixed",A.style.zIndex="0",A!=null&&A.style.width&&(A.style.width="100%"),h.appendChild(J),y.domElement.parentNode.style.position="relative",(I=(g=y==null?void 0:y.domElement)==null?void 0:g.parentNode)==null||I.appendChild(h),M.value=t.horizontal?b.value*t.pages:x.value*t.pages}},{immediate:!0});const{onLoop:C}=oe.useRenderLoop();return C(()=>{var y;if((y=i.value)!=null&&y.position){const A=(T.value*t.distance-i.value.position[D]+v)*t.smoothScroll;i.value.position[D]+=A,c.value.children.length>0&&(c.value.position[D]+=A)}}),(y,A)=>(u.openBlock(),u.createElementBlock("TresGroup",{ref_key:"wrapperRef",ref:c},[u.renderSlot(y.$slots,"default")],512))}});/*!
  * camera-controls
  * https://github.com/yomotsu/camera-controls
  * (c) 2017 @yomotsu
  * Released under the MIT License.
- */const de={LEFT:1,RIGHT:2,MIDDLE:4},$=Object.freeze({NONE:0,ROTATE:1,TRUCK:2,OFFSET:4,DOLLY:8,ZOOM:16,TOUCH_ROTATE:32,TOUCH_TRUCK:64,TOUCH_OFFSET:128,TOUCH_DOLLY:256,TOUCH_ZOOM:512,TOUCH_DOLLY_TRUCK:1024,TOUCH_DOLLY_OFFSET:2048,TOUCH_DOLLY_ROTATE:4096,TOUCH_ZOOM_TRUCK:8192,TOUCH_ZOOM_OFFSET:16384,TOUCH_ZOOM_ROTATE:32768}),Ft={NONE:0,IN:1,OUT:-1};function At(o){return o.isPerspectiveCamera}function mt(o){return o.isOrthographicCamera}const kt=Math.PI*2,Er=Math.PI/2,Yr=1e-5,qt=Math.PI/180;function Qe(o,e,t){return Math.max(e,Math.min(t,o))}function Ce(o,e=Yr){return Math.abs(o)<e}function Ae(o,e,t=Yr){return Ce(o-e,t)}function Xr(o,e){return Math.round(o/e)*e}function Qt(o){return isFinite(o)?o:o<0?-Number.MAX_VALUE:Number.MAX_VALUE}function Jt(o){return Math.abs(o)<Number.MAX_VALUE?o:o*(1/0)}function wn(o,e,t,n,s=1/0,r){n=Math.max(1e-4,n);const i=2/n,a=i*r,l=1/(1+a+.48*a*a+.235*a*a*a);let u=o-e;const h=e,d=s*n;u=Qe(u,-d,d),e=o-u;const y=(t.value+i*u)*r;t.value=(t.value-i*y)*l;let g=e+(u+y)*l;return h-o>0==g>h&&(g=h,t.value=(g-h)/r),g}function Wr(o,e,t,n,s=1/0,r,i){n=Math.max(1e-4,n);const a=2/n,l=a*r,u=1/(1+l+.48*l*l+.235*l*l*l);let h=e.x,d=e.y,y=e.z,g=o.x-h,x=o.y-d,w=o.z-y;const v=h,P=d,D=y,S=s*n,_=S*S,L=g*g+x*x+w*w;if(L>_){const Q=Math.sqrt(L);g=g/Q*S,x=x/Q*S,w=w/Q*S}h=o.x-g,d=o.y-x,y=o.z-w;const b=(t.x+a*g)*r,C=(t.y+a*x)*r,m=(t.z+a*w)*r;t.x=(t.x-a*b)*u,t.y=(t.y-a*C)*u,t.z=(t.z-a*m)*u,i.x=h+(g+b)*u,i.y=d+(x+C)*u,i.z=y+(w+m)*u;const M=v-o.x,p=P-o.y,I=D-o.z,F=i.x-v,J=i.y-P,G=i.z-D;return M*F+p*J+I*G>0&&(i.x=v,i.y=P,i.z=D,t.x=(i.x-v)/r,t.y=(i.y-P)/r,t.z=(i.z-D)/r),i}function ls(o,e){e.set(0,0),o.forEach(t=>{e.x+=t.clientX,e.y+=t.clientY}),e.x/=o.length,e.y/=o.length}function cs(o,e){return mt(o)?(console.warn(`${e} is not supported in OrthographicCamera`),!0):!1}class fc{constructor(){this._listeners={}}addEventListener(e,t){const n=this._listeners;n[e]===void 0&&(n[e]=[]),n[e].indexOf(t)===-1&&n[e].push(t)}hasEventListener(e,t){const n=this._listeners;return n[e]!==void 0&&n[e].indexOf(t)!==-1}removeEventListener(e,t){const s=this._listeners[e];if(s!==void 0){const r=s.indexOf(t);r!==-1&&s.splice(r,1)}}removeAllEventListeners(e){if(!e){this._listeners={};return}Array.isArray(this._listeners[e])&&(this._listeners[e].length=0)}dispatchEvent(e){const n=this._listeners[e.type];if(n!==void 0){e.target=this;const s=n.slice(0);for(let r=0,i=s.length;r<i;r++)s[r].call(this,e)}}}const dc="2.7.4",bn=1/8,Zr=typeof window<"u",pc=Zr&&/Mac/.test(navigator.platform),mc=!(Zr&&"PointerEvent"in window);let he,Kr,Mn,us,Re,ye,Me,Bt,Ht,$e,et,Pt,qr,Qr,Ze,$t,Ut,Jr,hs,Hr,fs,ds,Sn;class en extends fc{static install(e){he=e.THREE,Kr=Object.freeze(new he.Vector3(0,0,0)),Mn=Object.freeze(new he.Vector3(0,1,0)),us=Object.freeze(new he.Vector3(0,0,1)),Re=new he.Vector2,ye=new he.Vector3,Me=new he.Vector3,Bt=new he.Vector3,Ht=new he.Vector3,$e=new he.Vector3,et=new he.Vector3,Pt=new he.Vector3,qr=new he.Vector3,Qr=new he.Vector3,Ze=new he.Spherical,$t=new he.Spherical,Ut=new he.Box3,Jr=new he.Box3,hs=new he.Sphere,Hr=new he.Quaternion,fs=new he.Quaternion,ds=new he.Matrix4,Sn=new he.Raycaster}static get ACTION(){return $}constructor(e,t){super(),this.minPolarAngle=0,this.maxPolarAngle=Math.PI,this.minAzimuthAngle=-1/0,this.maxAzimuthAngle=1/0,this.minDistance=Number.EPSILON,this.maxDistance=1/0,this.infinityDolly=!1,this.minZoom=.01,this.maxZoom=1/0,this.smoothTime=.25,this.draggingSmoothTime=.125,this.maxSpeed=1/0,this.azimuthRotateSpeed=1,this.polarRotateSpeed=1,this.dollySpeed=1,this.dollyDragInverted=!1,this.truckSpeed=2,this.dollyToCursor=!1,this.dragToOffset=!1,this.verticalDragToForward=!1,this.boundaryFriction=0,this.restThreshold=.01,this.colliderMeshes=[],this.cancel=()=>{},this._enabled=!0,this._state=$.NONE,this._viewport=null,this._changedDolly=0,this._changedZoom=0,this._hasRested=!0,this._boundaryEnclosesCamera=!1,this._needsUpdate=!0,this._updatedLastTime=!1,this._elementRect=new DOMRect,this._isDragging=!1,this._dragNeedsUpdate=!0,this._activePointers=[],this._lockedPointer=null,this._interactiveArea=new DOMRect(0,0,1,1),this._isUserControllingRotate=!1,this._isUserControllingDolly=!1,this._isUserControllingTruck=!1,this._isUserControllingOffset=!1,this._isUserControllingZoom=!1,this._lastDollyDirection=Ft.NONE,this._thetaVelocity={value:0},this._phiVelocity={value:0},this._radiusVelocity={value:0},this._targetVelocity=new he.Vector3,this._focalOffsetVelocity=new he.Vector3,this._zoomVelocity={value:0},this._truckInternal=(_,L,b)=>{let C,m;if(At(this._camera)){const M=ye.copy(this._camera.position).sub(this._target),p=this._camera.getEffectiveFOV()*qt,I=M.length()*Math.tan(p*.5);C=this.truckSpeed*_*I/this._elementRect.height,m=this.truckSpeed*L*I/this._elementRect.height}else if(mt(this._camera)){const M=this._camera;C=_*(M.right-M.left)/M.zoom/this._elementRect.width,m=L*(M.top-M.bottom)/M.zoom/this._elementRect.height}else return;this.verticalDragToForward?(b?this.setFocalOffset(this._focalOffsetEnd.x+C,this._focalOffsetEnd.y,this._focalOffsetEnd.z,!0):this.truck(C,0,!0),this.forward(-m,!0)):b?this.setFocalOffset(this._focalOffsetEnd.x+C,this._focalOffsetEnd.y+m,this._focalOffsetEnd.z,!0):this.truck(C,m,!0)},this._rotateInternal=(_,L)=>{const b=kt*this.azimuthRotateSpeed*_/this._elementRect.height,C=kt*this.polarRotateSpeed*L/this._elementRect.height;this.rotate(b,C,!0)},this._dollyInternal=(_,L,b)=>{const C=Math.pow(.95,-_*this.dollySpeed),m=this._sphericalEnd.radius,M=this._sphericalEnd.radius*C,p=Qe(M,this.minDistance,this.maxDistance),I=p-M;this.infinityDolly&&this.dollyToCursor?this._dollyToNoClamp(M,!0):this.infinityDolly&&!this.dollyToCursor?(this.dollyInFixed(I,!0),this._dollyToNoClamp(p,!0)):this._dollyToNoClamp(p,!0),this.dollyToCursor&&(this._changedDolly+=(this.infinityDolly?M:p)-m,this._dollyControlCoord.set(L,b)),this._lastDollyDirection=Math.sign(-_)},this._zoomInternal=(_,L,b)=>{const C=Math.pow(.95,_*this.dollySpeed),m=this._zoom,M=this._zoom*C;this.zoomTo(M,!0),this.dollyToCursor&&(this._changedZoom+=M-m,this._dollyControlCoord.set(L,b))},typeof he>"u"&&console.error("camera-controls: `THREE` is undefined. You must first run `CameraControls.install( { THREE: THREE } )`. Check the docs for further information."),this._camera=e,this._yAxisUpSpace=new he.Quaternion().setFromUnitVectors(this._camera.up,Mn),this._yAxisUpSpaceInverse=this._yAxisUpSpace.clone().invert(),this._state=$.NONE,this._target=new he.Vector3,this._targetEnd=this._target.clone(),this._focalOffset=new he.Vector3,this._focalOffsetEnd=this._focalOffset.clone(),this._spherical=new he.Spherical().setFromVector3(ye.copy(this._camera.position).applyQuaternion(this._yAxisUpSpace)),this._sphericalEnd=this._spherical.clone(),this._lastDistance=this._spherical.radius,this._zoom=this._camera.zoom,this._zoomEnd=this._zoom,this._lastZoom=this._zoom,this._nearPlaneCorners=[new he.Vector3,new he.Vector3,new he.Vector3,new he.Vector3],this._updateNearPlaneCorners(),this._boundary=new he.Box3(new he.Vector3(-1/0,-1/0,-1/0),new he.Vector3(1/0,1/0,1/0)),this._cameraUp0=this._camera.up.clone(),this._target0=this._target.clone(),this._position0=this._camera.position.clone(),this._zoom0=this._zoom,this._focalOffset0=this._focalOffset.clone(),this._dollyControlCoord=new he.Vector2,this.mouseButtons={left:$.ROTATE,middle:$.DOLLY,right:$.TRUCK,wheel:At(this._camera)?$.DOLLY:mt(this._camera)?$.ZOOM:$.NONE},this.touches={one:$.TOUCH_ROTATE,two:At(this._camera)?$.TOUCH_DOLLY_TRUCK:mt(this._camera)?$.TOUCH_ZOOM_TRUCK:$.NONE,three:$.TOUCH_TRUCK};const n=new he.Vector2,s=new he.Vector2,r=new he.Vector2,i=_=>{if(!this._enabled||!this._domElement)return;if(this._interactiveArea.left!==0||this._interactiveArea.top!==0||this._interactiveArea.width!==1||this._interactiveArea.height!==1){const C=this._domElement.getBoundingClientRect(),m=_.clientX/C.width,M=_.clientY/C.height;if(m<this._interactiveArea.left||m>this._interactiveArea.right||M<this._interactiveArea.top||M>this._interactiveArea.bottom)return}const L=_.pointerType!=="mouse"?null:(_.buttons&de.LEFT)===de.LEFT?de.LEFT:(_.buttons&de.MIDDLE)===de.MIDDLE?de.MIDDLE:(_.buttons&de.RIGHT)===de.RIGHT?de.RIGHT:null;if(L!==null){const C=this._findPointerByMouseButton(L);C&&this._disposePointer(C)}if((_.buttons&de.LEFT)===de.LEFT&&this._lockedPointer)return;const b={pointerId:_.pointerId,clientX:_.clientX,clientY:_.clientY,deltaX:0,deltaY:0,mouseButton:L};this._activePointers.push(b),this._domElement.ownerDocument.removeEventListener("pointermove",l,{passive:!1}),this._domElement.ownerDocument.removeEventListener("pointerup",h),this._domElement.ownerDocument.addEventListener("pointermove",l,{passive:!1}),this._domElement.ownerDocument.addEventListener("pointerup",h),this._isDragging=!0,w(_)},a=_=>{if(!this._enabled||!this._domElement||this._lockedPointer)return;if(this._interactiveArea.left!==0||this._interactiveArea.top!==0||this._interactiveArea.width!==1||this._interactiveArea.height!==1){const C=this._domElement.getBoundingClientRect(),m=_.clientX/C.width,M=_.clientY/C.height;if(m<this._interactiveArea.left||m>this._interactiveArea.right||M<this._interactiveArea.top||M>this._interactiveArea.bottom)return}const L=(_.buttons&de.LEFT)===de.LEFT?de.LEFT:(_.buttons&de.MIDDLE)===de.MIDDLE?de.MIDDLE:(_.buttons&de.RIGHT)===de.RIGHT?de.RIGHT:null;if(L!==null){const C=this._findPointerByMouseButton(L);C&&this._disposePointer(C)}const b={pointerId:1,clientX:_.clientX,clientY:_.clientY,deltaX:0,deltaY:0,mouseButton:(_.buttons&de.LEFT)===de.LEFT?de.LEFT:(_.buttons&de.MIDDLE)===de.LEFT?de.MIDDLE:(_.buttons&de.RIGHT)===de.LEFT?de.RIGHT:null};this._activePointers.push(b),this._domElement.ownerDocument.removeEventListener("mousemove",u),this._domElement.ownerDocument.removeEventListener("mouseup",d),this._domElement.ownerDocument.addEventListener("mousemove",u),this._domElement.ownerDocument.addEventListener("mouseup",d),this._isDragging=!0,w(_)},l=_=>{_.cancelable&&_.preventDefault();const L=_.pointerId,b=this._lockedPointer||this._findPointerById(L);if(b){if(b.clientX=_.clientX,b.clientY=_.clientY,b.deltaX=_.movementX,b.deltaY=_.movementY,this._state=0,_.pointerType==="touch")switch(this._activePointers.length){case 1:this._state=this.touches.one;break;case 2:this._state=this.touches.two;break;case 3:this._state=this.touches.three;break}else(!this._isDragging&&this._lockedPointer||this._isDragging&&(_.buttons&de.LEFT)===de.LEFT)&&(this._state=this._state|this.mouseButtons.left),this._isDragging&&(_.buttons&de.MIDDLE)===de.MIDDLE&&(this._state=this._state|this.mouseButtons.middle),this._isDragging&&(_.buttons&de.RIGHT)===de.RIGHT&&(this._state=this._state|this.mouseButtons.right);v()}},u=_=>{const L=this._lockedPointer||this._findPointerById(1);L&&(L.clientX=_.clientX,L.clientY=_.clientY,L.deltaX=_.movementX,L.deltaY=_.movementY,this._state=0,(this._lockedPointer||(_.buttons&de.LEFT)===de.LEFT)&&(this._state=this._state|this.mouseButtons.left),(_.buttons&de.MIDDLE)===de.MIDDLE&&(this._state=this._state|this.mouseButtons.middle),(_.buttons&de.RIGHT)===de.RIGHT&&(this._state=this._state|this.mouseButtons.right),v())},h=_=>{const L=this._findPointerById(_.pointerId);if(!(L&&L===this._lockedPointer)){if(L&&this._disposePointer(L),_.pointerType==="touch")switch(this._activePointers.length){case 0:this._state=$.NONE;break;case 1:this._state=this.touches.one;break;case 2:this._state=this.touches.two;break;case 3:this._state=this.touches.three;break}else this._state=$.NONE;P()}},d=()=>{const _=this._findPointerById(1);_&&_===this._lockedPointer||(_&&this._disposePointer(_),this._state=$.NONE,P())};let y=-1;const g=_=>{if(!this._domElement||!this._enabled||this.mouseButtons.wheel===$.NONE)return;if(this._interactiveArea.left!==0||this._interactiveArea.top!==0||this._interactiveArea.width!==1||this._interactiveArea.height!==1){const M=this._domElement.getBoundingClientRect(),p=_.clientX/M.width,I=_.clientY/M.height;if(p<this._interactiveArea.left||p>this._interactiveArea.right||I<this._interactiveArea.top||I>this._interactiveArea.bottom)return}if(_.preventDefault(),this.dollyToCursor||this.mouseButtons.wheel===$.ROTATE||this.mouseButtons.wheel===$.TRUCK){const M=performance.now();y-M<1e3&&this._getClientRect(this._elementRect),y=M}const L=pc?-1:-3,b=_.deltaMode===1?_.deltaY/L:_.deltaY/(L*10),C=this.dollyToCursor?(_.clientX-this._elementRect.x)/this._elementRect.width*2-1:0,m=this.dollyToCursor?(_.clientY-this._elementRect.y)/this._elementRect.height*-2+1:0;switch(this.mouseButtons.wheel){case $.ROTATE:{this._rotateInternal(_.deltaX,_.deltaY),this._isUserControllingRotate=!0;break}case $.TRUCK:{this._truckInternal(_.deltaX,_.deltaY,!1),this._isUserControllingTruck=!0;break}case $.OFFSET:{this._truckInternal(_.deltaX,_.deltaY,!0),this._isUserControllingOffset=!0;break}case $.DOLLY:{this._dollyInternal(-b,C,m),this._isUserControllingDolly=!0;break}case $.ZOOM:{this._zoomInternal(-b,C,m),this._isUserControllingZoom=!0;break}}this.dispatchEvent({type:"control"})},x=_=>{if(!(!this._domElement||!this._enabled)){if(this.mouseButtons.right===en.ACTION.NONE){const L=_ instanceof PointerEvent?_.pointerId:(_ instanceof MouseEvent,0),b=this._findPointerById(L);b&&this._disposePointer(b),this._domElement.ownerDocument.removeEventListener("pointermove",l,{passive:!1}),this._domElement.ownerDocument.removeEventListener("pointerup",h),this._domElement.ownerDocument.removeEventListener("mousemove",u),this._domElement.ownerDocument.removeEventListener("mouseup",d);return}_.preventDefault()}},w=_=>{if(!this._enabled)return;if(ls(this._activePointers,Re),this._getClientRect(this._elementRect),n.copy(Re),s.copy(Re),this._activePointers.length>=2){const b=Re.x-this._activePointers[1].clientX,C=Re.y-this._activePointers[1].clientY,m=Math.sqrt(b*b+C*C);r.set(0,m);const M=(this._activePointers[0].clientX+this._activePointers[1].clientX)*.5,p=(this._activePointers[0].clientY+this._activePointers[1].clientY)*.5;s.set(M,p)}if(this._state=0,!_)this._lockedPointer&&(this._state=this._state|this.mouseButtons.left);else if("pointerType"in _&&_.pointerType==="touch")switch(this._activePointers.length){case 1:this._state=this.touches.one;break;case 2:this._state=this.touches.two;break;case 3:this._state=this.touches.three;break}else!this._lockedPointer&&(_.buttons&de.LEFT)===de.LEFT&&(this._state=this._state|this.mouseButtons.left),(_.buttons&de.MIDDLE)===de.MIDDLE&&(this._state=this._state|this.mouseButtons.middle),(_.buttons&de.RIGHT)===de.RIGHT&&(this._state=this._state|this.mouseButtons.right);((this._state&$.ROTATE)===$.ROTATE||(this._state&$.TOUCH_ROTATE)===$.TOUCH_ROTATE||(this._state&$.TOUCH_DOLLY_ROTATE)===$.TOUCH_DOLLY_ROTATE||(this._state&$.TOUCH_ZOOM_ROTATE)===$.TOUCH_ZOOM_ROTATE)&&(this._sphericalEnd.theta=this._spherical.theta,this._sphericalEnd.phi=this._spherical.phi,this._thetaVelocity.value=0,this._phiVelocity.value=0),((this._state&$.TRUCK)===$.TRUCK||(this._state&$.TOUCH_TRUCK)===$.TOUCH_TRUCK||(this._state&$.TOUCH_DOLLY_TRUCK)===$.TOUCH_DOLLY_TRUCK||(this._state&$.TOUCH_ZOOM_TRUCK)===$.TOUCH_ZOOM_TRUCK)&&(this._targetEnd.copy(this._target),this._targetVelocity.set(0,0,0)),((this._state&$.DOLLY)===$.DOLLY||(this._state&$.TOUCH_DOLLY)===$.TOUCH_DOLLY||(this._state&$.TOUCH_DOLLY_TRUCK)===$.TOUCH_DOLLY_TRUCK||(this._state&$.TOUCH_DOLLY_OFFSET)===$.TOUCH_DOLLY_OFFSET||(this._state&$.TOUCH_DOLLY_ROTATE)===$.TOUCH_DOLLY_ROTATE)&&(this._sphericalEnd.radius=this._spherical.radius,this._radiusVelocity.value=0),((this._state&$.ZOOM)===$.ZOOM||(this._state&$.TOUCH_ZOOM)===$.TOUCH_ZOOM||(this._state&$.TOUCH_ZOOM_TRUCK)===$.TOUCH_ZOOM_TRUCK||(this._state&$.TOUCH_ZOOM_OFFSET)===$.TOUCH_ZOOM_OFFSET||(this._state&$.TOUCH_ZOOM_ROTATE)===$.TOUCH_ZOOM_ROTATE)&&(this._zoomEnd=this._zoom,this._zoomVelocity.value=0),((this._state&$.OFFSET)===$.OFFSET||(this._state&$.TOUCH_OFFSET)===$.TOUCH_OFFSET||(this._state&$.TOUCH_DOLLY_OFFSET)===$.TOUCH_DOLLY_OFFSET||(this._state&$.TOUCH_ZOOM_OFFSET)===$.TOUCH_ZOOM_OFFSET)&&(this._focalOffsetEnd.copy(this._focalOffset),this._focalOffsetVelocity.set(0,0,0)),this.dispatchEvent({type:"controlstart"})},v=()=>{if(!this._enabled||!this._dragNeedsUpdate)return;this._dragNeedsUpdate=!1,ls(this._activePointers,Re);const L=this._domElement&&document.pointerLockElement===this._domElement?this._lockedPointer||this._activePointers[0]:null,b=L?-L.deltaX:s.x-Re.x,C=L?-L.deltaY:s.y-Re.y;if(s.copy(Re),((this._state&$.ROTATE)===$.ROTATE||(this._state&$.TOUCH_ROTATE)===$.TOUCH_ROTATE||(this._state&$.TOUCH_DOLLY_ROTATE)===$.TOUCH_DOLLY_ROTATE||(this._state&$.TOUCH_ZOOM_ROTATE)===$.TOUCH_ZOOM_ROTATE)&&(this._rotateInternal(b,C),this._isUserControllingRotate=!0),(this._state&$.DOLLY)===$.DOLLY||(this._state&$.ZOOM)===$.ZOOM){const m=this.dollyToCursor?(n.x-this._elementRect.x)/this._elementRect.width*2-1:0,M=this.dollyToCursor?(n.y-this._elementRect.y)/this._elementRect.height*-2+1:0,p=this.dollyDragInverted?-1:1;(this._state&$.DOLLY)===$.DOLLY?(this._dollyInternal(p*C*bn,m,M),this._isUserControllingDolly=!0):(this._zoomInternal(p*C*bn,m,M),this._isUserControllingZoom=!0)}if((this._state&$.TOUCH_DOLLY)===$.TOUCH_DOLLY||(this._state&$.TOUCH_ZOOM)===$.TOUCH_ZOOM||(this._state&$.TOUCH_DOLLY_TRUCK)===$.TOUCH_DOLLY_TRUCK||(this._state&$.TOUCH_ZOOM_TRUCK)===$.TOUCH_ZOOM_TRUCK||(this._state&$.TOUCH_DOLLY_OFFSET)===$.TOUCH_DOLLY_OFFSET||(this._state&$.TOUCH_ZOOM_OFFSET)===$.TOUCH_ZOOM_OFFSET||(this._state&$.TOUCH_DOLLY_ROTATE)===$.TOUCH_DOLLY_ROTATE||(this._state&$.TOUCH_ZOOM_ROTATE)===$.TOUCH_ZOOM_ROTATE){const m=Re.x-this._activePointers[1].clientX,M=Re.y-this._activePointers[1].clientY,p=Math.sqrt(m*m+M*M),I=r.y-p;r.set(0,p);const F=this.dollyToCursor?(s.x-this._elementRect.x)/this._elementRect.width*2-1:0,J=this.dollyToCursor?(s.y-this._elementRect.y)/this._elementRect.height*-2+1:0;(this._state&$.TOUCH_DOLLY)===$.TOUCH_DOLLY||(this._state&$.TOUCH_DOLLY_ROTATE)===$.TOUCH_DOLLY_ROTATE||(this._state&$.TOUCH_DOLLY_TRUCK)===$.TOUCH_DOLLY_TRUCK||(this._state&$.TOUCH_DOLLY_OFFSET)===$.TOUCH_DOLLY_OFFSET?(this._dollyInternal(I*bn,F,J),this._isUserControllingDolly=!0):(this._zoomInternal(I*bn,F,J),this._isUserControllingZoom=!0)}((this._state&$.TRUCK)===$.TRUCK||(this._state&$.TOUCH_TRUCK)===$.TOUCH_TRUCK||(this._state&$.TOUCH_DOLLY_TRUCK)===$.TOUCH_DOLLY_TRUCK||(this._state&$.TOUCH_ZOOM_TRUCK)===$.TOUCH_ZOOM_TRUCK)&&(this._truckInternal(b,C,!1),this._isUserControllingTruck=!0),((this._state&$.OFFSET)===$.OFFSET||(this._state&$.TOUCH_OFFSET)===$.TOUCH_OFFSET||(this._state&$.TOUCH_DOLLY_OFFSET)===$.TOUCH_DOLLY_OFFSET||(this._state&$.TOUCH_ZOOM_OFFSET)===$.TOUCH_ZOOM_OFFSET)&&(this._truckInternal(b,C,!0),this._isUserControllingOffset=!0),this.dispatchEvent({type:"control"})},P=()=>{ls(this._activePointers,Re),s.copy(Re),this._dragNeedsUpdate=!1,(this._activePointers.length===0||this._activePointers.length===1&&this._activePointers[0]===this._lockedPointer)&&(this._isDragging=!1),this._activePointers.length===0&&this._domElement&&(this._domElement.ownerDocument.removeEventListener("pointermove",l,{passive:!1}),this._domElement.ownerDocument.removeEventListener("mousemove",u),this._domElement.ownerDocument.removeEventListener("pointerup",h),this._domElement.ownerDocument.removeEventListener("mouseup",d),this.dispatchEvent({type:"controlend"}))};this.lockPointer=()=>{!this._enabled||!this._domElement||(this.cancel(),this._lockedPointer={pointerId:-1,clientX:0,clientY:0,deltaX:0,deltaY:0,mouseButton:null},this._activePointers.push(this._lockedPointer),this._domElement.ownerDocument.removeEventListener("pointermove",l,{passive:!1}),this._domElement.ownerDocument.removeEventListener("pointerup",h),this._domElement.requestPointerLock(),this._domElement.ownerDocument.addEventListener("pointerlockchange",D),this._domElement.ownerDocument.addEventListener("pointerlockerror",S),this._domElement.ownerDocument.addEventListener("pointermove",l,{passive:!1}),this._domElement.ownerDocument.addEventListener("pointerup",h),w())},this.unlockPointer=()=>{this._lockedPointer!==null&&(this._disposePointer(this._lockedPointer),this._lockedPointer=null),document.exitPointerLock(),this.cancel(),this._domElement&&(this._domElement.ownerDocument.removeEventListener("pointerlockchange",D),this._domElement.ownerDocument.removeEventListener("pointerlockerror",S))};const D=()=>{this._domElement&&this._domElement.ownerDocument.pointerLockElement===this._domElement||this.unlockPointer()},S=()=>{this.unlockPointer()};this._addAllEventListeners=_=>{this._domElement=_,this._domElement.style.touchAction="none",this._domElement.style.userSelect="none",this._domElement.style.webkitUserSelect="none",this._domElement.addEventListener("pointerdown",i),mc&&this._domElement.addEventListener("mousedown",a),this._domElement.addEventListener("pointercancel",h),this._domElement.addEventListener("wheel",g,{passive:!1}),this._domElement.addEventListener("contextmenu",x)},this._removeAllEventListeners=()=>{this._domElement&&(this._domElement.style.touchAction="",this._domElement.style.userSelect="",this._domElement.style.webkitUserSelect="",this._domElement.removeEventListener("pointerdown",i),this._domElement.removeEventListener("mousedown",a),this._domElement.removeEventListener("pointercancel",h),this._domElement.removeEventListener("wheel",g,{passive:!1}),this._domElement.removeEventListener("contextmenu",x),this._domElement.ownerDocument.removeEventListener("pointermove",l,{passive:!1}),this._domElement.ownerDocument.removeEventListener("mousemove",u),this._domElement.ownerDocument.removeEventListener("pointerup",h),this._domElement.ownerDocument.removeEventListener("mouseup",d),this._domElement.ownerDocument.removeEventListener("pointerlockchange",D),this._domElement.ownerDocument.removeEventListener("pointerlockerror",S))},this.cancel=()=>{this._state!==$.NONE&&(this._state=$.NONE,this._activePointers.length=0,P())},t&&this.connect(t),this.update(0)}get camera(){return this._camera}set camera(e){this._camera=e,this.updateCameraUp(),this._camera.updateProjectionMatrix(),this._updateNearPlaneCorners(),this._needsUpdate=!0}get enabled(){return this._enabled}set enabled(e){this._enabled=e,this._domElement&&(e?(this._domElement.style.touchAction="none",this._domElement.style.userSelect="none",this._domElement.style.webkitUserSelect="none"):(this.cancel(),this._domElement.style.touchAction="",this._domElement.style.userSelect="",this._domElement.style.webkitUserSelect=""))}get active(){return!this._hasRested}get currentAction(){return this._state}get distance(){return this._spherical.radius}set distance(e){this._spherical.radius===e&&this._sphericalEnd.radius===e||(this._spherical.radius=e,this._sphericalEnd.radius=e,this._needsUpdate=!0)}get azimuthAngle(){return this._spherical.theta}set azimuthAngle(e){this._spherical.theta===e&&this._sphericalEnd.theta===e||(this._spherical.theta=e,this._sphericalEnd.theta=e,this._needsUpdate=!0)}get polarAngle(){return this._spherical.phi}set polarAngle(e){this._spherical.phi===e&&this._sphericalEnd.phi===e||(this._spherical.phi=e,this._sphericalEnd.phi=e,this._needsUpdate=!0)}get boundaryEnclosesCamera(){return this._boundaryEnclosesCamera}set boundaryEnclosesCamera(e){this._boundaryEnclosesCamera=e,this._needsUpdate=!0}set interactiveArea(e){this._interactiveArea.width=Qe(e.width,0,1),this._interactiveArea.height=Qe(e.height,0,1),this._interactiveArea.x=Qe(e.x,0,1-this._interactiveArea.width),this._interactiveArea.y=Qe(e.y,0,1-this._interactiveArea.height)}addEventListener(e,t){super.addEventListener(e,t)}removeEventListener(e,t){super.removeEventListener(e,t)}rotate(e,t,n=!1){return this.rotateTo(this._sphericalEnd.theta+e,this._sphericalEnd.phi+t,n)}rotateAzimuthTo(e,t=!1){return this.rotateTo(e,this._sphericalEnd.phi,t)}rotatePolarTo(e,t=!1){return this.rotateTo(this._sphericalEnd.theta,e,t)}rotateTo(e,t,n=!1){this._isUserControllingRotate=!1;const s=Qe(e,this.minAzimuthAngle,this.maxAzimuthAngle),r=Qe(t,this.minPolarAngle,this.maxPolarAngle);this._sphericalEnd.theta=s,this._sphericalEnd.phi=r,this._sphericalEnd.makeSafe(),this._needsUpdate=!0,n||(this._spherical.theta=this._sphericalEnd.theta,this._spherical.phi=this._sphericalEnd.phi);const i=!n||Ae(this._spherical.theta,this._sphericalEnd.theta,this.restThreshold)&&Ae(this._spherical.phi,this._sphericalEnd.phi,this.restThreshold);return this._createOnRestPromise(i)}dolly(e,t=!1){return this.dollyTo(this._sphericalEnd.radius-e,t)}dollyTo(e,t=!1){return this._isUserControllingDolly=!1,this._lastDollyDirection=Ft.NONE,this._changedDolly=0,this._dollyToNoClamp(Qe(e,this.minDistance,this.maxDistance),t)}_dollyToNoClamp(e,t=!1){const n=this._sphericalEnd.radius;if(this.colliderMeshes.length>=1){const i=this._collisionTest(),a=Ae(i,this._spherical.radius);if(!(n>e)&&a)return Promise.resolve();this._sphericalEnd.radius=Math.min(e,i)}else this._sphericalEnd.radius=e;this._needsUpdate=!0,t||(this._spherical.radius=this._sphericalEnd.radius);const r=!t||Ae(this._spherical.radius,this._sphericalEnd.radius,this.restThreshold);return this._createOnRestPromise(r)}dollyInFixed(e,t=!1){this._targetEnd.add(this._getCameraDirection(Ht).multiplyScalar(e)),t||this._target.copy(this._targetEnd);const n=!t||Ae(this._target.x,this._targetEnd.x,this.restThreshold)&&Ae(this._target.y,this._targetEnd.y,this.restThreshold)&&Ae(this._target.z,this._targetEnd.z,this.restThreshold);return this._createOnRestPromise(n)}zoom(e,t=!1){return this.zoomTo(this._zoomEnd+e,t)}zoomTo(e,t=!1){this._isUserControllingZoom=!1,this._zoomEnd=Qe(e,this.minZoom,this.maxZoom),this._needsUpdate=!0,t||(this._zoom=this._zoomEnd);const n=!t||Ae(this._zoom,this._zoomEnd,this.restThreshold);return this._changedZoom=0,this._createOnRestPromise(n)}pan(e,t,n=!1){return console.warn("`pan` has been renamed to `truck`"),this.truck(e,t,n)}truck(e,t,n=!1){this._camera.updateMatrix(),$e.setFromMatrixColumn(this._camera.matrix,0),et.setFromMatrixColumn(this._camera.matrix,1),$e.multiplyScalar(e),et.multiplyScalar(-t);const s=ye.copy($e).add(et),r=Me.copy(this._targetEnd).add(s);return this.moveTo(r.x,r.y,r.z,n)}forward(e,t=!1){ye.setFromMatrixColumn(this._camera.matrix,0),ye.crossVectors(this._camera.up,ye),ye.multiplyScalar(e);const n=Me.copy(this._targetEnd).add(ye);return this.moveTo(n.x,n.y,n.z,t)}elevate(e,t=!1){return ye.copy(this._camera.up).multiplyScalar(e),this.moveTo(this._targetEnd.x+ye.x,this._targetEnd.y+ye.y,this._targetEnd.z+ye.z,t)}moveTo(e,t,n,s=!1){this._isUserControllingTruck=!1;const r=ye.set(e,t,n).sub(this._targetEnd);this._encloseToBoundary(this._targetEnd,r,this.boundaryFriction),this._needsUpdate=!0,s||this._target.copy(this._targetEnd);const i=!s||Ae(this._target.x,this._targetEnd.x,this.restThreshold)&&Ae(this._target.y,this._targetEnd.y,this.restThreshold)&&Ae(this._target.z,this._targetEnd.z,this.restThreshold);return this._createOnRestPromise(i)}lookInDirectionOf(e,t,n,s=!1){const a=ye.set(e,t,n).sub(this._targetEnd).normalize().multiplyScalar(-this._sphericalEnd.radius).add(this._targetEnd);return this.setPosition(a.x,a.y,a.z,s)}fitToBox(e,t,{cover:n=!1,paddingLeft:s=0,paddingRight:r=0,paddingBottom:i=0,paddingTop:a=0}={}){const l=[],u=e.isBox3?Ut.copy(e):Ut.setFromObject(e);u.isEmpty()&&(console.warn("camera-controls: fitTo() cannot be used with an empty box. Aborting"),Promise.resolve());const h=Xr(this._sphericalEnd.theta,Er),d=Xr(this._sphericalEnd.phi,Er);l.push(this.rotateTo(h,d,t));const y=ye.setFromSpherical(this._sphericalEnd).normalize(),g=Hr.setFromUnitVectors(y,us),x=Ae(Math.abs(y.y),1);x&&g.multiply(fs.setFromAxisAngle(Mn,h)),g.multiply(this._yAxisUpSpaceInverse);const w=Jr.makeEmpty();Me.copy(u.min).applyQuaternion(g),w.expandByPoint(Me),Me.copy(u.min).setX(u.max.x).applyQuaternion(g),w.expandByPoint(Me),Me.copy(u.min).setY(u.max.y).applyQuaternion(g),w.expandByPoint(Me),Me.copy(u.max).setZ(u.min.z).applyQuaternion(g),w.expandByPoint(Me),Me.copy(u.min).setZ(u.max.z).applyQuaternion(g),w.expandByPoint(Me),Me.copy(u.max).setY(u.min.y).applyQuaternion(g),w.expandByPoint(Me),Me.copy(u.max).setX(u.min.x).applyQuaternion(g),w.expandByPoint(Me),Me.copy(u.max).applyQuaternion(g),w.expandByPoint(Me),w.min.x-=s,w.min.y-=i,w.max.x+=r,w.max.y+=a,g.setFromUnitVectors(us,y),x&&g.premultiply(fs.invert()),g.premultiply(this._yAxisUpSpace);const v=w.getSize(ye),P=w.getCenter(Me).applyQuaternion(g);if(At(this._camera)){const D=this.getDistanceToFitBox(v.x,v.y,v.z,n);l.push(this.moveTo(P.x,P.y,P.z,t)),l.push(this.dollyTo(D,t)),l.push(this.setFocalOffset(0,0,0,t))}else if(mt(this._camera)){const D=this._camera,S=D.right-D.left,_=D.top-D.bottom,L=n?Math.max(S/v.x,_/v.y):Math.min(S/v.x,_/v.y);l.push(this.moveTo(P.x,P.y,P.z,t)),l.push(this.zoomTo(L,t)),l.push(this.setFocalOffset(0,0,0,t))}return Promise.all(l)}fitToSphere(e,t){const n=[],r=e instanceof he.Sphere?hs.copy(e):en.createBoundingSphere(e,hs);if(n.push(this.moveTo(r.center.x,r.center.y,r.center.z,t)),At(this._camera)){const i=this.getDistanceToFitSphere(r.radius);n.push(this.dollyTo(i,t))}else if(mt(this._camera)){const i=this._camera.right-this._camera.left,a=this._camera.top-this._camera.bottom,l=2*r.radius,u=Math.min(i/l,a/l);n.push(this.zoomTo(u,t))}return n.push(this.setFocalOffset(0,0,0,t)),Promise.all(n)}setLookAt(e,t,n,s,r,i,a=!1){this._isUserControllingRotate=!1,this._isUserControllingDolly=!1,this._isUserControllingTruck=!1,this._lastDollyDirection=Ft.NONE,this._changedDolly=0;const l=Me.set(s,r,i),u=ye.set(e,t,n);this._targetEnd.copy(l),this._sphericalEnd.setFromVector3(u.sub(l).applyQuaternion(this._yAxisUpSpace)),this.normalizeRotations(),this._needsUpdate=!0,a||(this._target.copy(this._targetEnd),this._spherical.copy(this._sphericalEnd));const h=!a||Ae(this._target.x,this._targetEnd.x,this.restThreshold)&&Ae(this._target.y,this._targetEnd.y,this.restThreshold)&&Ae(this._target.z,this._targetEnd.z,this.restThreshold)&&Ae(this._spherical.theta,this._sphericalEnd.theta,this.restThreshold)&&Ae(this._spherical.phi,this._sphericalEnd.phi,this.restThreshold)&&Ae(this._spherical.radius,this._sphericalEnd.radius,this.restThreshold);return this._createOnRestPromise(h)}lerpLookAt(e,t,n,s,r,i,a,l,u,h,d,y,g,x=!1){this._isUserControllingRotate=!1,this._isUserControllingDolly=!1,this._isUserControllingTruck=!1,this._lastDollyDirection=Ft.NONE,this._changedDolly=0;const w=ye.set(s,r,i),v=Me.set(e,t,n);Ze.setFromVector3(v.sub(w).applyQuaternion(this._yAxisUpSpace));const P=Bt.set(h,d,y),D=Me.set(a,l,u);$t.setFromVector3(D.sub(P).applyQuaternion(this._yAxisUpSpace)),this._targetEnd.copy(w.lerp(P,g));const S=$t.theta-Ze.theta,_=$t.phi-Ze.phi,L=$t.radius-Ze.radius;this._sphericalEnd.set(Ze.radius+L*g,Ze.phi+_*g,Ze.theta+S*g),this.normalizeRotations(),this._needsUpdate=!0,x||(this._target.copy(this._targetEnd),this._spherical.copy(this._sphericalEnd));const b=!x||Ae(this._target.x,this._targetEnd.x,this.restThreshold)&&Ae(this._target.y,this._targetEnd.y,this.restThreshold)&&Ae(this._target.z,this._targetEnd.z,this.restThreshold)&&Ae(this._spherical.theta,this._sphericalEnd.theta,this.restThreshold)&&Ae(this._spherical.phi,this._sphericalEnd.phi,this.restThreshold)&&Ae(this._spherical.radius,this._sphericalEnd.radius,this.restThreshold);return this._createOnRestPromise(b)}setPosition(e,t,n,s=!1){return this.setLookAt(e,t,n,this._targetEnd.x,this._targetEnd.y,this._targetEnd.z,s)}setTarget(e,t,n,s=!1){const r=this.getPosition(ye),i=this.setLookAt(r.x,r.y,r.z,e,t,n,s);return this._sphericalEnd.phi=Qe(this._sphericalEnd.phi,this.minPolarAngle,this.maxPolarAngle),i}setFocalOffset(e,t,n,s=!1){this._isUserControllingOffset=!1,this._focalOffsetEnd.set(e,t,n),this._needsUpdate=!0,s||this._focalOffset.copy(this._focalOffsetEnd);const r=!s||Ae(this._focalOffset.x,this._focalOffsetEnd.x,this.restThreshold)&&Ae(this._focalOffset.y,this._focalOffsetEnd.y,this.restThreshold)&&Ae(this._focalOffset.z,this._focalOffsetEnd.z,this.restThreshold);return this._createOnRestPromise(r)}setOrbitPoint(e,t,n){this._camera.updateMatrixWorld(),$e.setFromMatrixColumn(this._camera.matrixWorldInverse,0),et.setFromMatrixColumn(this._camera.matrixWorldInverse,1),Pt.setFromMatrixColumn(this._camera.matrixWorldInverse,2);const s=ye.set(e,t,n),r=s.distanceTo(this._camera.position),i=s.sub(this._camera.position);$e.multiplyScalar(i.x),et.multiplyScalar(i.y),Pt.multiplyScalar(i.z),ye.copy($e).add(et).add(Pt),ye.z=ye.z+r,this.dollyTo(r,!1),this.setFocalOffset(-ye.x,ye.y,-ye.z,!1),this.moveTo(e,t,n,!1)}setBoundary(e){if(!e){this._boundary.min.set(-1/0,-1/0,-1/0),this._boundary.max.set(1/0,1/0,1/0),this._needsUpdate=!0;return}this._boundary.copy(e),this._boundary.clampPoint(this._targetEnd,this._targetEnd),this._needsUpdate=!0}setViewport(e,t,n,s){if(e===null){this._viewport=null;return}this._viewport=this._viewport||new he.Vector4,typeof e=="number"?this._viewport.set(e,t,n,s):this._viewport.copy(e)}getDistanceToFitBox(e,t,n,s=!1){if(cs(this._camera,"getDistanceToFitBox"))return this._spherical.radius;const r=e/t,i=this._camera.getEffectiveFOV()*qt,a=this._camera.aspect;return((s?r>a:r<a)?t:e/a)*.5/Math.tan(i*.5)+n*.5}getDistanceToFitSphere(e){if(cs(this._camera,"getDistanceToFitSphere"))return this._spherical.radius;const t=this._camera.getEffectiveFOV()*qt,n=Math.atan(Math.tan(t*.5)*this._camera.aspect)*2,s=1<this._camera.aspect?t:n;return e/Math.sin(s*.5)}getTarget(e,t=!0){return(e&&e.isVector3?e:new he.Vector3).copy(t?this._targetEnd:this._target)}getPosition(e,t=!0){return(e&&e.isVector3?e:new he.Vector3).setFromSpherical(t?this._sphericalEnd:this._spherical).applyQuaternion(this._yAxisUpSpaceInverse).add(t?this._targetEnd:this._target)}getSpherical(e,t=!0){return(e&&e instanceof he.Spherical?e:new he.Spherical).copy(t?this._sphericalEnd:this._spherical)}getFocalOffset(e,t=!0){return(e&&e.isVector3?e:new he.Vector3).copy(t?this._focalOffsetEnd:this._focalOffset)}normalizeRotations(){this._sphericalEnd.theta=this._sphericalEnd.theta%kt,this._sphericalEnd.theta<0&&(this._sphericalEnd.theta+=kt),this._spherical.theta+=kt*Math.round((this._sphericalEnd.theta-this._spherical.theta)/kt)}reset(e=!1){if(!Ae(this._camera.up.x,this._cameraUp0.x)||!Ae(this._camera.up.y,this._cameraUp0.y)||!Ae(this._camera.up.z,this._cameraUp0.z)){this._camera.up.copy(this._cameraUp0);const n=this.getPosition(ye);this.updateCameraUp(),this.setPosition(n.x,n.y,n.z)}const t=[this.setLookAt(this._position0.x,this._position0.y,this._position0.z,this._target0.x,this._target0.y,this._target0.z,e),this.setFocalOffset(this._focalOffset0.x,this._focalOffset0.y,this._focalOffset0.z,e),this.zoomTo(this._zoom0,e)];return Promise.all(t)}saveState(){this._cameraUp0.copy(this._camera.up),this.getTarget(this._target0),this.getPosition(this._position0),this._zoom0=this._zoom,this._focalOffset0.copy(this._focalOffset)}updateCameraUp(){this._yAxisUpSpace.setFromUnitVectors(this._camera.up,Mn),this._yAxisUpSpaceInverse.copy(this._yAxisUpSpace).invert()}applyCameraUp(){const e=ye.subVectors(this._target,this._camera.position).normalize(),t=Me.crossVectors(e,this._camera.up);this._camera.up.crossVectors(t,e).normalize(),this._camera.updateMatrixWorld();const n=this.getPosition(ye);this.updateCameraUp(),this.setPosition(n.x,n.y,n.z)}update(e){const t=this._sphericalEnd.theta-this._spherical.theta,n=this._sphericalEnd.phi-this._spherical.phi,s=this._sphericalEnd.radius-this._spherical.radius,r=qr.subVectors(this._targetEnd,this._target),i=Qr.subVectors(this._focalOffsetEnd,this._focalOffset),a=this._zoomEnd-this._zoom;if(Ce(t))this._thetaVelocity.value=0,this._spherical.theta=this._sphericalEnd.theta;else{const d=this._isUserControllingRotate?this.draggingSmoothTime:this.smoothTime;this._spherical.theta=wn(this._spherical.theta,this._sphericalEnd.theta,this._thetaVelocity,d,1/0,e),this._needsUpdate=!0}if(Ce(n))this._phiVelocity.value=0,this._spherical.phi=this._sphericalEnd.phi;else{const d=this._isUserControllingRotate?this.draggingSmoothTime:this.smoothTime;this._spherical.phi=wn(this._spherical.phi,this._sphericalEnd.phi,this._phiVelocity,d,1/0,e),this._needsUpdate=!0}if(Ce(s))this._radiusVelocity.value=0,this._spherical.radius=this._sphericalEnd.radius;else{const d=this._isUserControllingDolly?this.draggingSmoothTime:this.smoothTime;this._spherical.radius=wn(this._spherical.radius,this._sphericalEnd.radius,this._radiusVelocity,d,this.maxSpeed,e),this._needsUpdate=!0}if(Ce(r.x)&&Ce(r.y)&&Ce(r.z))this._targetVelocity.set(0,0,0),this._target.copy(this._targetEnd);else{const d=this._isUserControllingTruck?this.draggingSmoothTime:this.smoothTime;Wr(this._target,this._targetEnd,this._targetVelocity,d,this.maxSpeed,e,this._target),this._needsUpdate=!0}if(Ce(i.x)&&Ce(i.y)&&Ce(i.z))this._focalOffsetVelocity.set(0,0,0),this._focalOffset.copy(this._focalOffsetEnd);else{const d=this._isUserControllingOffset?this.draggingSmoothTime:this.smoothTime;Wr(this._focalOffset,this._focalOffsetEnd,this._focalOffsetVelocity,d,this.maxSpeed,e,this._focalOffset),this._needsUpdate=!0}if(Ce(a))this._zoomVelocity.value=0,this._zoom=this._zoomEnd;else{const d=this._isUserControllingZoom?this.draggingSmoothTime:this.smoothTime;this._zoom=wn(this._zoom,this._zoomEnd,this._zoomVelocity,d,1/0,e)}if(this.dollyToCursor){if(At(this._camera)&&this._changedDolly!==0){const d=this._spherical.radius-this._lastDistance,y=this._camera,g=this._getCameraDirection(Ht),x=ye.copy(g).cross(y.up).normalize();x.lengthSq()===0&&(x.x=1);const w=Me.crossVectors(x,g),v=this._sphericalEnd.radius*Math.tan(y.getEffectiveFOV()*qt*.5),D=(this._sphericalEnd.radius-d-this._sphericalEnd.radius)/this._sphericalEnd.radius,S=Bt.copy(this._targetEnd).add(x.multiplyScalar(this._dollyControlCoord.x*v*y.aspect)).add(w.multiplyScalar(this._dollyControlCoord.y*v)),_=ye.copy(this._targetEnd).lerp(S,D),L=this._lastDollyDirection===Ft.IN&&this._spherical.radius<=this.minDistance,b=this._lastDollyDirection===Ft.OUT&&this.maxDistance<=this._spherical.radius;if(this.infinityDolly&&(L||b)){this._sphericalEnd.radius-=d,this._spherical.radius-=d;const m=Me.copy(g).multiplyScalar(-d);_.add(m)}this._boundary.clampPoint(_,_);const C=Me.subVectors(_,this._targetEnd);this._targetEnd.copy(_),this._target.add(C),this._changedDolly-=d,Ce(this._changedDolly)&&(this._changedDolly=0)}else if(mt(this._camera)&&this._changedZoom!==0){const d=this._zoom-this._lastZoom,y=this._camera,g=ye.set(this._dollyControlCoord.x,this._dollyControlCoord.y,(y.near+y.far)/(y.near-y.far)).unproject(y),x=Me.set(0,0,-1).applyQuaternion(y.quaternion),w=Bt.copy(g).add(x.multiplyScalar(-g.dot(y.up))),P=-(this._zoom-d-this._zoom)/this._zoom,D=this._getCameraDirection(Ht),S=this._targetEnd.dot(D),_=ye.copy(this._targetEnd).lerp(w,P),L=_.dot(D),b=D.multiplyScalar(L-S);_.sub(b),this._boundary.clampPoint(_,_);const C=Me.subVectors(_,this._targetEnd);this._targetEnd.copy(_),this._target.add(C),this._changedZoom-=d,Ce(this._changedZoom)&&(this._changedZoom=0)}}this._camera.zoom!==this._zoom&&(this._camera.zoom=this._zoom,this._camera.updateProjectionMatrix(),this._updateNearPlaneCorners(),this._needsUpdate=!0),this._dragNeedsUpdate=!0;const l=this._collisionTest();this._spherical.radius=Math.min(this._spherical.radius,l),this._spherical.makeSafe(),this._camera.position.setFromSpherical(this._spherical).applyQuaternion(this._yAxisUpSpaceInverse).add(this._target),this._camera.lookAt(this._target),(!Ce(this._focalOffset.x)||!Ce(this._focalOffset.y)||!Ce(this._focalOffset.z))&&(this._camera.updateMatrixWorld(),$e.setFromMatrixColumn(this._camera.matrix,0),et.setFromMatrixColumn(this._camera.matrix,1),Pt.setFromMatrixColumn(this._camera.matrix,2),$e.multiplyScalar(this._focalOffset.x),et.multiplyScalar(-this._focalOffset.y),Pt.multiplyScalar(this._focalOffset.z),ye.copy($e).add(et).add(Pt),this._camera.position.add(ye)),this._boundaryEnclosesCamera&&this._encloseToBoundary(this._camera.position.copy(this._target),ye.setFromSpherical(this._spherical).applyQuaternion(this._yAxisUpSpaceInverse),1);const h=this._needsUpdate;return h&&!this._updatedLastTime?(this._hasRested=!1,this.dispatchEvent({type:"wake"}),this.dispatchEvent({type:"update"})):h?(this.dispatchEvent({type:"update"}),Ce(t,this.restThreshold)&&Ce(n,this.restThreshold)&&Ce(s,this.restThreshold)&&Ce(r.x,this.restThreshold)&&Ce(r.y,this.restThreshold)&&Ce(r.z,this.restThreshold)&&Ce(i.x,this.restThreshold)&&Ce(i.y,this.restThreshold)&&Ce(i.z,this.restThreshold)&&Ce(a,this.restThreshold)&&!this._hasRested&&(this._hasRested=!0,this.dispatchEvent({type:"rest"}))):!h&&this._updatedLastTime&&this.dispatchEvent({type:"sleep"}),this._lastDistance=this._spherical.radius,this._lastZoom=this._zoom,this._updatedLastTime=h,this._needsUpdate=!1,h}toJSON(){return JSON.stringify({enabled:this._enabled,minDistance:this.minDistance,maxDistance:Qt(this.maxDistance),minZoom:this.minZoom,maxZoom:Qt(this.maxZoom),minPolarAngle:this.minPolarAngle,maxPolarAngle:Qt(this.maxPolarAngle),minAzimuthAngle:Qt(this.minAzimuthAngle),maxAzimuthAngle:Qt(this.maxAzimuthAngle),smoothTime:this.smoothTime,draggingSmoothTime:this.draggingSmoothTime,dollySpeed:this.dollySpeed,truckSpeed:this.truckSpeed,dollyToCursor:this.dollyToCursor,verticalDragToForward:this.verticalDragToForward,target:this._targetEnd.toArray(),position:ye.setFromSpherical(this._sphericalEnd).add(this._targetEnd).toArray(),zoom:this._zoomEnd,focalOffset:this._focalOffsetEnd.toArray(),target0:this._target0.toArray(),position0:this._position0.toArray(),zoom0:this._zoom0,focalOffset0:this._focalOffset0.toArray()})}fromJSON(e,t=!1){const n=JSON.parse(e);this.enabled=n.enabled,this.minDistance=n.minDistance,this.maxDistance=Jt(n.maxDistance),this.minZoom=n.minZoom,this.maxZoom=Jt(n.maxZoom),this.minPolarAngle=n.minPolarAngle,this.maxPolarAngle=Jt(n.maxPolarAngle),this.minAzimuthAngle=Jt(n.minAzimuthAngle),this.maxAzimuthAngle=Jt(n.maxAzimuthAngle),this.smoothTime=n.smoothTime,this.draggingSmoothTime=n.draggingSmoothTime,this.dollySpeed=n.dollySpeed,this.truckSpeed=n.truckSpeed,this.dollyToCursor=n.dollyToCursor,this.verticalDragToForward=n.verticalDragToForward,this._target0.fromArray(n.target0),this._position0.fromArray(n.position0),this._zoom0=n.zoom0,this._focalOffset0.fromArray(n.focalOffset0),this.moveTo(n.target[0],n.target[1],n.target[2],t),Ze.setFromVector3(ye.fromArray(n.position).sub(this._targetEnd).applyQuaternion(this._yAxisUpSpace)),this.rotateTo(Ze.theta,Ze.phi,t),this.dollyTo(Ze.radius,t),this.zoomTo(n.zoom,t),this.setFocalOffset(n.focalOffset[0],n.focalOffset[1],n.focalOffset[2],t),this._needsUpdate=!0}connect(e){if(this._domElement){console.warn("camera-controls is already connected.");return}e.setAttribute("data-camera-controls-version",dc),this._addAllEventListeners(e),this._getClientRect(this._elementRect)}disconnect(){this.cancel(),this._removeAllEventListeners(),this._domElement&&(this._domElement.removeAttribute("data-camera-controls-version"),this._domElement=void 0)}dispose(){this.removeAllEventListeners(),this.disconnect()}_getTargetDirection(e){return e.setFromSpherical(this._spherical).divideScalar(this._spherical.radius).applyQuaternion(this._yAxisUpSpaceInverse)}_getCameraDirection(e){return this._getTargetDirection(e).negate()}_findPointerById(e){return this._activePointers.find(t=>t.pointerId===e)}_findPointerByMouseButton(e){return this._activePointers.find(t=>t.mouseButton===e)}_disposePointer(e){this._activePointers.splice(this._activePointers.indexOf(e),1)}_encloseToBoundary(e,t,n){const s=t.lengthSq();if(s===0)return e;const r=Me.copy(t).add(e),a=this._boundary.clampPoint(r,Bt).sub(r),l=a.lengthSq();if(l===0)return e.add(t);if(l===s)return e;if(n===0)return e.add(t).add(a);{const u=1+n*l/t.dot(a);return e.add(Me.copy(t).multiplyScalar(u)).add(a.multiplyScalar(1-n))}}_updateNearPlaneCorners(){if(At(this._camera)){const e=this._camera,t=e.near,n=e.getEffectiveFOV()*qt,s=Math.tan(n*.5)*t,r=s*e.aspect;this._nearPlaneCorners[0].set(-r,-s,0),this._nearPlaneCorners[1].set(r,-s,0),this._nearPlaneCorners[2].set(r,s,0),this._nearPlaneCorners[3].set(-r,s,0)}else if(mt(this._camera)){const e=this._camera,t=1/e.zoom,n=e.left*t,s=e.right*t,r=e.top*t,i=e.bottom*t;this._nearPlaneCorners[0].set(n,r,0),this._nearPlaneCorners[1].set(s,r,0),this._nearPlaneCorners[2].set(s,i,0),this._nearPlaneCorners[3].set(n,i,0)}}_collisionTest(){let e=1/0;if(!(this.colliderMeshes.length>=1)||cs(this._camera,"_collisionTest"))return e;const n=this._getTargetDirection(Ht);ds.lookAt(Kr,n,this._camera.up);for(let s=0;s<4;s++){const r=Me.copy(this._nearPlaneCorners[s]);r.applyMatrix4(ds);const i=Bt.addVectors(this._target,r);Sn.set(i,n),Sn.far=this._spherical.radius+1;const a=Sn.intersectObjects(this.colliderMeshes);a.length!==0&&a[0].distance<e&&(e=a[0].distance)}return e}_getClientRect(e){if(!this._domElement)return;const t=this._domElement.getBoundingClientRect();return e.x=t.left,e.y=t.top,this._viewport?(e.x+=this._viewport.x,e.y+=t.height-this._viewport.w-this._viewport.y,e.width=this._viewport.z,e.height=this._viewport.w):(e.width=t.width,e.height=t.height),e}_createOnRestPromise(e){return e?Promise.resolve():(this._hasRested=!1,this.dispatchEvent({type:"transitionstart"}),new Promise(t=>{const n=()=>{this.removeEventListener("rest",n),t()};this.addEventListener("rest",n)}))}_addAllEventListeners(e){}_removeAllEventListeners(){}get dampingFactor(){return console.warn(".dampingFactor has been deprecated. use smoothTime (in seconds) instead."),0}set dampingFactor(e){console.warn(".dampingFactor has been deprecated. use smoothTime (in seconds) instead.")}get draggingDampingFactor(){return console.warn(".draggingDampingFactor has been deprecated. use draggingSmoothTime (in seconds) instead."),0}set draggingDampingFactor(e){console.warn(".draggingDampingFactor has been deprecated. use draggingSmoothTime (in seconds) instead.")}static createBoundingSphere(e,t=new he.Sphere){const n=t,s=n.center;Ut.makeEmpty(),e.traverseVisible(i=>{i.isMesh&&Ut.expandByObject(i)}),Ut.getCenter(s);let r=0;return e.traverseVisible(i=>{if(!i.isMesh)return;const a=i,l=a.geometry.clone();l.applyMatrix4(a.matrixWorld);const h=l.attributes.position;for(let d=0,y=h.count;d<y;d++)ye.fromBufferAttribute(h,d),r=Math.max(r,s.distanceToSquared(ye))}),n.radius=Math.sqrt(r),n}}const gc=["min-polar-angle","max-polar-angle","min-azimuth-angle","max-azimuth-angle","distance","min-distance","max-distance","infinity-dolly","min-zoom","max-zoom","smooth-time","dragging-smooth-time","max-speed","azimuth-rotate-speed","polar-rotate-speed","dolly-speed","dolly-drag-inverted","truck-speed","dolly-to-cursor","drag-to-offset","vertical-drag-to-forward","boundary-friction","rest-threshold","collider-meshes","args"],yc=f.defineComponent({__name:"CameraControls",props:{makeDefault:{type:Boolean,default:!1},camera:{},domElement:{},minPolarAngle:{default:0},maxPolarAngle:{default:Math.PI},minAzimuthAngle:{default:-1/0},maxAzimuthAngle:{default:1/0},distance:{default:()=>ae.useTresContext().camera.value.position.z},minDistance:{default:Number.EPSILON},maxDistance:{default:1/0},infinityDolly:{type:Boolean,default:!1},minZoom:{default:.01},maxZoom:{default:1/0},smoothTime:{default:.25},draggingSmoothTime:{default:.125},maxSpeed:{default:1/0},azimuthRotateSpeed:{default:1},polarRotateSpeed:{default:1},dollySpeed:{default:1},dollyDragInverted:{type:Boolean,default:!1},truckSpeed:{default:2},dollyToCursor:{type:Boolean,default:!1},dragToOffset:{type:Boolean,default:!1},verticalDragToForward:{type:Boolean,default:!1},boundaryFriction:{default:0},restThreshold:{default:.01},colliderMeshes:{default:()=>[]},mouseButtons:{},touches:{}},emits:["change","start","end"],setup(o,{expose:e,emit:t}){const n=o,s=t,{makeDefault:r,minPolarAngle:i,maxPolarAngle:a,minAzimuthAngle:l,maxAzimuthAngle:u,distance:h,minDistance:d,maxDistance:y,infinityDolly:g,minZoom:x,maxZoom:w,smoothTime:v,draggingSmoothTime:P,maxSpeed:D,azimuthRotateSpeed:S,polarRotateSpeed:_,dollySpeed:L,dollyDragInverted:b,truckSpeed:C,dollyToCursor:m,dragToOffset:M,verticalDragToForward:p,boundaryFriction:I,restThreshold:F,colliderMeshes:J}=f.toRefs(n),G={Box3:c.Box3,MathUtils:{clamp:c.MathUtils.clamp},Matrix4:c.Matrix4,Quaternion:c.Quaternion,Raycaster:c.Raycaster,Sphere:c.Sphere,Spherical:c.Spherical,Vector2:c.Vector2,Vector3:c.Vector3,Vector4:c.Vector4};en.install({THREE:G});const{camera:Q,renderer:K,extend:Z,controls:X}=ae.useTresContext(),ne=f.ref(null);Z({CameraControls:en}),f.watchEffect(()=>{se(),ne.value&&r.value?X.value=ne.value:X.value=null});function se(){Le(ne.value,"update",()=>s("change",ne.value)),Le(ne.value,"controlend",()=>s("end",ne.value)),Le(ne.value,"controlstart",()=>s("start",ne.value))}const{onLoop:ue}=ae.useRenderLoop();return ue(({delta:j})=>{var z,A;(z=ne.value)!=null&&z.enabled&&((A=ne.value)==null||A.update(j))}),f.onUnmounted(()=>{ne.value&&ne.value.disconnect()}),e({value:ne}),(j,z)=>(j.camera||f.unref(Q))&&(j.domElement||f.unref(K))?(f.openBlock(),f.createElementBlock("TresCameraControls",{key:0,ref_key:"controlsRef",ref:ne,"min-polar-angle":f.unref(i),"max-polar-angle":f.unref(a),"min-azimuth-angle":f.unref(l),"max-azimuth-angle":f.unref(u),distance:f.unref(h),"min-distance":f.unref(d),"max-distance":f.unref(y),"infinity-dolly":f.unref(g),"min-zoom":f.unref(x),"max-zoom":f.unref(w),"smooth-time":f.unref(v),"dragging-smooth-time":f.unref(P),"max-speed":f.unref(D),"azimuth-rotate-speed":f.unref(S),"polar-rotate-speed":f.unref(_),"dolly-speed":f.unref(L),"dolly-drag-inverted":f.unref(b),"truck-speed":f.unref(C),"dolly-to-cursor":f.unref(m),"drag-to-offset":f.unref(M),"vertical-drag-to-forward":f.unref(p),"boundary-friction":f.unref(I),"rest-threshold":f.unref(F),"collider-meshes":f.unref(J),args:[j.camera||f.unref(Q),j.domElement||f.unref(K).domElement]},null,8,gc)):f.createCommentVNode("",!0)}});class _c extends c.MeshStandardMaterial{constructor(t={}){super(t);le(this,"_time");le(this,"_factor");this.setValues(t),this._time={value:0},this._factor={value:1}}onBeforeCompile(t){t.uniforms||(t.uniforms={}),t.uniforms.time=this._time,t.uniforms.factor=this._factor,t.vertexShader=`
+ */const Le={LEFT:1,RIGHT:2,MIDDLE:4},$=Object.freeze({NONE:0,ROTATE:1,TRUCK:2,OFFSET:4,DOLLY:8,ZOOM:16,TOUCH_ROTATE:32,TOUCH_TRUCK:64,TOUCH_OFFSET:128,TOUCH_DOLLY:256,TOUCH_ZOOM:512,TOUCH_DOLLY_TRUCK:1024,TOUCH_DOLLY_OFFSET:2048,TOUCH_DOLLY_ROTATE:4096,TOUCH_ZOOM_TRUCK:8192,TOUCH_ZOOM_OFFSET:16384,TOUCH_ZOOM_ROTATE:32768}),Bt={NONE:0,IN:1,OUT:-1};function Ct(o){return o.isPerspectiveCamera}function gt(o){return o.isOrthographicCamera}const Ft=Math.PI*2,Zi=Math.PI/2,Ki=1e-5,Ht=Math.PI/180;function Je(o,e,t){return Math.max(e,Math.min(t,o))}function Ce(o,e=Ki){return Math.abs(o)<e}function Se(o,e,t=Ki){return Ce(o-e,t)}function qi(o,e){return Math.round(o/e)*e}function $t(o){return isFinite(o)?o:o<0?-Number.MAX_VALUE:Number.MAX_VALUE}function en(o){return Math.abs(o)<Number.MAX_VALUE?o:o*(1/0)}function Sn(o,e,t,n,r=1/0,i){n=Math.max(1e-4,n);const s=2/n,a=s*i,c=1/(1+a+.48*a*a+.235*a*a*a);let h=o-e;const f=e,d=r*n;h=Je(h,-d,d),e=o-h;const p=(t.value+s*h)*i;t.value=(t.value-s*p)*c;let m=e+(h+p)*c;return f-o>0==m>f&&(m=f,t.value=(m-f)/i),m}function Qi(o,e,t,n,r=1/0,i,s){n=Math.max(1e-4,n);const a=2/n,c=a*i,h=1/(1+c+.48*c*c+.235*c*c*c);let f=e.x,d=e.y,p=e.z,m=o.x-f,x=o.y-d,b=o.z-p;const v=f,_=d,T=p,w=r*n,M=w*w,D=m*m+x*x+b*b;if(D>M){const Z=Math.sqrt(D);m=m/Z*w,x=x/Z*w,b=b/Z*w}f=o.x-m,d=o.y-x,p=o.z-b;const S=(t.x+a*m)*i,C=(t.y+a*x)*i,y=(t.z+a*b)*i;t.x=(t.x-a*S)*h,t.y=(t.y-a*C)*h,t.z=(t.z-a*y)*h,s.x=f+(m+S)*h,s.y=d+(x+C)*h,s.z=p+(b+y)*h;const A=v-o.x,g=_-o.y,I=T-o.z,k=s.x-v,J=s.y-_,G=s.z-T;return A*k+g*J+I*G>0&&(s.x=v,s.y=_,s.z=T,t.x=(s.x-v)/i,t.y=(s.y-_)/i,t.z=(s.z-T)/i),s}function ur(o,e){e.set(0,0),o.forEach(t=>{e.x+=t.clientX,e.y+=t.clientY}),e.x/=o.length,e.y/=o.length}function hr(o,e){return gt(o)?(console.warn(`${e} is not supported in OrthographicCamera`),!0):!1}class gc{constructor(){this._listeners={}}addEventListener(e,t){const n=this._listeners;n[e]===void 0&&(n[e]=[]),n[e].indexOf(t)===-1&&n[e].push(t)}hasEventListener(e,t){const n=this._listeners;return n[e]!==void 0&&n[e].indexOf(t)!==-1}removeEventListener(e,t){const r=this._listeners[e];if(r!==void 0){const i=r.indexOf(t);i!==-1&&r.splice(i,1)}}removeAllEventListeners(e){if(!e){this._listeners={};return}Array.isArray(this._listeners[e])&&(this._listeners[e].length=0)}dispatchEvent(e){const n=this._listeners[e.type];if(n!==void 0){e.target=this;const r=n.slice(0);for(let i=0,s=r.length;i<s;i++)r[i].call(this,e)}}}var fr;const yc="2.8.3",An=1/8,vc=/Mac/.test((fr=globalThis==null?void 0:globalThis.navigator)===null||fr===void 0?void 0:fr.platform);let he,Ji,Cn,dr,Re,ge,be,Ut,tn,et,tt,Pt,Hi,$i,Ke,nn,Nt,es,pr,ts,mr,gr,Pn;class rn extends gc{static install(e){he=e.THREE,Ji=Object.freeze(new he.Vector3(0,0,0)),Cn=Object.freeze(new he.Vector3(0,1,0)),dr=Object.freeze(new he.Vector3(0,0,1)),Re=new he.Vector2,ge=new he.Vector3,be=new he.Vector3,Ut=new he.Vector3,tn=new he.Vector3,et=new he.Vector3,tt=new he.Vector3,Pt=new he.Vector3,Hi=new he.Vector3,$i=new he.Vector3,Ke=new he.Spherical,nn=new he.Spherical,Nt=new he.Box3,es=new he.Box3,pr=new he.Sphere,ts=new he.Quaternion,mr=new he.Quaternion,gr=new he.Matrix4,Pn=new he.Raycaster}static get ACTION(){return $}constructor(e,t){super(),this.minPolarAngle=0,this.maxPolarAngle=Math.PI,this.minAzimuthAngle=-1/0,this.maxAzimuthAngle=1/0,this.minDistance=Number.EPSILON,this.maxDistance=1/0,this.infinityDolly=!1,this.minZoom=.01,this.maxZoom=1/0,this.smoothTime=.25,this.draggingSmoothTime=.125,this.maxSpeed=1/0,this.azimuthRotateSpeed=1,this.polarRotateSpeed=1,this.dollySpeed=1,this.dollyDragInverted=!1,this.truckSpeed=2,this.dollyToCursor=!1,this.dragToOffset=!1,this.verticalDragToForward=!1,this.boundaryFriction=0,this.restThreshold=.01,this.colliderMeshes=[],this.cancel=()=>{},this._enabled=!0,this._state=$.NONE,this._viewport=null,this._changedDolly=0,this._changedZoom=0,this._hasRested=!0,this._boundaryEnclosesCamera=!1,this._needsUpdate=!0,this._updatedLastTime=!1,this._elementRect=new DOMRect,this._isDragging=!1,this._dragNeedsUpdate=!0,this._activePointers=[],this._lockedPointer=null,this._interactiveArea=new DOMRect(0,0,1,1),this._isUserControllingRotate=!1,this._isUserControllingDolly=!1,this._isUserControllingTruck=!1,this._isUserControllingOffset=!1,this._isUserControllingZoom=!1,this._lastDollyDirection=Bt.NONE,this._thetaVelocity={value:0},this._phiVelocity={value:0},this._radiusVelocity={value:0},this._targetVelocity=new he.Vector3,this._focalOffsetVelocity=new he.Vector3,this._zoomVelocity={value:0},this._truckInternal=(_,T,w)=>{let M,D;if(Ct(this._camera)){const S=ge.copy(this._camera.position).sub(this._target),C=this._camera.getEffectiveFOV()*Ht,y=S.length()*Math.tan(C*.5);M=this.truckSpeed*_*y/this._elementRect.height,D=this.truckSpeed*T*y/this._elementRect.height}else if(gt(this._camera)){const S=this._camera;M=_*(S.right-S.left)/S.zoom/this._elementRect.width,D=T*(S.top-S.bottom)/S.zoom/this._elementRect.height}else return;this.verticalDragToForward?(w?this.setFocalOffset(this._focalOffsetEnd.x+M,this._focalOffsetEnd.y,this._focalOffsetEnd.z,!0):this.truck(M,0,!0),this.forward(-D,!0)):w?this.setFocalOffset(this._focalOffsetEnd.x+M,this._focalOffsetEnd.y+D,this._focalOffsetEnd.z,!0):this.truck(M,D,!0)},this._rotateInternal=(_,T)=>{const w=Ft*this.azimuthRotateSpeed*_/this._elementRect.height,M=Ft*this.polarRotateSpeed*T/this._elementRect.height;this.rotate(w,M,!0)},this._dollyInternal=(_,T,w)=>{const M=Math.pow(.95,-_*this.dollySpeed),D=this._sphericalEnd.radius,S=this._sphericalEnd.radius*M,C=Je(S,this.minDistance,this.maxDistance),y=C-S;this.infinityDolly&&this.dollyToCursor?this._dollyToNoClamp(S,!0):this.infinityDolly&&!this.dollyToCursor?(this.dollyInFixed(y,!0),this._dollyToNoClamp(C,!0)):this._dollyToNoClamp(C,!0),this.dollyToCursor&&(this._changedDolly+=(this.infinityDolly?S:C)-D,this._dollyControlCoord.set(T,w)),this._lastDollyDirection=Math.sign(-_)},this._zoomInternal=(_,T,w)=>{const M=Math.pow(.95,_*this.dollySpeed),D=this._zoom,S=this._zoom*M;this.zoomTo(S,!0),this.dollyToCursor&&(this._changedZoom+=S-D,this._dollyControlCoord.set(T,w))},typeof he>"u"&&console.error("camera-controls: `THREE` is undefined. You must first run `CameraControls.install( { THREE: THREE } )`. Check the docs for further information."),this._camera=e,this._yAxisUpSpace=new he.Quaternion().setFromUnitVectors(this._camera.up,Cn),this._yAxisUpSpaceInverse=this._yAxisUpSpace.clone().invert(),this._state=$.NONE,this._target=new he.Vector3,this._targetEnd=this._target.clone(),this._focalOffset=new he.Vector3,this._focalOffsetEnd=this._focalOffset.clone(),this._spherical=new he.Spherical().setFromVector3(ge.copy(this._camera.position).applyQuaternion(this._yAxisUpSpace)),this._sphericalEnd=this._spherical.clone(),this._lastDistance=this._spherical.radius,this._zoom=this._camera.zoom,this._zoomEnd=this._zoom,this._lastZoom=this._zoom,this._nearPlaneCorners=[new he.Vector3,new he.Vector3,new he.Vector3,new he.Vector3],this._updateNearPlaneCorners(),this._boundary=new he.Box3(new he.Vector3(-1/0,-1/0,-1/0),new he.Vector3(1/0,1/0,1/0)),this._cameraUp0=this._camera.up.clone(),this._target0=this._target.clone(),this._position0=this._camera.position.clone(),this._zoom0=this._zoom,this._focalOffset0=this._focalOffset.clone(),this._dollyControlCoord=new he.Vector2,this.mouseButtons={left:$.ROTATE,middle:$.DOLLY,right:$.TRUCK,wheel:Ct(this._camera)?$.DOLLY:gt(this._camera)?$.ZOOM:$.NONE},this.touches={one:$.TOUCH_ROTATE,two:Ct(this._camera)?$.TOUCH_DOLLY_TRUCK:gt(this._camera)?$.TOUCH_ZOOM_TRUCK:$.NONE,three:$.TOUCH_TRUCK};const n=new he.Vector2,r=new he.Vector2,i=new he.Vector2,s=_=>{if(!this._enabled||!this._domElement)return;if(this._interactiveArea.left!==0||this._interactiveArea.top!==0||this._interactiveArea.width!==1||this._interactiveArea.height!==1){const M=this._domElement.getBoundingClientRect(),D=_.clientX/M.width,S=_.clientY/M.height;if(D<this._interactiveArea.left||D>this._interactiveArea.right||S<this._interactiveArea.top||S>this._interactiveArea.bottom)return}const T=_.pointerType!=="mouse"?null:(_.buttons&Le.LEFT)===Le.LEFT?Le.LEFT:(_.buttons&Le.MIDDLE)===Le.MIDDLE?Le.MIDDLE:(_.buttons&Le.RIGHT)===Le.RIGHT?Le.RIGHT:null;if(T!==null){const M=this._findPointerByMouseButton(T);M&&this._disposePointer(M)}if((_.buttons&Le.LEFT)===Le.LEFT&&this._lockedPointer)return;const w={pointerId:_.pointerId,clientX:_.clientX,clientY:_.clientY,deltaX:0,deltaY:0,mouseButton:T};this._activePointers.push(w),this._domElement.ownerDocument.removeEventListener("pointermove",a,{passive:!1}),this._domElement.ownerDocument.removeEventListener("pointerup",c),this._domElement.ownerDocument.addEventListener("pointermove",a,{passive:!1}),this._domElement.ownerDocument.addEventListener("pointerup",c),this._isDragging=!0,p(_)},a=_=>{_.cancelable&&_.preventDefault();const T=_.pointerId,w=this._lockedPointer||this._findPointerById(T);if(w){if(w.clientX=_.clientX,w.clientY=_.clientY,w.deltaX=_.movementX,w.deltaY=_.movementY,this._state=0,_.pointerType==="touch")switch(this._activePointers.length){case 1:this._state=this.touches.one;break;case 2:this._state=this.touches.two;break;case 3:this._state=this.touches.three;break}else(!this._isDragging&&this._lockedPointer||this._isDragging&&(_.buttons&Le.LEFT)===Le.LEFT)&&(this._state=this._state|this.mouseButtons.left),this._isDragging&&(_.buttons&Le.MIDDLE)===Le.MIDDLE&&(this._state=this._state|this.mouseButtons.middle),this._isDragging&&(_.buttons&Le.RIGHT)===Le.RIGHT&&(this._state=this._state|this.mouseButtons.right);m()}},c=_=>{const T=this._findPointerById(_.pointerId);if(!(T&&T===this._lockedPointer)){if(T&&this._disposePointer(T),_.pointerType==="touch")switch(this._activePointers.length){case 0:this._state=$.NONE;break;case 1:this._state=this.touches.one;break;case 2:this._state=this.touches.two;break;case 3:this._state=this.touches.three;break}else this._state=$.NONE;x()}};let h=-1;const f=_=>{if(!this._domElement||!this._enabled||this.mouseButtons.wheel===$.NONE)return;if(this._interactiveArea.left!==0||this._interactiveArea.top!==0||this._interactiveArea.width!==1||this._interactiveArea.height!==1){const S=this._domElement.getBoundingClientRect(),C=_.clientX/S.width,y=_.clientY/S.height;if(C<this._interactiveArea.left||C>this._interactiveArea.right||y<this._interactiveArea.top||y>this._interactiveArea.bottom)return}if(_.preventDefault(),this.dollyToCursor||this.mouseButtons.wheel===$.ROTATE||this.mouseButtons.wheel===$.TRUCK){const S=performance.now();h-S<1e3&&this._getClientRect(this._elementRect),h=S}const T=vc?-1:-3,w=_.deltaMode===1?_.deltaY/T:_.deltaY/(T*10),M=this.dollyToCursor?(_.clientX-this._elementRect.x)/this._elementRect.width*2-1:0,D=this.dollyToCursor?(_.clientY-this._elementRect.y)/this._elementRect.height*-2+1:0;switch(this.mouseButtons.wheel){case $.ROTATE:{this._rotateInternal(_.deltaX,_.deltaY),this._isUserControllingRotate=!0;break}case $.TRUCK:{this._truckInternal(_.deltaX,_.deltaY,!1),this._isUserControllingTruck=!0;break}case $.OFFSET:{this._truckInternal(_.deltaX,_.deltaY,!0),this._isUserControllingOffset=!0;break}case $.DOLLY:{this._dollyInternal(-w,M,D),this._isUserControllingDolly=!0;break}case $.ZOOM:{this._zoomInternal(-w,M,D),this._isUserControllingZoom=!0;break}}this.dispatchEvent({type:"control"})},d=_=>{if(!(!this._domElement||!this._enabled)){if(this.mouseButtons.right===rn.ACTION.NONE){const T=_ instanceof PointerEvent?_.pointerId:0,w=this._findPointerById(T);w&&this._disposePointer(w),this._domElement.ownerDocument.removeEventListener("pointermove",a,{passive:!1}),this._domElement.ownerDocument.removeEventListener("pointerup",c);return}_.preventDefault()}},p=_=>{if(!this._enabled)return;if(ur(this._activePointers,Re),this._getClientRect(this._elementRect),n.copy(Re),r.copy(Re),this._activePointers.length>=2){const w=Re.x-this._activePointers[1].clientX,M=Re.y-this._activePointers[1].clientY,D=Math.sqrt(w*w+M*M);i.set(0,D);const S=(this._activePointers[0].clientX+this._activePointers[1].clientX)*.5,C=(this._activePointers[0].clientY+this._activePointers[1].clientY)*.5;r.set(S,C)}if(this._state=0,!_)this._lockedPointer&&(this._state=this._state|this.mouseButtons.left);else if("pointerType"in _&&_.pointerType==="touch")switch(this._activePointers.length){case 1:this._state=this.touches.one;break;case 2:this._state=this.touches.two;break;case 3:this._state=this.touches.three;break}else!this._lockedPointer&&(_.buttons&Le.LEFT)===Le.LEFT&&(this._state=this._state|this.mouseButtons.left),(_.buttons&Le.MIDDLE)===Le.MIDDLE&&(this._state=this._state|this.mouseButtons.middle),(_.buttons&Le.RIGHT)===Le.RIGHT&&(this._state=this._state|this.mouseButtons.right);((this._state&$.ROTATE)===$.ROTATE||(this._state&$.TOUCH_ROTATE)===$.TOUCH_ROTATE||(this._state&$.TOUCH_DOLLY_ROTATE)===$.TOUCH_DOLLY_ROTATE||(this._state&$.TOUCH_ZOOM_ROTATE)===$.TOUCH_ZOOM_ROTATE)&&(this._sphericalEnd.theta=this._spherical.theta,this._sphericalEnd.phi=this._spherical.phi,this._thetaVelocity.value=0,this._phiVelocity.value=0),((this._state&$.TRUCK)===$.TRUCK||(this._state&$.TOUCH_TRUCK)===$.TOUCH_TRUCK||(this._state&$.TOUCH_DOLLY_TRUCK)===$.TOUCH_DOLLY_TRUCK||(this._state&$.TOUCH_ZOOM_TRUCK)===$.TOUCH_ZOOM_TRUCK)&&(this._targetEnd.copy(this._target),this._targetVelocity.set(0,0,0)),((this._state&$.DOLLY)===$.DOLLY||(this._state&$.TOUCH_DOLLY)===$.TOUCH_DOLLY||(this._state&$.TOUCH_DOLLY_TRUCK)===$.TOUCH_DOLLY_TRUCK||(this._state&$.TOUCH_DOLLY_OFFSET)===$.TOUCH_DOLLY_OFFSET||(this._state&$.TOUCH_DOLLY_ROTATE)===$.TOUCH_DOLLY_ROTATE)&&(this._sphericalEnd.radius=this._spherical.radius,this._radiusVelocity.value=0),((this._state&$.ZOOM)===$.ZOOM||(this._state&$.TOUCH_ZOOM)===$.TOUCH_ZOOM||(this._state&$.TOUCH_ZOOM_TRUCK)===$.TOUCH_ZOOM_TRUCK||(this._state&$.TOUCH_ZOOM_OFFSET)===$.TOUCH_ZOOM_OFFSET||(this._state&$.TOUCH_ZOOM_ROTATE)===$.TOUCH_ZOOM_ROTATE)&&(this._zoomEnd=this._zoom,this._zoomVelocity.value=0),((this._state&$.OFFSET)===$.OFFSET||(this._state&$.TOUCH_OFFSET)===$.TOUCH_OFFSET||(this._state&$.TOUCH_DOLLY_OFFSET)===$.TOUCH_DOLLY_OFFSET||(this._state&$.TOUCH_ZOOM_OFFSET)===$.TOUCH_ZOOM_OFFSET)&&(this._focalOffsetEnd.copy(this._focalOffset),this._focalOffsetVelocity.set(0,0,0)),this.dispatchEvent({type:"controlstart"})},m=()=>{if(!this._enabled||!this._dragNeedsUpdate)return;this._dragNeedsUpdate=!1,ur(this._activePointers,Re);const T=this._domElement&&this._domElement.ownerDocument.pointerLockElement===this._domElement?this._lockedPointer||this._activePointers[0]:null,w=T?-T.deltaX:r.x-Re.x,M=T?-T.deltaY:r.y-Re.y;if(r.copy(Re),((this._state&$.ROTATE)===$.ROTATE||(this._state&$.TOUCH_ROTATE)===$.TOUCH_ROTATE||(this._state&$.TOUCH_DOLLY_ROTATE)===$.TOUCH_DOLLY_ROTATE||(this._state&$.TOUCH_ZOOM_ROTATE)===$.TOUCH_ZOOM_ROTATE)&&(this._rotateInternal(w,M),this._isUserControllingRotate=!0),(this._state&$.DOLLY)===$.DOLLY||(this._state&$.ZOOM)===$.ZOOM){const D=this.dollyToCursor?(n.x-this._elementRect.x)/this._elementRect.width*2-1:0,S=this.dollyToCursor?(n.y-this._elementRect.y)/this._elementRect.height*-2+1:0,C=this.dollyDragInverted?-1:1;(this._state&$.DOLLY)===$.DOLLY?(this._dollyInternal(C*M*An,D,S),this._isUserControllingDolly=!0):(this._zoomInternal(C*M*An,D,S),this._isUserControllingZoom=!0)}if((this._state&$.TOUCH_DOLLY)===$.TOUCH_DOLLY||(this._state&$.TOUCH_ZOOM)===$.TOUCH_ZOOM||(this._state&$.TOUCH_DOLLY_TRUCK)===$.TOUCH_DOLLY_TRUCK||(this._state&$.TOUCH_ZOOM_TRUCK)===$.TOUCH_ZOOM_TRUCK||(this._state&$.TOUCH_DOLLY_OFFSET)===$.TOUCH_DOLLY_OFFSET||(this._state&$.TOUCH_ZOOM_OFFSET)===$.TOUCH_ZOOM_OFFSET||(this._state&$.TOUCH_DOLLY_ROTATE)===$.TOUCH_DOLLY_ROTATE||(this._state&$.TOUCH_ZOOM_ROTATE)===$.TOUCH_ZOOM_ROTATE){const D=Re.x-this._activePointers[1].clientX,S=Re.y-this._activePointers[1].clientY,C=Math.sqrt(D*D+S*S),y=i.y-C;i.set(0,C);const A=this.dollyToCursor?(r.x-this._elementRect.x)/this._elementRect.width*2-1:0,g=this.dollyToCursor?(r.y-this._elementRect.y)/this._elementRect.height*-2+1:0;(this._state&$.TOUCH_DOLLY)===$.TOUCH_DOLLY||(this._state&$.TOUCH_DOLLY_ROTATE)===$.TOUCH_DOLLY_ROTATE||(this._state&$.TOUCH_DOLLY_TRUCK)===$.TOUCH_DOLLY_TRUCK||(this._state&$.TOUCH_DOLLY_OFFSET)===$.TOUCH_DOLLY_OFFSET?(this._dollyInternal(y*An,A,g),this._isUserControllingDolly=!0):(this._zoomInternal(y*An,A,g),this._isUserControllingZoom=!0)}((this._state&$.TRUCK)===$.TRUCK||(this._state&$.TOUCH_TRUCK)===$.TOUCH_TRUCK||(this._state&$.TOUCH_DOLLY_TRUCK)===$.TOUCH_DOLLY_TRUCK||(this._state&$.TOUCH_ZOOM_TRUCK)===$.TOUCH_ZOOM_TRUCK)&&(this._truckInternal(w,M,!1),this._isUserControllingTruck=!0),((this._state&$.OFFSET)===$.OFFSET||(this._state&$.TOUCH_OFFSET)===$.TOUCH_OFFSET||(this._state&$.TOUCH_DOLLY_OFFSET)===$.TOUCH_DOLLY_OFFSET||(this._state&$.TOUCH_ZOOM_OFFSET)===$.TOUCH_ZOOM_OFFSET)&&(this._truckInternal(w,M,!0),this._isUserControllingOffset=!0),this.dispatchEvent({type:"control"})},x=()=>{ur(this._activePointers,Re),r.copy(Re),this._dragNeedsUpdate=!1,(this._activePointers.length===0||this._activePointers.length===1&&this._activePointers[0]===this._lockedPointer)&&(this._isDragging=!1),this._activePointers.length===0&&this._domElement&&(this._domElement.ownerDocument.removeEventListener("pointermove",a,{passive:!1}),this._domElement.ownerDocument.removeEventListener("pointerup",c),this.dispatchEvent({type:"controlend"}))};this.lockPointer=()=>{!this._enabled||!this._domElement||(this.cancel(),this._lockedPointer={pointerId:-1,clientX:0,clientY:0,deltaX:0,deltaY:0,mouseButton:null},this._activePointers.push(this._lockedPointer),this._domElement.ownerDocument.removeEventListener("pointermove",a,{passive:!1}),this._domElement.ownerDocument.removeEventListener("pointerup",c),this._domElement.requestPointerLock(),this._domElement.ownerDocument.addEventListener("pointerlockchange",b),this._domElement.ownerDocument.addEventListener("pointerlockerror",v),this._domElement.ownerDocument.addEventListener("pointermove",a,{passive:!1}),this._domElement.ownerDocument.addEventListener("pointerup",c),p())},this.unlockPointer=()=>{var _,T,w;this._lockedPointer!==null&&(this._disposePointer(this._lockedPointer),this._lockedPointer=null),(_=this._domElement)===null||_===void 0||_.ownerDocument.exitPointerLock(),(T=this._domElement)===null||T===void 0||T.ownerDocument.removeEventListener("pointerlockchange",b),(w=this._domElement)===null||w===void 0||w.ownerDocument.removeEventListener("pointerlockerror",v),this.cancel()};const b=()=>{this._domElement&&this._domElement.ownerDocument.pointerLockElement===this._domElement||this.unlockPointer()},v=()=>{this.unlockPointer()};this._addAllEventListeners=_=>{this._domElement=_,this._domElement.style.touchAction="none",this._domElement.style.userSelect="none",this._domElement.style.webkitUserSelect="none",this._domElement.addEventListener("pointerdown",s),this._domElement.addEventListener("pointercancel",c),this._domElement.addEventListener("wheel",f,{passive:!1}),this._domElement.addEventListener("contextmenu",d)},this._removeAllEventListeners=()=>{this._domElement&&(this._domElement.style.touchAction="",this._domElement.style.userSelect="",this._domElement.style.webkitUserSelect="",this._domElement.removeEventListener("pointerdown",s),this._domElement.removeEventListener("pointercancel",c),this._domElement.removeEventListener("wheel",f,{passive:!1}),this._domElement.removeEventListener("contextmenu",d),this._domElement.ownerDocument.removeEventListener("pointermove",a,{passive:!1}),this._domElement.ownerDocument.removeEventListener("pointerup",c),this._domElement.ownerDocument.removeEventListener("pointerlockchange",b),this._domElement.ownerDocument.removeEventListener("pointerlockerror",v))},this.cancel=()=>{this._state!==$.NONE&&(this._state=$.NONE,this._activePointers.length=0,x())},t&&this.connect(t),this.update(0)}get camera(){return this._camera}set camera(e){this._camera=e,this.updateCameraUp(),this._camera.updateProjectionMatrix(),this._updateNearPlaneCorners(),this._needsUpdate=!0}get enabled(){return this._enabled}set enabled(e){this._enabled=e,this._domElement&&(e?(this._domElement.style.touchAction="none",this._domElement.style.userSelect="none",this._domElement.style.webkitUserSelect="none"):(this.cancel(),this._domElement.style.touchAction="",this._domElement.style.userSelect="",this._domElement.style.webkitUserSelect=""))}get active(){return!this._hasRested}get currentAction(){return this._state}get distance(){return this._spherical.radius}set distance(e){this._spherical.radius===e&&this._sphericalEnd.radius===e||(this._spherical.radius=e,this._sphericalEnd.radius=e,this._needsUpdate=!0)}get azimuthAngle(){return this._spherical.theta}set azimuthAngle(e){this._spherical.theta===e&&this._sphericalEnd.theta===e||(this._spherical.theta=e,this._sphericalEnd.theta=e,this._needsUpdate=!0)}get polarAngle(){return this._spherical.phi}set polarAngle(e){this._spherical.phi===e&&this._sphericalEnd.phi===e||(this._spherical.phi=e,this._sphericalEnd.phi=e,this._needsUpdate=!0)}get boundaryEnclosesCamera(){return this._boundaryEnclosesCamera}set boundaryEnclosesCamera(e){this._boundaryEnclosesCamera=e,this._needsUpdate=!0}set interactiveArea(e){this._interactiveArea.width=Je(e.width,0,1),this._interactiveArea.height=Je(e.height,0,1),this._interactiveArea.x=Je(e.x,0,1-this._interactiveArea.width),this._interactiveArea.y=Je(e.y,0,1-this._interactiveArea.height)}addEventListener(e,t){super.addEventListener(e,t)}removeEventListener(e,t){super.removeEventListener(e,t)}rotate(e,t,n=!1){return this.rotateTo(this._sphericalEnd.theta+e,this._sphericalEnd.phi+t,n)}rotateAzimuthTo(e,t=!1){return this.rotateTo(e,this._sphericalEnd.phi,t)}rotatePolarTo(e,t=!1){return this.rotateTo(this._sphericalEnd.theta,e,t)}rotateTo(e,t,n=!1){this._isUserControllingRotate=!1;const r=Je(e,this.minAzimuthAngle,this.maxAzimuthAngle),i=Je(t,this.minPolarAngle,this.maxPolarAngle);this._sphericalEnd.theta=r,this._sphericalEnd.phi=i,this._sphericalEnd.makeSafe(),this._needsUpdate=!0,n||(this._spherical.theta=this._sphericalEnd.theta,this._spherical.phi=this._sphericalEnd.phi);const s=!n||Se(this._spherical.theta,this._sphericalEnd.theta,this.restThreshold)&&Se(this._spherical.phi,this._sphericalEnd.phi,this.restThreshold);return this._createOnRestPromise(s)}dolly(e,t=!1){return this.dollyTo(this._sphericalEnd.radius-e,t)}dollyTo(e,t=!1){return this._isUserControllingDolly=!1,this._lastDollyDirection=Bt.NONE,this._changedDolly=0,this._dollyToNoClamp(Je(e,this.minDistance,this.maxDistance),t)}_dollyToNoClamp(e,t=!1){const n=this._sphericalEnd.radius;if(this.colliderMeshes.length>=1){const s=this._collisionTest(),a=Se(s,this._spherical.radius);if(!(n>e)&&a)return Promise.resolve();this._sphericalEnd.radius=Math.min(e,s)}else this._sphericalEnd.radius=e;this._needsUpdate=!0,t||(this._spherical.radius=this._sphericalEnd.radius);const i=!t||Se(this._spherical.radius,this._sphericalEnd.radius,this.restThreshold);return this._createOnRestPromise(i)}dollyInFixed(e,t=!1){this._targetEnd.add(this._getCameraDirection(tn).multiplyScalar(e)),t||this._target.copy(this._targetEnd);const n=!t||Se(this._target.x,this._targetEnd.x,this.restThreshold)&&Se(this._target.y,this._targetEnd.y,this.restThreshold)&&Se(this._target.z,this._targetEnd.z,this.restThreshold);return this._createOnRestPromise(n)}zoom(e,t=!1){return this.zoomTo(this._zoomEnd+e,t)}zoomTo(e,t=!1){this._isUserControllingZoom=!1,this._zoomEnd=Je(e,this.minZoom,this.maxZoom),this._needsUpdate=!0,t||(this._zoom=this._zoomEnd);const n=!t||Se(this._zoom,this._zoomEnd,this.restThreshold);return this._changedZoom=0,this._createOnRestPromise(n)}pan(e,t,n=!1){return console.warn("`pan` has been renamed to `truck`"),this.truck(e,t,n)}truck(e,t,n=!1){this._camera.updateMatrix(),et.setFromMatrixColumn(this._camera.matrix,0),tt.setFromMatrixColumn(this._camera.matrix,1),et.multiplyScalar(e),tt.multiplyScalar(-t);const r=ge.copy(et).add(tt),i=be.copy(this._targetEnd).add(r);return this.moveTo(i.x,i.y,i.z,n)}forward(e,t=!1){ge.setFromMatrixColumn(this._camera.matrix,0),ge.crossVectors(this._camera.up,ge),ge.multiplyScalar(e);const n=be.copy(this._targetEnd).add(ge);return this.moveTo(n.x,n.y,n.z,t)}elevate(e,t=!1){return ge.copy(this._camera.up).multiplyScalar(e),this.moveTo(this._targetEnd.x+ge.x,this._targetEnd.y+ge.y,this._targetEnd.z+ge.z,t)}moveTo(e,t,n,r=!1){this._isUserControllingTruck=!1;const i=ge.set(e,t,n).sub(this._targetEnd);this._encloseToBoundary(this._targetEnd,i,this.boundaryFriction),this._needsUpdate=!0,r||this._target.copy(this._targetEnd);const s=!r||Se(this._target.x,this._targetEnd.x,this.restThreshold)&&Se(this._target.y,this._targetEnd.y,this.restThreshold)&&Se(this._target.z,this._targetEnd.z,this.restThreshold);return this._createOnRestPromise(s)}lookInDirectionOf(e,t,n,r=!1){const a=ge.set(e,t,n).sub(this._targetEnd).normalize().multiplyScalar(-this._sphericalEnd.radius).add(this._targetEnd);return this.setPosition(a.x,a.y,a.z,r)}fitToBox(e,t,{cover:n=!1,paddingLeft:r=0,paddingRight:i=0,paddingBottom:s=0,paddingTop:a=0}={}){const c=[],h=e.isBox3?Nt.copy(e):Nt.setFromObject(e);h.isEmpty()&&(console.warn("camera-controls: fitTo() cannot be used with an empty box. Aborting"),Promise.resolve());const f=qi(this._sphericalEnd.theta,Zi),d=qi(this._sphericalEnd.phi,Zi);c.push(this.rotateTo(f,d,t));const p=ge.setFromSpherical(this._sphericalEnd).normalize(),m=ts.setFromUnitVectors(p,dr),x=Se(Math.abs(p.y),1);x&&m.multiply(mr.setFromAxisAngle(Cn,f)),m.multiply(this._yAxisUpSpaceInverse);const b=es.makeEmpty();be.copy(h.min).applyQuaternion(m),b.expandByPoint(be),be.copy(h.min).setX(h.max.x).applyQuaternion(m),b.expandByPoint(be),be.copy(h.min).setY(h.max.y).applyQuaternion(m),b.expandByPoint(be),be.copy(h.max).setZ(h.min.z).applyQuaternion(m),b.expandByPoint(be),be.copy(h.min).setZ(h.max.z).applyQuaternion(m),b.expandByPoint(be),be.copy(h.max).setY(h.min.y).applyQuaternion(m),b.expandByPoint(be),be.copy(h.max).setX(h.min.x).applyQuaternion(m),b.expandByPoint(be),be.copy(h.max).applyQuaternion(m),b.expandByPoint(be),b.min.x-=r,b.min.y-=s,b.max.x+=i,b.max.y+=a,m.setFromUnitVectors(dr,p),x&&m.premultiply(mr.invert()),m.premultiply(this._yAxisUpSpace);const v=b.getSize(ge),_=b.getCenter(be).applyQuaternion(m);if(Ct(this._camera)){const T=this.getDistanceToFitBox(v.x,v.y,v.z,n);c.push(this.moveTo(_.x,_.y,_.z,t)),c.push(this.dollyTo(T,t)),c.push(this.setFocalOffset(0,0,0,t))}else if(gt(this._camera)){const T=this._camera,w=T.right-T.left,M=T.top-T.bottom,D=n?Math.max(w/v.x,M/v.y):Math.min(w/v.x,M/v.y);c.push(this.moveTo(_.x,_.y,_.z,t)),c.push(this.zoomTo(D,t)),c.push(this.setFocalOffset(0,0,0,t))}return Promise.all(c)}fitToSphere(e,t){const n=[],i=e instanceof he.Sphere?pr.copy(e):rn.createBoundingSphere(e,pr);if(n.push(this.moveTo(i.center.x,i.center.y,i.center.z,t)),Ct(this._camera)){const s=this.getDistanceToFitSphere(i.radius);n.push(this.dollyTo(s,t))}else if(gt(this._camera)){const s=this._camera.right-this._camera.left,a=this._camera.top-this._camera.bottom,c=2*i.radius,h=Math.min(s/c,a/c);n.push(this.zoomTo(h,t))}return n.push(this.setFocalOffset(0,0,0,t)),Promise.all(n)}setLookAt(e,t,n,r,i,s,a=!1){this._isUserControllingRotate=!1,this._isUserControllingDolly=!1,this._isUserControllingTruck=!1,this._lastDollyDirection=Bt.NONE,this._changedDolly=0;const c=be.set(r,i,s),h=ge.set(e,t,n);this._targetEnd.copy(c),this._sphericalEnd.setFromVector3(h.sub(c).applyQuaternion(this._yAxisUpSpace)),this.normalizeRotations(),this._needsUpdate=!0,a||(this._target.copy(this._targetEnd),this._spherical.copy(this._sphericalEnd));const f=!a||Se(this._target.x,this._targetEnd.x,this.restThreshold)&&Se(this._target.y,this._targetEnd.y,this.restThreshold)&&Se(this._target.z,this._targetEnd.z,this.restThreshold)&&Se(this._spherical.theta,this._sphericalEnd.theta,this.restThreshold)&&Se(this._spherical.phi,this._sphericalEnd.phi,this.restThreshold)&&Se(this._spherical.radius,this._sphericalEnd.radius,this.restThreshold);return this._createOnRestPromise(f)}lerpLookAt(e,t,n,r,i,s,a,c,h,f,d,p,m,x=!1){this._isUserControllingRotate=!1,this._isUserControllingDolly=!1,this._isUserControllingTruck=!1,this._lastDollyDirection=Bt.NONE,this._changedDolly=0;const b=ge.set(r,i,s),v=be.set(e,t,n);Ke.setFromVector3(v.sub(b).applyQuaternion(this._yAxisUpSpace));const _=Ut.set(f,d,p),T=be.set(a,c,h);nn.setFromVector3(T.sub(_).applyQuaternion(this._yAxisUpSpace)),this._targetEnd.copy(b.lerp(_,m));const w=nn.theta-Ke.theta,M=nn.phi-Ke.phi,D=nn.radius-Ke.radius;this._sphericalEnd.set(Ke.radius+D*m,Ke.phi+M*m,Ke.theta+w*m),this.normalizeRotations(),this._needsUpdate=!0,x||(this._target.copy(this._targetEnd),this._spherical.copy(this._sphericalEnd));const S=!x||Se(this._target.x,this._targetEnd.x,this.restThreshold)&&Se(this._target.y,this._targetEnd.y,this.restThreshold)&&Se(this._target.z,this._targetEnd.z,this.restThreshold)&&Se(this._spherical.theta,this._sphericalEnd.theta,this.restThreshold)&&Se(this._spherical.phi,this._sphericalEnd.phi,this.restThreshold)&&Se(this._spherical.radius,this._sphericalEnd.radius,this.restThreshold);return this._createOnRestPromise(S)}setPosition(e,t,n,r=!1){return this.setLookAt(e,t,n,this._targetEnd.x,this._targetEnd.y,this._targetEnd.z,r)}setTarget(e,t,n,r=!1){const i=this.getPosition(ge),s=this.setLookAt(i.x,i.y,i.z,e,t,n,r);return this._sphericalEnd.phi=Je(this._sphericalEnd.phi,this.minPolarAngle,this.maxPolarAngle),s}setFocalOffset(e,t,n,r=!1){this._isUserControllingOffset=!1,this._focalOffsetEnd.set(e,t,n),this._needsUpdate=!0,r||this._focalOffset.copy(this._focalOffsetEnd);const i=!r||Se(this._focalOffset.x,this._focalOffsetEnd.x,this.restThreshold)&&Se(this._focalOffset.y,this._focalOffsetEnd.y,this.restThreshold)&&Se(this._focalOffset.z,this._focalOffsetEnd.z,this.restThreshold);return this._createOnRestPromise(i)}setOrbitPoint(e,t,n){this._camera.updateMatrixWorld(),et.setFromMatrixColumn(this._camera.matrixWorldInverse,0),tt.setFromMatrixColumn(this._camera.matrixWorldInverse,1),Pt.setFromMatrixColumn(this._camera.matrixWorldInverse,2);const r=ge.set(e,t,n),i=r.distanceTo(this._camera.position),s=r.sub(this._camera.position);et.multiplyScalar(s.x),tt.multiplyScalar(s.y),Pt.multiplyScalar(s.z),ge.copy(et).add(tt).add(Pt),ge.z=ge.z+i,this.dollyTo(i,!1),this.setFocalOffset(-ge.x,ge.y,-ge.z,!1),this.moveTo(e,t,n,!1)}setBoundary(e){if(!e){this._boundary.min.set(-1/0,-1/0,-1/0),this._boundary.max.set(1/0,1/0,1/0),this._needsUpdate=!0;return}this._boundary.copy(e),this._boundary.clampPoint(this._targetEnd,this._targetEnd),this._needsUpdate=!0}setViewport(e,t,n,r){if(e===null){this._viewport=null;return}this._viewport=this._viewport||new he.Vector4,typeof e=="number"?this._viewport.set(e,t,n,r):this._viewport.copy(e)}getDistanceToFitBox(e,t,n,r=!1){if(hr(this._camera,"getDistanceToFitBox"))return this._spherical.radius;const i=e/t,s=this._camera.getEffectiveFOV()*Ht,a=this._camera.aspect;return((r?i>a:i<a)?t:e/a)*.5/Math.tan(s*.5)+n*.5}getDistanceToFitSphere(e){if(hr(this._camera,"getDistanceToFitSphere"))return this._spherical.radius;const t=this._camera.getEffectiveFOV()*Ht,n=Math.atan(Math.tan(t*.5)*this._camera.aspect)*2,r=1<this._camera.aspect?t:n;return e/Math.sin(r*.5)}getTarget(e,t=!0){return(e&&e.isVector3?e:new he.Vector3).copy(t?this._targetEnd:this._target)}getPosition(e,t=!0){return(e&&e.isVector3?e:new he.Vector3).setFromSpherical(t?this._sphericalEnd:this._spherical).applyQuaternion(this._yAxisUpSpaceInverse).add(t?this._targetEnd:this._target)}getSpherical(e,t=!0){return(e&&e instanceof he.Spherical?e:new he.Spherical).copy(t?this._sphericalEnd:this._spherical)}getFocalOffset(e,t=!0){return(e&&e.isVector3?e:new he.Vector3).copy(t?this._focalOffsetEnd:this._focalOffset)}normalizeRotations(){this._sphericalEnd.theta=this._sphericalEnd.theta%Ft,this._sphericalEnd.theta<0&&(this._sphericalEnd.theta+=Ft),this._spherical.theta+=Ft*Math.round((this._sphericalEnd.theta-this._spherical.theta)/Ft)}reset(e=!1){if(!Se(this._camera.up.x,this._cameraUp0.x)||!Se(this._camera.up.y,this._cameraUp0.y)||!Se(this._camera.up.z,this._cameraUp0.z)){this._camera.up.copy(this._cameraUp0);const n=this.getPosition(ge);this.updateCameraUp(),this.setPosition(n.x,n.y,n.z)}const t=[this.setLookAt(this._position0.x,this._position0.y,this._position0.z,this._target0.x,this._target0.y,this._target0.z,e),this.setFocalOffset(this._focalOffset0.x,this._focalOffset0.y,this._focalOffset0.z,e),this.zoomTo(this._zoom0,e)];return Promise.all(t)}saveState(){this._cameraUp0.copy(this._camera.up),this.getTarget(this._target0),this.getPosition(this._position0),this._zoom0=this._zoom,this._focalOffset0.copy(this._focalOffset)}updateCameraUp(){this._yAxisUpSpace.setFromUnitVectors(this._camera.up,Cn),this._yAxisUpSpaceInverse.copy(this._yAxisUpSpace).invert()}applyCameraUp(){const e=ge.subVectors(this._target,this._camera.position).normalize(),t=be.crossVectors(e,this._camera.up);this._camera.up.crossVectors(t,e).normalize(),this._camera.updateMatrixWorld();const n=this.getPosition(ge);this.updateCameraUp(),this.setPosition(n.x,n.y,n.z)}update(e){const t=this._sphericalEnd.theta-this._spherical.theta,n=this._sphericalEnd.phi-this._spherical.phi,r=this._sphericalEnd.radius-this._spherical.radius,i=Hi.subVectors(this._targetEnd,this._target),s=$i.subVectors(this._focalOffsetEnd,this._focalOffset),a=this._zoomEnd-this._zoom;if(Ce(t))this._thetaVelocity.value=0,this._spherical.theta=this._sphericalEnd.theta;else{const d=this._isUserControllingRotate?this.draggingSmoothTime:this.smoothTime;this._spherical.theta=Sn(this._spherical.theta,this._sphericalEnd.theta,this._thetaVelocity,d,1/0,e),this._needsUpdate=!0}if(Ce(n))this._phiVelocity.value=0,this._spherical.phi=this._sphericalEnd.phi;else{const d=this._isUserControllingRotate?this.draggingSmoothTime:this.smoothTime;this._spherical.phi=Sn(this._spherical.phi,this._sphericalEnd.phi,this._phiVelocity,d,1/0,e),this._needsUpdate=!0}if(Ce(r))this._radiusVelocity.value=0,this._spherical.radius=this._sphericalEnd.radius;else{const d=this._isUserControllingDolly?this.draggingSmoothTime:this.smoothTime;this._spherical.radius=Sn(this._spherical.radius,this._sphericalEnd.radius,this._radiusVelocity,d,this.maxSpeed,e),this._needsUpdate=!0}if(Ce(i.x)&&Ce(i.y)&&Ce(i.z))this._targetVelocity.set(0,0,0),this._target.copy(this._targetEnd);else{const d=this._isUserControllingTruck?this.draggingSmoothTime:this.smoothTime;Qi(this._target,this._targetEnd,this._targetVelocity,d,this.maxSpeed,e,this._target),this._needsUpdate=!0}if(Ce(s.x)&&Ce(s.y)&&Ce(s.z))this._focalOffsetVelocity.set(0,0,0),this._focalOffset.copy(this._focalOffsetEnd);else{const d=this._isUserControllingOffset?this.draggingSmoothTime:this.smoothTime;Qi(this._focalOffset,this._focalOffsetEnd,this._focalOffsetVelocity,d,this.maxSpeed,e,this._focalOffset),this._needsUpdate=!0}if(Ce(a))this._zoomVelocity.value=0,this._zoom=this._zoomEnd;else{const d=this._isUserControllingZoom?this.draggingSmoothTime:this.smoothTime;this._zoom=Sn(this._zoom,this._zoomEnd,this._zoomVelocity,d,1/0,e)}if(this.dollyToCursor){if(Ct(this._camera)&&this._changedDolly!==0){const d=this._spherical.radius-this._lastDistance,p=this._camera,m=this._getCameraDirection(tn),x=ge.copy(m).cross(p.up).normalize();x.lengthSq()===0&&(x.x=1);const b=be.crossVectors(x,m),v=this._sphericalEnd.radius*Math.tan(p.getEffectiveFOV()*Ht*.5),T=(this._sphericalEnd.radius-d-this._sphericalEnd.radius)/this._sphericalEnd.radius,w=Ut.copy(this._targetEnd).add(x.multiplyScalar(this._dollyControlCoord.x*v*p.aspect)).add(b.multiplyScalar(this._dollyControlCoord.y*v)),M=ge.copy(this._targetEnd).lerp(w,T),D=this._lastDollyDirection===Bt.IN&&this._spherical.radius<=this.minDistance,S=this._lastDollyDirection===Bt.OUT&&this.maxDistance<=this._spherical.radius;if(this.infinityDolly&&(D||S)){this._sphericalEnd.radius-=d,this._spherical.radius-=d;const y=be.copy(m).multiplyScalar(-d);M.add(y)}this._boundary.clampPoint(M,M);const C=be.subVectors(M,this._targetEnd);this._targetEnd.copy(M),this._target.add(C),this._changedDolly-=d,Ce(this._changedDolly)&&(this._changedDolly=0)}else if(gt(this._camera)&&this._changedZoom!==0){const d=this._zoom-this._lastZoom,p=this._camera,m=ge.set(this._dollyControlCoord.x,this._dollyControlCoord.y,(p.near+p.far)/(p.near-p.far)).unproject(p),x=be.set(0,0,-1).applyQuaternion(p.quaternion),b=Ut.copy(m).add(x.multiplyScalar(-m.dot(p.up))),_=-(this._zoom-d-this._zoom)/this._zoom,T=this._getCameraDirection(tn),w=this._targetEnd.dot(T),M=ge.copy(this._targetEnd).lerp(b,_),D=M.dot(T),S=T.multiplyScalar(D-w);M.sub(S),this._boundary.clampPoint(M,M);const C=be.subVectors(M,this._targetEnd);this._targetEnd.copy(M),this._target.add(C),this._changedZoom-=d,Ce(this._changedZoom)&&(this._changedZoom=0)}}this._camera.zoom!==this._zoom&&(this._camera.zoom=this._zoom,this._camera.updateProjectionMatrix(),this._updateNearPlaneCorners(),this._needsUpdate=!0),this._dragNeedsUpdate=!0;const c=this._collisionTest();this._spherical.radius=Math.min(this._spherical.radius,c),this._spherical.makeSafe(),this._camera.position.setFromSpherical(this._spherical).applyQuaternion(this._yAxisUpSpaceInverse).add(this._target),this._camera.lookAt(this._target),(!Ce(this._focalOffset.x)||!Ce(this._focalOffset.y)||!Ce(this._focalOffset.z))&&(this._camera.updateMatrixWorld(),et.setFromMatrixColumn(this._camera.matrix,0),tt.setFromMatrixColumn(this._camera.matrix,1),Pt.setFromMatrixColumn(this._camera.matrix,2),et.multiplyScalar(this._focalOffset.x),tt.multiplyScalar(-this._focalOffset.y),Pt.multiplyScalar(this._focalOffset.z),ge.copy(et).add(tt).add(Pt),this._camera.position.add(ge)),this._boundaryEnclosesCamera&&this._encloseToBoundary(this._camera.position.copy(this._target),ge.setFromSpherical(this._spherical).applyQuaternion(this._yAxisUpSpaceInverse),1);const f=this._needsUpdate;return f&&!this._updatedLastTime?(this._hasRested=!1,this.dispatchEvent({type:"wake"}),this.dispatchEvent({type:"update"})):f?(this.dispatchEvent({type:"update"}),Ce(t,this.restThreshold)&&Ce(n,this.restThreshold)&&Ce(r,this.restThreshold)&&Ce(i.x,this.restThreshold)&&Ce(i.y,this.restThreshold)&&Ce(i.z,this.restThreshold)&&Ce(s.x,this.restThreshold)&&Ce(s.y,this.restThreshold)&&Ce(s.z,this.restThreshold)&&Ce(a,this.restThreshold)&&!this._hasRested&&(this._hasRested=!0,this.dispatchEvent({type:"rest"}))):!f&&this._updatedLastTime&&this.dispatchEvent({type:"sleep"}),this._lastDistance=this._spherical.radius,this._lastZoom=this._zoom,this._updatedLastTime=f,this._needsUpdate=!1,f}toJSON(){return JSON.stringify({enabled:this._enabled,minDistance:this.minDistance,maxDistance:$t(this.maxDistance),minZoom:this.minZoom,maxZoom:$t(this.maxZoom),minPolarAngle:this.minPolarAngle,maxPolarAngle:$t(this.maxPolarAngle),minAzimuthAngle:$t(this.minAzimuthAngle),maxAzimuthAngle:$t(this.maxAzimuthAngle),smoothTime:this.smoothTime,draggingSmoothTime:this.draggingSmoothTime,dollySpeed:this.dollySpeed,truckSpeed:this.truckSpeed,dollyToCursor:this.dollyToCursor,verticalDragToForward:this.verticalDragToForward,target:this._targetEnd.toArray(),position:ge.setFromSpherical(this._sphericalEnd).add(this._targetEnd).toArray(),zoom:this._zoomEnd,focalOffset:this._focalOffsetEnd.toArray(),target0:this._target0.toArray(),position0:this._position0.toArray(),zoom0:this._zoom0,focalOffset0:this._focalOffset0.toArray()})}fromJSON(e,t=!1){const n=JSON.parse(e);this.enabled=n.enabled,this.minDistance=n.minDistance,this.maxDistance=en(n.maxDistance),this.minZoom=n.minZoom,this.maxZoom=en(n.maxZoom),this.minPolarAngle=n.minPolarAngle,this.maxPolarAngle=en(n.maxPolarAngle),this.minAzimuthAngle=en(n.minAzimuthAngle),this.maxAzimuthAngle=en(n.maxAzimuthAngle),this.smoothTime=n.smoothTime,this.draggingSmoothTime=n.draggingSmoothTime,this.dollySpeed=n.dollySpeed,this.truckSpeed=n.truckSpeed,this.dollyToCursor=n.dollyToCursor,this.verticalDragToForward=n.verticalDragToForward,this._target0.fromArray(n.target0),this._position0.fromArray(n.position0),this._zoom0=n.zoom0,this._focalOffset0.fromArray(n.focalOffset0),this.moveTo(n.target[0],n.target[1],n.target[2],t),Ke.setFromVector3(ge.fromArray(n.position).sub(this._targetEnd).applyQuaternion(this._yAxisUpSpace)),this.rotateTo(Ke.theta,Ke.phi,t),this.dollyTo(Ke.radius,t),this.zoomTo(n.zoom,t),this.setFocalOffset(n.focalOffset[0],n.focalOffset[1],n.focalOffset[2],t),this._needsUpdate=!0}connect(e){if(this._domElement){console.warn("camera-controls is already connected.");return}e.setAttribute("data-camera-controls-version",yc),this._addAllEventListeners(e),this._getClientRect(this._elementRect)}disconnect(){this.cancel(),this._removeAllEventListeners(),this._domElement&&(this._domElement.removeAttribute("data-camera-controls-version"),this._domElement=void 0)}dispose(){this.removeAllEventListeners(),this.disconnect()}_getTargetDirection(e){return e.setFromSpherical(this._spherical).divideScalar(this._spherical.radius).applyQuaternion(this._yAxisUpSpaceInverse)}_getCameraDirection(e){return this._getTargetDirection(e).negate()}_findPointerById(e){return this._activePointers.find(t=>t.pointerId===e)}_findPointerByMouseButton(e){return this._activePointers.find(t=>t.mouseButton===e)}_disposePointer(e){this._activePointers.splice(this._activePointers.indexOf(e),1)}_encloseToBoundary(e,t,n){const r=t.lengthSq();if(r===0)return e;const i=be.copy(t).add(e),a=this._boundary.clampPoint(i,Ut).sub(i),c=a.lengthSq();if(c===0)return e.add(t);if(c===r)return e;if(n===0)return e.add(t).add(a);{const h=1+n*c/t.dot(a);return e.add(be.copy(t).multiplyScalar(h)).add(a.multiplyScalar(1-n))}}_updateNearPlaneCorners(){if(Ct(this._camera)){const e=this._camera,t=e.near,n=e.getEffectiveFOV()*Ht,r=Math.tan(n*.5)*t,i=r*e.aspect;this._nearPlaneCorners[0].set(-i,-r,0),this._nearPlaneCorners[1].set(i,-r,0),this._nearPlaneCorners[2].set(i,r,0),this._nearPlaneCorners[3].set(-i,r,0)}else if(gt(this._camera)){const e=this._camera,t=1/e.zoom,n=e.left*t,r=e.right*t,i=e.top*t,s=e.bottom*t;this._nearPlaneCorners[0].set(n,i,0),this._nearPlaneCorners[1].set(r,i,0),this._nearPlaneCorners[2].set(r,s,0),this._nearPlaneCorners[3].set(n,s,0)}}_collisionTest(){let e=1/0;if(!(this.colliderMeshes.length>=1)||hr(this._camera,"_collisionTest"))return e;const n=this._getTargetDirection(tn);gr.lookAt(Ji,n,this._camera.up);for(let r=0;r<4;r++){const i=be.copy(this._nearPlaneCorners[r]);i.applyMatrix4(gr);const s=Ut.addVectors(this._target,i);Pn.set(s,n),Pn.far=this._spherical.radius+1;const a=Pn.intersectObjects(this.colliderMeshes);a.length!==0&&a[0].distance<e&&(e=a[0].distance)}return e}_getClientRect(e){if(!this._domElement)return;const t=this._domElement.getBoundingClientRect();return e.x=t.left,e.y=t.top,this._viewport?(e.x+=this._viewport.x,e.y+=t.height-this._viewport.w-this._viewport.y,e.width=this._viewport.z,e.height=this._viewport.w):(e.width=t.width,e.height=t.height),e}_createOnRestPromise(e){return e?Promise.resolve():(this._hasRested=!1,this.dispatchEvent({type:"transitionstart"}),new Promise(t=>{const n=()=>{this.removeEventListener("rest",n),t()};this.addEventListener("rest",n)}))}_addAllEventListeners(e){}_removeAllEventListeners(){}get dampingFactor(){return console.warn(".dampingFactor has been deprecated. use smoothTime (in seconds) instead."),0}set dampingFactor(e){console.warn(".dampingFactor has been deprecated. use smoothTime (in seconds) instead.")}get draggingDampingFactor(){return console.warn(".draggingDampingFactor has been deprecated. use draggingSmoothTime (in seconds) instead."),0}set draggingDampingFactor(e){console.warn(".draggingDampingFactor has been deprecated. use draggingSmoothTime (in seconds) instead.")}static createBoundingSphere(e,t=new he.Sphere){const n=t,r=n.center;Nt.makeEmpty(),e.traverseVisible(s=>{s.isMesh&&Nt.expandByObject(s)}),Nt.getCenter(r);let i=0;return e.traverseVisible(s=>{if(!s.isMesh)return;const a=s,c=a.geometry.clone();c.applyMatrix4(a.matrixWorld);const f=c.attributes.position;for(let d=0,p=f.count;d<p;d++)ge.fromBufferAttribute(f,d),i=Math.max(i,r.distanceToSquared(ge))}),n.radius=Math.sqrt(i),n}}const _c=["min-polar-angle","max-polar-angle","min-azimuth-angle","max-azimuth-angle","distance","min-distance","max-distance","infinity-dolly","min-zoom","max-zoom","smooth-time","dragging-smooth-time","max-speed","azimuth-rotate-speed","polar-rotate-speed","dolly-speed","dolly-drag-inverted","truck-speed","dolly-to-cursor","drag-to-offset","vertical-drag-to-forward","boundary-friction","rest-threshold","collider-meshes","args"],xc=u.defineComponent({__name:"CameraControls",props:{makeDefault:{type:Boolean,default:!1},camera:{},domElement:{},minPolarAngle:{default:0},maxPolarAngle:{default:Math.PI},minAzimuthAngle:{default:-1/0},maxAzimuthAngle:{default:1/0},distance:{default:()=>oe.useTresContext().camera.value.position.z},minDistance:{default:Number.EPSILON},maxDistance:{default:1/0},infinityDolly:{type:Boolean,default:!1},minZoom:{default:.01},maxZoom:{default:1/0},smoothTime:{default:.25},draggingSmoothTime:{default:.125},maxSpeed:{default:1/0},azimuthRotateSpeed:{default:1},polarRotateSpeed:{default:1},dollySpeed:{default:1},dollyDragInverted:{type:Boolean,default:!1},truckSpeed:{default:2},dollyToCursor:{type:Boolean,default:!1},dragToOffset:{type:Boolean,default:!1},verticalDragToForward:{type:Boolean,default:!1},boundaryFriction:{default:0},restThreshold:{default:.01},colliderMeshes:{default:()=>[]},mouseButtons:{},touches:{}},emits:["change","start","end"],setup(o,{expose:e,emit:t}){const n=o,r=t,{makeDefault:i,minPolarAngle:s,maxPolarAngle:a,minAzimuthAngle:c,maxAzimuthAngle:h,distance:f,minDistance:d,maxDistance:p,infinityDolly:m,minZoom:x,maxZoom:b,smoothTime:v,draggingSmoothTime:_,maxSpeed:T,azimuthRotateSpeed:w,polarRotateSpeed:M,dollySpeed:D,dollyDragInverted:S,truckSpeed:C,dollyToCursor:y,dragToOffset:A,verticalDragToForward:g,boundaryFriction:I,restThreshold:k,colliderMeshes:J}=u.toRefs(n),G={Box3:l.Box3,MathUtils:{clamp:l.MathUtils.clamp},Matrix4:l.Matrix4,Quaternion:l.Quaternion,Raycaster:l.Raycaster,Sphere:l.Sphere,Spherical:l.Spherical,Vector2:l.Vector2,Vector3:l.Vector3,Vector4:l.Vector4};rn.install({THREE:G});const{camera:Z,renderer:X,extend:K,controls:Y}=oe.useTresContext(),te=u.ref(null);K({CameraControls:rn}),u.watchEffect(()=>{re(),te.value&&i.value?Y.value=te.value:Y.value=null});function re(){Te(te.value,"update",()=>r("change",te.value)),Te(te.value,"controlend",()=>r("end",te.value)),Te(te.value,"controlstart",()=>r("start",te.value))}const{onLoop:ce}=oe.useRenderLoop();return ce(({delta:j})=>{var z,P;(z=te.value)!=null&&z.enabled&&((P=te.value)==null||P.update(j))}),u.onUnmounted(()=>{te.value&&te.value.disconnect()}),e({value:te}),(j,z)=>(j.camera||u.unref(Z))&&(j.domElement||u.unref(X))?(u.openBlock(),u.createElementBlock("TresCameraControls",{key:0,ref_key:"controlsRef",ref:te,"min-polar-angle":u.unref(s),"max-polar-angle":u.unref(a),"min-azimuth-angle":u.unref(c),"max-azimuth-angle":u.unref(h),distance:u.unref(f),"min-distance":u.unref(d),"max-distance":u.unref(p),"infinity-dolly":u.unref(m),"min-zoom":u.unref(x),"max-zoom":u.unref(b),"smooth-time":u.unref(v),"dragging-smooth-time":u.unref(_),"max-speed":u.unref(T),"azimuth-rotate-speed":u.unref(w),"polar-rotate-speed":u.unref(M),"dolly-speed":u.unref(D),"dolly-drag-inverted":u.unref(S),"truck-speed":u.unref(C),"dolly-to-cursor":u.unref(y),"drag-to-offset":u.unref(A),"vertical-drag-to-forward":u.unref(g),"boundary-friction":u.unref(I),"rest-threshold":u.unref(k),"collider-meshes":u.unref(J),args:[j.camera||u.unref(Z),j.domElement||u.unref(X).domElement]},null,8,_c)):u.createCommentVNode("",!0)}});class wc extends l.MeshStandardMaterial{constructor(t={}){super(t);le(this,"_time");le(this,"_factor");this.setValues(t),this._time={value:0},this._factor={value:1}}onBeforeCompile(t){t.uniforms||(t.uniforms={}),t.uniforms.time=this._time,t.uniforms.factor=this._factor,t.vertexShader=`
         uniform float time;
         uniform float factor;
         ${t.vertexShader}
@@ -258,68 +258,68 @@
           float s = sin( theta );
           mat3 m = mat3( c, 0, s, 0, 1, 0, -s, 0, c );
           vec3 transformed = vec3( position ) * m;
-          vNormal = vNormal * m;`)}get time(){return this._time.value}set time(t){this._time.value=t}get factor(){return this._factor.value}set factor(t){this._factor.value=t}}const vc=["factor"],xc=f.defineComponent({__name:"index",props:{speed:{default:1},factor:{default:1}},setup(o){const e=o,t=f.shallowRef(),{extend:n}=ae.useTresContext();n({MeshWobbleMaterial:_c});const{onLoop:s}=ae.useRenderLoop();return s(({elapsed:r})=>{t.value&&(t.value.time=r*(e==null?void 0:e.speed))}),(r,i)=>(f.openBlock(),f.createElementBlock("TresMeshWobbleMaterial",f.mergeProps({ref_key:"materialRef",ref:t,factor:r.factor},r.$attrs),null,16,vc))}});function gt(o,e,t){return Math.max(e,Math.min(t,o))}function wc(o,e){return(o%e+e)%e}function bc(o,e,t,n,s){return n+(o-e)*(s-n)/(t-e)}function ps(o,e,t){return(1-t)*o+t*e}class ms{constructor(e=0,t=0){ms.prototype.isVector2=!0,this.x=e,this.y=t}get width(){return this.x}set width(e){this.x=e}get height(){return this.y}set height(e){this.y=e}set(e,t){return this.x=e,this.y=t,this}setScalar(e){return this.x=e,this.y=e,this}setX(e){return this.x=e,this}setY(e){return this.y=e,this}setComponent(e,t){switch(e){case 0:this.x=t;break;case 1:this.y=t;break;default:throw new Error("index is out of range: "+e)}return this}getComponent(e){switch(e){case 0:return this.x;case 1:return this.y;default:throw new Error("index is out of range: "+e)}}clone(){return new this.constructor(this.x,this.y)}copy(e){return this.x=e.x,this.y=e.y,this}add(e){return this.x+=e.x,this.y+=e.y,this}addScalar(e){return this.x+=e,this.y+=e,this}addVectors(e,t){return this.x=e.x+t.x,this.y=e.y+t.y,this}addScaledVector(e,t){return this.x+=e.x*t,this.y+=e.y*t,this}sub(e){return this.x-=e.x,this.y-=e.y,this}subScalar(e){return this.x-=e,this.y-=e,this}subVectors(e,t){return this.x=e.x-t.x,this.y=e.y-t.y,this}multiply(e){return this.x*=e.x,this.y*=e.y,this}multiplyScalar(e){return this.x*=e,this.y*=e,this}divide(e){return this.x/=e.x,this.y/=e.y,this}divideScalar(e){return this.multiplyScalar(1/e)}applyMatrix3(e){const t=this.x,n=this.y,s=e.elements;return this.x=s[0]*t+s[3]*n+s[6],this.y=s[1]*t+s[4]*n+s[7],this}min(e){return this.x=Math.min(this.x,e.x),this.y=Math.min(this.y,e.y),this}max(e){return this.x=Math.max(this.x,e.x),this.y=Math.max(this.y,e.y),this}clamp(e,t){return this.x=Math.max(e.x,Math.min(t.x,this.x)),this.y=Math.max(e.y,Math.min(t.y,this.y)),this}clampScalar(e,t){return this.x=Math.max(e,Math.min(t,this.x)),this.y=Math.max(e,Math.min(t,this.y)),this}clampLength(e,t){const n=this.length();return this.divideScalar(n||1).multiplyScalar(Math.max(e,Math.min(t,n)))}floor(){return this.x=Math.floor(this.x),this.y=Math.floor(this.y),this}ceil(){return this.x=Math.ceil(this.x),this.y=Math.ceil(this.y),this}round(){return this.x=Math.round(this.x),this.y=Math.round(this.y),this}roundToZero(){return this.x=Math.trunc(this.x),this.y=Math.trunc(this.y),this}negate(){return this.x=-this.x,this.y=-this.y,this}dot(e){return this.x*e.x+this.y*e.y}cross(e){return this.x*e.y-this.y*e.x}lengthSq(){return this.x*this.x+this.y*this.y}length(){return Math.sqrt(this.x*this.x+this.y*this.y)}manhattanLength(){return Math.abs(this.x)+Math.abs(this.y)}normalize(){return this.divideScalar(this.length()||1)}angle(){return Math.atan2(-this.y,-this.x)+Math.PI}angleTo(e){const t=Math.sqrt(this.lengthSq()*e.lengthSq());if(t===0)return Math.PI/2;const n=this.dot(e)/t;return Math.acos(gt(n,-1,1))}distanceTo(e){return Math.sqrt(this.distanceToSquared(e))}distanceToSquared(e){const t=this.x-e.x,n=this.y-e.y;return t*t+n*n}manhattanDistanceTo(e){return Math.abs(this.x-e.x)+Math.abs(this.y-e.y)}setLength(e){return this.normalize().multiplyScalar(e)}lerp(e,t){return this.x+=(e.x-this.x)*t,this.y+=(e.y-this.y)*t,this}lerpVectors(e,t,n){return this.x=e.x+(t.x-e.x)*n,this.y=e.y+(t.y-e.y)*n,this}equals(e){return e.x===this.x&&e.y===this.y}fromArray(e,t=0){return this.x=e[t],this.y=e[t+1],this}toArray(e=[],t=0){return e[t]=this.x,e[t+1]=this.y,e}fromBufferAttribute(e,t){return this.x=e.getX(t),this.y=e.getY(t),this}rotateAround(e,t){const n=Math.cos(t),s=Math.sin(t),r=this.x-e.x,i=this.y-e.y;return this.x=r*n-i*s+e.x,this.y=r*s+i*n+e.y,this}random(){return this.x=Math.random(),this.y=Math.random(),this}*[Symbol.iterator](){yield this.x,yield this.y}}const Mc="",yt="srgb",gs="srgb-linear",Sc="display-p3",$r="display-p3-linear",ys="linear",ei="srgb",ti="rec709",ni="p3";class tn{constructor(e,t,n,s,r,i,a,l,u){tn.prototype.isMatrix3=!0,this.elements=[1,0,0,0,1,0,0,0,1],e!==void 0&&this.set(e,t,n,s,r,i,a,l,u)}set(e,t,n,s,r,i,a,l,u){const h=this.elements;return h[0]=e,h[1]=s,h[2]=a,h[3]=t,h[4]=r,h[5]=l,h[6]=n,h[7]=i,h[8]=u,this}identity(){return this.set(1,0,0,0,1,0,0,0,1),this}copy(e){const t=this.elements,n=e.elements;return t[0]=n[0],t[1]=n[1],t[2]=n[2],t[3]=n[3],t[4]=n[4],t[5]=n[5],t[6]=n[6],t[7]=n[7],t[8]=n[8],this}extractBasis(e,t,n){return e.setFromMatrix3Column(this,0),t.setFromMatrix3Column(this,1),n.setFromMatrix3Column(this,2),this}setFromMatrix4(e){const t=e.elements;return this.set(t[0],t[4],t[8],t[1],t[5],t[9],t[2],t[6],t[10]),this}multiply(e){return this.multiplyMatrices(this,e)}premultiply(e){return this.multiplyMatrices(e,this)}multiplyMatrices(e,t){const n=e.elements,s=t.elements,r=this.elements,i=n[0],a=n[3],l=n[6],u=n[1],h=n[4],d=n[7],y=n[2],g=n[5],x=n[8],w=s[0],v=s[3],P=s[6],D=s[1],S=s[4],_=s[7],L=s[2],b=s[5],C=s[8];return r[0]=i*w+a*D+l*L,r[3]=i*v+a*S+l*b,r[6]=i*P+a*_+l*C,r[1]=u*w+h*D+d*L,r[4]=u*v+h*S+d*b,r[7]=u*P+h*_+d*C,r[2]=y*w+g*D+x*L,r[5]=y*v+g*S+x*b,r[8]=y*P+g*_+x*C,this}multiplyScalar(e){const t=this.elements;return t[0]*=e,t[3]*=e,t[6]*=e,t[1]*=e,t[4]*=e,t[7]*=e,t[2]*=e,t[5]*=e,t[8]*=e,this}determinant(){const e=this.elements,t=e[0],n=e[1],s=e[2],r=e[3],i=e[4],a=e[5],l=e[6],u=e[7],h=e[8];return t*i*h-t*a*u-n*r*h+n*a*l+s*r*u-s*i*l}invert(){const e=this.elements,t=e[0],n=e[1],s=e[2],r=e[3],i=e[4],a=e[5],l=e[6],u=e[7],h=e[8],d=h*i-a*u,y=a*l-h*r,g=u*r-i*l,x=t*d+n*y+s*g;if(x===0)return this.set(0,0,0,0,0,0,0,0,0);const w=1/x;return e[0]=d*w,e[1]=(s*u-h*n)*w,e[2]=(a*n-s*i)*w,e[3]=y*w,e[4]=(h*t-s*l)*w,e[5]=(s*r-a*t)*w,e[6]=g*w,e[7]=(n*l-u*t)*w,e[8]=(i*t-n*r)*w,this}transpose(){let e;const t=this.elements;return e=t[1],t[1]=t[3],t[3]=e,e=t[2],t[2]=t[6],t[6]=e,e=t[5],t[5]=t[7],t[7]=e,this}getNormalMatrix(e){return this.setFromMatrix4(e).invert().transpose()}transposeIntoArray(e){const t=this.elements;return e[0]=t[0],e[1]=t[3],e[2]=t[6],e[3]=t[1],e[4]=t[4],e[5]=t[7],e[6]=t[2],e[7]=t[5],e[8]=t[8],this}setUvTransform(e,t,n,s,r,i,a){const l=Math.cos(r),u=Math.sin(r);return this.set(n*l,n*u,-n*(l*i+u*a)+i+e,-s*u,s*l,-s*(-u*i+l*a)+a+t,0,0,1),this}scale(e,t){return this.premultiply(_s.makeScale(e,t)),this}rotate(e){return this.premultiply(_s.makeRotation(-e)),this}translate(e,t){return this.premultiply(_s.makeTranslation(e,t)),this}makeTranslation(e,t){return e.isVector2?this.set(1,0,e.x,0,1,e.y,0,0,1):this.set(1,0,e,0,1,t,0,0,1),this}makeRotation(e){const t=Math.cos(e),n=Math.sin(e);return this.set(t,-n,0,n,t,0,0,0,1),this}makeScale(e,t){return this.set(e,0,0,0,t,0,0,0,1),this}equals(e){const t=this.elements,n=e.elements;for(let s=0;s<9;s++)if(t[s]!==n[s])return!1;return!0}fromArray(e,t=0){for(let n=0;n<9;n++)this.elements[n]=e[n+t];return this}toArray(e=[],t=0){const n=this.elements;return e[t]=n[0],e[t+1]=n[1],e[t+2]=n[2],e[t+3]=n[3],e[t+4]=n[4],e[t+5]=n[5],e[t+6]=n[6],e[t+7]=n[7],e[t+8]=n[8],e}clone(){return new this.constructor().fromArray(this.elements)}}const _s=new tn,si=new tn().set(.8224621,.177538,0,.0331941,.9668058,0,.0170827,.0723974,.9105199),ri=new tn().set(1.2249401,-.2249404,0,-.0420569,1.0420571,0,-.0196376,-.0786361,1.0982735),An={[gs]:{transfer:ys,primaries:ti,toReference:o=>o,fromReference:o=>o},[yt]:{transfer:ei,primaries:ti,toReference:o=>o.convertSRGBToLinear(),fromReference:o=>o.convertLinearToSRGB()},[$r]:{transfer:ys,primaries:ni,toReference:o=>o.applyMatrix3(ri),fromReference:o=>o.applyMatrix3(si)},[Sc]:{transfer:ei,primaries:ni,toReference:o=>o.convertSRGBToLinear().applyMatrix3(ri),fromReference:o=>o.applyMatrix3(si).convertLinearToSRGB()}},Ac=new Set([gs,$r]),Je={enabled:!0,_workingColorSpace:gs,get workingColorSpace(){return this._workingColorSpace},set workingColorSpace(o){if(!Ac.has(o))throw new Error(`Unsupported working color space, "${o}".`);this._workingColorSpace=o},convert:function(o,e,t){if(this.enabled===!1||e===t||!e||!t)return o;const n=An[e].toReference,s=An[t].fromReference;return s(n(o))},fromWorkingColorSpace:function(o,e){return this.convert(o,this._workingColorSpace,e)},toWorkingColorSpace:function(o,e){return this.convert(o,e,this._workingColorSpace)},getPrimaries:function(o){return An[o].primaries},getTransfer:function(o){return o===Mc?ys:An[o].transfer}};function vs(o){return o<.04045?o*.0773993808:Math.pow(o*.9478672986+.0521327014,2.4)}function xs(o){return o<.0031308?o*12.92:1.055*Math.pow(o,.41666)-.055}const ii={aliceblue:15792383,antiquewhite:16444375,aqua:65535,aquamarine:8388564,azure:15794175,beige:16119260,bisque:16770244,black:0,blanchedalmond:16772045,blue:255,blueviolet:9055202,brown:10824234,burlywood:14596231,cadetblue:6266528,chartreuse:8388352,chocolate:13789470,coral:16744272,cornflowerblue:6591981,cornsilk:16775388,crimson:14423100,cyan:65535,darkblue:139,darkcyan:35723,darkgoldenrod:12092939,darkgray:11119017,darkgreen:25600,darkgrey:11119017,darkkhaki:12433259,darkmagenta:9109643,darkolivegreen:5597999,darkorange:16747520,darkorchid:10040012,darkred:9109504,darksalmon:15308410,darkseagreen:9419919,darkslateblue:4734347,darkslategray:3100495,darkslategrey:3100495,darkturquoise:52945,darkviolet:9699539,deeppink:16716947,deepskyblue:49151,dimgray:6908265,dimgrey:6908265,dodgerblue:2003199,firebrick:11674146,floralwhite:16775920,forestgreen:2263842,fuchsia:16711935,gainsboro:14474460,ghostwhite:16316671,gold:16766720,goldenrod:14329120,gray:8421504,green:32768,greenyellow:11403055,grey:8421504,honeydew:15794160,hotpink:16738740,indianred:13458524,indigo:4915330,ivory:16777200,khaki:15787660,lavender:15132410,lavenderblush:16773365,lawngreen:8190976,lemonchiffon:16775885,lightblue:11393254,lightcoral:15761536,lightcyan:14745599,lightgoldenrodyellow:16448210,lightgray:13882323,lightgreen:9498256,lightgrey:13882323,lightpink:16758465,lightsalmon:16752762,lightseagreen:2142890,lightskyblue:8900346,lightslategray:7833753,lightslategrey:7833753,lightsteelblue:11584734,lightyellow:16777184,lime:65280,limegreen:3329330,linen:16445670,magenta:16711935,maroon:8388608,mediumaquamarine:6737322,mediumblue:205,mediumorchid:12211667,mediumpurple:9662683,mediumseagreen:3978097,mediumslateblue:8087790,mediumspringgreen:64154,mediumturquoise:4772300,mediumvioletred:13047173,midnightblue:1644912,mintcream:16121850,mistyrose:16770273,moccasin:16770229,navajowhite:16768685,navy:128,oldlace:16643558,olive:8421376,olivedrab:7048739,orange:16753920,orangered:16729344,orchid:14315734,palegoldenrod:15657130,palegreen:10025880,paleturquoise:11529966,palevioletred:14381203,papayawhip:16773077,peachpuff:16767673,peru:13468991,pink:16761035,plum:14524637,powderblue:11591910,purple:8388736,rebeccapurple:6697881,red:16711680,rosybrown:12357519,royalblue:4286945,saddlebrown:9127187,salmon:16416882,sandybrown:16032864,seagreen:3050327,seashell:16774638,sienna:10506797,silver:12632256,skyblue:8900331,slateblue:6970061,slategray:7372944,slategrey:7372944,snow:16775930,springgreen:65407,steelblue:4620980,tan:13808780,teal:32896,thistle:14204888,tomato:16737095,turquoise:4251856,violet:15631086,wheat:16113331,white:16777215,whitesmoke:16119285,yellow:16776960,yellowgreen:10145074},_t={h:0,s:0,l:0},Pn={h:0,s:0,l:0};function ws(o,e,t){return t<0&&(t+=1),t>1&&(t-=1),t<1/6?o+(e-o)*6*t:t<1/2?e:t<2/3?o+(e-o)*6*(2/3-t):o}class Cn{constructor(e,t,n){return this.isColor=!0,this.r=1,this.g=1,this.b=1,this.set(e,t,n)}set(e,t,n){if(t===void 0&&n===void 0){const s=e;s&&s.isColor?this.copy(s):typeof s=="number"?this.setHex(s):typeof s=="string"&&this.setStyle(s)}else this.setRGB(e,t,n);return this}setScalar(e){return this.r=e,this.g=e,this.b=e,this}setHex(e,t=yt){return e=Math.floor(e),this.r=(e>>16&255)/255,this.g=(e>>8&255)/255,this.b=(e&255)/255,Je.toWorkingColorSpace(this,t),this}setRGB(e,t,n,s=Je.workingColorSpace){return this.r=e,this.g=t,this.b=n,Je.toWorkingColorSpace(this,s),this}setHSL(e,t,n,s=Je.workingColorSpace){if(e=wc(e,1),t=gt(t,0,1),n=gt(n,0,1),t===0)this.r=this.g=this.b=n;else{const r=n<=.5?n*(1+t):n+t-n*t,i=2*n-r;this.r=ws(i,r,e+1/3),this.g=ws(i,r,e),this.b=ws(i,r,e-1/3)}return Je.toWorkingColorSpace(this,s),this}setStyle(e,t=yt){function n(r){r!==void 0&&parseFloat(r)<1&&console.warn("THREE.Color: Alpha component of "+e+" will be ignored.")}let s;if(s=/^(\w+)\(([^\)]*)\)/.exec(e)){let r;const i=s[1],a=s[2];switch(i){case"rgb":case"rgba":if(r=/^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(a))return n(r[4]),this.setRGB(Math.min(255,parseInt(r[1],10))/255,Math.min(255,parseInt(r[2],10))/255,Math.min(255,parseInt(r[3],10))/255,t);if(r=/^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(a))return n(r[4]),this.setRGB(Math.min(100,parseInt(r[1],10))/100,Math.min(100,parseInt(r[2],10))/100,Math.min(100,parseInt(r[3],10))/100,t);break;case"hsl":case"hsla":if(r=/^\s*(\d*\.?\d+)\s*,\s*(\d*\.?\d+)\%\s*,\s*(\d*\.?\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(a))return n(r[4]),this.setHSL(parseFloat(r[1])/360,parseFloat(r[2])/100,parseFloat(r[3])/100,t);break;default:console.warn("THREE.Color: Unknown color model "+e)}}else if(s=/^\#([A-Fa-f\d]+)$/.exec(e)){const r=s[1],i=r.length;if(i===3)return this.setRGB(parseInt(r.charAt(0),16)/15,parseInt(r.charAt(1),16)/15,parseInt(r.charAt(2),16)/15,t);if(i===6)return this.setHex(parseInt(r,16),t);console.warn("THREE.Color: Invalid hex color "+e)}else if(e&&e.length>0)return this.setColorName(e,t);return this}setColorName(e,t=yt){const n=ii[e.toLowerCase()];return n!==void 0?this.setHex(n,t):console.warn("THREE.Color: Unknown color "+e),this}clone(){return new this.constructor(this.r,this.g,this.b)}copy(e){return this.r=e.r,this.g=e.g,this.b=e.b,this}copySRGBToLinear(e){return this.r=vs(e.r),this.g=vs(e.g),this.b=vs(e.b),this}copyLinearToSRGB(e){return this.r=xs(e.r),this.g=xs(e.g),this.b=xs(e.b),this}convertSRGBToLinear(){return this.copySRGBToLinear(this),this}convertLinearToSRGB(){return this.copyLinearToSRGB(this),this}getHex(e=yt){return Je.fromWorkingColorSpace(ze.copy(this),e),Math.round(gt(ze.r*255,0,255))*65536+Math.round(gt(ze.g*255,0,255))*256+Math.round(gt(ze.b*255,0,255))}getHexString(e=yt){return("000000"+this.getHex(e).toString(16)).slice(-6)}getHSL(e,t=Je.workingColorSpace){Je.fromWorkingColorSpace(ze.copy(this),t);const n=ze.r,s=ze.g,r=ze.b,i=Math.max(n,s,r),a=Math.min(n,s,r);let l,u;const h=(a+i)/2;if(a===i)l=0,u=0;else{const d=i-a;switch(u=h<=.5?d/(i+a):d/(2-i-a),i){case n:l=(s-r)/d+(s<r?6:0);break;case s:l=(r-n)/d+2;break;case r:l=(n-s)/d+4;break}l/=6}return e.h=l,e.s=u,e.l=h,e}getRGB(e,t=Je.workingColorSpace){return Je.fromWorkingColorSpace(ze.copy(this),t),e.r=ze.r,e.g=ze.g,e.b=ze.b,e}getStyle(e=yt){Je.fromWorkingColorSpace(ze.copy(this),e);const t=ze.r,n=ze.g,s=ze.b;return e!==yt?`color(${e} ${t.toFixed(3)} ${n.toFixed(3)} ${s.toFixed(3)})`:`rgb(${Math.round(t*255)},${Math.round(n*255)},${Math.round(s*255)})`}offsetHSL(e,t,n){return this.getHSL(_t),this.setHSL(_t.h+e,_t.s+t,_t.l+n)}add(e){return this.r+=e.r,this.g+=e.g,this.b+=e.b,this}addColors(e,t){return this.r=e.r+t.r,this.g=e.g+t.g,this.b=e.b+t.b,this}addScalar(e){return this.r+=e,this.g+=e,this.b+=e,this}sub(e){return this.r=Math.max(0,this.r-e.r),this.g=Math.max(0,this.g-e.g),this.b=Math.max(0,this.b-e.b),this}multiply(e){return this.r*=e.r,this.g*=e.g,this.b*=e.b,this}multiplyScalar(e){return this.r*=e,this.g*=e,this.b*=e,this}lerp(e,t){return this.r+=(e.r-this.r)*t,this.g+=(e.g-this.g)*t,this.b+=(e.b-this.b)*t,this}lerpColors(e,t,n){return this.r=e.r+(t.r-e.r)*n,this.g=e.g+(t.g-e.g)*n,this.b=e.b+(t.b-e.b)*n,this}lerpHSL(e,t){this.getHSL(_t),e.getHSL(Pn);const n=ps(_t.h,Pn.h,t),s=ps(_t.s,Pn.s,t),r=ps(_t.l,Pn.l,t);return this.setHSL(n,s,r),this}setFromVector3(e){return this.r=e.x,this.g=e.y,this.b=e.z,this}applyMatrix3(e){const t=this.r,n=this.g,s=this.b,r=e.elements;return this.r=r[0]*t+r[3]*n+r[6]*s,this.g=r[1]*t+r[4]*n+r[7]*s,this.b=r[2]*t+r[5]*n+r[8]*s,this}equals(e){return e.r===this.r&&e.g===this.g&&e.b===this.b}fromArray(e,t=0){return this.r=e[t],this.g=e[t+1],this.b=e[t+2],this}toArray(e=[],t=0){return e[t]=this.r,e[t+1]=this.g,e[t+2]=this.b,e}fromBufferAttribute(e,t){return this.r=e.getX(t),this.g=e.getY(t),this.b=e.getZ(t),this}toJSON(){return this.getHex()}*[Symbol.iterator](){yield this.r,yield this.g,yield this.b}}const ze=new Cn;Cn.NAMES=ii;class Pc extends c.MeshStandardMaterial{constructor(t={}){super();le(this,"isMeshPhysicalMaterial");le(this,"clearcoatMap");le(this,"clearcoatRoughness");le(this,"clearcoatRoughnessMap");le(this,"clearcoatNormalScale");le(this,"clearcoatNormalMap");le(this,"ior");le(this,"transmissionMap");le(this,"thickness");le(this,"thicknessMap");le(this,"attenuationDistance");le(this,"attenuationColor");le(this,"specularIntensity");le(this,"specularIntensityMap");le(this,"specularColor");le(this,"specularColorMap");le(this,"_clearcoat");le(this,"_transmission");this.isMeshPhysicalMaterial=!0,this.defines={STANDARD:"",PHYSICAL:""},this.type="MeshPhysicalMaterial",this.clearcoatMap=null,this.clearcoatRoughness=0,this.clearcoatRoughnessMap=null,this.clearcoatNormalScale=new ms(1,1),this.clearcoatNormalMap=null,this.ior=1.5,Object.defineProperty(this,"reflectivity",{get(){return gt(2.5*(this.ior-1)/(this.ior+1),0,1)},set(n){this.ior=(1+.4*n)/(1-.4*n)}}),this.roughness=0,this.transmissionMap=null,this.thickness=.5,this.thicknessMap=null,this.attenuationDistance=1/0,this.attenuationColor=new Cn(1,1,1),this.specularIntensity=1,this.specularIntensityMap=null,this.specularColor=new Cn(1,1,1),this.specularColorMap=null,this._clearcoat=.5,this._transmission=1,this.setValues(t)}get clearcoat(){return this._clearcoat}set clearcoat(t){this._clearcoat>0!=t>0&&this.version++,this._clearcoat=t}get transmission(){return this._transmission}set transmission(t){this._transmission>0!=t>0&&this.version++,this._transmission=t}copy(t){return super.copy(t),this.defines={STANDARD:"",PHYSICAL:""},this.clearcoat=t.clearcoat,this.clearcoatMap=t.clearcoatMap,this.clearcoatRoughness=t.clearcoatRoughness,this.clearcoatRoughnessMap=t.clearcoatRoughnessMap,this.clearcoatNormalMap=t.clearcoatNormalMap,this.clearcoatNormalScale.copy(t.clearcoatNormalScale),this.ior=t.ior,this.transmission=t.transmission,this.transmissionMap=t.transmissionMap,this.thickness=t.thickness,this.thicknessMap=t.thicknessMap,this.attenuationDistance=t.attenuationDistance,this.attenuationColor.copy(t.attenuationColor),this.specularIntensity=t.specularIntensity,this.specularIntensityMap=t.specularIntensityMap,this.specularColor.copy(t.specularColor),this.specularColorMap=t.specularColorMap,this}}const Cc=Pc,Tc=f.defineComponent({__name:"index",setup(o,{expose:e}){const t=f.shallowRef(),{extend:n}=ae.useTresContext();return n({MeshGlassMaterial:Cc}),e({MeshGlassMaterialClass:t}),(s,r)=>(f.openBlock(),f.createElementBlock("TresMeshGlassMaterial",{ref_key:"MeshGlassMaterialClass",ref:t},null,512))}});var Lc=typeof globalThis<"u"?globalThis:typeof window<"u"?window:typeof global<"u"?global:typeof self<"u"?self:{};function nn(o){return o&&o.__esModule&&Object.prototype.hasOwnProperty.call(o,"default")?o.default:o}function Tn(o){throw new Error('Could not dynamically require "'+o+'". Please configure the dynamicRequireTargets or/and ignoreDynamicRequires option of @rollup/plugin-commonjs appropriately for this require call to work.')}var oi={exports:{}};(function(o,e){(function(t){o.exports=t()})(function(){return function t(n,s,r){function i(u,h){if(!s[u]){if(!n[u]){var d=typeof Tn=="function"&&Tn;if(!h&&d)return d(u,!0);if(a)return a(u,!0);throw new Error("Cannot find module '"+u+"'")}h=s[u]={exports:{}},n[u][0].call(h.exports,function(y){var g=n[u][1][y];return i(g||y)},h,h.exports,t,n,s,r)}return s[u].exports}for(var a=typeof Tn=="function"&&Tn,l=0;l<r.length;l++)i(r[l]);return i}({1:[function(t,n,s){(function(r,i,a,l,u,h,d,y,g){var x=t("crypto");function w(b,C){C=D(b,C);var m;return(m=C.algorithm!=="passthrough"?x.createHash(C.algorithm):new L).write===void 0&&(m.write=m.update,m.end=m.update),_(C,m).dispatch(b),m.update||m.end(""),m.digest?m.digest(C.encoding==="buffer"?void 0:C.encoding):(b=m.read(),C.encoding!=="buffer"?b.toString(C.encoding):b)}(s=n.exports=w).sha1=function(b){return w(b)},s.keys=function(b){return w(b,{excludeValues:!0,algorithm:"sha1",encoding:"hex"})},s.MD5=function(b){return w(b,{algorithm:"md5",encoding:"hex"})},s.keysMD5=function(b){return w(b,{algorithm:"md5",encoding:"hex",excludeValues:!0})};var v=x.getHashes?x.getHashes().slice():["sha1","md5"],P=(v.push("passthrough"),["buffer","hex","binary","base64"]);function D(b,C){var m={};if(m.algorithm=(C=C||{}).algorithm||"sha1",m.encoding=C.encoding||"hex",m.excludeValues=!!C.excludeValues,m.algorithm=m.algorithm.toLowerCase(),m.encoding=m.encoding.toLowerCase(),m.ignoreUnknown=C.ignoreUnknown===!0,m.respectType=C.respectType!==!1,m.respectFunctionNames=C.respectFunctionNames!==!1,m.respectFunctionProperties=C.respectFunctionProperties!==!1,m.unorderedArrays=C.unorderedArrays===!0,m.unorderedSets=C.unorderedSets!==!1,m.unorderedObjects=C.unorderedObjects!==!1,m.replacer=C.replacer||void 0,m.excludeKeys=C.excludeKeys||void 0,b===void 0)throw new Error("Object argument required.");for(var M=0;M<v.length;++M)v[M].toLowerCase()===m.algorithm.toLowerCase()&&(m.algorithm=v[M]);if(v.indexOf(m.algorithm)===-1)throw new Error('Algorithm "'+m.algorithm+'"  not supported. supported values: '+v.join(", "));if(P.indexOf(m.encoding)===-1&&m.algorithm!=="passthrough")throw new Error('Encoding "'+m.encoding+'"  not supported. supported values: '+P.join(", "));return m}function S(b){if(typeof b=="function")return/^function\s+\w*\s*\(\s*\)\s*{\s+\[native code\]\s+}$/i.exec(Function.prototype.toString.call(b))!=null}function _(b,C,m){m=m||[];function M(p){return C.update?C.update(p,"utf8"):C.write(p,"utf8")}return{dispatch:function(p){return this["_"+((p=b.replacer?b.replacer(p):p)===null?"null":typeof p)](p)},_object:function(p){var I,F=Object.prototype.toString.call(p),J=/\[object (.*)\]/i.exec(F);if(J=(J=J?J[1]:"unknown:["+F+"]").toLowerCase(),0<=(F=m.indexOf(p)))return this.dispatch("[CIRCULAR:"+F+"]");if(m.push(p),a!==void 0&&a.isBuffer&&a.isBuffer(p))return M("buffer:"),M(p);if(J==="object"||J==="function"||J==="asyncfunction")return F=Object.keys(p),b.unorderedObjects&&(F=F.sort()),b.respectType===!1||S(p)||F.splice(0,0,"prototype","__proto__","constructor"),b.excludeKeys&&(F=F.filter(function(G){return!b.excludeKeys(G)})),M("object:"+F.length+":"),I=this,F.forEach(function(G){I.dispatch(G),M(":"),b.excludeValues||I.dispatch(p[G]),M(",")});if(!this["_"+J]){if(b.ignoreUnknown)return M("["+J+"]");throw new Error('Unknown object type "'+J+'"')}this["_"+J](p)},_array:function(p,G){G=G!==void 0?G:b.unorderedArrays!==!1;var F=this;if(M("array:"+p.length+":"),!G||p.length<=1)return p.forEach(function(Q){return F.dispatch(Q)});var J=[],G=p.map(function(Q){var K=new L,Z=m.slice();return _(b,K,Z).dispatch(Q),J=J.concat(Z.slice(m.length)),K.read().toString()});return m=m.concat(J),G.sort(),this._array(G,!1)},_date:function(p){return M("date:"+p.toJSON())},_symbol:function(p){return M("symbol:"+p.toString())},_error:function(p){return M("error:"+p.toString())},_boolean:function(p){return M("bool:"+p.toString())},_string:function(p){M("string:"+p.length+":"),M(p.toString())},_function:function(p){M("fn:"),S(p)?this.dispatch("[native]"):this.dispatch(p.toString()),b.respectFunctionNames!==!1&&this.dispatch("function-name:"+String(p.name)),b.respectFunctionProperties&&this._object(p)},_number:function(p){return M("number:"+p.toString())},_xml:function(p){return M("xml:"+p.toString())},_null:function(){return M("Null")},_undefined:function(){return M("Undefined")},_regexp:function(p){return M("regex:"+p.toString())},_uint8array:function(p){return M("uint8array:"),this.dispatch(Array.prototype.slice.call(p))},_uint8clampedarray:function(p){return M("uint8clampedarray:"),this.dispatch(Array.prototype.slice.call(p))},_int8array:function(p){return M("int8array:"),this.dispatch(Array.prototype.slice.call(p))},_uint16array:function(p){return M("uint16array:"),this.dispatch(Array.prototype.slice.call(p))},_int16array:function(p){return M("int16array:"),this.dispatch(Array.prototype.slice.call(p))},_uint32array:function(p){return M("uint32array:"),this.dispatch(Array.prototype.slice.call(p))},_int32array:function(p){return M("int32array:"),this.dispatch(Array.prototype.slice.call(p))},_float32array:function(p){return M("float32array:"),this.dispatch(Array.prototype.slice.call(p))},_float64array:function(p){return M("float64array:"),this.dispatch(Array.prototype.slice.call(p))},_arraybuffer:function(p){return M("arraybuffer:"),this.dispatch(new Uint8Array(p))},_url:function(p){return M("url:"+p.toString())},_map:function(p){return M("map:"),p=Array.from(p),this._array(p,b.unorderedSets!==!1)},_set:function(p){return M("set:"),p=Array.from(p),this._array(p,b.unorderedSets!==!1)},_file:function(p){return M("file:"),this.dispatch([p.name,p.size,p.type,p.lastModfied])},_blob:function(){if(b.ignoreUnknown)return M("[blob]");throw Error(`Hashing Blob objects is currently not supported
+          vNormal = vNormal * m;`)}get time(){return this._time.value}set time(t){this._time.value=t}get factor(){return this._factor.value}set factor(t){this._factor.value=t}}const bc=["factor"],Mc=u.defineComponent({__name:"index",props:{speed:{default:1},factor:{default:1}},setup(o){const e=o,t=u.shallowRef(),{extend:n}=oe.useTresContext();n({MeshWobbleMaterial:wc});const{onLoop:r}=oe.useRenderLoop();return r(({elapsed:i})=>{t.value&&(t.value.time=i*(e==null?void 0:e.speed))}),(i,s)=>(u.openBlock(),u.createElementBlock("TresMeshWobbleMaterial",u.mergeProps({ref_key:"materialRef",ref:t,factor:i.factor},i.$attrs),null,16,bc))}});function yt(o,e,t){return Math.max(e,Math.min(t,o))}function Sc(o,e){return(o%e+e)%e}function Ac(o,e,t,n,r){return n+(o-e)*(r-n)/(t-e)}function yr(o,e,t){return(1-t)*o+t*e}class vr{constructor(e=0,t=0){vr.prototype.isVector2=!0,this.x=e,this.y=t}get width(){return this.x}set width(e){this.x=e}get height(){return this.y}set height(e){this.y=e}set(e,t){return this.x=e,this.y=t,this}setScalar(e){return this.x=e,this.y=e,this}setX(e){return this.x=e,this}setY(e){return this.y=e,this}setComponent(e,t){switch(e){case 0:this.x=t;break;case 1:this.y=t;break;default:throw new Error("index is out of range: "+e)}return this}getComponent(e){switch(e){case 0:return this.x;case 1:return this.y;default:throw new Error("index is out of range: "+e)}}clone(){return new this.constructor(this.x,this.y)}copy(e){return this.x=e.x,this.y=e.y,this}add(e){return this.x+=e.x,this.y+=e.y,this}addScalar(e){return this.x+=e,this.y+=e,this}addVectors(e,t){return this.x=e.x+t.x,this.y=e.y+t.y,this}addScaledVector(e,t){return this.x+=e.x*t,this.y+=e.y*t,this}sub(e){return this.x-=e.x,this.y-=e.y,this}subScalar(e){return this.x-=e,this.y-=e,this}subVectors(e,t){return this.x=e.x-t.x,this.y=e.y-t.y,this}multiply(e){return this.x*=e.x,this.y*=e.y,this}multiplyScalar(e){return this.x*=e,this.y*=e,this}divide(e){return this.x/=e.x,this.y/=e.y,this}divideScalar(e){return this.multiplyScalar(1/e)}applyMatrix3(e){const t=this.x,n=this.y,r=e.elements;return this.x=r[0]*t+r[3]*n+r[6],this.y=r[1]*t+r[4]*n+r[7],this}min(e){return this.x=Math.min(this.x,e.x),this.y=Math.min(this.y,e.y),this}max(e){return this.x=Math.max(this.x,e.x),this.y=Math.max(this.y,e.y),this}clamp(e,t){return this.x=Math.max(e.x,Math.min(t.x,this.x)),this.y=Math.max(e.y,Math.min(t.y,this.y)),this}clampScalar(e,t){return this.x=Math.max(e,Math.min(t,this.x)),this.y=Math.max(e,Math.min(t,this.y)),this}clampLength(e,t){const n=this.length();return this.divideScalar(n||1).multiplyScalar(Math.max(e,Math.min(t,n)))}floor(){return this.x=Math.floor(this.x),this.y=Math.floor(this.y),this}ceil(){return this.x=Math.ceil(this.x),this.y=Math.ceil(this.y),this}round(){return this.x=Math.round(this.x),this.y=Math.round(this.y),this}roundToZero(){return this.x=Math.trunc(this.x),this.y=Math.trunc(this.y),this}negate(){return this.x=-this.x,this.y=-this.y,this}dot(e){return this.x*e.x+this.y*e.y}cross(e){return this.x*e.y-this.y*e.x}lengthSq(){return this.x*this.x+this.y*this.y}length(){return Math.sqrt(this.x*this.x+this.y*this.y)}manhattanLength(){return Math.abs(this.x)+Math.abs(this.y)}normalize(){return this.divideScalar(this.length()||1)}angle(){return Math.atan2(-this.y,-this.x)+Math.PI}angleTo(e){const t=Math.sqrt(this.lengthSq()*e.lengthSq());if(t===0)return Math.PI/2;const n=this.dot(e)/t;return Math.acos(yt(n,-1,1))}distanceTo(e){return Math.sqrt(this.distanceToSquared(e))}distanceToSquared(e){const t=this.x-e.x,n=this.y-e.y;return t*t+n*n}manhattanDistanceTo(e){return Math.abs(this.x-e.x)+Math.abs(this.y-e.y)}setLength(e){return this.normalize().multiplyScalar(e)}lerp(e,t){return this.x+=(e.x-this.x)*t,this.y+=(e.y-this.y)*t,this}lerpVectors(e,t,n){return this.x=e.x+(t.x-e.x)*n,this.y=e.y+(t.y-e.y)*n,this}equals(e){return e.x===this.x&&e.y===this.y}fromArray(e,t=0){return this.x=e[t],this.y=e[t+1],this}toArray(e=[],t=0){return e[t]=this.x,e[t+1]=this.y,e}fromBufferAttribute(e,t){return this.x=e.getX(t),this.y=e.getY(t),this}rotateAround(e,t){const n=Math.cos(t),r=Math.sin(t),i=this.x-e.x,s=this.y-e.y;return this.x=i*n-s*r+e.x,this.y=i*r+s*n+e.y,this}random(){return this.x=Math.random(),this.y=Math.random(),this}*[Symbol.iterator](){yield this.x,yield this.y}}const Cc="",vt="srgb",_r="srgb-linear",Pc="display-p3",ns="display-p3-linear",xr="linear",rs="srgb",is="rec709",ss="p3";class sn{constructor(e,t,n,r,i,s,a,c,h){sn.prototype.isMatrix3=!0,this.elements=[1,0,0,0,1,0,0,0,1],e!==void 0&&this.set(e,t,n,r,i,s,a,c,h)}set(e,t,n,r,i,s,a,c,h){const f=this.elements;return f[0]=e,f[1]=r,f[2]=a,f[3]=t,f[4]=i,f[5]=c,f[6]=n,f[7]=s,f[8]=h,this}identity(){return this.set(1,0,0,0,1,0,0,0,1),this}copy(e){const t=this.elements,n=e.elements;return t[0]=n[0],t[1]=n[1],t[2]=n[2],t[3]=n[3],t[4]=n[4],t[5]=n[5],t[6]=n[6],t[7]=n[7],t[8]=n[8],this}extractBasis(e,t,n){return e.setFromMatrix3Column(this,0),t.setFromMatrix3Column(this,1),n.setFromMatrix3Column(this,2),this}setFromMatrix4(e){const t=e.elements;return this.set(t[0],t[4],t[8],t[1],t[5],t[9],t[2],t[6],t[10]),this}multiply(e){return this.multiplyMatrices(this,e)}premultiply(e){return this.multiplyMatrices(e,this)}multiplyMatrices(e,t){const n=e.elements,r=t.elements,i=this.elements,s=n[0],a=n[3],c=n[6],h=n[1],f=n[4],d=n[7],p=n[2],m=n[5],x=n[8],b=r[0],v=r[3],_=r[6],T=r[1],w=r[4],M=r[7],D=r[2],S=r[5],C=r[8];return i[0]=s*b+a*T+c*D,i[3]=s*v+a*w+c*S,i[6]=s*_+a*M+c*C,i[1]=h*b+f*T+d*D,i[4]=h*v+f*w+d*S,i[7]=h*_+f*M+d*C,i[2]=p*b+m*T+x*D,i[5]=p*v+m*w+x*S,i[8]=p*_+m*M+x*C,this}multiplyScalar(e){const t=this.elements;return t[0]*=e,t[3]*=e,t[6]*=e,t[1]*=e,t[4]*=e,t[7]*=e,t[2]*=e,t[5]*=e,t[8]*=e,this}determinant(){const e=this.elements,t=e[0],n=e[1],r=e[2],i=e[3],s=e[4],a=e[5],c=e[6],h=e[7],f=e[8];return t*s*f-t*a*h-n*i*f+n*a*c+r*i*h-r*s*c}invert(){const e=this.elements,t=e[0],n=e[1],r=e[2],i=e[3],s=e[4],a=e[5],c=e[6],h=e[7],f=e[8],d=f*s-a*h,p=a*c-f*i,m=h*i-s*c,x=t*d+n*p+r*m;if(x===0)return this.set(0,0,0,0,0,0,0,0,0);const b=1/x;return e[0]=d*b,e[1]=(r*h-f*n)*b,e[2]=(a*n-r*s)*b,e[3]=p*b,e[4]=(f*t-r*c)*b,e[5]=(r*i-a*t)*b,e[6]=m*b,e[7]=(n*c-h*t)*b,e[8]=(s*t-n*i)*b,this}transpose(){let e;const t=this.elements;return e=t[1],t[1]=t[3],t[3]=e,e=t[2],t[2]=t[6],t[6]=e,e=t[5],t[5]=t[7],t[7]=e,this}getNormalMatrix(e){return this.setFromMatrix4(e).invert().transpose()}transposeIntoArray(e){const t=this.elements;return e[0]=t[0],e[1]=t[3],e[2]=t[6],e[3]=t[1],e[4]=t[4],e[5]=t[7],e[6]=t[2],e[7]=t[5],e[8]=t[8],this}setUvTransform(e,t,n,r,i,s,a){const c=Math.cos(i),h=Math.sin(i);return this.set(n*c,n*h,-n*(c*s+h*a)+s+e,-r*h,r*c,-r*(-h*s+c*a)+a+t,0,0,1),this}scale(e,t){return this.premultiply(wr.makeScale(e,t)),this}rotate(e){return this.premultiply(wr.makeRotation(-e)),this}translate(e,t){return this.premultiply(wr.makeTranslation(e,t)),this}makeTranslation(e,t){return e.isVector2?this.set(1,0,e.x,0,1,e.y,0,0,1):this.set(1,0,e,0,1,t,0,0,1),this}makeRotation(e){const t=Math.cos(e),n=Math.sin(e);return this.set(t,-n,0,n,t,0,0,0,1),this}makeScale(e,t){return this.set(e,0,0,0,t,0,0,0,1),this}equals(e){const t=this.elements,n=e.elements;for(let r=0;r<9;r++)if(t[r]!==n[r])return!1;return!0}fromArray(e,t=0){for(let n=0;n<9;n++)this.elements[n]=e[n+t];return this}toArray(e=[],t=0){const n=this.elements;return e[t]=n[0],e[t+1]=n[1],e[t+2]=n[2],e[t+3]=n[3],e[t+4]=n[4],e[t+5]=n[5],e[t+6]=n[6],e[t+7]=n[7],e[t+8]=n[8],e}clone(){return new this.constructor().fromArray(this.elements)}}const wr=new sn,os=new sn().set(.8224621,.177538,0,.0331941,.9668058,0,.0170827,.0723974,.9105199),as=new sn().set(1.2249401,-.2249404,0,-.0420569,1.0420571,0,-.0196376,-.0786361,1.0982735),Tn={[_r]:{transfer:xr,primaries:is,toReference:o=>o,fromReference:o=>o},[vt]:{transfer:rs,primaries:is,toReference:o=>o.convertSRGBToLinear(),fromReference:o=>o.convertLinearToSRGB()},[ns]:{transfer:xr,primaries:ss,toReference:o=>o.applyMatrix3(as),fromReference:o=>o.applyMatrix3(os)},[Pc]:{transfer:rs,primaries:ss,toReference:o=>o.convertSRGBToLinear().applyMatrix3(as),fromReference:o=>o.applyMatrix3(os).convertLinearToSRGB()}},Tc=new Set([_r,ns]),He={enabled:!0,_workingColorSpace:_r,get workingColorSpace(){return this._workingColorSpace},set workingColorSpace(o){if(!Tc.has(o))throw new Error(`Unsupported working color space, "${o}".`);this._workingColorSpace=o},convert:function(o,e,t){if(this.enabled===!1||e===t||!e||!t)return o;const n=Tn[e].toReference,r=Tn[t].fromReference;return r(n(o))},fromWorkingColorSpace:function(o,e){return this.convert(o,this._workingColorSpace,e)},toWorkingColorSpace:function(o,e){return this.convert(o,e,this._workingColorSpace)},getPrimaries:function(o){return Tn[o].primaries},getTransfer:function(o){return o===Cc?xr:Tn[o].transfer}};function br(o){return o<.04045?o*.0773993808:Math.pow(o*.9478672986+.0521327014,2.4)}function Mr(o){return o<.0031308?o*12.92:1.055*Math.pow(o,.41666)-.055}const ls={aliceblue:15792383,antiquewhite:16444375,aqua:65535,aquamarine:8388564,azure:15794175,beige:16119260,bisque:16770244,black:0,blanchedalmond:16772045,blue:255,blueviolet:9055202,brown:10824234,burlywood:14596231,cadetblue:6266528,chartreuse:8388352,chocolate:13789470,coral:16744272,cornflowerblue:6591981,cornsilk:16775388,crimson:14423100,cyan:65535,darkblue:139,darkcyan:35723,darkgoldenrod:12092939,darkgray:11119017,darkgreen:25600,darkgrey:11119017,darkkhaki:12433259,darkmagenta:9109643,darkolivegreen:5597999,darkorange:16747520,darkorchid:10040012,darkred:9109504,darksalmon:15308410,darkseagreen:9419919,darkslateblue:4734347,darkslategray:3100495,darkslategrey:3100495,darkturquoise:52945,darkviolet:9699539,deeppink:16716947,deepskyblue:49151,dimgray:6908265,dimgrey:6908265,dodgerblue:2003199,firebrick:11674146,floralwhite:16775920,forestgreen:2263842,fuchsia:16711935,gainsboro:14474460,ghostwhite:16316671,gold:16766720,goldenrod:14329120,gray:8421504,green:32768,greenyellow:11403055,grey:8421504,honeydew:15794160,hotpink:16738740,indianred:13458524,indigo:4915330,ivory:16777200,khaki:15787660,lavender:15132410,lavenderblush:16773365,lawngreen:8190976,lemonchiffon:16775885,lightblue:11393254,lightcoral:15761536,lightcyan:14745599,lightgoldenrodyellow:16448210,lightgray:13882323,lightgreen:9498256,lightgrey:13882323,lightpink:16758465,lightsalmon:16752762,lightseagreen:2142890,lightskyblue:8900346,lightslategray:7833753,lightslategrey:7833753,lightsteelblue:11584734,lightyellow:16777184,lime:65280,limegreen:3329330,linen:16445670,magenta:16711935,maroon:8388608,mediumaquamarine:6737322,mediumblue:205,mediumorchid:12211667,mediumpurple:9662683,mediumseagreen:3978097,mediumslateblue:8087790,mediumspringgreen:64154,mediumturquoise:4772300,mediumvioletred:13047173,midnightblue:1644912,mintcream:16121850,mistyrose:16770273,moccasin:16770229,navajowhite:16768685,navy:128,oldlace:16643558,olive:8421376,olivedrab:7048739,orange:16753920,orangered:16729344,orchid:14315734,palegoldenrod:15657130,palegreen:10025880,paleturquoise:11529966,palevioletred:14381203,papayawhip:16773077,peachpuff:16767673,peru:13468991,pink:16761035,plum:14524637,powderblue:11591910,purple:8388736,rebeccapurple:6697881,red:16711680,rosybrown:12357519,royalblue:4286945,saddlebrown:9127187,salmon:16416882,sandybrown:16032864,seagreen:3050327,seashell:16774638,sienna:10506797,silver:12632256,skyblue:8900331,slateblue:6970061,slategray:7372944,slategrey:7372944,snow:16775930,springgreen:65407,steelblue:4620980,tan:13808780,teal:32896,thistle:14204888,tomato:16737095,turquoise:4251856,violet:15631086,wheat:16113331,white:16777215,whitesmoke:16119285,yellow:16776960,yellowgreen:10145074},_t={h:0,s:0,l:0},Ln={h:0,s:0,l:0};function Sr(o,e,t){return t<0&&(t+=1),t>1&&(t-=1),t<1/6?o+(e-o)*6*t:t<1/2?e:t<2/3?o+(e-o)*6*(2/3-t):o}class Dn{constructor(e,t,n){return this.isColor=!0,this.r=1,this.g=1,this.b=1,this.set(e,t,n)}set(e,t,n){if(t===void 0&&n===void 0){const r=e;r&&r.isColor?this.copy(r):typeof r=="number"?this.setHex(r):typeof r=="string"&&this.setStyle(r)}else this.setRGB(e,t,n);return this}setScalar(e){return this.r=e,this.g=e,this.b=e,this}setHex(e,t=vt){return e=Math.floor(e),this.r=(e>>16&255)/255,this.g=(e>>8&255)/255,this.b=(e&255)/255,He.toWorkingColorSpace(this,t),this}setRGB(e,t,n,r=He.workingColorSpace){return this.r=e,this.g=t,this.b=n,He.toWorkingColorSpace(this,r),this}setHSL(e,t,n,r=He.workingColorSpace){if(e=Sc(e,1),t=yt(t,0,1),n=yt(n,0,1),t===0)this.r=this.g=this.b=n;else{const i=n<=.5?n*(1+t):n+t-n*t,s=2*n-i;this.r=Sr(s,i,e+1/3),this.g=Sr(s,i,e),this.b=Sr(s,i,e-1/3)}return He.toWorkingColorSpace(this,r),this}setStyle(e,t=vt){function n(i){i!==void 0&&parseFloat(i)<1&&console.warn("THREE.Color: Alpha component of "+e+" will be ignored.")}let r;if(r=/^(\w+)\(([^\)]*)\)/.exec(e)){let i;const s=r[1],a=r[2];switch(s){case"rgb":case"rgba":if(i=/^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(a))return n(i[4]),this.setRGB(Math.min(255,parseInt(i[1],10))/255,Math.min(255,parseInt(i[2],10))/255,Math.min(255,parseInt(i[3],10))/255,t);if(i=/^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(a))return n(i[4]),this.setRGB(Math.min(100,parseInt(i[1],10))/100,Math.min(100,parseInt(i[2],10))/100,Math.min(100,parseInt(i[3],10))/100,t);break;case"hsl":case"hsla":if(i=/^\s*(\d*\.?\d+)\s*,\s*(\d*\.?\d+)\%\s*,\s*(\d*\.?\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(a))return n(i[4]),this.setHSL(parseFloat(i[1])/360,parseFloat(i[2])/100,parseFloat(i[3])/100,t);break;default:console.warn("THREE.Color: Unknown color model "+e)}}else if(r=/^\#([A-Fa-f\d]+)$/.exec(e)){const i=r[1],s=i.length;if(s===3)return this.setRGB(parseInt(i.charAt(0),16)/15,parseInt(i.charAt(1),16)/15,parseInt(i.charAt(2),16)/15,t);if(s===6)return this.setHex(parseInt(i,16),t);console.warn("THREE.Color: Invalid hex color "+e)}else if(e&&e.length>0)return this.setColorName(e,t);return this}setColorName(e,t=vt){const n=ls[e.toLowerCase()];return n!==void 0?this.setHex(n,t):console.warn("THREE.Color: Unknown color "+e),this}clone(){return new this.constructor(this.r,this.g,this.b)}copy(e){return this.r=e.r,this.g=e.g,this.b=e.b,this}copySRGBToLinear(e){return this.r=br(e.r),this.g=br(e.g),this.b=br(e.b),this}copyLinearToSRGB(e){return this.r=Mr(e.r),this.g=Mr(e.g),this.b=Mr(e.b),this}convertSRGBToLinear(){return this.copySRGBToLinear(this),this}convertLinearToSRGB(){return this.copyLinearToSRGB(this),this}getHex(e=vt){return He.fromWorkingColorSpace(ze.copy(this),e),Math.round(yt(ze.r*255,0,255))*65536+Math.round(yt(ze.g*255,0,255))*256+Math.round(yt(ze.b*255,0,255))}getHexString(e=vt){return("000000"+this.getHex(e).toString(16)).slice(-6)}getHSL(e,t=He.workingColorSpace){He.fromWorkingColorSpace(ze.copy(this),t);const n=ze.r,r=ze.g,i=ze.b,s=Math.max(n,r,i),a=Math.min(n,r,i);let c,h;const f=(a+s)/2;if(a===s)c=0,h=0;else{const d=s-a;switch(h=f<=.5?d/(s+a):d/(2-s-a),s){case n:c=(r-i)/d+(r<i?6:0);break;case r:c=(i-n)/d+2;break;case i:c=(n-r)/d+4;break}c/=6}return e.h=c,e.s=h,e.l=f,e}getRGB(e,t=He.workingColorSpace){return He.fromWorkingColorSpace(ze.copy(this),t),e.r=ze.r,e.g=ze.g,e.b=ze.b,e}getStyle(e=vt){He.fromWorkingColorSpace(ze.copy(this),e);const t=ze.r,n=ze.g,r=ze.b;return e!==vt?`color(${e} ${t.toFixed(3)} ${n.toFixed(3)} ${r.toFixed(3)})`:`rgb(${Math.round(t*255)},${Math.round(n*255)},${Math.round(r*255)})`}offsetHSL(e,t,n){return this.getHSL(_t),this.setHSL(_t.h+e,_t.s+t,_t.l+n)}add(e){return this.r+=e.r,this.g+=e.g,this.b+=e.b,this}addColors(e,t){return this.r=e.r+t.r,this.g=e.g+t.g,this.b=e.b+t.b,this}addScalar(e){return this.r+=e,this.g+=e,this.b+=e,this}sub(e){return this.r=Math.max(0,this.r-e.r),this.g=Math.max(0,this.g-e.g),this.b=Math.max(0,this.b-e.b),this}multiply(e){return this.r*=e.r,this.g*=e.g,this.b*=e.b,this}multiplyScalar(e){return this.r*=e,this.g*=e,this.b*=e,this}lerp(e,t){return this.r+=(e.r-this.r)*t,this.g+=(e.g-this.g)*t,this.b+=(e.b-this.b)*t,this}lerpColors(e,t,n){return this.r=e.r+(t.r-e.r)*n,this.g=e.g+(t.g-e.g)*n,this.b=e.b+(t.b-e.b)*n,this}lerpHSL(e,t){this.getHSL(_t),e.getHSL(Ln);const n=yr(_t.h,Ln.h,t),r=yr(_t.s,Ln.s,t),i=yr(_t.l,Ln.l,t);return this.setHSL(n,r,i),this}setFromVector3(e){return this.r=e.x,this.g=e.y,this.b=e.z,this}applyMatrix3(e){const t=this.r,n=this.g,r=this.b,i=e.elements;return this.r=i[0]*t+i[3]*n+i[6]*r,this.g=i[1]*t+i[4]*n+i[7]*r,this.b=i[2]*t+i[5]*n+i[8]*r,this}equals(e){return e.r===this.r&&e.g===this.g&&e.b===this.b}fromArray(e,t=0){return this.r=e[t],this.g=e[t+1],this.b=e[t+2],this}toArray(e=[],t=0){return e[t]=this.r,e[t+1]=this.g,e[t+2]=this.b,e}fromBufferAttribute(e,t){return this.r=e.getX(t),this.g=e.getY(t),this.b=e.getZ(t),this}toJSON(){return this.getHex()}*[Symbol.iterator](){yield this.r,yield this.g,yield this.b}}const ze=new Dn;Dn.NAMES=ls;class Lc extends l.MeshStandardMaterial{constructor(t={}){super();le(this,"isMeshPhysicalMaterial");le(this,"clearcoatMap");le(this,"clearcoatRoughness");le(this,"clearcoatRoughnessMap");le(this,"clearcoatNormalScale");le(this,"clearcoatNormalMap");le(this,"ior");le(this,"transmissionMap");le(this,"thickness");le(this,"thicknessMap");le(this,"attenuationDistance");le(this,"attenuationColor");le(this,"specularIntensity");le(this,"specularIntensityMap");le(this,"specularColor");le(this,"specularColorMap");le(this,"_clearcoat");le(this,"_transmission");this.isMeshPhysicalMaterial=!0,this.defines={STANDARD:"",PHYSICAL:""},this.type="MeshPhysicalMaterial",this.clearcoatMap=null,this.clearcoatRoughness=0,this.clearcoatRoughnessMap=null,this.clearcoatNormalScale=new vr(1,1),this.clearcoatNormalMap=null,this.ior=1.5,Object.defineProperty(this,"reflectivity",{get(){return yt(2.5*(this.ior-1)/(this.ior+1),0,1)},set(n){this.ior=(1+.4*n)/(1-.4*n)}}),this.roughness=0,this.transmissionMap=null,this.thickness=.5,this.thicknessMap=null,this.attenuationDistance=1/0,this.attenuationColor=new Dn(1,1,1),this.specularIntensity=1,this.specularIntensityMap=null,this.specularColor=new Dn(1,1,1),this.specularColorMap=null,this._clearcoat=.5,this._transmission=1,this.setValues(t)}get clearcoat(){return this._clearcoat}set clearcoat(t){this._clearcoat>0!=t>0&&this.version++,this._clearcoat=t}get transmission(){return this._transmission}set transmission(t){this._transmission>0!=t>0&&this.version++,this._transmission=t}copy(t){return super.copy(t),this.defines={STANDARD:"",PHYSICAL:""},this.clearcoat=t.clearcoat,this.clearcoatMap=t.clearcoatMap,this.clearcoatRoughness=t.clearcoatRoughness,this.clearcoatRoughnessMap=t.clearcoatRoughnessMap,this.clearcoatNormalMap=t.clearcoatNormalMap,this.clearcoatNormalScale.copy(t.clearcoatNormalScale),this.ior=t.ior,this.transmission=t.transmission,this.transmissionMap=t.transmissionMap,this.thickness=t.thickness,this.thicknessMap=t.thicknessMap,this.attenuationDistance=t.attenuationDistance,this.attenuationColor.copy(t.attenuationColor),this.specularIntensity=t.specularIntensity,this.specularIntensityMap=t.specularIntensityMap,this.specularColor.copy(t.specularColor),this.specularColorMap=t.specularColorMap,this}}const Dc=Lc,Ic=u.defineComponent({__name:"index",setup(o,{expose:e}){const t=u.shallowRef(),{extend:n}=oe.useTresContext();return n({MeshGlassMaterial:Dc}),e({MeshGlassMaterialClass:t}),(r,i)=>(u.openBlock(),u.createElementBlock("TresMeshGlassMaterial",{ref_key:"MeshGlassMaterialClass",ref:t},null,512))}});var Oc=typeof globalThis<"u"?globalThis:typeof window<"u"?window:typeof global<"u"?global:typeof self<"u"?self:{};function on(o){return o&&o.__esModule&&Object.prototype.hasOwnProperty.call(o,"default")?o.default:o}function In(o){throw new Error('Could not dynamically require "'+o+'". Please configure the dynamicRequireTargets or/and ignoreDynamicRequires option of @rollup/plugin-commonjs appropriately for this require call to work.')}var cs={exports:{}};(function(o,e){(function(t){o.exports=t()})(function(){return function t(n,r,i){function s(h,f){if(!r[h]){if(!n[h]){var d=typeof In=="function"&&In;if(!f&&d)return d(h,!0);if(a)return a(h,!0);throw new Error("Cannot find module '"+h+"'")}f=r[h]={exports:{}},n[h][0].call(f.exports,function(p){var m=n[h][1][p];return s(m||p)},f,f.exports,t,n,r,i)}return r[h].exports}for(var a=typeof In=="function"&&In,c=0;c<i.length;c++)s(i[c]);return s}({1:[function(t,n,r){(function(i,s,a,c,h,f,d,p,m){var x=t("crypto");function b(S,C){C=T(S,C);var y;return(y=C.algorithm!=="passthrough"?x.createHash(C.algorithm):new D).write===void 0&&(y.write=y.update,y.end=y.update),M(C,y).dispatch(S),y.update||y.end(""),y.digest?y.digest(C.encoding==="buffer"?void 0:C.encoding):(S=y.read(),C.encoding!=="buffer"?S.toString(C.encoding):S)}(r=n.exports=b).sha1=function(S){return b(S)},r.keys=function(S){return b(S,{excludeValues:!0,algorithm:"sha1",encoding:"hex"})},r.MD5=function(S){return b(S,{algorithm:"md5",encoding:"hex"})},r.keysMD5=function(S){return b(S,{algorithm:"md5",encoding:"hex",excludeValues:!0})};var v=x.getHashes?x.getHashes().slice():["sha1","md5"],_=(v.push("passthrough"),["buffer","hex","binary","base64"]);function T(S,C){var y={};if(y.algorithm=(C=C||{}).algorithm||"sha1",y.encoding=C.encoding||"hex",y.excludeValues=!!C.excludeValues,y.algorithm=y.algorithm.toLowerCase(),y.encoding=y.encoding.toLowerCase(),y.ignoreUnknown=C.ignoreUnknown===!0,y.respectType=C.respectType!==!1,y.respectFunctionNames=C.respectFunctionNames!==!1,y.respectFunctionProperties=C.respectFunctionProperties!==!1,y.unorderedArrays=C.unorderedArrays===!0,y.unorderedSets=C.unorderedSets!==!1,y.unorderedObjects=C.unorderedObjects!==!1,y.replacer=C.replacer||void 0,y.excludeKeys=C.excludeKeys||void 0,S===void 0)throw new Error("Object argument required.");for(var A=0;A<v.length;++A)v[A].toLowerCase()===y.algorithm.toLowerCase()&&(y.algorithm=v[A]);if(v.indexOf(y.algorithm)===-1)throw new Error('Algorithm "'+y.algorithm+'"  not supported. supported values: '+v.join(", "));if(_.indexOf(y.encoding)===-1&&y.algorithm!=="passthrough")throw new Error('Encoding "'+y.encoding+'"  not supported. supported values: '+_.join(", "));return y}function w(S){if(typeof S=="function")return/^function\s+\w*\s*\(\s*\)\s*{\s+\[native code\]\s+}$/i.exec(Function.prototype.toString.call(S))!=null}function M(S,C,y){y=y||[];function A(g){return C.update?C.update(g,"utf8"):C.write(g,"utf8")}return{dispatch:function(g){return this["_"+((g=S.replacer?S.replacer(g):g)===null?"null":typeof g)](g)},_object:function(g){var I,k=Object.prototype.toString.call(g),J=/\[object (.*)\]/i.exec(k);if(J=(J=J?J[1]:"unknown:["+k+"]").toLowerCase(),0<=(k=y.indexOf(g)))return this.dispatch("[CIRCULAR:"+k+"]");if(y.push(g),a!==void 0&&a.isBuffer&&a.isBuffer(g))return A("buffer:"),A(g);if(J==="object"||J==="function"||J==="asyncfunction")return k=Object.keys(g),S.unorderedObjects&&(k=k.sort()),S.respectType===!1||w(g)||k.splice(0,0,"prototype","__proto__","constructor"),S.excludeKeys&&(k=k.filter(function(G){return!S.excludeKeys(G)})),A("object:"+k.length+":"),I=this,k.forEach(function(G){I.dispatch(G),A(":"),S.excludeValues||I.dispatch(g[G]),A(",")});if(!this["_"+J]){if(S.ignoreUnknown)return A("["+J+"]");throw new Error('Unknown object type "'+J+'"')}this["_"+J](g)},_array:function(g,G){G=G!==void 0?G:S.unorderedArrays!==!1;var k=this;if(A("array:"+g.length+":"),!G||g.length<=1)return g.forEach(function(Z){return k.dispatch(Z)});var J=[],G=g.map(function(Z){var X=new D,K=y.slice();return M(S,X,K).dispatch(Z),J=J.concat(K.slice(y.length)),X.read().toString()});return y=y.concat(J),G.sort(),this._array(G,!1)},_date:function(g){return A("date:"+g.toJSON())},_symbol:function(g){return A("symbol:"+g.toString())},_error:function(g){return A("error:"+g.toString())},_boolean:function(g){return A("bool:"+g.toString())},_string:function(g){A("string:"+g.length+":"),A(g.toString())},_function:function(g){A("fn:"),w(g)?this.dispatch("[native]"):this.dispatch(g.toString()),S.respectFunctionNames!==!1&&this.dispatch("function-name:"+String(g.name)),S.respectFunctionProperties&&this._object(g)},_number:function(g){return A("number:"+g.toString())},_xml:function(g){return A("xml:"+g.toString())},_null:function(){return A("Null")},_undefined:function(){return A("Undefined")},_regexp:function(g){return A("regex:"+g.toString())},_uint8array:function(g){return A("uint8array:"),this.dispatch(Array.prototype.slice.call(g))},_uint8clampedarray:function(g){return A("uint8clampedarray:"),this.dispatch(Array.prototype.slice.call(g))},_int8array:function(g){return A("int8array:"),this.dispatch(Array.prototype.slice.call(g))},_uint16array:function(g){return A("uint16array:"),this.dispatch(Array.prototype.slice.call(g))},_int16array:function(g){return A("int16array:"),this.dispatch(Array.prototype.slice.call(g))},_uint32array:function(g){return A("uint32array:"),this.dispatch(Array.prototype.slice.call(g))},_int32array:function(g){return A("int32array:"),this.dispatch(Array.prototype.slice.call(g))},_float32array:function(g){return A("float32array:"),this.dispatch(Array.prototype.slice.call(g))},_float64array:function(g){return A("float64array:"),this.dispatch(Array.prototype.slice.call(g))},_arraybuffer:function(g){return A("arraybuffer:"),this.dispatch(new Uint8Array(g))},_url:function(g){return A("url:"+g.toString())},_map:function(g){return A("map:"),g=Array.from(g),this._array(g,S.unorderedSets!==!1)},_set:function(g){return A("set:"),g=Array.from(g),this._array(g,S.unorderedSets!==!1)},_file:function(g){return A("file:"),this.dispatch([g.name,g.size,g.type,g.lastModfied])},_blob:function(){if(S.ignoreUnknown)return A("[blob]");throw Error(`Hashing Blob objects is currently not supported
 (see https://github.com/puleos/object-hash/issues/26)
 Use "options.replacer" or "options.ignoreUnknown"
-`)},_domwindow:function(){return M("domwindow")},_bigint:function(p){return M("bigint:"+p.toString())},_process:function(){return M("process")},_timer:function(){return M("timer")},_pipe:function(){return M("pipe")},_tcp:function(){return M("tcp")},_udp:function(){return M("udp")},_tty:function(){return M("tty")},_statwatcher:function(){return M("statwatcher")},_securecontext:function(){return M("securecontext")},_connection:function(){return M("connection")},_zlib:function(){return M("zlib")},_context:function(){return M("context")},_nodescript:function(){return M("nodescript")},_httpparser:function(){return M("httpparser")},_dataview:function(){return M("dataview")},_signal:function(){return M("signal")},_fsevent:function(){return M("fsevent")},_tlswrap:function(){return M("tlswrap")}}}function L(){return{buf:"",write:function(b){this.buf+=b},end:function(b){this.buf+=b},read:function(){return this.buf}}}s.writeToStream=function(b,C,m){return m===void 0&&(m=C,C={}),_(C=D(b,C),m).dispatch(b)}}).call(this,t("lYpoI2"),typeof self<"u"?self:typeof window<"u"?window:{},t("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/fake_9a5aa49d.js","/")},{buffer:3,crypto:5,lYpoI2:11}],2:[function(t,n,s){(function(r,i,a,l,u,h,d,y,g){(function(x){var w=typeof Uint8Array<"u"?Uint8Array:Array,v=43,P=47,D=48,S=97,_=65,L=45,b=95;function C(m){return m=m.charCodeAt(0),m===v||m===L?62:m===P||m===b?63:m<D?-1:m<D+10?m-D+26+26:m<_+26?m-_:m<S+26?m-S+26:void 0}x.toByteArray=function(m){var M,p;if(0<m.length%4)throw new Error("Invalid string. Length must be a multiple of 4");var I=m.length,I=m.charAt(I-2)==="="?2:m.charAt(I-1)==="="?1:0,F=new w(3*m.length/4-I),J=0<I?m.length-4:m.length,G=0;function Q(K){F[G++]=K}for(M=0;M<J;M+=4,0)Q((16711680&(p=C(m.charAt(M))<<18|C(m.charAt(M+1))<<12|C(m.charAt(M+2))<<6|C(m.charAt(M+3))))>>16),Q((65280&p)>>8),Q(255&p);return I==2?Q(255&(p=C(m.charAt(M))<<2|C(m.charAt(M+1))>>4)):I==1&&(Q((p=C(m.charAt(M))<<10|C(m.charAt(M+1))<<4|C(m.charAt(M+2))>>2)>>8&255),Q(255&p)),F},x.fromByteArray=function(m){var M,p,I,F,J=m.length%3,G="";function Q(K){return"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/".charAt(K)}for(M=0,I=m.length-J;M<I;M+=3)p=(m[M]<<16)+(m[M+1]<<8)+m[M+2],G+=Q((F=p)>>18&63)+Q(F>>12&63)+Q(F>>6&63)+Q(63&F);switch(J){case 1:G=(G+=Q((p=m[m.length-1])>>2))+Q(p<<4&63)+"==";break;case 2:G=(G=(G+=Q((p=(m[m.length-2]<<8)+m[m.length-1])>>10))+Q(p>>4&63))+Q(p<<2&63)+"="}return G}})(s===void 0?this.base64js={}:s)}).call(this,t("lYpoI2"),typeof self<"u"?self:typeof window<"u"?window:{},t("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/gulp-browserify/node_modules/base64-js/lib/b64.js","/node_modules/gulp-browserify/node_modules/base64-js/lib")},{buffer:3,lYpoI2:11}],3:[function(t,n,s){(function(r,i,v,l,u,h,d,y,g){var x=t("base64-js"),w=t("ieee754");function v(T,O,k){if(!(this instanceof v))return new v(T,O,k);var E,q,W,te,U=typeof T;if(O==="base64"&&U=="string")for(T=(te=T).trim?te.trim():te.replace(/^\s+|\s+$/g,"");T.length%4!=0;)T+="=";if(U=="number")E=X(T);else if(U=="string")E=v.byteLength(T,O);else{if(U!="object")throw new Error("First argument needs to be a number, array or string.");E=X(T.length)}if(v._useTypedArrays?q=v._augment(new Uint8Array(E)):((q=this).length=E,q._isBuffer=!0),v._useTypedArrays&&typeof T.byteLength=="number")q._set(T);else if(ne(te=T)||v.isBuffer(te)||te&&typeof te=="object"&&typeof te.length=="number")for(W=0;W<E;W++)v.isBuffer(T)?q[W]=T.readUInt8(W):q[W]=T[W];else if(U=="string")q.write(T,0,O);else if(U=="number"&&!v._useTypedArrays&&!k)for(W=0;W<E;W++)q[W]=0;return q}function P(T,O,k,E){return v._charsWritten=z(function(q){for(var W=[],te=0;te<q.length;te++)W.push(255&q.charCodeAt(te));return W}(O),T,k,E)}function D(T,O,k,E){return v._charsWritten=z(function(q){for(var W,te,U=[],B=0;B<q.length;B++)te=q.charCodeAt(B),W=te>>8,te=te%256,U.push(te),U.push(W);return U}(O),T,k,E)}function S(T,O,k){var E="";k=Math.min(T.length,k);for(var q=O;q<k;q++)E+=String.fromCharCode(T[q]);return E}function _(T,O,k,W){W||(R(typeof k=="boolean","missing or invalid endian"),R(O!=null,"missing offset"),R(O+1<T.length,"Trying to read beyond buffer length"));var q,W=T.length;if(!(W<=O))return k?(q=T[O],O+1<W&&(q|=T[O+1]<<8)):(q=T[O]<<8,O+1<W&&(q|=T[O+1])),q}function L(T,O,k,W){W||(R(typeof k=="boolean","missing or invalid endian"),R(O!=null,"missing offset"),R(O+3<T.length,"Trying to read beyond buffer length"));var q,W=T.length;if(!(W<=O))return k?(O+2<W&&(q=T[O+2]<<16),O+1<W&&(q|=T[O+1]<<8),q|=T[O],O+3<W&&(q+=T[O+3]<<24>>>0)):(O+1<W&&(q=T[O+1]<<16),O+2<W&&(q|=T[O+2]<<8),O+3<W&&(q|=T[O+3]),q+=T[O]<<24>>>0),q}function b(T,O,k,E){if(E||(R(typeof k=="boolean","missing or invalid endian"),R(O!=null,"missing offset"),R(O+1<T.length,"Trying to read beyond buffer length")),!(T.length<=O))return E=_(T,O,k,!0),32768&E?-1*(65535-E+1):E}function C(T,O,k,E){if(E||(R(typeof k=="boolean","missing or invalid endian"),R(O!=null,"missing offset"),R(O+3<T.length,"Trying to read beyond buffer length")),!(T.length<=O))return E=L(T,O,k,!0),2147483648&E?-1*(4294967295-E+1):E}function m(T,O,k,E){return E||(R(typeof k=="boolean","missing or invalid endian"),R(O+3<T.length,"Trying to read beyond buffer length")),w.read(T,O,k,23,4)}function M(T,O,k,E){return E||(R(typeof k=="boolean","missing or invalid endian"),R(O+7<T.length,"Trying to read beyond buffer length")),w.read(T,O,k,52,8)}function p(T,O,k,E,q){if(q||(R(O!=null,"missing value"),R(typeof E=="boolean","missing or invalid endian"),R(k!=null,"missing offset"),R(k+1<T.length,"trying to write beyond buffer length"),V(O,65535)),q=T.length,!(q<=k))for(var W=0,te=Math.min(q-k,2);W<te;W++)T[k+W]=(O&255<<8*(E?W:1-W))>>>8*(E?W:1-W)}function I(T,O,k,E,q){if(q||(R(O!=null,"missing value"),R(typeof E=="boolean","missing or invalid endian"),R(k!=null,"missing offset"),R(k+3<T.length,"trying to write beyond buffer length"),V(O,4294967295)),q=T.length,!(q<=k))for(var W=0,te=Math.min(q-k,4);W<te;W++)T[k+W]=O>>>8*(E?W:3-W)&255}function F(T,O,k,E,q){q||(R(O!=null,"missing value"),R(typeof E=="boolean","missing or invalid endian"),R(k!=null,"missing offset"),R(k+1<T.length,"Trying to write beyond buffer length"),ee(O,32767,-32768)),T.length<=k||p(T,0<=O?O:65535+O+1,k,E,q)}function J(T,O,k,E,q){q||(R(O!=null,"missing value"),R(typeof E=="boolean","missing or invalid endian"),R(k!=null,"missing offset"),R(k+3<T.length,"Trying to write beyond buffer length"),ee(O,2147483647,-2147483648)),T.length<=k||I(T,0<=O?O:4294967295+O+1,k,E,q)}function G(T,O,k,E,q){q||(R(O!=null,"missing value"),R(typeof E=="boolean","missing or invalid endian"),R(k!=null,"missing offset"),R(k+3<T.length,"Trying to write beyond buffer length"),N(O,34028234663852886e22,-34028234663852886e22)),T.length<=k||w.write(T,O,k,E,23,4)}function Q(T,O,k,E,q){q||(R(O!=null,"missing value"),R(typeof E=="boolean","missing or invalid endian"),R(k!=null,"missing offset"),R(k+7<T.length,"Trying to write beyond buffer length"),N(O,17976931348623157e292,-17976931348623157e292)),T.length<=k||w.write(T,O,k,E,52,8)}s.Buffer=v,s.SlowBuffer=v,s.INSPECT_MAX_BYTES=50,v.poolSize=8192,v._useTypedArrays=function(){try{var T=new ArrayBuffer(0),O=new Uint8Array(T);return O.foo=function(){return 42},O.foo()===42&&typeof O.subarray=="function"}catch{return!1}}(),v.isEncoding=function(T){switch(String(T).toLowerCase()){case"hex":case"utf8":case"utf-8":case"ascii":case"binary":case"base64":case"raw":case"ucs2":case"ucs-2":case"utf16le":case"utf-16le":return!0;default:return!1}},v.isBuffer=function(T){return!(T==null||!T._isBuffer)},v.byteLength=function(T,O){var k;switch(T+="",O||"utf8"){case"hex":k=T.length/2;break;case"utf8":case"utf-8":k=ue(T).length;break;case"ascii":case"binary":case"raw":k=T.length;break;case"base64":k=j(T).length;break;case"ucs2":case"ucs-2":case"utf16le":case"utf-16le":k=2*T.length;break;default:throw new Error("Unknown encoding")}return k},v.concat=function(T,O){if(R(ne(T),`Usage: Buffer.concat(list, [totalLength])
-list should be an Array.`),T.length===0)return new v(0);if(T.length===1)return T[0];if(typeof O!="number")for(q=O=0;q<T.length;q++)O+=T[q].length;for(var k=new v(O),E=0,q=0;q<T.length;q++){var W=T[q];W.copy(k,E),E+=W.length}return k},v.prototype.write=function(T,O,k,E){isFinite(O)?isFinite(k)||(E=k,k=void 0):(B=E,E=O,O=k,k=B),O=Number(O)||0;var q,W,te,U,B=this.length-O;switch((!k||B<(k=Number(k)))&&(k=B),E=String(E||"utf8").toLowerCase()){case"hex":q=function(oe,ce,ge,_e){ge=Number(ge)||0;var xe=oe.length-ge;(!_e||xe<(_e=Number(_e)))&&(_e=xe),R((xe=ce.length)%2==0,"Invalid hex string"),xe/2<_e&&(_e=xe/2);for(var Oe=0;Oe<_e;Oe++){var at=parseInt(ce.substr(2*Oe,2),16);R(!isNaN(at),"Invalid hex string"),oe[ge+Oe]=at}return v._charsWritten=2*Oe,Oe}(this,T,O,k);break;case"utf8":case"utf-8":W=this,te=O,U=k,q=v._charsWritten=z(ue(T),W,te,U);break;case"ascii":case"binary":q=P(this,T,O,k);break;case"base64":W=this,te=O,U=k,q=v._charsWritten=z(j(T),W,te,U);break;case"ucs2":case"ucs-2":case"utf16le":case"utf-16le":q=D(this,T,O,k);break;default:throw new Error("Unknown encoding")}return q},v.prototype.toString=function(T,O,k){var E,q,W,te,U=this;if(T=String(T||"utf8").toLowerCase(),O=Number(O)||0,(k=k!==void 0?Number(k):U.length)===O)return"";switch(T){case"hex":E=function(B,oe,ce){var ge=B.length;(!oe||oe<0)&&(oe=0),(!ce||ce<0||ge<ce)&&(ce=ge);for(var _e="",xe=oe;xe<ce;xe++)_e+=se(B[xe]);return _e}(U,O,k);break;case"utf8":case"utf-8":E=function(B,oe,ce){var ge="",_e="";ce=Math.min(B.length,ce);for(var xe=oe;xe<ce;xe++)B[xe]<=127?(ge+=A(_e)+String.fromCharCode(B[xe]),_e=""):_e+="%"+B[xe].toString(16);return ge+A(_e)}(U,O,k);break;case"ascii":case"binary":E=S(U,O,k);break;case"base64":q=U,te=k,E=(W=O)===0&&te===q.length?x.fromByteArray(q):x.fromByteArray(q.slice(W,te));break;case"ucs2":case"ucs-2":case"utf16le":case"utf-16le":E=function(B,oe,ce){for(var ge=B.slice(oe,ce),_e="",xe=0;xe<ge.length;xe+=2)_e+=String.fromCharCode(ge[xe]+256*ge[xe+1]);return _e}(U,O,k);break;default:throw new Error("Unknown encoding")}return E},v.prototype.toJSON=function(){return{type:"Buffer",data:Array.prototype.slice.call(this._arr||this,0)}},v.prototype.copy=function(T,O,k,E){if(O=O||0,(E=E||E===0?E:this.length)!==(k=k||0)&&T.length!==0&&this.length!==0){R(k<=E,"sourceEnd < sourceStart"),R(0<=O&&O<T.length,"targetStart out of bounds"),R(0<=k&&k<this.length,"sourceStart out of bounds"),R(0<=E&&E<=this.length,"sourceEnd out of bounds"),E>this.length&&(E=this.length);var q=(E=T.length-O<E-k?T.length-O+k:E)-k;if(q<100||!v._useTypedArrays)for(var W=0;W<q;W++)T[W+O]=this[W+k];else T._set(this.subarray(k,k+q),O)}},v.prototype.slice=function(T,O){var k=this.length;if(T=Z(T,k,0),O=Z(O,k,k),v._useTypedArrays)return v._augment(this.subarray(T,O));for(var E=O-T,q=new v(E,void 0,!0),W=0;W<E;W++)q[W]=this[W+T];return q},v.prototype.get=function(T){return console.log(".get() is deprecated. Access using array indexes instead."),this.readUInt8(T)},v.prototype.set=function(T,O){return console.log(".set() is deprecated. Access using array indexes instead."),this.writeUInt8(T,O)},v.prototype.readUInt8=function(T,O){if(O||(R(T!=null,"missing offset"),R(T<this.length,"Trying to read beyond buffer length")),!(T>=this.length))return this[T]},v.prototype.readUInt16LE=function(T,O){return _(this,T,!0,O)},v.prototype.readUInt16BE=function(T,O){return _(this,T,!1,O)},v.prototype.readUInt32LE=function(T,O){return L(this,T,!0,O)},v.prototype.readUInt32BE=function(T,O){return L(this,T,!1,O)},v.prototype.readInt8=function(T,O){if(O||(R(T!=null,"missing offset"),R(T<this.length,"Trying to read beyond buffer length")),!(T>=this.length))return 128&this[T]?-1*(255-this[T]+1):this[T]},v.prototype.readInt16LE=function(T,O){return b(this,T,!0,O)},v.prototype.readInt16BE=function(T,O){return b(this,T,!1,O)},v.prototype.readInt32LE=function(T,O){return C(this,T,!0,O)},v.prototype.readInt32BE=function(T,O){return C(this,T,!1,O)},v.prototype.readFloatLE=function(T,O){return m(this,T,!0,O)},v.prototype.readFloatBE=function(T,O){return m(this,T,!1,O)},v.prototype.readDoubleLE=function(T,O){return M(this,T,!0,O)},v.prototype.readDoubleBE=function(T,O){return M(this,T,!1,O)},v.prototype.writeUInt8=function(T,O,k){k||(R(T!=null,"missing value"),R(O!=null,"missing offset"),R(O<this.length,"trying to write beyond buffer length"),V(T,255)),O>=this.length||(this[O]=T)},v.prototype.writeUInt16LE=function(T,O,k){p(this,T,O,!0,k)},v.prototype.writeUInt16BE=function(T,O,k){p(this,T,O,!1,k)},v.prototype.writeUInt32LE=function(T,O,k){I(this,T,O,!0,k)},v.prototype.writeUInt32BE=function(T,O,k){I(this,T,O,!1,k)},v.prototype.writeInt8=function(T,O,k){k||(R(T!=null,"missing value"),R(O!=null,"missing offset"),R(O<this.length,"Trying to write beyond buffer length"),ee(T,127,-128)),O>=this.length||(0<=T?this.writeUInt8(T,O,k):this.writeUInt8(255+T+1,O,k))},v.prototype.writeInt16LE=function(T,O,k){F(this,T,O,!0,k)},v.prototype.writeInt16BE=function(T,O,k){F(this,T,O,!1,k)},v.prototype.writeInt32LE=function(T,O,k){J(this,T,O,!0,k)},v.prototype.writeInt32BE=function(T,O,k){J(this,T,O,!1,k)},v.prototype.writeFloatLE=function(T,O,k){G(this,T,O,!0,k)},v.prototype.writeFloatBE=function(T,O,k){G(this,T,O,!1,k)},v.prototype.writeDoubleLE=function(T,O,k){Q(this,T,O,!0,k)},v.prototype.writeDoubleBE=function(T,O,k){Q(this,T,O,!1,k)},v.prototype.fill=function(T,O,k){if(O=O||0,k=k||this.length,R(typeof(T=typeof(T=T||0)=="string"?T.charCodeAt(0):T)=="number"&&!isNaN(T),"value is not a number"),R(O<=k,"end < start"),k!==O&&this.length!==0){R(0<=O&&O<this.length,"start out of bounds"),R(0<=k&&k<=this.length,"end out of bounds");for(var E=O;E<k;E++)this[E]=T}},v.prototype.inspect=function(){for(var T=[],O=this.length,k=0;k<O;k++)if(T[k]=se(this[k]),k===s.INSPECT_MAX_BYTES){T[k+1]="...";break}return"<Buffer "+T.join(" ")+">"},v.prototype.toArrayBuffer=function(){if(typeof Uint8Array>"u")throw new Error("Buffer.toArrayBuffer not supported in this browser");if(v._useTypedArrays)return new v(this).buffer;for(var T=new Uint8Array(this.length),O=0,k=T.length;O<k;O+=1)T[O]=this[O];return T.buffer};var K=v.prototype;function Z(T,O,k){return typeof T!="number"?k:O<=(T=~~T)?O:0<=T||0<=(T+=O)?T:0}function X(T){return(T=~~Math.ceil(+T))<0?0:T}function ne(T){return(Array.isArray||function(O){return Object.prototype.toString.call(O)==="[object Array]"})(T)}function se(T){return T<16?"0"+T.toString(16):T.toString(16)}function ue(T){for(var O=[],k=0;k<T.length;k++){var E=T.charCodeAt(k);if(E<=127)O.push(T.charCodeAt(k));else for(var q=k,W=(55296<=E&&E<=57343&&k++,encodeURIComponent(T.slice(q,k+1)).substr(1).split("%")),te=0;te<W.length;te++)O.push(parseInt(W[te],16))}return O}function j(T){return x.toByteArray(T)}function z(T,O,k,E){for(var q=0;q<E&&!(q+k>=O.length||q>=T.length);q++)O[q+k]=T[q];return q}function A(T){try{return decodeURIComponent(T)}catch{return"�"}}function V(T,O){R(typeof T=="number","cannot write a non-number as a number"),R(0<=T,"specified a negative value for writing an unsigned value"),R(T<=O,"value is larger than maximum value for type"),R(Math.floor(T)===T,"value has a fractional component")}function ee(T,O,k){R(typeof T=="number","cannot write a non-number as a number"),R(T<=O,"value larger than maximum allowed value"),R(k<=T,"value smaller than minimum allowed value"),R(Math.floor(T)===T,"value has a fractional component")}function N(T,O,k){R(typeof T=="number","cannot write a non-number as a number"),R(T<=O,"value larger than maximum allowed value"),R(k<=T,"value smaller than minimum allowed value")}function R(T,O){if(!T)throw new Error(O||"Failed assertion")}v._augment=function(T){return T._isBuffer=!0,T._get=T.get,T._set=T.set,T.get=K.get,T.set=K.set,T.write=K.write,T.toString=K.toString,T.toLocaleString=K.toString,T.toJSON=K.toJSON,T.copy=K.copy,T.slice=K.slice,T.readUInt8=K.readUInt8,T.readUInt16LE=K.readUInt16LE,T.readUInt16BE=K.readUInt16BE,T.readUInt32LE=K.readUInt32LE,T.readUInt32BE=K.readUInt32BE,T.readInt8=K.readInt8,T.readInt16LE=K.readInt16LE,T.readInt16BE=K.readInt16BE,T.readInt32LE=K.readInt32LE,T.readInt32BE=K.readInt32BE,T.readFloatLE=K.readFloatLE,T.readFloatBE=K.readFloatBE,T.readDoubleLE=K.readDoubleLE,T.readDoubleBE=K.readDoubleBE,T.writeUInt8=K.writeUInt8,T.writeUInt16LE=K.writeUInt16LE,T.writeUInt16BE=K.writeUInt16BE,T.writeUInt32LE=K.writeUInt32LE,T.writeUInt32BE=K.writeUInt32BE,T.writeInt8=K.writeInt8,T.writeInt16LE=K.writeInt16LE,T.writeInt16BE=K.writeInt16BE,T.writeInt32LE=K.writeInt32LE,T.writeInt32BE=K.writeInt32BE,T.writeFloatLE=K.writeFloatLE,T.writeFloatBE=K.writeFloatBE,T.writeDoubleLE=K.writeDoubleLE,T.writeDoubleBE=K.writeDoubleBE,T.fill=K.fill,T.inspect=K.inspect,T.toArrayBuffer=K.toArrayBuffer,T}}).call(this,t("lYpoI2"),typeof self<"u"?self:typeof window<"u"?window:{},t("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/gulp-browserify/node_modules/buffer/index.js","/node_modules/gulp-browserify/node_modules/buffer")},{"base64-js":2,buffer:3,ieee754:10,lYpoI2:11}],4:[function(t,n,s){(function(r,i,x,l,u,h,d,y,g){var x=t("buffer").Buffer,w=4,v=new x(w);v.fill(0),n.exports={hash:function(P,D,S,_){for(var L=D(function(p,I){p.length%w!=0&&(F=p.length+(w-p.length%w),p=x.concat([p,v],F));for(var F,J=[],G=I?p.readInt32BE:p.readInt32LE,Q=0;Q<p.length;Q+=w)J.push(G.call(p,Q));return J}(P=x.isBuffer(P)?P:new x(P),_),8*P.length),D=_,b=new x(S),C=D?b.writeInt32BE:b.writeInt32LE,m=0;m<L.length;m++)C.call(b,L[m],4*m,!0);return b}}}).call(this,t("lYpoI2"),typeof self<"u"?self:typeof window<"u"?window:{},t("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/gulp-browserify/node_modules/crypto-browserify/helpers.js","/node_modules/gulp-browserify/node_modules/crypto-browserify")},{buffer:3,lYpoI2:11}],5:[function(t,n,s){(function(r,i,x,l,u,h,d,y,g){var x=t("buffer").Buffer,w=t("./sha"),v=t("./sha256"),P=t("./rng"),D={sha1:w,sha256:v,md5:t("./md5")},S=64,_=new x(S);function L(p,I){var F=D[p=p||"sha1"],J=[];return F||b("algorithm:",p,"is not yet supported"),{update:function(G){return x.isBuffer(G)||(G=new x(G)),J.push(G),G.length,this},digest:function(G){var Q=x.concat(J),Q=I?function(K,Z,X){x.isBuffer(Z)||(Z=new x(Z)),x.isBuffer(X)||(X=new x(X)),Z.length>S?Z=K(Z):Z.length<S&&(Z=x.concat([Z,_],S));for(var ne=new x(S),se=new x(S),ue=0;ue<S;ue++)ne[ue]=54^Z[ue],se[ue]=92^Z[ue];return X=K(x.concat([ne,X])),K(x.concat([se,X]))}(F,I,Q):F(Q);return J=null,G?Q.toString(G):Q}}}function b(){var p=[].slice.call(arguments).join(" ");throw new Error([p,"we accept pull requests","http://github.com/dominictarr/crypto-browserify"].join(`
-`))}_.fill(0),s.createHash=function(p){return L(p)},s.createHmac=L,s.randomBytes=function(p,I){if(!I||!I.call)return new x(P(p));try{I.call(this,void 0,new x(P(p)))}catch(F){I(F)}};var C,m=["createCredentials","createCipher","createCipheriv","createDecipher","createDecipheriv","createSign","createVerify","createDiffieHellman","pbkdf2"],M=function(p){s[p]=function(){b("sorry,",p,"is not implemented yet")}};for(C in m)M(m[C])}).call(this,t("lYpoI2"),typeof self<"u"?self:typeof window<"u"?window:{},t("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/gulp-browserify/node_modules/crypto-browserify/index.js","/node_modules/gulp-browserify/node_modules/crypto-browserify")},{"./md5":6,"./rng":7,"./sha":8,"./sha256":9,buffer:3,lYpoI2:11}],6:[function(t,n,s){(function(r,i,a,l,u,h,d,y,g){var x=t("./helpers");function w(b,C){b[C>>5]|=128<<C%32,b[14+(C+64>>>9<<4)]=C;for(var m=1732584193,M=-271733879,p=-1732584194,I=271733878,F=0;F<b.length;F+=16){var J=m,G=M,Q=p,K=I,m=P(m,M,p,I,b[F+0],7,-680876936),I=P(I,m,M,p,b[F+1],12,-389564586),p=P(p,I,m,M,b[F+2],17,606105819),M=P(M,p,I,m,b[F+3],22,-1044525330);m=P(m,M,p,I,b[F+4],7,-176418897),I=P(I,m,M,p,b[F+5],12,1200080426),p=P(p,I,m,M,b[F+6],17,-1473231341),M=P(M,p,I,m,b[F+7],22,-45705983),m=P(m,M,p,I,b[F+8],7,1770035416),I=P(I,m,M,p,b[F+9],12,-1958414417),p=P(p,I,m,M,b[F+10],17,-42063),M=P(M,p,I,m,b[F+11],22,-1990404162),m=P(m,M,p,I,b[F+12],7,1804603682),I=P(I,m,M,p,b[F+13],12,-40341101),p=P(p,I,m,M,b[F+14],17,-1502002290),m=D(m,M=P(M,p,I,m,b[F+15],22,1236535329),p,I,b[F+1],5,-165796510),I=D(I,m,M,p,b[F+6],9,-1069501632),p=D(p,I,m,M,b[F+11],14,643717713),M=D(M,p,I,m,b[F+0],20,-373897302),m=D(m,M,p,I,b[F+5],5,-701558691),I=D(I,m,M,p,b[F+10],9,38016083),p=D(p,I,m,M,b[F+15],14,-660478335),M=D(M,p,I,m,b[F+4],20,-405537848),m=D(m,M,p,I,b[F+9],5,568446438),I=D(I,m,M,p,b[F+14],9,-1019803690),p=D(p,I,m,M,b[F+3],14,-187363961),M=D(M,p,I,m,b[F+8],20,1163531501),m=D(m,M,p,I,b[F+13],5,-1444681467),I=D(I,m,M,p,b[F+2],9,-51403784),p=D(p,I,m,M,b[F+7],14,1735328473),m=S(m,M=D(M,p,I,m,b[F+12],20,-1926607734),p,I,b[F+5],4,-378558),I=S(I,m,M,p,b[F+8],11,-2022574463),p=S(p,I,m,M,b[F+11],16,1839030562),M=S(M,p,I,m,b[F+14],23,-35309556),m=S(m,M,p,I,b[F+1],4,-1530992060),I=S(I,m,M,p,b[F+4],11,1272893353),p=S(p,I,m,M,b[F+7],16,-155497632),M=S(M,p,I,m,b[F+10],23,-1094730640),m=S(m,M,p,I,b[F+13],4,681279174),I=S(I,m,M,p,b[F+0],11,-358537222),p=S(p,I,m,M,b[F+3],16,-722521979),M=S(M,p,I,m,b[F+6],23,76029189),m=S(m,M,p,I,b[F+9],4,-640364487),I=S(I,m,M,p,b[F+12],11,-421815835),p=S(p,I,m,M,b[F+15],16,530742520),m=_(m,M=S(M,p,I,m,b[F+2],23,-995338651),p,I,b[F+0],6,-198630844),I=_(I,m,M,p,b[F+7],10,1126891415),p=_(p,I,m,M,b[F+14],15,-1416354905),M=_(M,p,I,m,b[F+5],21,-57434055),m=_(m,M,p,I,b[F+12],6,1700485571),I=_(I,m,M,p,b[F+3],10,-1894986606),p=_(p,I,m,M,b[F+10],15,-1051523),M=_(M,p,I,m,b[F+1],21,-2054922799),m=_(m,M,p,I,b[F+8],6,1873313359),I=_(I,m,M,p,b[F+15],10,-30611744),p=_(p,I,m,M,b[F+6],15,-1560198380),M=_(M,p,I,m,b[F+13],21,1309151649),m=_(m,M,p,I,b[F+4],6,-145523070),I=_(I,m,M,p,b[F+11],10,-1120210379),p=_(p,I,m,M,b[F+2],15,718787259),M=_(M,p,I,m,b[F+9],21,-343485551),m=L(m,J),M=L(M,G),p=L(p,Q),I=L(I,K)}return Array(m,M,p,I)}function v(b,C,m,M,p,I){return L((C=L(L(C,b),L(M,I)))<<p|C>>>32-p,m)}function P(b,C,m,M,p,I,F){return v(C&m|~C&M,b,C,p,I,F)}function D(b,C,m,M,p,I,F){return v(C&M|m&~M,b,C,p,I,F)}function S(b,C,m,M,p,I,F){return v(C^m^M,b,C,p,I,F)}function _(b,C,m,M,p,I,F){return v(m^(C|~M),b,C,p,I,F)}function L(b,C){var m=(65535&b)+(65535&C);return(b>>16)+(C>>16)+(m>>16)<<16|65535&m}n.exports=function(b){return x.hash(b,w,16)}}).call(this,t("lYpoI2"),typeof self<"u"?self:typeof window<"u"?window:{},t("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/gulp-browserify/node_modules/crypto-browserify/md5.js","/node_modules/gulp-browserify/node_modules/crypto-browserify")},{"./helpers":4,buffer:3,lYpoI2:11}],7:[function(t,n,s){(function(r,i,a,l,u,h,d,y,g){n.exports=function(x){for(var w,v=new Array(x),P=0;P<x;P++)!(3&P)&&(w=4294967296*Math.random()),v[P]=w>>>((3&P)<<3)&255;return v}}).call(this,t("lYpoI2"),typeof self<"u"?self:typeof window<"u"?window:{},t("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/gulp-browserify/node_modules/crypto-browserify/rng.js","/node_modules/gulp-browserify/node_modules/crypto-browserify")},{buffer:3,lYpoI2:11}],8:[function(t,n,s){(function(r,i,a,l,u,h,d,y,g){var x=t("./helpers");function w(D,S){D[S>>5]|=128<<24-S%32,D[15+(S+64>>9<<4)]=S;for(var _,L,b,C=Array(80),m=1732584193,M=-271733879,p=-1732584194,I=271733878,F=-1009589776,J=0;J<D.length;J+=16){for(var G=m,Q=M,K=p,Z=I,X=F,ne=0;ne<80;ne++){C[ne]=ne<16?D[J+ne]:P(C[ne-3]^C[ne-8]^C[ne-14]^C[ne-16],1);var se=v(v(P(m,5),(se=M,L=p,b=I,(_=ne)<20?se&L|~se&b:!(_<40)&&_<60?se&L|se&b|L&b:se^L^b)),v(v(F,C[ne]),(_=ne)<20?1518500249:_<40?1859775393:_<60?-1894007588:-899497514)),F=I,I=p,p=P(M,30),M=m,m=se}m=v(m,G),M=v(M,Q),p=v(p,K),I=v(I,Z),F=v(F,X)}return Array(m,M,p,I,F)}function v(D,S){var _=(65535&D)+(65535&S);return(D>>16)+(S>>16)+(_>>16)<<16|65535&_}function P(D,S){return D<<S|D>>>32-S}n.exports=function(D){return x.hash(D,w,20,!0)}}).call(this,t("lYpoI2"),typeof self<"u"?self:typeof window<"u"?window:{},t("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/gulp-browserify/node_modules/crypto-browserify/sha.js","/node_modules/gulp-browserify/node_modules/crypto-browserify")},{"./helpers":4,buffer:3,lYpoI2:11}],9:[function(t,n,s){(function(r,i,a,l,u,h,d,y,g){function x(S,_){var L=(65535&S)+(65535&_);return(S>>16)+(_>>16)+(L>>16)<<16|65535&L}function w(S,_){var L,b=new Array(1116352408,1899447441,3049323471,3921009573,961987163,1508970993,2453635748,2870763221,3624381080,310598401,607225278,1426881987,1925078388,2162078206,2614888103,3248222580,3835390401,4022224774,264347078,604807628,770255983,1249150122,1555081692,1996064986,2554220882,2821834349,2952996808,3210313671,3336571891,3584528711,113926993,338241895,666307205,773529912,1294757372,1396182291,1695183700,1986661051,2177026350,2456956037,2730485921,2820302411,3259730800,3345764771,3516065817,3600352804,4094571909,275423344,430227734,506948616,659060556,883997877,958139571,1322822218,1537002063,1747873779,1955562222,2024104815,2227730452,2361852424,2428436474,2756734187,3204031479,3329325298),C=new Array(1779033703,3144134277,1013904242,2773480762,1359893119,2600822924,528734635,1541459225),m=new Array(64);S[_>>5]|=128<<24-_%32,S[15+(_+64>>9<<4)]=_;for(var M,p,I=0;I<S.length;I+=16){for(var F=C[0],J=C[1],G=C[2],Q=C[3],K=C[4],Z=C[5],X=C[6],ne=C[7],se=0;se<64;se++)m[se]=se<16?S[se+I]:x(x(x((p=m[se-2],P(p,17)^P(p,19)^D(p,10)),m[se-7]),(p=m[se-15],P(p,7)^P(p,18)^D(p,3))),m[se-16]),L=x(x(x(x(ne,P(p=K,6)^P(p,11)^P(p,25)),K&Z^~K&X),b[se]),m[se]),M=x(P(M=F,2)^P(M,13)^P(M,22),F&J^F&G^J&G),ne=X,X=Z,Z=K,K=x(Q,L),Q=G,G=J,J=F,F=x(L,M);C[0]=x(F,C[0]),C[1]=x(J,C[1]),C[2]=x(G,C[2]),C[3]=x(Q,C[3]),C[4]=x(K,C[4]),C[5]=x(Z,C[5]),C[6]=x(X,C[6]),C[7]=x(ne,C[7])}return C}var v=t("./helpers"),P=function(S,_){return S>>>_|S<<32-_},D=function(S,_){return S>>>_};n.exports=function(S){return v.hash(S,w,32,!0)}}).call(this,t("lYpoI2"),typeof self<"u"?self:typeof window<"u"?window:{},t("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/gulp-browserify/node_modules/crypto-browserify/sha256.js","/node_modules/gulp-browserify/node_modules/crypto-browserify")},{"./helpers":4,buffer:3,lYpoI2:11}],10:[function(t,n,s){(function(r,i,a,l,u,h,d,y,g){s.read=function(x,w,v,P,I){var S,_,L=8*I-P-1,b=(1<<L)-1,C=b>>1,m=-7,M=v?I-1:0,p=v?-1:1,I=x[w+M];for(M+=p,S=I&(1<<-m)-1,I>>=-m,m+=L;0<m;S=256*S+x[w+M],M+=p,m-=8);for(_=S&(1<<-m)-1,S>>=-m,m+=P;0<m;_=256*_+x[w+M],M+=p,m-=8);if(S===0)S=1-C;else{if(S===b)return _?NaN:1/0*(I?-1:1);_+=Math.pow(2,P),S-=C}return(I?-1:1)*_*Math.pow(2,S-P)},s.write=function(x,w,v,P,D,F){var _,L,b=8*F-D-1,C=(1<<b)-1,m=C>>1,M=D===23?Math.pow(2,-24)-Math.pow(2,-77):0,p=P?0:F-1,I=P?1:-1,F=w<0||w===0&&1/w<0?1:0;for(w=Math.abs(w),isNaN(w)||w===1/0?(L=isNaN(w)?1:0,_=C):(_=Math.floor(Math.log(w)/Math.LN2),w*(P=Math.pow(2,-_))<1&&(_--,P*=2),2<=(w+=1<=_+m?M/P:M*Math.pow(2,1-m))*P&&(_++,P/=2),C<=_+m?(L=0,_=C):1<=_+m?(L=(w*P-1)*Math.pow(2,D),_+=m):(L=w*Math.pow(2,m-1)*Math.pow(2,D),_=0));8<=D;x[v+p]=255&L,p+=I,L/=256,D-=8);for(_=_<<D|L,b+=D;0<b;x[v+p]=255&_,p+=I,_/=256,b-=8);x[v+p-I]|=128*F}}).call(this,t("lYpoI2"),typeof self<"u"?self:typeof window<"u"?window:{},t("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/gulp-browserify/node_modules/ieee754/index.js","/node_modules/gulp-browserify/node_modules/ieee754")},{buffer:3,lYpoI2:11}],11:[function(t,n,s){(function(r,i,a,l,u,h,d,y,g){var x,w,v;function P(){}(r=n.exports={}).nextTick=(w=typeof window<"u"&&window.setImmediate,v=typeof window<"u"&&window.postMessage&&window.addEventListener,w?function(D){return window.setImmediate(D)}:v?(x=[],window.addEventListener("message",function(D){var S=D.source;S!==window&&S!==null||D.data!=="process-tick"||(D.stopPropagation(),0<x.length&&x.shift()())},!0),function(D){x.push(D),window.postMessage("process-tick","*")}):function(D){setTimeout(D,0)}),r.title="browser",r.browser=!0,r.env={},r.argv=[],r.on=P,r.addListener=P,r.once=P,r.off=P,r.removeListener=P,r.removeAllListeners=P,r.emit=P,r.binding=function(D){throw new Error("process.binding is not supported")},r.cwd=function(){return"/"},r.chdir=function(D){throw new Error("process.chdir is not supported")}}).call(this,t("lYpoI2"),typeof self<"u"?self:typeof window<"u"?window:{},t("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/gulp-browserify/node_modules/process/browser.js","/node_modules/gulp-browserify/node_modules/process")},{buffer:3,lYpoI2:11}]},{},[1])(1)})})(oi);var Ic=oi.exports;const Dc=nn(Ic);var ai=["precision","highp","mediump","lowp","attribute","const","uniform","varying","break","continue","do","for","while","if","else","in","out","inout","float","int","uint","void","bool","true","false","discard","return","mat2","mat3","mat4","vec2","vec3","vec4","ivec2","ivec3","ivec4","bvec2","bvec3","bvec4","sampler1D","sampler2D","sampler3D","samplerCube","sampler1DShadow","sampler2DShadow","struct","asm","class","union","enum","typedef","template","this","packed","goto","switch","default","inline","noinline","volatile","public","static","extern","external","interface","long","short","double","half","fixed","unsigned","input","output","hvec2","hvec3","hvec4","dvec2","dvec3","dvec4","fvec2","fvec3","fvec4","sampler2DRect","sampler3DRect","sampler2DRectShadow","sizeof","cast","namespace","using"],Oc=["<<=",">>=","++","--","<<",">>","<=",">=","==","!=","&&","||","+=","-=","*=","/=","%=","&=","^^","^=","|=","(",")","[","]",".","!","~","*","/","%","+","-","<",">","&","^","|","?",":","=",",",";","{","}"],li=["abs","acos","all","any","asin","atan","ceil","clamp","cos","cross","dFdx","dFdy","degrees","distance","dot","equal","exp","exp2","faceforward","floor","fract","gl_BackColor","gl_BackLightModelProduct","gl_BackLightProduct","gl_BackMaterial","gl_BackSecondaryColor","gl_ClipPlane","gl_ClipVertex","gl_Color","gl_DepthRange","gl_DepthRangeParameters","gl_EyePlaneQ","gl_EyePlaneR","gl_EyePlaneS","gl_EyePlaneT","gl_Fog","gl_FogCoord","gl_FogFragCoord","gl_FogParameters","gl_FragColor","gl_FragCoord","gl_FragData","gl_FragDepth","gl_FragDepthEXT","gl_FrontColor","gl_FrontFacing","gl_FrontLightModelProduct","gl_FrontLightProduct","gl_FrontMaterial","gl_FrontSecondaryColor","gl_LightModel","gl_LightModelParameters","gl_LightModelProducts","gl_LightProducts","gl_LightSource","gl_LightSourceParameters","gl_MaterialParameters","gl_MaxClipPlanes","gl_MaxCombinedTextureImageUnits","gl_MaxDrawBuffers","gl_MaxFragmentUniformComponents","gl_MaxLights","gl_MaxTextureCoords","gl_MaxTextureImageUnits","gl_MaxTextureUnits","gl_MaxVaryingFloats","gl_MaxVertexAttribs","gl_MaxVertexTextureImageUnits","gl_MaxVertexUniformComponents","gl_ModelViewMatrix","gl_ModelViewMatrixInverse","gl_ModelViewMatrixInverseTranspose","gl_ModelViewMatrixTranspose","gl_ModelViewProjectionMatrix","gl_ModelViewProjectionMatrixInverse","gl_ModelViewProjectionMatrixInverseTranspose","gl_ModelViewProjectionMatrixTranspose","gl_MultiTexCoord0","gl_MultiTexCoord1","gl_MultiTexCoord2","gl_MultiTexCoord3","gl_MultiTexCoord4","gl_MultiTexCoord5","gl_MultiTexCoord6","gl_MultiTexCoord7","gl_Normal","gl_NormalMatrix","gl_NormalScale","gl_ObjectPlaneQ","gl_ObjectPlaneR","gl_ObjectPlaneS","gl_ObjectPlaneT","gl_Point","gl_PointCoord","gl_PointParameters","gl_PointSize","gl_Position","gl_ProjectionMatrix","gl_ProjectionMatrixInverse","gl_ProjectionMatrixInverseTranspose","gl_ProjectionMatrixTranspose","gl_SecondaryColor","gl_TexCoord","gl_TextureEnvColor","gl_TextureMatrix","gl_TextureMatrixInverse","gl_TextureMatrixInverseTranspose","gl_TextureMatrixTranspose","gl_Vertex","greaterThan","greaterThanEqual","inversesqrt","length","lessThan","lessThanEqual","log","log2","matrixCompMult","max","min","mix","mod","normalize","not","notEqual","pow","radians","reflect","refract","sign","sin","smoothstep","sqrt","step","tan","texture2D","texture2DLod","texture2DProj","texture2DProjLod","textureCube","textureCubeLod","texture2DLodEXT","texture2DProjLodEXT","textureCubeLodEXT","texture2DGradEXT","texture2DProjGradEXT","textureCubeGradEXT"],Fc=ai,kc=Fc.slice().concat(["layout","centroid","smooth","case","mat2x2","mat2x3","mat2x4","mat3x2","mat3x3","mat3x4","mat4x2","mat4x3","mat4x4","uvec2","uvec3","uvec4","samplerCubeShadow","sampler2DArray","sampler2DArrayShadow","isampler2D","isampler3D","isamplerCube","isampler2DArray","usampler2D","usampler3D","usamplerCube","usampler2DArray","coherent","restrict","readonly","writeonly","resource","atomic_uint","noperspective","patch","sample","subroutine","common","partition","active","filter","image1D","image2D","image3D","imageCube","iimage1D","iimage2D","iimage3D","iimageCube","uimage1D","uimage2D","uimage3D","uimageCube","image1DArray","image2DArray","iimage1DArray","iimage2DArray","uimage1DArray","uimage2DArray","image1DShadow","image2DShadow","image1DArrayShadow","image2DArrayShadow","imageBuffer","iimageBuffer","uimageBuffer","sampler1DArray","sampler1DArrayShadow","isampler1D","isampler1DArray","usampler1D","usampler1DArray","isampler2DRect","usampler2DRect","samplerBuffer","isamplerBuffer","usamplerBuffer","sampler2DMS","isampler2DMS","usampler2DMS","sampler2DMSArray","isampler2DMSArray","usampler2DMSArray"]),bs=li;bs=bs.slice().filter(function(o){return!/^(gl\_|texture)/.test(o)});var Bc=bs.concat(["gl_VertexID","gl_InstanceID","gl_Position","gl_PointSize","gl_FragCoord","gl_FrontFacing","gl_FragDepth","gl_PointCoord","gl_MaxVertexAttribs","gl_MaxVertexUniformVectors","gl_MaxVertexOutputVectors","gl_MaxFragmentInputVectors","gl_MaxVertexTextureImageUnits","gl_MaxCombinedTextureImageUnits","gl_MaxTextureImageUnits","gl_MaxFragmentUniformVectors","gl_MaxDrawBuffers","gl_MinProgramTexelOffset","gl_MaxProgramTexelOffset","gl_DepthRangeParameters","gl_DepthRange","trunc","round","roundEven","isnan","isinf","floatBitsToInt","floatBitsToUint","intBitsToFloat","uintBitsToFloat","packSnorm2x16","unpackSnorm2x16","packUnorm2x16","unpackUnorm2x16","packHalf2x16","unpackHalf2x16","outerProduct","transpose","determinant","inverse","texture","textureSize","textureProj","textureLod","textureOffset","texelFetch","texelFetchOffset","textureProjOffset","textureLodOffset","textureProjLod","textureProjLodOffset","textureGrad","textureGradOffset","textureProjGrad","textureProjGradOffset"]),Uc=Wc,Nc=ai,ci=Oc,zc=li,Vc=kc,Rc=Bc,He=999,ui=9999,Ms=0,Ss=1,hi=2,fi=3,di=4,sn=5,Gc=6,jc=7,Ec=8,pi=9,Yc=10,mi=11,Xc=["block-comment","line-comment","preprocessor","operator","integer","float","ident","builtin","keyword","whitespace","eof","integer"];function Wc(o){var e=0,t=0,n=He,s,r,i=[],a=[],l=1,u=0,h=0,d=!1,y=!1,g="",x;o=o||{};var w=zc,v=Nc;o.version==="300 es"&&(w=Rc,v=Vc);for(var P={},D={},e=0;e<w.length;e++)P[w[e]]=!0;for(var e=0;e<v.length;e++)D[v[e]]=!0;return function(Z){return a=[],Z!==null?_(Z):L()};function S(Z){Z.length&&a.push({type:Xc[n],data:Z,position:h,line:l,column:u})}function _(Z){e=0,Z.toString&&(Z=Z.toString()),g+=Z.replace(/\r\n/g,`
-`),x=g.length;for(var X;s=g[e],e<x;){switch(X=e,n){case Ms:e=p();break;case Ss:e=M();break;case hi:e=m();break;case fi:e=I();break;case di:e=G();break;case mi:e=J();break;case sn:e=Q();break;case ui:e=K();break;case pi:e=C();break;case He:e=b();break}if(X!==e)switch(g[X]){case`
-`:u=0,++l;break;default:++u;break}}return t+=e,g=g.slice(e),a}function L(Z){return i.length&&S(i.join("")),n=Yc,S("(eof)"),a}function b(){return i=i.length?[]:i,r==="/"&&s==="*"?(h=t+e-1,n=Ms,r=s,e+1):r==="/"&&s==="/"?(h=t+e-1,n=Ss,r=s,e+1):s==="#"?(n=hi,h=t+e,e):/\s/.test(s)?(n=pi,h=t+e,e):(d=/\d/.test(s),y=/[^\w_]/.test(s),h=t+e,n=d?di:y?fi:ui,e)}function C(){return/[^\s]/g.test(s)?(S(i.join("")),n=He,e):(i.push(s),r=s,e+1)}function m(){return(s==="\r"||s===`
-`)&&r!=="\\"?(S(i.join("")),n=He,e):(i.push(s),r=s,e+1)}function M(){return m()}function p(){return s==="/"&&r==="*"?(i.push(s),S(i.join("")),n=He,e+1):(i.push(s),r=s,e+1)}function I(){if(r==="."&&/\d/.test(s))return n=sn,e;if(r==="/"&&s==="*")return n=Ms,e;if(r==="/"&&s==="/")return n=Ss,e;if(s==="."&&i.length){for(;F(i););return n=sn,e}if(s===";"||s===")"||s==="("){if(i.length)for(;F(i););return S(s),n=He,e+1}var Z=i.length===2&&s!=="=";if(/[\w_\d\s]/.test(s)||Z){for(;F(i););return n=He,e}return i.push(s),r=s,e+1}function F(Z){var X=0,ne,se;do{if(ne=ci.indexOf(Z.slice(0,Z.length+X).join("")),se=ci[ne],ne===-1){if(X--+Z.length>0)continue;se=Z.slice(0,1).join("")}return S(se),h+=se.length,i=i.slice(se.length),i.length}while(!0)}function J(){return/[^a-fA-F0-9]/.test(s)?(S(i.join("")),n=He,e):(i.push(s),r=s,e+1)}function G(){return s==="."||/[eE]/.test(s)?(i.push(s),n=sn,r=s,e+1):s==="x"&&i.length===1&&i[0]==="0"?(n=mi,i.push(s),r=s,e+1):/[^\d]/.test(s)?(S(i.join("")),n=He,e):(i.push(s),r=s,e+1)}function Q(){return s==="f"&&(i.push(s),r=s,e+=1),/[eE]/.test(s)||(s==="-"||s==="+")&&/[eE]/.test(r)?(i.push(s),r=s,e+1):/[^\d]/.test(s)?(S(i.join("")),n=He,e):(i.push(s),r=s,e+1)}function K(){if(/[^\d\w_]/.test(s)){var Z=i.join("");return D[Z]?n=Ec:P[Z]?n=jc:n=Gc,S(i.join("")),n=He,e}return i.push(s),r=s,e+1}}var Zc=Uc,Kc=qc;function qc(o,e){var t=Zc(e),n=[];return n=n.concat(t(o)),n=n.concat(t(null)),n}const Qc=nn(Kc);var Jc=Hc;function Hc(o){for(var e=[],t=0;t<o.length;t++)o[t].type!=="eof"&&e.push(o[t].data);return e.join("")}const gi=nn(Jc);var $c=eu;function eu(o){var e=null,t=null,n=0,s=0,r=0,i=0,a=0,l=[],u,h,d;for(u=0,h;u<o.length;u++)if(d=o[u],d.data==="{"){if(n&&n++||(h=g(u,vt(")"),vt()),h<0)||(i=h,h=g(h,vt("("),vt(")")),h<0)||(a=h,h=g(h,rn),h<0)||o[h].type!=="ident"||(t=o[h].data,h=g(h,rn),h<0))continue;n=1,s=u,e=o[h].data,r=h;var y=g(h,rn);switch(o[y]&&o[y].data){case"lowp":case"highp":case"mediump":r=y}}else if(n&&d.data==="}"){if(--n)continue;l.push({name:t,type:e,body:[s+1,u],args:[a,i+1],outer:[r,u+1]})}for(u=0;u<o.length;u++)if(d=o[u],d.data===";"){if(h=g(u,vt(")"),vt()),h<0||(i=h,h=g(h,vt("("),vt(")")),h<0)||(a=h,h=g(h,rn),h<0)||o[h].type!=="ident"||(t=o[h].data,h=g(h,rn),h<0)||o[h].type==="operator"||o[h].data==="return")continue;e=o[h].data,l.push({name:t,type:e,body:!1,args:[a,i+1],outer:[h,u+1]})}return l.sort(function(x,w){return x.outer[0]-w.outer[0]});function g(x,w,v){for(var P=x-1;P>=0;P--){if(w(o[P]))return P;if(v&&v(o[P]))return-1}return-1}}function vt(o){return function(e){return e.type==="operator"&&(!o||e.data===o)}}function rn(o){return o.type!=="whitespace"}const tu=nn($c);function nu(o,e){if(typeof o!="object"||o===null)return o;var t=o[Symbol.toPrimitive];if(t!==void 0){var n=t.call(o,e||"default");if(typeof n!="object")return n;throw new TypeError("@@toPrimitive must return a primitive value.")}return(e==="string"?String:Number)(o)}function yi(o){var e=nu(o,"string");return typeof e=="symbol"?e:String(e)}function Pe(o,e,t){return e=yi(e),e in o?Object.defineProperty(o,e,{value:t,enumerable:!0,configurable:!0,writable:!0}):o[e]=t,o}function _i(o,e){var t=Object.keys(o);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(o);e&&(n=n.filter(function(s){return Object.getOwnPropertyDescriptor(o,s).enumerable})),t.push.apply(t,n)}return t}function Nt(o){for(var e=1;e<arguments.length;e++){var t=arguments[e]!=null?arguments[e]:{};e%2?_i(Object(t),!0).forEach(function(n){Pe(o,n,t[n])}):Object.getOwnPropertyDescriptors?Object.defineProperties(o,Object.getOwnPropertyDescriptors(t)):_i(Object(t)).forEach(function(n){Object.defineProperty(o,n,Object.getOwnPropertyDescriptor(t,n))})}return o}function su(o,e){if(o==null)return{};var t={},n=Object.keys(o),s,r;for(r=0;r<n.length;r++)s=n[r],!(e.indexOf(s)>=0)&&(t[s]=o[s]);return t}function ru(o,e){if(o==null)return{};var t=su(o,e),n,s;if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(o);for(s=0;s<r.length;s++)n=r[s],!(e.indexOf(n)>=0)&&Object.prototype.propertyIsEnumerable.call(o,n)&&(t[n]=o[n])}return t}function iu(o,e){if(!(o instanceof e))throw new TypeError("Cannot call a class as a function")}function vi(o,e){for(var t=0;t<e.length;t++){var n=e[t];n.enumerable=n.enumerable||!1,n.configurable=!0,"value"in n&&(n.writable=!0),Object.defineProperty(o,yi(n.key),n)}}function ou(o,e,t){return e&&vi(o.prototype,e),t&&vi(o,t),Object.defineProperty(o,"prototype",{writable:!1}),o}function xi(o){if(o===void 0)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return o}function As(o,e){return As=Object.setPrototypeOf?Object.setPrototypeOf.bind():function(n,s){return n.__proto__=s,n},As(o,e)}function au(o,e){if(typeof e!="function"&&e!==null)throw new TypeError("Super expression must either be null or a function");o.prototype=Object.create(e&&e.prototype,{constructor:{value:o,writable:!0,configurable:!0}}),Object.defineProperty(o,"prototype",{writable:!1}),e&&As(o,e)}function Ln(o){return Ln=Object.setPrototypeOf?Object.getPrototypeOf.bind():function(t){return t.__proto__||Object.getPrototypeOf(t)},Ln(o)}function lu(){if(typeof Reflect>"u"||!Reflect.construct||Reflect.construct.sham)return!1;if(typeof Proxy=="function")return!0;try{return Boolean.prototype.valueOf.call(Reflect.construct(Boolean,[],function(){})),!0}catch{return!1}}function cu(o,e){if(e&&(typeof e=="object"||typeof e=="function"))return e;if(e!==void 0)throw new TypeError("Derived constructors may only return object or undefined");return xi(o)}function uu(o){var e=lu();return function(){var n=Ln(o),s;if(e){var r=Ln(this).constructor;s=Reflect.construct(n,arguments,r)}else s=n.apply(this,arguments);return cu(this,s)}}var pe={position:"csm_Position",positionRaw:"csm_PositionRaw",pointSize:"csm_PointSize",fragColor:"csm_FragColor",diffuseColor:"csm_DiffuseColor",normal:"csm_Normal",roughness:"csm_Roughness",metalness:"csm_Metalness",emissive:"csm_Emissive",ao:"csm_AO",bump:"csm_Bump",depthAlpha:"csm_DepthAlpha"},Ge,zt,hu=(Ge={},Pe(Ge,"".concat(pe.normal),{"#include <beginnormal_vertex>":`
-    vec3 objectNormal = `.concat(pe.normal,`;
+`)},_domwindow:function(){return A("domwindow")},_bigint:function(g){return A("bigint:"+g.toString())},_process:function(){return A("process")},_timer:function(){return A("timer")},_pipe:function(){return A("pipe")},_tcp:function(){return A("tcp")},_udp:function(){return A("udp")},_tty:function(){return A("tty")},_statwatcher:function(){return A("statwatcher")},_securecontext:function(){return A("securecontext")},_connection:function(){return A("connection")},_zlib:function(){return A("zlib")},_context:function(){return A("context")},_nodescript:function(){return A("nodescript")},_httpparser:function(){return A("httpparser")},_dataview:function(){return A("dataview")},_signal:function(){return A("signal")},_fsevent:function(){return A("fsevent")},_tlswrap:function(){return A("tlswrap")}}}function D(){return{buf:"",write:function(S){this.buf+=S},end:function(S){this.buf+=S},read:function(){return this.buf}}}r.writeToStream=function(S,C,y){return y===void 0&&(y=C,C={}),M(C=T(S,C),y).dispatch(S)}}).call(this,t("lYpoI2"),typeof self<"u"?self:typeof window<"u"?window:{},t("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/fake_9a5aa49d.js","/")},{buffer:3,crypto:5,lYpoI2:11}],2:[function(t,n,r){(function(i,s,a,c,h,f,d,p,m){(function(x){var b=typeof Uint8Array<"u"?Uint8Array:Array,v=43,_=47,T=48,w=97,M=65,D=45,S=95;function C(y){return y=y.charCodeAt(0),y===v||y===D?62:y===_||y===S?63:y<T?-1:y<T+10?y-T+26+26:y<M+26?y-M:y<w+26?y-w+26:void 0}x.toByteArray=function(y){var A,g;if(0<y.length%4)throw new Error("Invalid string. Length must be a multiple of 4");var I=y.length,I=y.charAt(I-2)==="="?2:y.charAt(I-1)==="="?1:0,k=new b(3*y.length/4-I),J=0<I?y.length-4:y.length,G=0;function Z(X){k[G++]=X}for(A=0;A<J;A+=4,0)Z((16711680&(g=C(y.charAt(A))<<18|C(y.charAt(A+1))<<12|C(y.charAt(A+2))<<6|C(y.charAt(A+3))))>>16),Z((65280&g)>>8),Z(255&g);return I==2?Z(255&(g=C(y.charAt(A))<<2|C(y.charAt(A+1))>>4)):I==1&&(Z((g=C(y.charAt(A))<<10|C(y.charAt(A+1))<<4|C(y.charAt(A+2))>>2)>>8&255),Z(255&g)),k},x.fromByteArray=function(y){var A,g,I,k,J=y.length%3,G="";function Z(X){return"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/".charAt(X)}for(A=0,I=y.length-J;A<I;A+=3)g=(y[A]<<16)+(y[A+1]<<8)+y[A+2],G+=Z((k=g)>>18&63)+Z(k>>12&63)+Z(k>>6&63)+Z(63&k);switch(J){case 1:G=(G+=Z((g=y[y.length-1])>>2))+Z(g<<4&63)+"==";break;case 2:G=(G=(G+=Z((g=(y[y.length-2]<<8)+y[y.length-1])>>10))+Z(g>>4&63))+Z(g<<2&63)+"="}return G}})(r===void 0?this.base64js={}:r)}).call(this,t("lYpoI2"),typeof self<"u"?self:typeof window<"u"?window:{},t("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/gulp-browserify/node_modules/base64-js/lib/b64.js","/node_modules/gulp-browserify/node_modules/base64-js/lib")},{buffer:3,lYpoI2:11}],3:[function(t,n,r){(function(i,s,v,c,h,f,d,p,m){var x=t("base64-js"),b=t("ieee754");function v(L,O,B){if(!(this instanceof v))return new v(L,O,B);var E,Q,q,ne,U=typeof L;if(O==="base64"&&U=="string")for(L=(ne=L).trim?ne.trim():ne.replace(/^\s+|\s+$/g,"");L.length%4!=0;)L+="=";if(U=="number")E=Y(L);else if(U=="string")E=v.byteLength(L,O);else{if(U!="object")throw new Error("First argument needs to be a number, array or string.");E=Y(L.length)}if(v._useTypedArrays?Q=v._augment(new Uint8Array(E)):((Q=this).length=E,Q._isBuffer=!0),v._useTypedArrays&&typeof L.byteLength=="number")Q._set(L);else if(te(ne=L)||v.isBuffer(ne)||ne&&typeof ne=="object"&&typeof ne.length=="number")for(q=0;q<E;q++)v.isBuffer(L)?Q[q]=L.readUInt8(q):Q[q]=L[q];else if(U=="string")Q.write(L,0,O);else if(U=="number"&&!v._useTypedArrays&&!B)for(q=0;q<E;q++)Q[q]=0;return Q}function _(L,O,B,E){return v._charsWritten=z(function(Q){for(var q=[],ne=0;ne<Q.length;ne++)q.push(255&Q.charCodeAt(ne));return q}(O),L,B,E)}function T(L,O,B,E){return v._charsWritten=z(function(Q){for(var q,ne,U=[],F=0;F<Q.length;F++)ne=Q.charCodeAt(F),q=ne>>8,ne=ne%256,U.push(ne),U.push(q);return U}(O),L,B,E)}function w(L,O,B){var E="";B=Math.min(L.length,B);for(var Q=O;Q<B;Q++)E+=String.fromCharCode(L[Q]);return E}function M(L,O,B,q){q||(R(typeof B=="boolean","missing or invalid endian"),R(O!=null,"missing offset"),R(O+1<L.length,"Trying to read beyond buffer length"));var Q,q=L.length;if(!(q<=O))return B?(Q=L[O],O+1<q&&(Q|=L[O+1]<<8)):(Q=L[O]<<8,O+1<q&&(Q|=L[O+1])),Q}function D(L,O,B,q){q||(R(typeof B=="boolean","missing or invalid endian"),R(O!=null,"missing offset"),R(O+3<L.length,"Trying to read beyond buffer length"));var Q,q=L.length;if(!(q<=O))return B?(O+2<q&&(Q=L[O+2]<<16),O+1<q&&(Q|=L[O+1]<<8),Q|=L[O],O+3<q&&(Q+=L[O+3]<<24>>>0)):(O+1<q&&(Q=L[O+1]<<16),O+2<q&&(Q|=L[O+2]<<8),O+3<q&&(Q|=L[O+3]),Q+=L[O]<<24>>>0),Q}function S(L,O,B,E){if(E||(R(typeof B=="boolean","missing or invalid endian"),R(O!=null,"missing offset"),R(O+1<L.length,"Trying to read beyond buffer length")),!(L.length<=O))return E=M(L,O,B,!0),32768&E?-1*(65535-E+1):E}function C(L,O,B,E){if(E||(R(typeof B=="boolean","missing or invalid endian"),R(O!=null,"missing offset"),R(O+3<L.length,"Trying to read beyond buffer length")),!(L.length<=O))return E=D(L,O,B,!0),2147483648&E?-1*(4294967295-E+1):E}function y(L,O,B,E){return E||(R(typeof B=="boolean","missing or invalid endian"),R(O+3<L.length,"Trying to read beyond buffer length")),b.read(L,O,B,23,4)}function A(L,O,B,E){return E||(R(typeof B=="boolean","missing or invalid endian"),R(O+7<L.length,"Trying to read beyond buffer length")),b.read(L,O,B,52,8)}function g(L,O,B,E,Q){if(Q||(R(O!=null,"missing value"),R(typeof E=="boolean","missing or invalid endian"),R(B!=null,"missing offset"),R(B+1<L.length,"trying to write beyond buffer length"),V(O,65535)),Q=L.length,!(Q<=B))for(var q=0,ne=Math.min(Q-B,2);q<ne;q++)L[B+q]=(O&255<<8*(E?q:1-q))>>>8*(E?q:1-q)}function I(L,O,B,E,Q){if(Q||(R(O!=null,"missing value"),R(typeof E=="boolean","missing or invalid endian"),R(B!=null,"missing offset"),R(B+3<L.length,"trying to write beyond buffer length"),V(O,4294967295)),Q=L.length,!(Q<=B))for(var q=0,ne=Math.min(Q-B,4);q<ne;q++)L[B+q]=O>>>8*(E?q:3-q)&255}function k(L,O,B,E,Q){Q||(R(O!=null,"missing value"),R(typeof E=="boolean","missing or invalid endian"),R(B!=null,"missing offset"),R(B+1<L.length,"Trying to write beyond buffer length"),ee(O,32767,-32768)),L.length<=B||g(L,0<=O?O:65535+O+1,B,E,Q)}function J(L,O,B,E,Q){Q||(R(O!=null,"missing value"),R(typeof E=="boolean","missing or invalid endian"),R(B!=null,"missing offset"),R(B+3<L.length,"Trying to write beyond buffer length"),ee(O,2147483647,-2147483648)),L.length<=B||I(L,0<=O?O:4294967295+O+1,B,E,Q)}function G(L,O,B,E,Q){Q||(R(O!=null,"missing value"),R(typeof E=="boolean","missing or invalid endian"),R(B!=null,"missing offset"),R(B+3<L.length,"Trying to write beyond buffer length"),N(O,34028234663852886e22,-34028234663852886e22)),L.length<=B||b.write(L,O,B,E,23,4)}function Z(L,O,B,E,Q){Q||(R(O!=null,"missing value"),R(typeof E=="boolean","missing or invalid endian"),R(B!=null,"missing offset"),R(B+7<L.length,"Trying to write beyond buffer length"),N(O,17976931348623157e292,-17976931348623157e292)),L.length<=B||b.write(L,O,B,E,52,8)}r.Buffer=v,r.SlowBuffer=v,r.INSPECT_MAX_BYTES=50,v.poolSize=8192,v._useTypedArrays=function(){try{var L=new ArrayBuffer(0),O=new Uint8Array(L);return O.foo=function(){return 42},O.foo()===42&&typeof O.subarray=="function"}catch{return!1}}(),v.isEncoding=function(L){switch(String(L).toLowerCase()){case"hex":case"utf8":case"utf-8":case"ascii":case"binary":case"base64":case"raw":case"ucs2":case"ucs-2":case"utf16le":case"utf-16le":return!0;default:return!1}},v.isBuffer=function(L){return!(L==null||!L._isBuffer)},v.byteLength=function(L,O){var B;switch(L+="",O||"utf8"){case"hex":B=L.length/2;break;case"utf8":case"utf-8":B=ce(L).length;break;case"ascii":case"binary":case"raw":B=L.length;break;case"base64":B=j(L).length;break;case"ucs2":case"ucs-2":case"utf16le":case"utf-16le":B=2*L.length;break;default:throw new Error("Unknown encoding")}return B},v.concat=function(L,O){if(R(te(L),`Usage: Buffer.concat(list, [totalLength])
+list should be an Array.`),L.length===0)return new v(0);if(L.length===1)return L[0];if(typeof O!="number")for(Q=O=0;Q<L.length;Q++)O+=L[Q].length;for(var B=new v(O),E=0,Q=0;Q<L.length;Q++){var q=L[Q];q.copy(B,E),E+=q.length}return B},v.prototype.write=function(L,O,B,E){isFinite(O)?isFinite(B)||(E=B,B=void 0):(F=E,E=O,O=B,B=F),O=Number(O)||0;var Q,q,ne,U,F=this.length-O;switch((!B||F<(B=Number(B)))&&(B=F),E=String(E||"utf8").toLowerCase()){case"hex":Q=function(ae,ue,me,ye){me=Number(me)||0;var _e=ae.length-me;(!ye||_e<(ye=Number(ye)))&&(ye=_e),R((_e=ue.length)%2==0,"Invalid hex string"),_e/2<ye&&(ye=_e/2);for(var Oe=0;Oe<ye;Oe++){var lt=parseInt(ue.substr(2*Oe,2),16);R(!isNaN(lt),"Invalid hex string"),ae[me+Oe]=lt}return v._charsWritten=2*Oe,Oe}(this,L,O,B);break;case"utf8":case"utf-8":q=this,ne=O,U=B,Q=v._charsWritten=z(ce(L),q,ne,U);break;case"ascii":case"binary":Q=_(this,L,O,B);break;case"base64":q=this,ne=O,U=B,Q=v._charsWritten=z(j(L),q,ne,U);break;case"ucs2":case"ucs-2":case"utf16le":case"utf-16le":Q=T(this,L,O,B);break;default:throw new Error("Unknown encoding")}return Q},v.prototype.toString=function(L,O,B){var E,Q,q,ne,U=this;if(L=String(L||"utf8").toLowerCase(),O=Number(O)||0,(B=B!==void 0?Number(B):U.length)===O)return"";switch(L){case"hex":E=function(F,ae,ue){var me=F.length;(!ae||ae<0)&&(ae=0),(!ue||ue<0||me<ue)&&(ue=me);for(var ye="",_e=ae;_e<ue;_e++)ye+=re(F[_e]);return ye}(U,O,B);break;case"utf8":case"utf-8":E=function(F,ae,ue){var me="",ye="";ue=Math.min(F.length,ue);for(var _e=ae;_e<ue;_e++)F[_e]<=127?(me+=P(ye)+String.fromCharCode(F[_e]),ye=""):ye+="%"+F[_e].toString(16);return me+P(ye)}(U,O,B);break;case"ascii":case"binary":E=w(U,O,B);break;case"base64":Q=U,ne=B,E=(q=O)===0&&ne===Q.length?x.fromByteArray(Q):x.fromByteArray(Q.slice(q,ne));break;case"ucs2":case"ucs-2":case"utf16le":case"utf-16le":E=function(F,ae,ue){for(var me=F.slice(ae,ue),ye="",_e=0;_e<me.length;_e+=2)ye+=String.fromCharCode(me[_e]+256*me[_e+1]);return ye}(U,O,B);break;default:throw new Error("Unknown encoding")}return E},v.prototype.toJSON=function(){return{type:"Buffer",data:Array.prototype.slice.call(this._arr||this,0)}},v.prototype.copy=function(L,O,B,E){if(O=O||0,(E=E||E===0?E:this.length)!==(B=B||0)&&L.length!==0&&this.length!==0){R(B<=E,"sourceEnd < sourceStart"),R(0<=O&&O<L.length,"targetStart out of bounds"),R(0<=B&&B<this.length,"sourceStart out of bounds"),R(0<=E&&E<=this.length,"sourceEnd out of bounds"),E>this.length&&(E=this.length);var Q=(E=L.length-O<E-B?L.length-O+B:E)-B;if(Q<100||!v._useTypedArrays)for(var q=0;q<Q;q++)L[q+O]=this[q+B];else L._set(this.subarray(B,B+Q),O)}},v.prototype.slice=function(L,O){var B=this.length;if(L=K(L,B,0),O=K(O,B,B),v._useTypedArrays)return v._augment(this.subarray(L,O));for(var E=O-L,Q=new v(E,void 0,!0),q=0;q<E;q++)Q[q]=this[q+L];return Q},v.prototype.get=function(L){return console.log(".get() is deprecated. Access using array indexes instead."),this.readUInt8(L)},v.prototype.set=function(L,O){return console.log(".set() is deprecated. Access using array indexes instead."),this.writeUInt8(L,O)},v.prototype.readUInt8=function(L,O){if(O||(R(L!=null,"missing offset"),R(L<this.length,"Trying to read beyond buffer length")),!(L>=this.length))return this[L]},v.prototype.readUInt16LE=function(L,O){return M(this,L,!0,O)},v.prototype.readUInt16BE=function(L,O){return M(this,L,!1,O)},v.prototype.readUInt32LE=function(L,O){return D(this,L,!0,O)},v.prototype.readUInt32BE=function(L,O){return D(this,L,!1,O)},v.prototype.readInt8=function(L,O){if(O||(R(L!=null,"missing offset"),R(L<this.length,"Trying to read beyond buffer length")),!(L>=this.length))return 128&this[L]?-1*(255-this[L]+1):this[L]},v.prototype.readInt16LE=function(L,O){return S(this,L,!0,O)},v.prototype.readInt16BE=function(L,O){return S(this,L,!1,O)},v.prototype.readInt32LE=function(L,O){return C(this,L,!0,O)},v.prototype.readInt32BE=function(L,O){return C(this,L,!1,O)},v.prototype.readFloatLE=function(L,O){return y(this,L,!0,O)},v.prototype.readFloatBE=function(L,O){return y(this,L,!1,O)},v.prototype.readDoubleLE=function(L,O){return A(this,L,!0,O)},v.prototype.readDoubleBE=function(L,O){return A(this,L,!1,O)},v.prototype.writeUInt8=function(L,O,B){B||(R(L!=null,"missing value"),R(O!=null,"missing offset"),R(O<this.length,"trying to write beyond buffer length"),V(L,255)),O>=this.length||(this[O]=L)},v.prototype.writeUInt16LE=function(L,O,B){g(this,L,O,!0,B)},v.prototype.writeUInt16BE=function(L,O,B){g(this,L,O,!1,B)},v.prototype.writeUInt32LE=function(L,O,B){I(this,L,O,!0,B)},v.prototype.writeUInt32BE=function(L,O,B){I(this,L,O,!1,B)},v.prototype.writeInt8=function(L,O,B){B||(R(L!=null,"missing value"),R(O!=null,"missing offset"),R(O<this.length,"Trying to write beyond buffer length"),ee(L,127,-128)),O>=this.length||(0<=L?this.writeUInt8(L,O,B):this.writeUInt8(255+L+1,O,B))},v.prototype.writeInt16LE=function(L,O,B){k(this,L,O,!0,B)},v.prototype.writeInt16BE=function(L,O,B){k(this,L,O,!1,B)},v.prototype.writeInt32LE=function(L,O,B){J(this,L,O,!0,B)},v.prototype.writeInt32BE=function(L,O,B){J(this,L,O,!1,B)},v.prototype.writeFloatLE=function(L,O,B){G(this,L,O,!0,B)},v.prototype.writeFloatBE=function(L,O,B){G(this,L,O,!1,B)},v.prototype.writeDoubleLE=function(L,O,B){Z(this,L,O,!0,B)},v.prototype.writeDoubleBE=function(L,O,B){Z(this,L,O,!1,B)},v.prototype.fill=function(L,O,B){if(O=O||0,B=B||this.length,R(typeof(L=typeof(L=L||0)=="string"?L.charCodeAt(0):L)=="number"&&!isNaN(L),"value is not a number"),R(O<=B,"end < start"),B!==O&&this.length!==0){R(0<=O&&O<this.length,"start out of bounds"),R(0<=B&&B<=this.length,"end out of bounds");for(var E=O;E<B;E++)this[E]=L}},v.prototype.inspect=function(){for(var L=[],O=this.length,B=0;B<O;B++)if(L[B]=re(this[B]),B===r.INSPECT_MAX_BYTES){L[B+1]="...";break}return"<Buffer "+L.join(" ")+">"},v.prototype.toArrayBuffer=function(){if(typeof Uint8Array>"u")throw new Error("Buffer.toArrayBuffer not supported in this browser");if(v._useTypedArrays)return new v(this).buffer;for(var L=new Uint8Array(this.length),O=0,B=L.length;O<B;O+=1)L[O]=this[O];return L.buffer};var X=v.prototype;function K(L,O,B){return typeof L!="number"?B:O<=(L=~~L)?O:0<=L||0<=(L+=O)?L:0}function Y(L){return(L=~~Math.ceil(+L))<0?0:L}function te(L){return(Array.isArray||function(O){return Object.prototype.toString.call(O)==="[object Array]"})(L)}function re(L){return L<16?"0"+L.toString(16):L.toString(16)}function ce(L){for(var O=[],B=0;B<L.length;B++){var E=L.charCodeAt(B);if(E<=127)O.push(L.charCodeAt(B));else for(var Q=B,q=(55296<=E&&E<=57343&&B++,encodeURIComponent(L.slice(Q,B+1)).substr(1).split("%")),ne=0;ne<q.length;ne++)O.push(parseInt(q[ne],16))}return O}function j(L){return x.toByteArray(L)}function z(L,O,B,E){for(var Q=0;Q<E&&!(Q+B>=O.length||Q>=L.length);Q++)O[Q+B]=L[Q];return Q}function P(L){try{return decodeURIComponent(L)}catch{return"�"}}function V(L,O){R(typeof L=="number","cannot write a non-number as a number"),R(0<=L,"specified a negative value for writing an unsigned value"),R(L<=O,"value is larger than maximum value for type"),R(Math.floor(L)===L,"value has a fractional component")}function ee(L,O,B){R(typeof L=="number","cannot write a non-number as a number"),R(L<=O,"value larger than maximum allowed value"),R(B<=L,"value smaller than minimum allowed value"),R(Math.floor(L)===L,"value has a fractional component")}function N(L,O,B){R(typeof L=="number","cannot write a non-number as a number"),R(L<=O,"value larger than maximum allowed value"),R(B<=L,"value smaller than minimum allowed value")}function R(L,O){if(!L)throw new Error(O||"Failed assertion")}v._augment=function(L){return L._isBuffer=!0,L._get=L.get,L._set=L.set,L.get=X.get,L.set=X.set,L.write=X.write,L.toString=X.toString,L.toLocaleString=X.toString,L.toJSON=X.toJSON,L.copy=X.copy,L.slice=X.slice,L.readUInt8=X.readUInt8,L.readUInt16LE=X.readUInt16LE,L.readUInt16BE=X.readUInt16BE,L.readUInt32LE=X.readUInt32LE,L.readUInt32BE=X.readUInt32BE,L.readInt8=X.readInt8,L.readInt16LE=X.readInt16LE,L.readInt16BE=X.readInt16BE,L.readInt32LE=X.readInt32LE,L.readInt32BE=X.readInt32BE,L.readFloatLE=X.readFloatLE,L.readFloatBE=X.readFloatBE,L.readDoubleLE=X.readDoubleLE,L.readDoubleBE=X.readDoubleBE,L.writeUInt8=X.writeUInt8,L.writeUInt16LE=X.writeUInt16LE,L.writeUInt16BE=X.writeUInt16BE,L.writeUInt32LE=X.writeUInt32LE,L.writeUInt32BE=X.writeUInt32BE,L.writeInt8=X.writeInt8,L.writeInt16LE=X.writeInt16LE,L.writeInt16BE=X.writeInt16BE,L.writeInt32LE=X.writeInt32LE,L.writeInt32BE=X.writeInt32BE,L.writeFloatLE=X.writeFloatLE,L.writeFloatBE=X.writeFloatBE,L.writeDoubleLE=X.writeDoubleLE,L.writeDoubleBE=X.writeDoubleBE,L.fill=X.fill,L.inspect=X.inspect,L.toArrayBuffer=X.toArrayBuffer,L}}).call(this,t("lYpoI2"),typeof self<"u"?self:typeof window<"u"?window:{},t("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/gulp-browserify/node_modules/buffer/index.js","/node_modules/gulp-browserify/node_modules/buffer")},{"base64-js":2,buffer:3,ieee754:10,lYpoI2:11}],4:[function(t,n,r){(function(i,s,x,c,h,f,d,p,m){var x=t("buffer").Buffer,b=4,v=new x(b);v.fill(0),n.exports={hash:function(_,T,w,M){for(var D=T(function(g,I){g.length%b!=0&&(k=g.length+(b-g.length%b),g=x.concat([g,v],k));for(var k,J=[],G=I?g.readInt32BE:g.readInt32LE,Z=0;Z<g.length;Z+=b)J.push(G.call(g,Z));return J}(_=x.isBuffer(_)?_:new x(_),M),8*_.length),T=M,S=new x(w),C=T?S.writeInt32BE:S.writeInt32LE,y=0;y<D.length;y++)C.call(S,D[y],4*y,!0);return S}}}).call(this,t("lYpoI2"),typeof self<"u"?self:typeof window<"u"?window:{},t("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/gulp-browserify/node_modules/crypto-browserify/helpers.js","/node_modules/gulp-browserify/node_modules/crypto-browserify")},{buffer:3,lYpoI2:11}],5:[function(t,n,r){(function(i,s,x,c,h,f,d,p,m){var x=t("buffer").Buffer,b=t("./sha"),v=t("./sha256"),_=t("./rng"),T={sha1:b,sha256:v,md5:t("./md5")},w=64,M=new x(w);function D(g,I){var k=T[g=g||"sha1"],J=[];return k||S("algorithm:",g,"is not yet supported"),{update:function(G){return x.isBuffer(G)||(G=new x(G)),J.push(G),G.length,this},digest:function(G){var Z=x.concat(J),Z=I?function(X,K,Y){x.isBuffer(K)||(K=new x(K)),x.isBuffer(Y)||(Y=new x(Y)),K.length>w?K=X(K):K.length<w&&(K=x.concat([K,M],w));for(var te=new x(w),re=new x(w),ce=0;ce<w;ce++)te[ce]=54^K[ce],re[ce]=92^K[ce];return Y=X(x.concat([te,Y])),X(x.concat([re,Y]))}(k,I,Z):k(Z);return J=null,G?Z.toString(G):Z}}}function S(){var g=[].slice.call(arguments).join(" ");throw new Error([g,"we accept pull requests","http://github.com/dominictarr/crypto-browserify"].join(`
+`))}M.fill(0),r.createHash=function(g){return D(g)},r.createHmac=D,r.randomBytes=function(g,I){if(!I||!I.call)return new x(_(g));try{I.call(this,void 0,new x(_(g)))}catch(k){I(k)}};var C,y=["createCredentials","createCipher","createCipheriv","createDecipher","createDecipheriv","createSign","createVerify","createDiffieHellman","pbkdf2"],A=function(g){r[g]=function(){S("sorry,",g,"is not implemented yet")}};for(C in y)A(y[C])}).call(this,t("lYpoI2"),typeof self<"u"?self:typeof window<"u"?window:{},t("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/gulp-browserify/node_modules/crypto-browserify/index.js","/node_modules/gulp-browserify/node_modules/crypto-browserify")},{"./md5":6,"./rng":7,"./sha":8,"./sha256":9,buffer:3,lYpoI2:11}],6:[function(t,n,r){(function(i,s,a,c,h,f,d,p,m){var x=t("./helpers");function b(S,C){S[C>>5]|=128<<C%32,S[14+(C+64>>>9<<4)]=C;for(var y=1732584193,A=-271733879,g=-1732584194,I=271733878,k=0;k<S.length;k+=16){var J=y,G=A,Z=g,X=I,y=_(y,A,g,I,S[k+0],7,-680876936),I=_(I,y,A,g,S[k+1],12,-389564586),g=_(g,I,y,A,S[k+2],17,606105819),A=_(A,g,I,y,S[k+3],22,-1044525330);y=_(y,A,g,I,S[k+4],7,-176418897),I=_(I,y,A,g,S[k+5],12,1200080426),g=_(g,I,y,A,S[k+6],17,-1473231341),A=_(A,g,I,y,S[k+7],22,-45705983),y=_(y,A,g,I,S[k+8],7,1770035416),I=_(I,y,A,g,S[k+9],12,-1958414417),g=_(g,I,y,A,S[k+10],17,-42063),A=_(A,g,I,y,S[k+11],22,-1990404162),y=_(y,A,g,I,S[k+12],7,1804603682),I=_(I,y,A,g,S[k+13],12,-40341101),g=_(g,I,y,A,S[k+14],17,-1502002290),y=T(y,A=_(A,g,I,y,S[k+15],22,1236535329),g,I,S[k+1],5,-165796510),I=T(I,y,A,g,S[k+6],9,-1069501632),g=T(g,I,y,A,S[k+11],14,643717713),A=T(A,g,I,y,S[k+0],20,-373897302),y=T(y,A,g,I,S[k+5],5,-701558691),I=T(I,y,A,g,S[k+10],9,38016083),g=T(g,I,y,A,S[k+15],14,-660478335),A=T(A,g,I,y,S[k+4],20,-405537848),y=T(y,A,g,I,S[k+9],5,568446438),I=T(I,y,A,g,S[k+14],9,-1019803690),g=T(g,I,y,A,S[k+3],14,-187363961),A=T(A,g,I,y,S[k+8],20,1163531501),y=T(y,A,g,I,S[k+13],5,-1444681467),I=T(I,y,A,g,S[k+2],9,-51403784),g=T(g,I,y,A,S[k+7],14,1735328473),y=w(y,A=T(A,g,I,y,S[k+12],20,-1926607734),g,I,S[k+5],4,-378558),I=w(I,y,A,g,S[k+8],11,-2022574463),g=w(g,I,y,A,S[k+11],16,1839030562),A=w(A,g,I,y,S[k+14],23,-35309556),y=w(y,A,g,I,S[k+1],4,-1530992060),I=w(I,y,A,g,S[k+4],11,1272893353),g=w(g,I,y,A,S[k+7],16,-155497632),A=w(A,g,I,y,S[k+10],23,-1094730640),y=w(y,A,g,I,S[k+13],4,681279174),I=w(I,y,A,g,S[k+0],11,-358537222),g=w(g,I,y,A,S[k+3],16,-722521979),A=w(A,g,I,y,S[k+6],23,76029189),y=w(y,A,g,I,S[k+9],4,-640364487),I=w(I,y,A,g,S[k+12],11,-421815835),g=w(g,I,y,A,S[k+15],16,530742520),y=M(y,A=w(A,g,I,y,S[k+2],23,-995338651),g,I,S[k+0],6,-198630844),I=M(I,y,A,g,S[k+7],10,1126891415),g=M(g,I,y,A,S[k+14],15,-1416354905),A=M(A,g,I,y,S[k+5],21,-57434055),y=M(y,A,g,I,S[k+12],6,1700485571),I=M(I,y,A,g,S[k+3],10,-1894986606),g=M(g,I,y,A,S[k+10],15,-1051523),A=M(A,g,I,y,S[k+1],21,-2054922799),y=M(y,A,g,I,S[k+8],6,1873313359),I=M(I,y,A,g,S[k+15],10,-30611744),g=M(g,I,y,A,S[k+6],15,-1560198380),A=M(A,g,I,y,S[k+13],21,1309151649),y=M(y,A,g,I,S[k+4],6,-145523070),I=M(I,y,A,g,S[k+11],10,-1120210379),g=M(g,I,y,A,S[k+2],15,718787259),A=M(A,g,I,y,S[k+9],21,-343485551),y=D(y,J),A=D(A,G),g=D(g,Z),I=D(I,X)}return Array(y,A,g,I)}function v(S,C,y,A,g,I){return D((C=D(D(C,S),D(A,I)))<<g|C>>>32-g,y)}function _(S,C,y,A,g,I,k){return v(C&y|~C&A,S,C,g,I,k)}function T(S,C,y,A,g,I,k){return v(C&A|y&~A,S,C,g,I,k)}function w(S,C,y,A,g,I,k){return v(C^y^A,S,C,g,I,k)}function M(S,C,y,A,g,I,k){return v(y^(C|~A),S,C,g,I,k)}function D(S,C){var y=(65535&S)+(65535&C);return(S>>16)+(C>>16)+(y>>16)<<16|65535&y}n.exports=function(S){return x.hash(S,b,16)}}).call(this,t("lYpoI2"),typeof self<"u"?self:typeof window<"u"?window:{},t("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/gulp-browserify/node_modules/crypto-browserify/md5.js","/node_modules/gulp-browserify/node_modules/crypto-browserify")},{"./helpers":4,buffer:3,lYpoI2:11}],7:[function(t,n,r){(function(i,s,a,c,h,f,d,p,m){n.exports=function(x){for(var b,v=new Array(x),_=0;_<x;_++)!(3&_)&&(b=4294967296*Math.random()),v[_]=b>>>((3&_)<<3)&255;return v}}).call(this,t("lYpoI2"),typeof self<"u"?self:typeof window<"u"?window:{},t("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/gulp-browserify/node_modules/crypto-browserify/rng.js","/node_modules/gulp-browserify/node_modules/crypto-browserify")},{buffer:3,lYpoI2:11}],8:[function(t,n,r){(function(i,s,a,c,h,f,d,p,m){var x=t("./helpers");function b(T,w){T[w>>5]|=128<<24-w%32,T[15+(w+64>>9<<4)]=w;for(var M,D,S,C=Array(80),y=1732584193,A=-271733879,g=-1732584194,I=271733878,k=-1009589776,J=0;J<T.length;J+=16){for(var G=y,Z=A,X=g,K=I,Y=k,te=0;te<80;te++){C[te]=te<16?T[J+te]:_(C[te-3]^C[te-8]^C[te-14]^C[te-16],1);var re=v(v(_(y,5),(re=A,D=g,S=I,(M=te)<20?re&D|~re&S:!(M<40)&&M<60?re&D|re&S|D&S:re^D^S)),v(v(k,C[te]),(M=te)<20?1518500249:M<40?1859775393:M<60?-1894007588:-899497514)),k=I,I=g,g=_(A,30),A=y,y=re}y=v(y,G),A=v(A,Z),g=v(g,X),I=v(I,K),k=v(k,Y)}return Array(y,A,g,I,k)}function v(T,w){var M=(65535&T)+(65535&w);return(T>>16)+(w>>16)+(M>>16)<<16|65535&M}function _(T,w){return T<<w|T>>>32-w}n.exports=function(T){return x.hash(T,b,20,!0)}}).call(this,t("lYpoI2"),typeof self<"u"?self:typeof window<"u"?window:{},t("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/gulp-browserify/node_modules/crypto-browserify/sha.js","/node_modules/gulp-browserify/node_modules/crypto-browserify")},{"./helpers":4,buffer:3,lYpoI2:11}],9:[function(t,n,r){(function(i,s,a,c,h,f,d,p,m){function x(w,M){var D=(65535&w)+(65535&M);return(w>>16)+(M>>16)+(D>>16)<<16|65535&D}function b(w,M){var D,S=new Array(1116352408,1899447441,3049323471,3921009573,961987163,1508970993,2453635748,2870763221,3624381080,310598401,607225278,1426881987,1925078388,2162078206,2614888103,3248222580,3835390401,4022224774,264347078,604807628,770255983,1249150122,1555081692,1996064986,2554220882,2821834349,2952996808,3210313671,3336571891,3584528711,113926993,338241895,666307205,773529912,1294757372,1396182291,1695183700,1986661051,2177026350,2456956037,2730485921,2820302411,3259730800,3345764771,3516065817,3600352804,4094571909,275423344,430227734,506948616,659060556,883997877,958139571,1322822218,1537002063,1747873779,1955562222,2024104815,2227730452,2361852424,2428436474,2756734187,3204031479,3329325298),C=new Array(1779033703,3144134277,1013904242,2773480762,1359893119,2600822924,528734635,1541459225),y=new Array(64);w[M>>5]|=128<<24-M%32,w[15+(M+64>>9<<4)]=M;for(var A,g,I=0;I<w.length;I+=16){for(var k=C[0],J=C[1],G=C[2],Z=C[3],X=C[4],K=C[5],Y=C[6],te=C[7],re=0;re<64;re++)y[re]=re<16?w[re+I]:x(x(x((g=y[re-2],_(g,17)^_(g,19)^T(g,10)),y[re-7]),(g=y[re-15],_(g,7)^_(g,18)^T(g,3))),y[re-16]),D=x(x(x(x(te,_(g=X,6)^_(g,11)^_(g,25)),X&K^~X&Y),S[re]),y[re]),A=x(_(A=k,2)^_(A,13)^_(A,22),k&J^k&G^J&G),te=Y,Y=K,K=X,X=x(Z,D),Z=G,G=J,J=k,k=x(D,A);C[0]=x(k,C[0]),C[1]=x(J,C[1]),C[2]=x(G,C[2]),C[3]=x(Z,C[3]),C[4]=x(X,C[4]),C[5]=x(K,C[5]),C[6]=x(Y,C[6]),C[7]=x(te,C[7])}return C}var v=t("./helpers"),_=function(w,M){return w>>>M|w<<32-M},T=function(w,M){return w>>>M};n.exports=function(w){return v.hash(w,b,32,!0)}}).call(this,t("lYpoI2"),typeof self<"u"?self:typeof window<"u"?window:{},t("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/gulp-browserify/node_modules/crypto-browserify/sha256.js","/node_modules/gulp-browserify/node_modules/crypto-browserify")},{"./helpers":4,buffer:3,lYpoI2:11}],10:[function(t,n,r){(function(i,s,a,c,h,f,d,p,m){r.read=function(x,b,v,_,I){var w,M,D=8*I-_-1,S=(1<<D)-1,C=S>>1,y=-7,A=v?I-1:0,g=v?-1:1,I=x[b+A];for(A+=g,w=I&(1<<-y)-1,I>>=-y,y+=D;0<y;w=256*w+x[b+A],A+=g,y-=8);for(M=w&(1<<-y)-1,w>>=-y,y+=_;0<y;M=256*M+x[b+A],A+=g,y-=8);if(w===0)w=1-C;else{if(w===S)return M?NaN:1/0*(I?-1:1);M+=Math.pow(2,_),w-=C}return(I?-1:1)*M*Math.pow(2,w-_)},r.write=function(x,b,v,_,T,k){var M,D,S=8*k-T-1,C=(1<<S)-1,y=C>>1,A=T===23?Math.pow(2,-24)-Math.pow(2,-77):0,g=_?0:k-1,I=_?1:-1,k=b<0||b===0&&1/b<0?1:0;for(b=Math.abs(b),isNaN(b)||b===1/0?(D=isNaN(b)?1:0,M=C):(M=Math.floor(Math.log(b)/Math.LN2),b*(_=Math.pow(2,-M))<1&&(M--,_*=2),2<=(b+=1<=M+y?A/_:A*Math.pow(2,1-y))*_&&(M++,_/=2),C<=M+y?(D=0,M=C):1<=M+y?(D=(b*_-1)*Math.pow(2,T),M+=y):(D=b*Math.pow(2,y-1)*Math.pow(2,T),M=0));8<=T;x[v+g]=255&D,g+=I,D/=256,T-=8);for(M=M<<T|D,S+=T;0<S;x[v+g]=255&M,g+=I,M/=256,S-=8);x[v+g-I]|=128*k}}).call(this,t("lYpoI2"),typeof self<"u"?self:typeof window<"u"?window:{},t("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/gulp-browserify/node_modules/ieee754/index.js","/node_modules/gulp-browserify/node_modules/ieee754")},{buffer:3,lYpoI2:11}],11:[function(t,n,r){(function(i,s,a,c,h,f,d,p,m){var x,b,v;function _(){}(i=n.exports={}).nextTick=(b=typeof window<"u"&&window.setImmediate,v=typeof window<"u"&&window.postMessage&&window.addEventListener,b?function(T){return window.setImmediate(T)}:v?(x=[],window.addEventListener("message",function(T){var w=T.source;w!==window&&w!==null||T.data!=="process-tick"||(T.stopPropagation(),0<x.length&&x.shift()())},!0),function(T){x.push(T),window.postMessage("process-tick","*")}):function(T){setTimeout(T,0)}),i.title="browser",i.browser=!0,i.env={},i.argv=[],i.on=_,i.addListener=_,i.once=_,i.off=_,i.removeListener=_,i.removeAllListeners=_,i.emit=_,i.binding=function(T){throw new Error("process.binding is not supported")},i.cwd=function(){return"/"},i.chdir=function(T){throw new Error("process.chdir is not supported")}}).call(this,t("lYpoI2"),typeof self<"u"?self:typeof window<"u"?window:{},t("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/gulp-browserify/node_modules/process/browser.js","/node_modules/gulp-browserify/node_modules/process")},{buffer:3,lYpoI2:11}]},{},[1])(1)})})(cs);var kc=cs.exports;const Bc=on(kc);var us=["precision","highp","mediump","lowp","attribute","const","uniform","varying","break","continue","do","for","while","if","else","in","out","inout","float","int","uint","void","bool","true","false","discard","return","mat2","mat3","mat4","vec2","vec3","vec4","ivec2","ivec3","ivec4","bvec2","bvec3","bvec4","sampler1D","sampler2D","sampler3D","samplerCube","sampler1DShadow","sampler2DShadow","struct","asm","class","union","enum","typedef","template","this","packed","goto","switch","default","inline","noinline","volatile","public","static","extern","external","interface","long","short","double","half","fixed","unsigned","input","output","hvec2","hvec3","hvec4","dvec2","dvec3","dvec4","fvec2","fvec3","fvec4","sampler2DRect","sampler3DRect","sampler2DRectShadow","sizeof","cast","namespace","using"],Fc=["<<=",">>=","++","--","<<",">>","<=",">=","==","!=","&&","||","+=","-=","*=","/=","%=","&=","^^","^=","|=","(",")","[","]",".","!","~","*","/","%","+","-","<",">","&","^","|","?",":","=",",",";","{","}"],hs=["abs","acos","all","any","asin","atan","ceil","clamp","cos","cross","dFdx","dFdy","degrees","distance","dot","equal","exp","exp2","faceforward","floor","fract","gl_BackColor","gl_BackLightModelProduct","gl_BackLightProduct","gl_BackMaterial","gl_BackSecondaryColor","gl_ClipPlane","gl_ClipVertex","gl_Color","gl_DepthRange","gl_DepthRangeParameters","gl_EyePlaneQ","gl_EyePlaneR","gl_EyePlaneS","gl_EyePlaneT","gl_Fog","gl_FogCoord","gl_FogFragCoord","gl_FogParameters","gl_FragColor","gl_FragCoord","gl_FragData","gl_FragDepth","gl_FragDepthEXT","gl_FrontColor","gl_FrontFacing","gl_FrontLightModelProduct","gl_FrontLightProduct","gl_FrontMaterial","gl_FrontSecondaryColor","gl_LightModel","gl_LightModelParameters","gl_LightModelProducts","gl_LightProducts","gl_LightSource","gl_LightSourceParameters","gl_MaterialParameters","gl_MaxClipPlanes","gl_MaxCombinedTextureImageUnits","gl_MaxDrawBuffers","gl_MaxFragmentUniformComponents","gl_MaxLights","gl_MaxTextureCoords","gl_MaxTextureImageUnits","gl_MaxTextureUnits","gl_MaxVaryingFloats","gl_MaxVertexAttribs","gl_MaxVertexTextureImageUnits","gl_MaxVertexUniformComponents","gl_ModelViewMatrix","gl_ModelViewMatrixInverse","gl_ModelViewMatrixInverseTranspose","gl_ModelViewMatrixTranspose","gl_ModelViewProjectionMatrix","gl_ModelViewProjectionMatrixInverse","gl_ModelViewProjectionMatrixInverseTranspose","gl_ModelViewProjectionMatrixTranspose","gl_MultiTexCoord0","gl_MultiTexCoord1","gl_MultiTexCoord2","gl_MultiTexCoord3","gl_MultiTexCoord4","gl_MultiTexCoord5","gl_MultiTexCoord6","gl_MultiTexCoord7","gl_Normal","gl_NormalMatrix","gl_NormalScale","gl_ObjectPlaneQ","gl_ObjectPlaneR","gl_ObjectPlaneS","gl_ObjectPlaneT","gl_Point","gl_PointCoord","gl_PointParameters","gl_PointSize","gl_Position","gl_ProjectionMatrix","gl_ProjectionMatrixInverse","gl_ProjectionMatrixInverseTranspose","gl_ProjectionMatrixTranspose","gl_SecondaryColor","gl_TexCoord","gl_TextureEnvColor","gl_TextureMatrix","gl_TextureMatrixInverse","gl_TextureMatrixInverseTranspose","gl_TextureMatrixTranspose","gl_Vertex","greaterThan","greaterThanEqual","inversesqrt","length","lessThan","lessThanEqual","log","log2","matrixCompMult","max","min","mix","mod","normalize","not","notEqual","pow","radians","reflect","refract","sign","sin","smoothstep","sqrt","step","tan","texture2D","texture2DLod","texture2DProj","texture2DProjLod","textureCube","textureCubeLod","texture2DLodEXT","texture2DProjLodEXT","textureCubeLodEXT","texture2DGradEXT","texture2DProjGradEXT","textureCubeGradEXT"],Uc=us,Nc=Uc.slice().concat(["layout","centroid","smooth","case","mat2x2","mat2x3","mat2x4","mat3x2","mat3x3","mat3x4","mat4x2","mat4x3","mat4x4","uvec2","uvec3","uvec4","samplerCubeShadow","sampler2DArray","sampler2DArrayShadow","isampler2D","isampler3D","isamplerCube","isampler2DArray","usampler2D","usampler3D","usamplerCube","usampler2DArray","coherent","restrict","readonly","writeonly","resource","atomic_uint","noperspective","patch","sample","subroutine","common","partition","active","filter","image1D","image2D","image3D","imageCube","iimage1D","iimage2D","iimage3D","iimageCube","uimage1D","uimage2D","uimage3D","uimageCube","image1DArray","image2DArray","iimage1DArray","iimage2DArray","uimage1DArray","uimage2DArray","image1DShadow","image2DShadow","image1DArrayShadow","image2DArrayShadow","imageBuffer","iimageBuffer","uimageBuffer","sampler1DArray","sampler1DArrayShadow","isampler1D","isampler1DArray","usampler1D","usampler1DArray","isampler2DRect","usampler2DRect","samplerBuffer","isamplerBuffer","usamplerBuffer","sampler2DMS","isampler2DMS","usampler2DMS","sampler2DMSArray","isampler2DMSArray","usampler2DMSArray"]),Ar=hs;Ar=Ar.slice().filter(function(o){return!/^(gl\_|texture)/.test(o)});var zc=Ar.concat(["gl_VertexID","gl_InstanceID","gl_Position","gl_PointSize","gl_FragCoord","gl_FrontFacing","gl_FragDepth","gl_PointCoord","gl_MaxVertexAttribs","gl_MaxVertexUniformVectors","gl_MaxVertexOutputVectors","gl_MaxFragmentInputVectors","gl_MaxVertexTextureImageUnits","gl_MaxCombinedTextureImageUnits","gl_MaxTextureImageUnits","gl_MaxFragmentUniformVectors","gl_MaxDrawBuffers","gl_MinProgramTexelOffset","gl_MaxProgramTexelOffset","gl_DepthRangeParameters","gl_DepthRange","trunc","round","roundEven","isnan","isinf","floatBitsToInt","floatBitsToUint","intBitsToFloat","uintBitsToFloat","packSnorm2x16","unpackSnorm2x16","packUnorm2x16","unpackUnorm2x16","packHalf2x16","unpackHalf2x16","outerProduct","transpose","determinant","inverse","texture","textureSize","textureProj","textureLod","textureOffset","texelFetch","texelFetchOffset","textureProjOffset","textureLodOffset","textureProjLod","textureProjLodOffset","textureGrad","textureGradOffset","textureProjGrad","textureProjGradOffset"]),Vc=qc,Rc=us,fs=Fc,Gc=hs,jc=Nc,Ec=zc,$e=999,ds=9999,Cr=0,Pr=1,ps=2,ms=3,gs=4,an=5,Wc=6,Yc=7,Xc=8,ys=9,Zc=10,vs=11,Kc=["block-comment","line-comment","preprocessor","operator","integer","float","ident","builtin","keyword","whitespace","eof","integer"];function qc(o){var e=0,t=0,n=$e,r,i,s=[],a=[],c=1,h=0,f=0,d=!1,p=!1,m="",x;o=o||{};var b=Gc,v=Rc;o.version==="300 es"&&(b=Ec,v=jc);for(var _={},T={},e=0;e<b.length;e++)_[b[e]]=!0;for(var e=0;e<v.length;e++)T[v[e]]=!0;return function(K){return a=[],K!==null?M(K):D()};function w(K){K.length&&a.push({type:Kc[n],data:K,position:f,line:c,column:h})}function M(K){e=0,K.toString&&(K=K.toString()),m+=K.replace(/\r\n/g,`
+`),x=m.length;for(var Y;r=m[e],e<x;){switch(Y=e,n){case Cr:e=g();break;case Pr:e=A();break;case ps:e=y();break;case ms:e=I();break;case gs:e=G();break;case vs:e=J();break;case an:e=Z();break;case ds:e=X();break;case ys:e=C();break;case $e:e=S();break}if(Y!==e)switch(m[Y]){case`
+`:h=0,++c;break;default:++h;break}}return t+=e,m=m.slice(e),a}function D(K){return s.length&&w(s.join("")),n=Zc,w("(eof)"),a}function S(){return s=s.length?[]:s,i==="/"&&r==="*"?(f=t+e-1,n=Cr,i=r,e+1):i==="/"&&r==="/"?(f=t+e-1,n=Pr,i=r,e+1):r==="#"?(n=ps,f=t+e,e):/\s/.test(r)?(n=ys,f=t+e,e):(d=/\d/.test(r),p=/[^\w_]/.test(r),f=t+e,n=d?gs:p?ms:ds,e)}function C(){return/[^\s]/g.test(r)?(w(s.join("")),n=$e,e):(s.push(r),i=r,e+1)}function y(){return(r==="\r"||r===`
+`)&&i!=="\\"?(w(s.join("")),n=$e,e):(s.push(r),i=r,e+1)}function A(){return y()}function g(){return r==="/"&&i==="*"?(s.push(r),w(s.join("")),n=$e,e+1):(s.push(r),i=r,e+1)}function I(){if(i==="."&&/\d/.test(r))return n=an,e;if(i==="/"&&r==="*")return n=Cr,e;if(i==="/"&&r==="/")return n=Pr,e;if(r==="."&&s.length){for(;k(s););return n=an,e}if(r===";"||r===")"||r==="("){if(s.length)for(;k(s););return w(r),n=$e,e+1}var K=s.length===2&&r!=="=";if(/[\w_\d\s]/.test(r)||K){for(;k(s););return n=$e,e}return s.push(r),i=r,e+1}function k(K){var Y=0,te,re;do{if(te=fs.indexOf(K.slice(0,K.length+Y).join("")),re=fs[te],te===-1){if(Y--+K.length>0)continue;re=K.slice(0,1).join("")}return w(re),f+=re.length,s=s.slice(re.length),s.length}while(!0)}function J(){return/[^a-fA-F0-9]/.test(r)?(w(s.join("")),n=$e,e):(s.push(r),i=r,e+1)}function G(){return r==="."||/[eE]/.test(r)?(s.push(r),n=an,i=r,e+1):r==="x"&&s.length===1&&s[0]==="0"?(n=vs,s.push(r),i=r,e+1):/[^\d]/.test(r)?(w(s.join("")),n=$e,e):(s.push(r),i=r,e+1)}function Z(){return r==="f"&&(s.push(r),i=r,e+=1),/[eE]/.test(r)||(r==="-"||r==="+")&&/[eE]/.test(i)?(s.push(r),i=r,e+1):/[^\d]/.test(r)?(w(s.join("")),n=$e,e):(s.push(r),i=r,e+1)}function X(){if(/[^\d\w_]/.test(r)){var K=s.join("");return T[K]?n=Xc:_[K]?n=Yc:n=Wc,w(s.join("")),n=$e,e}return s.push(r),i=r,e+1}}var Qc=Vc,Jc=Hc;function Hc(o,e){var t=Qc(e),n=[];return n=n.concat(t(o)),n=n.concat(t(null)),n}const $c=on(Jc);var eu=tu;function tu(o){for(var e=[],t=0;t<o.length;t++)o[t].type!=="eof"&&e.push(o[t].data);return e.join("")}const _s=on(eu);var nu=ru;function ru(o){var e=null,t=null,n=0,r=0,i=0,s=0,a=0,c=[],h,f,d;for(h=0,f;h<o.length;h++)if(d=o[h],d.data==="{"){if(n&&n++||(f=m(h,xt(")"),xt()),f<0)||(s=f,f=m(f,xt("("),xt(")")),f<0)||(a=f,f=m(f,ln),f<0)||o[f].type!=="ident"||(t=o[f].data,f=m(f,ln),f<0))continue;n=1,r=h,e=o[f].data,i=f;var p=m(f,ln);switch(o[p]&&o[p].data){case"lowp":case"highp":case"mediump":i=p}}else if(n&&d.data==="}"){if(--n)continue;c.push({name:t,type:e,body:[r+1,h],args:[a,s+1],outer:[i,h+1]})}for(h=0;h<o.length;h++)if(d=o[h],d.data===";"){if(f=m(h,xt(")"),xt()),f<0||(s=f,f=m(f,xt("("),xt(")")),f<0)||(a=f,f=m(f,ln),f<0)||o[f].type!=="ident"||(t=o[f].data,f=m(f,ln),f<0)||o[f].type==="operator"||o[f].data==="return")continue;e=o[f].data,c.push({name:t,type:e,body:!1,args:[a,s+1],outer:[f,h+1]})}return c.sort(function(x,b){return x.outer[0]-b.outer[0]});function m(x,b,v){for(var _=x-1;_>=0;_--){if(b(o[_]))return _;if(v&&v(o[_]))return-1}return-1}}function xt(o){return function(e){return e.type==="operator"&&(!o||e.data===o)}}function ln(o){return o.type!=="whitespace"}const iu=on(nu);function su(o,e){if(typeof o!="object"||o===null)return o;var t=o[Symbol.toPrimitive];if(t!==void 0){var n=t.call(o,e||"default");if(typeof n!="object")return n;throw new TypeError("@@toPrimitive must return a primitive value.")}return(e==="string"?String:Number)(o)}function xs(o){var e=su(o,"string");return typeof e=="symbol"?e:String(e)}function Ae(o,e,t){return e=xs(e),e in o?Object.defineProperty(o,e,{value:t,enumerable:!0,configurable:!0,writable:!0}):o[e]=t,o}function ws(o,e){var t=Object.keys(o);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(o);e&&(n=n.filter(function(r){return Object.getOwnPropertyDescriptor(o,r).enumerable})),t.push.apply(t,n)}return t}function zt(o){for(var e=1;e<arguments.length;e++){var t=arguments[e]!=null?arguments[e]:{};e%2?ws(Object(t),!0).forEach(function(n){Ae(o,n,t[n])}):Object.getOwnPropertyDescriptors?Object.defineProperties(o,Object.getOwnPropertyDescriptors(t)):ws(Object(t)).forEach(function(n){Object.defineProperty(o,n,Object.getOwnPropertyDescriptor(t,n))})}return o}function ou(o,e){if(o==null)return{};var t={},n=Object.keys(o),r,i;for(i=0;i<n.length;i++)r=n[i],!(e.indexOf(r)>=0)&&(t[r]=o[r]);return t}function au(o,e){if(o==null)return{};var t=ou(o,e),n,r;if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(o);for(r=0;r<i.length;r++)n=i[r],!(e.indexOf(n)>=0)&&Object.prototype.propertyIsEnumerable.call(o,n)&&(t[n]=o[n])}return t}function lu(o,e){if(!(o instanceof e))throw new TypeError("Cannot call a class as a function")}function bs(o,e){for(var t=0;t<e.length;t++){var n=e[t];n.enumerable=n.enumerable||!1,n.configurable=!0,"value"in n&&(n.writable=!0),Object.defineProperty(o,xs(n.key),n)}}function cu(o,e,t){return e&&bs(o.prototype,e),t&&bs(o,t),Object.defineProperty(o,"prototype",{writable:!1}),o}function Ms(o){if(o===void 0)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return o}function Tr(o,e){return Tr=Object.setPrototypeOf?Object.setPrototypeOf.bind():function(n,r){return n.__proto__=r,n},Tr(o,e)}function uu(o,e){if(typeof e!="function"&&e!==null)throw new TypeError("Super expression must either be null or a function");o.prototype=Object.create(e&&e.prototype,{constructor:{value:o,writable:!0,configurable:!0}}),Object.defineProperty(o,"prototype",{writable:!1}),e&&Tr(o,e)}function On(o){return On=Object.setPrototypeOf?Object.getPrototypeOf.bind():function(t){return t.__proto__||Object.getPrototypeOf(t)},On(o)}function hu(){if(typeof Reflect>"u"||!Reflect.construct||Reflect.construct.sham)return!1;if(typeof Proxy=="function")return!0;try{return Boolean.prototype.valueOf.call(Reflect.construct(Boolean,[],function(){})),!0}catch{return!1}}function fu(o,e){if(e&&(typeof e=="object"||typeof e=="function"))return e;if(e!==void 0)throw new TypeError("Derived constructors may only return object or undefined");return Ms(o)}function du(o){var e=hu();return function(){var n=On(o),r;if(e){var i=On(this).constructor;r=Reflect.construct(n,arguments,i)}else r=n.apply(this,arguments);return fu(this,r)}}var de={position:"csm_Position",positionRaw:"csm_PositionRaw",pointSize:"csm_PointSize",fragColor:"csm_FragColor",diffuseColor:"csm_DiffuseColor",normal:"csm_Normal",roughness:"csm_Roughness",metalness:"csm_Metalness",emissive:"csm_Emissive",ao:"csm_AO",bump:"csm_Bump",depthAlpha:"csm_DepthAlpha"},Ge,Vt,pu=(Ge={},Ae(Ge,"".concat(de.normal),{"#include <beginnormal_vertex>":`
+    vec3 objectNormal = `.concat(de.normal,`;
     #ifdef USE_TANGENT
 	    vec3 objectTangent = vec3( tangent.xyz );
     #endif
-    `)}),Pe(Ge,"".concat(pe.position),{"#include <begin_vertex>":`
-    vec3 transformed = `.concat(pe.position,`;
-  `)}),Pe(Ge,"".concat(pe.positionRaw),{"#include <begin_vertex>":`
-    vec4 csm_internal_positionUnprojected = `.concat(pe.positionRaw,`;
+    `)}),Ae(Ge,"".concat(de.position),{"#include <begin_vertex>":`
+    vec3 transformed = `.concat(de.position,`;
+  `)}),Ae(Ge,"".concat(de.positionRaw),{"#include <begin_vertex>":`
+    vec4 csm_internal_positionUnprojected = `.concat(de.positionRaw,`;
     mat4x4 csm_internal_unprojectMatrix = projectionMatrix * modelViewMatrix;
     #ifdef USE_INSTANCING
       csm_internal_unprojectMatrix = csm_internal_unprojectMatrix * instanceMatrix;
     #endif
     csm_internal_positionUnprojected = inverse(csm_internal_unprojectMatrix) * csm_internal_positionUnprojected;
     vec3 transformed = csm_internal_positionUnprojected.xyz;
-  `)}),Pe(Ge,"".concat(pe.pointSize),{"gl_PointSize = size;":`
-    gl_PointSize = `.concat(pe.pointSize,`;
-    `)}),Pe(Ge,"".concat(pe.diffuseColor),{"#include <color_fragment>":`
+  `)}),Ae(Ge,"".concat(de.pointSize),{"gl_PointSize = size;":`
+    gl_PointSize = `.concat(de.pointSize,`;
+    `)}),Ae(Ge,"".concat(de.diffuseColor),{"#include <color_fragment>":`
     #include <color_fragment>
-    diffuseColor = `.concat(pe.diffuseColor,`;
-  `)}),Pe(Ge,"".concat(pe.fragColor),{"#include <dithering_fragment>":`
+    diffuseColor = `.concat(de.diffuseColor,`;
+  `)}),Ae(Ge,"".concat(de.fragColor),{"#include <dithering_fragment>":`
     #include <dithering_fragment>
-    gl_FragColor  = `.concat(pe.fragColor,`;
-  `)}),Pe(Ge,"".concat(pe.emissive),{"vec3 totalEmissiveRadiance = emissive;":`
-    vec3 totalEmissiveRadiance = `.concat(pe.emissive,`;
-    `)}),Pe(Ge,"".concat(pe.roughness),{"#include <roughnessmap_fragment>":`
+    gl_FragColor  = `.concat(de.fragColor,`;
+  `)}),Ae(Ge,"".concat(de.emissive),{"vec3 totalEmissiveRadiance = emissive;":`
+    vec3 totalEmissiveRadiance = `.concat(de.emissive,`;
+    `)}),Ae(Ge,"".concat(de.roughness),{"#include <roughnessmap_fragment>":`
     #include <roughnessmap_fragment>
-    roughnessFactor = `.concat(pe.roughness,`;
-    `)}),Pe(Ge,"".concat(pe.metalness),{"#include <metalnessmap_fragment>":`
+    roughnessFactor = `.concat(de.roughness,`;
+    `)}),Ae(Ge,"".concat(de.metalness),{"#include <metalnessmap_fragment>":`
     #include <metalnessmap_fragment>
-    metalnessFactor = `.concat(pe.metalness,`;
-    `)}),Pe(Ge,"".concat(pe.ao),{"#include <aomap_fragment>":`
+    metalnessFactor = `.concat(de.metalness,`;
+    `)}),Ae(Ge,"".concat(de.ao),{"#include <aomap_fragment>":`
     #include <aomap_fragment>
-    reflectedLight.indirectDiffuse *= 1. - `.concat(pe.ao,`;
-    `)}),Pe(Ge,"".concat(pe.bump),{"#include <normal_fragment_maps>":`
+    reflectedLight.indirectDiffuse *= 1. - `.concat(de.ao,`;
+    `)}),Ae(Ge,"".concat(de.bump),{"#include <normal_fragment_maps>":`
     #include <normal_fragment_maps>
 
-    vec3 csm_internal_orthogonal = `.concat(pe.bump," - (dot(").concat(pe.bump,`, normal) * normal);
+    vec3 csm_internal_orthogonal = `.concat(de.bump," - (dot(").concat(de.bump,`, normal) * normal);
     vec3 csm_internal_projectedbump = mat3(csm_internal_vModelViewMatrix) * csm_internal_orthogonal;
     normal = normalize(normal - csm_internal_projectedbump);
-    `)}),Pe(Ge,"".concat(pe.depthAlpha),{"gl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );":`
-      gl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity * `.concat(pe.depthAlpha,` );
+    `)}),Ae(Ge,"".concat(de.depthAlpha),{"gl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );":`
+      gl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity * `.concat(de.depthAlpha,` );
     `),"gl_FragColor = packDepthToRGBA( fragCoordZ );":`
       gl_FragColor = packDepthToRGBA( fragCoordZ );
-      gl_FragColor.a *= `.concat(pe.depthAlpha,`;
-    `)}),Ge),fu=(zt={},Pe(zt,"".concat(pe.position),{"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );":`
-    gl_Position = projectionMatrix * modelViewMatrix * vec4( `.concat(pe.position,`, 1.0 );
-  `)}),Pe(zt,"".concat(pe.positionRaw),{"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );":`
-    gl_Position = `.concat(pe.position,`;
-  `)}),Pe(zt,"".concat(pe.diffuseColor),{"gl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );":`
-    gl_FragColor = `.concat(pe.diffuseColor,`;
-  `)}),Pe(zt,"".concat(pe.fragColor),{"gl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );":`
-    gl_FragColor = `.concat(pe.fragColor,`;
-  `)}),zt),du=`
+      gl_FragColor.a *= `.concat(de.depthAlpha,`;
+    `)}),Ge),mu=(Vt={},Ae(Vt,"".concat(de.position),{"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );":`
+    gl_Position = projectionMatrix * modelViewMatrix * vec4( `.concat(de.position,`, 1.0 );
+  `)}),Ae(Vt,"".concat(de.positionRaw),{"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );":`
+    gl_Position = `.concat(de.position,`;
+  `)}),Ae(Vt,"".concat(de.diffuseColor),{"gl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );":`
+    gl_FragColor = `.concat(de.diffuseColor,`;
+  `)}),Ae(Vt,"".concat(de.fragColor),{"gl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );":`
+    gl_FragColor = `.concat(de.fragColor,`;
+  `)}),Vt),gu=`
 
 #ifdef IS_VERTEX
     // csm_Position & csm_PositionRaw
@@ -378,46 +378,46 @@ list should be an Array.`),T.length===0)return new v(0);if(T.length===1)return T
 
     float csm_DepthAlpha = 1.0;
 #endif
-`,pu=`
+`,yu=`
     varying mat4 csm_internal_vModelViewMatrix;
-`,mu=`
+`,vu=`
     csm_internal_vModelViewMatrix = modelViewMatrix;
-`,gu=`
+`,_u=`
     varying mat4 csm_internal_vModelViewMatrix;
-`,yu=`
+`,xu=`
     
-`,je,_u=(je={},Pe(je,"".concat(pe.position),"*"),Pe(je,"".concat(pe.positionRaw),"*"),Pe(je,"".concat(pe.normal),"*"),Pe(je,"".concat(pe.pointSize),["PointsMaterial"]),Pe(je,"".concat(pe.diffuseColor),"*"),Pe(je,"".concat(pe.fragColor),"*"),Pe(je,"".concat(pe.emissive),["MeshStandardMaterial","MeshPhysicalMaterial"]),Pe(je,"".concat(pe.roughness),["MeshStandardMaterial","MeshPhysicalMaterial"]),Pe(je,"".concat(pe.metalness),["MeshStandardMaterial","MeshPhysicalMaterial"]),Pe(je,"".concat(pe.ao),["MeshStandardMaterial","MeshPhysicalMaterial","MeshBasicMaterial","MeshLambertMaterial","MeshPhongMaterial","MeshToonMaterial"]),Pe(je,"".concat(pe.bump),["MeshLambertMaterial","MeshMatcapMaterial","MeshNormalMaterial","MeshPhongMaterial","MeshPhysicalMaterial","MeshStandardMaterial","MeshToonMaterial","ShadowMaterial"]),Pe(je,"".concat(pe.depthAlpha),"*"),je),vu=["baseMaterial","fragmentShader","vertexShader","uniforms","patchMap","cacheKey","silent"],xu=function(e,t,n){return e.split(t).join(n)},wu=function(e){return e.replace(/[-\/\\^$*+?.()|[\]{}]/g,"\\$&")},bu=function(e,t){return new RegExp("\\b".concat(wu(t),"\\b")).test(e)};function Mu(o){try{new o}catch(e){if(e.message.indexOf("is not a constructor")>=0)return!1}return!0}function Su(o,e){var t=arguments.length>2&&arguments[2]!==void 0?arguments[2]:!1;Object.assign(o,e);var n=Object.getPrototypeOf(e);Object.entries(Object.getOwnPropertyDescriptors(n)).filter(function(s){var r=typeof s[1].get=="function",i=typeof s[1].set=="function",a=typeof s[1].value=="function",l=s[0]==="constructor";return(r||i||a)&&!l}).forEach(function(s){if(typeof o[s[0]]=="function"){t||console.warn("Function ".concat(s[0]," already exists on CSM, renaming to base_").concat(s[0]));var r="base_".concat(s[0]);o[r]=s[1].value.bind(o);return}Object.defineProperty(o,s[0],s[1])})}function Au(o){var e=o.toString().trim(),t=e.substring(e.indexOf("{")+1,e.lastIndexOf("}"));return t.trim().length===0}function wi(o){return o.replace(/\s/g,"")}function Pu(o,e,t){var n=o.lastIndexOf(e);return n===-1?o:o.substring(0,n)+t+o.substring(n+e.length)}var Cu=function(o){au(t,o);var e=uu(t);function t(n){var s,r=n.baseMaterial,i=n.fragmentShader,a=n.vertexShader,l=n.uniforms,u=n.patchMap,h=n.cacheKey,d=n.silent,y=ru(n,vu);iu(this,t);var g;if(Mu(r)?g=new r(y):(g=r,Object.assign(g,y)),g.type==="RawShaderMaterial")throw new Error("CustomShaderMaterial does not support RawShaderMaterial");s=e.call(this),Su(xi(s),g,d),s.__csm={patchMap:u||{},fragmentShader:i||"",vertexShader:a||"",cacheKey:h,baseMaterial:r,instanceID:Ns.MathUtils.generateUUID(),type:g.type,isAlreadyExtended:!Au(g.onBeforeCompile),cacheHash:"",silent:d},s.uniforms=Nt(Nt({},s.uniforms||{}),l||{});{var x=s.__csm,w=x.fragmentShader,v=x.vertexShader,P=s.uniforms;s.__csm.cacheHash=s.getCacheHash(),s.generateMaterial(w,v,P)}return s}return ou(t,[{key:"update",value:function(){var s=arguments.length>0&&arguments[0]!==void 0?arguments[0]:{};this.uniforms=s.uniforms||this.uniforms,Object.assign(this.__csm,s);var r=this.__csm,i=r.fragmentShader,a=r.vertexShader,l=this.uniforms,u=this.getCacheHash();this.__csm.cacheHash=u,this.generateMaterial(i,a,l)}},{key:"clone",value:function(){var s={baseMaterial:this.__csm.baseMaterial,fragmentShader:this.__csm.fragmentShader,vertexShader:this.__csm.vertexShader,uniforms:this.uniforms,silent:this.__csm.silent,patchMap:this.__csm.patchMap,cacheKey:this.__csm.cacheKey},r=new this.constructor(s);return Object.assign(this,r),r}},{key:"getCacheHash",value:function(){var s=this.__csm,r=s.fragmentShader,i=s.vertexShader,a=this.uniforms,l=Object.values(a).reduce(function(h,d){var y=d.value;return h+JSON.stringify(y)},""),u=wi(r)+wi(i)+l;return u.trim().length>0?Dc(u):this.customProgramCacheKey()}},{key:"generateMaterial",value:function(s,r,i){var a=this,l=this.parseShader(s),u=this.parseShader(r);this.uniforms=i||{},this.customProgramCacheKey=function(){return a.__csm.cacheHash};var h=function(g){try{if(l){var x=a.patchShader(l,g.fragmentShader,!0);g.fragmentShader=a.getMaterialDefine()+x}if(u){var w=a.patchShader(u,g.vertexShader);g.vertexShader=`#define IS_VERTEX;
-`+w,g.vertexShader=a.getMaterialDefine()+g.vertexShader}g.uniforms=Nt(Nt({},g.uniforms),a.uniforms),a.uniforms=g.uniforms}catch(v){console.error(v)}};if(this.__csm.isAlreadyExtended){var d=this.onBeforeCompile;this.onBeforeCompile=function(y,g){d(y,g),h(y)}}else this.onBeforeCompile=h;this.needsUpdate=!0}},{key:"patchShader",value:function(s,r,i){var a=this,l=r,u=Nt(Nt({},this.getPatchMapForMaterial()),this.__csm.patchMap);Object.keys(u).forEach(function(y){Object.keys(u[y]).forEach(function(g){var x=_u[y],w=a.__csm.type;if(y==="*"||bu(s.main,y))if(!x||Array.isArray(x)&&x.includes(w)||x==="*")l=xu(l,g,u[y][g]);else throw new Error("CSM: ".concat(y," is not available in ").concat(w,". Shader cannot compile."))})}),l=l.replace("void main() {",`
+`,je,wu=(je={},Ae(je,"".concat(de.position),"*"),Ae(je,"".concat(de.positionRaw),"*"),Ae(je,"".concat(de.normal),"*"),Ae(je,"".concat(de.pointSize),["PointsMaterial"]),Ae(je,"".concat(de.diffuseColor),"*"),Ae(je,"".concat(de.fragColor),"*"),Ae(je,"".concat(de.emissive),["MeshStandardMaterial","MeshPhysicalMaterial"]),Ae(je,"".concat(de.roughness),["MeshStandardMaterial","MeshPhysicalMaterial"]),Ae(je,"".concat(de.metalness),["MeshStandardMaterial","MeshPhysicalMaterial"]),Ae(je,"".concat(de.ao),["MeshStandardMaterial","MeshPhysicalMaterial","MeshBasicMaterial","MeshLambertMaterial","MeshPhongMaterial","MeshToonMaterial"]),Ae(je,"".concat(de.bump),["MeshLambertMaterial","MeshMatcapMaterial","MeshNormalMaterial","MeshPhongMaterial","MeshPhysicalMaterial","MeshStandardMaterial","MeshToonMaterial","ShadowMaterial"]),Ae(je,"".concat(de.depthAlpha),"*"),je),bu=["baseMaterial","fragmentShader","vertexShader","uniforms","patchMap","cacheKey","silent"],Mu=function(e,t,n){return e.split(t).join(n)},Su=function(e){return e.replace(/[-\/\\^$*+?.()|[\]{}]/g,"\\$&")},Au=function(e,t){return new RegExp("\\b".concat(Su(t),"\\b")).test(e)};function Cu(o){try{new o}catch(e){if(e.message.indexOf("is not a constructor")>=0)return!1}return!0}function Pu(o,e){var t=arguments.length>2&&arguments[2]!==void 0?arguments[2]:!1;Object.assign(o,e);var n=Object.getPrototypeOf(e);Object.entries(Object.getOwnPropertyDescriptors(n)).filter(function(r){var i=typeof r[1].get=="function",s=typeof r[1].set=="function",a=typeof r[1].value=="function",c=r[0]==="constructor";return(i||s||a)&&!c}).forEach(function(r){if(typeof o[r[0]]=="function"){t||console.warn("Function ".concat(r[0]," already exists on CSM, renaming to base_").concat(r[0]));var i="base_".concat(r[0]);o[i]=r[1].value.bind(o);return}Object.defineProperty(o,r[0],r[1])})}function Tu(o){var e=o.toString().trim(),t=e.substring(e.indexOf("{")+1,e.lastIndexOf("}"));return t.trim().length===0}function Ss(o){return o.replace(/\s/g,"")}function Lu(o,e,t){var n=o.lastIndexOf(e);return n===-1?o:o.substring(0,n)+t+o.substring(n+e.length)}var Du=function(o){uu(t,o);var e=du(t);function t(n){var r,i=n.baseMaterial,s=n.fragmentShader,a=n.vertexShader,c=n.uniforms,h=n.patchMap,f=n.cacheKey,d=n.silent,p=au(n,bu);lu(this,t);var m;if(Cu(i)?m=new i(p):(m=i,Object.assign(m,p)),m.type==="RawShaderMaterial")throw new Error("CustomShaderMaterial does not support RawShaderMaterial");r=e.call(this),Pu(Ms(r),m,d),r.__csm={patchMap:h||{},fragmentShader:s||"",vertexShader:a||"",cacheKey:f,baseMaterial:i,instanceID:Rr.MathUtils.generateUUID(),type:m.type,isAlreadyExtended:!Tu(m.onBeforeCompile),cacheHash:"",silent:d},r.uniforms=zt(zt({},r.uniforms||{}),c||{});{var x=r.__csm,b=x.fragmentShader,v=x.vertexShader,_=r.uniforms;r.__csm.cacheHash=r.getCacheHash(),r.generateMaterial(b,v,_)}return r}return cu(t,[{key:"update",value:function(){var r=arguments.length>0&&arguments[0]!==void 0?arguments[0]:{};this.uniforms=r.uniforms||this.uniforms,Object.assign(this.__csm,r);var i=this.__csm,s=i.fragmentShader,a=i.vertexShader,c=this.uniforms,h=this.getCacheHash();this.__csm.cacheHash=h,this.generateMaterial(s,a,c)}},{key:"clone",value:function(){var r={baseMaterial:this.__csm.baseMaterial,fragmentShader:this.__csm.fragmentShader,vertexShader:this.__csm.vertexShader,uniforms:this.uniforms,silent:this.__csm.silent,patchMap:this.__csm.patchMap,cacheKey:this.__csm.cacheKey},i=new this.constructor(r);return Object.assign(this,i),i}},{key:"getCacheHash",value:function(){var r=this.__csm,i=r.fragmentShader,s=r.vertexShader,a=this.uniforms,c=Object.values(a).reduce(function(f,d){var p=d.value;return f+JSON.stringify(p)},""),h=Ss(i)+Ss(s)+c;return h.trim().length>0?Bc(h):this.customProgramCacheKey()}},{key:"generateMaterial",value:function(r,i,s){var a=this,c=this.parseShader(r),h=this.parseShader(i);this.uniforms=s||{},this.customProgramCacheKey=function(){return a.__csm.cacheHash};var f=function(m){try{if(c){var x=a.patchShader(c,m.fragmentShader,!0);m.fragmentShader=a.getMaterialDefine()+x}if(h){var b=a.patchShader(h,m.vertexShader);m.vertexShader=`#define IS_VERTEX;
+`+b,m.vertexShader=a.getMaterialDefine()+m.vertexShader}m.uniforms=zt(zt({},m.uniforms),a.uniforms),a.uniforms=m.uniforms}catch(v){console.error(v)}};if(this.__csm.isAlreadyExtended){var d=this.onBeforeCompile;this.onBeforeCompile=function(p,m){d(p,m),f(p)}}else this.onBeforeCompile=f;this.needsUpdate=!0}},{key:"patchShader",value:function(r,i,s){var a=this,c=i,h=zt(zt({},this.getPatchMapForMaterial()),this.__csm.patchMap);Object.keys(h).forEach(function(p){Object.keys(h[p]).forEach(function(m){var x=wu[p],b=a.__csm.type;if(p==="*"||Au(r.main,p))if(!x||Array.isArray(x)&&x.includes(b)||x==="*")c=Mu(c,m,h[p][m]);else throw new Error("CSM: ".concat(p," is not available in ").concat(b,". Shader cannot compile."))})}),c=c.replace("void main() {",`
         #ifndef CSM_IS_HEAD_DEFAULTS_DEFINED
-          `.concat(i?gu:pu,`
+          `.concat(s?_u:yu,`
           #define CSM_IS_HEAD_DEFAULTS_DEFINED 1
         #endif
 
-        `).concat(s.header,`
+        `).concat(r.header,`
         
         void main() {
           #ifndef CSM_IS_DEFAULTS_DEFINED
-            `).concat(du,`
+            `).concat(gu,`
             #define CSM_IS_DEFAULTS_DEFINED 1
           #endif
           
           #ifndef CSM_IS_MAIN_DEFAULTS_DEFINED
-            `).concat(i?yu:mu,`
+            `).concat(s?xu:vu,`
             #define CSM_IS_MAIN_DEFAULTS_DEFINED 1
           #endif
 
           // CSM_START
-      `));var h=this.__csm.isAlreadyExtended,d=l.includes("// CSM_END");return h&&d?l=Pu(l,"// CSM_END",`
+      `));var f=this.__csm.isAlreadyExtended,d=c.includes("// CSM_END");return f&&d?c=Lu(c,"// CSM_END",`
           // CSM_END
-          `.concat(s.main,`
+          `.concat(r.main,`
           // CSM_END
-        `)):l=l.replace("// CSM_START",`
+        `)):c=c.replace("// CSM_START",`
         // CSM_START
-        `.concat(s.main,`
+        `.concat(r.main,`
         // CSM_END
-          `)),l=s.defines+l,l}},{key:"parseShader",value:function(s){if(s){var r=s.replace(/\/\*\*(.*?)\*\/|\/\/(.*?)\n/gm,""),i=Qc(r),a=tu(i),l=a.map(function(d){return d.name}).indexOf("main"),u=gi(i.slice(0,l>=0?a[l].outer[0]:void 0)),h=l>=0?this.getShaderFromIndex(i,a[l].body):"";return{defines:"",header:u,main:h}}}},{key:"getMaterialDefine",value:function(){var s=this.__csm.type;return s?"#define IS_".concat(s.toUpperCase(),`;
+          `)),c=r.defines+c,c}},{key:"parseShader",value:function(r){if(r){var i=r.replace(/\/\*\*(.*?)\*\/|\/\/(.*?)\n/gm,""),s=$c(i),a=iu(s),c=a.map(function(d){return d.name}).indexOf("main"),h=_s(s.slice(0,c>=0?a[c].outer[0]:void 0)),f=c>=0?this.getShaderFromIndex(s,a[c].body):"";return{defines:"",header:h,main:f}}}},{key:"getMaterialDefine",value:function(){var r=this.__csm.type;return r?"#define IS_".concat(r.toUpperCase(),`;
 `):`#define IS_UNKNOWN;
-`}},{key:"getPatchMapForMaterial",value:function(){switch(this.__csm.type){case"ShaderMaterial":return fu;default:return hu}}},{key:"getShaderFromIndex",value:function(s,r){return gi(s.slice(r[0],r[1]))}}]),t}(Ns.Material);const Tu=["args"],Lu=f.defineComponent({__name:"index",props:{baseMaterial:{type:Function},vertexShader:{},fragmentShader:{},silent:{type:Boolean},uniforms:{}},setup(o,{expose:e}){const t=o,n=f.shallowRef(null),{extend:s}=ae.useTresContext();return s({CustomShaderMaterial:Cu}),e({value:n}),(r,i)=>(f.openBlock(),f.createElementBlock("TresCustomShaderMaterial",{ref_key:"customShaderMaterialClass",ref:n,args:[t]},null,8,Tu))}}),Iu=parseInt(c.REVISION.replace(/\D+/g,""));class Du extends c.ShaderMaterial{constructor(t=new c.Vector2){super({uniforms:{inputBuffer:new c.Uniform(null),depthBuffer:new c.Uniform(null),resolution:new c.Uniform(new c.Vector2),texelSize:new c.Uniform(new c.Vector2),halfTexelSize:new c.Uniform(new c.Vector2),kernel:new c.Uniform(0),scale:new c.Uniform(1),cameraNear:new c.Uniform(0),cameraFar:new c.Uniform(1),minDepthThreshold:new c.Uniform(0),maxDepthThreshold:new c.Uniform(1),depthScale:new c.Uniform(0),depthToBlurRatioBias:new c.Uniform(.25)},fragmentShader:`#include <common>
+`}},{key:"getPatchMapForMaterial",value:function(){switch(this.__csm.type){case"ShaderMaterial":return mu;default:return pu}}},{key:"getShaderFromIndex",value:function(r,i){return _s(r.slice(i[0],i[1]))}}]),t}(Rr.Material);const Iu=["args"],Ou=u.defineComponent({__name:"index",props:{baseMaterial:{type:Function},vertexShader:{},fragmentShader:{},silent:{type:Boolean},uniforms:{}},setup(o,{expose:e}){const t=o,n=u.shallowRef(null),{extend:r}=oe.useTresContext();return r({CustomShaderMaterial:Du}),e({value:n}),(i,s)=>(u.openBlock(),u.createElementBlock("TresCustomShaderMaterial",{ref_key:"customShaderMaterialClass",ref:n,args:[t]},null,8,Iu))}}),ku=parseInt(l.REVISION.replace(/\D+/g,""));class Bu extends l.ShaderMaterial{constructor(t=new l.Vector2){super({uniforms:{inputBuffer:new l.Uniform(null),depthBuffer:new l.Uniform(null),resolution:new l.Uniform(new l.Vector2),texelSize:new l.Uniform(new l.Vector2),halfTexelSize:new l.Uniform(new l.Vector2),kernel:new l.Uniform(0),scale:new l.Uniform(1),cameraNear:new l.Uniform(0),cameraFar:new l.Uniform(1),minDepthThreshold:new l.Uniform(0),maxDepthThreshold:new l.Uniform(1),depthScale:new l.Uniform(0),depthToBlurRatioBias:new l.Uniform(.25)},fragmentShader:`#include <common>
         #include <dithering_pars_fragment>      
         uniform sampler2D inputBuffer;
         uniform sampler2D depthBuffer;
@@ -451,7 +451,7 @@ list should be an Array.`),T.length===0)return new v(0);if(T.length===1)return T
 
           #include <dithering_fragment>
           #include <tonemapping_fragment>
-          #include <${Iu>=154?"colorspace_fragment":"encodings_fragment"}>
+          #include <${ku>=154?"colorspace_fragment":"encodings_fragment"}>
         }`,vertexShader:`uniform vec2 texelSize;
         uniform vec2 halfTexelSize;
         uniform float kernel;
@@ -473,7 +473,7 @@ list should be an Array.`),T.length===0)return new v(0);if(T.length===1)return T
           vUv3 = vec2(uv.x - dUv.x, uv.y - dUv.y);
 
           gl_Position = vec4(position.xy, 1.0, 1.0);
-        }`,blending:c.NoBlending,depthWrite:!1,depthTest:!1});le(this,"kernel");this.toneMapped=!1,this.setTexelSize(t.x,t.y),this.kernel=new Float32Array([0,1,2,2,3])}setTexelSize(t,n){this.uniforms.texelSize.value.set(t,n),this.uniforms.halfTexelSize.value.set(t,n).multiplyScalar(.5)}setResolution(t){this.uniforms.resolution.value.copy(t)}}class Ou{constructor({resolution:e,width:t=500,height:n=500,minDepthThreshold:s=0,maxDepthThreshold:r=1,depthScale:i=0,depthToBlurRatioBias:a=.25}){le(this,"renderTargetA");le(this,"renderTargetB");le(this,"convolutionMaterial");le(this,"scene");le(this,"camera");le(this,"screen");le(this,"renderToScreen",!1);this.renderTargetA=new c.WebGLRenderTarget(e,e,{minFilter:c.LinearFilter,magFilter:c.LinearFilter,stencilBuffer:!1,depthBuffer:!1,type:c.HalfFloatType}),this.renderTargetB=this.renderTargetA.clone(),this.convolutionMaterial=new Du,this.convolutionMaterial.setTexelSize(1/t,1/n),this.convolutionMaterial.setResolution(new c.Vector2(t,n)),this.scene=new c.Scene,this.camera=new c.Camera,this.convolutionMaterial.uniforms.minDepthThreshold.value=s,this.convolutionMaterial.uniforms.maxDepthThreshold.value=r,this.convolutionMaterial.uniforms.depthScale.value=i,this.convolutionMaterial.uniforms.depthToBlurRatioBias.value=a,this.convolutionMaterial.defines.USE_DEPTH=i>0;const l=new Float32Array([-1,-1,0,3,-1,0,-1,3,0]),u=new Float32Array([0,0,2,0,0,2]),h=new c.BufferGeometry;h.setAttribute("position",new c.BufferAttribute(l,3)),h.setAttribute("uv",new c.BufferAttribute(u,2)),this.screen=new c.Mesh(h,this.convolutionMaterial),this.screen.frustumCulled=!1,this.scene.add(this.screen)}render(e,t,n){const s=this.scene,r=this.camera,i=this.renderTargetA,a=this.renderTargetB,l=this.convolutionMaterial,u=l.uniforms;u.depthBuffer.value=t.depthTexture;const h=l.kernel;let d=t,y,g,x;for(g=0,x=h.length-1;g<x;++g)y=g&1?a:i,u.kernel.value=h[g],u.inputBuffer.value=d.texture,e.setRenderTarget(y),e.render(s,r),d=y;u.kernel.value=h[g],u.inputBuffer.value=d.texture,e.setRenderTarget(this.renderToScreen?null:n),e.render(s,r)}}class Fu extends c.MeshStandardMaterial{constructor(t={}){super(t);le(this,"_tDepth",{value:null});le(this,"_distortionMap",{value:null});le(this,"_tDiffuse",{value:null});le(this,"_tDiffuseBlur",{value:null});le(this,"_textureMatrix",{value:null});le(this,"_hasBlur",{value:!1});le(this,"_mirror",{value:0});le(this,"_mixBlur",{value:0});le(this,"_blurStrength",{value:.5});le(this,"_minDepthThreshold",{value:.9});le(this,"_maxDepthThreshold",{value:1});le(this,"_depthScale",{value:0});le(this,"_depthToBlurRatioBias",{value:.25});le(this,"_distortion",{value:1});le(this,"_mixContrast",{value:1});this.setValues(t)}onBeforeCompile(t){var n;(n=t.defines)!=null&&n.USE_UV||(t.defines.USE_UV=""),t.uniforms.hasBlur=this._hasBlur,t.uniforms.tDiffuse=this._tDiffuse,t.uniforms.tDepth=this._tDepth,t.uniforms.distortionMap=this._distortionMap,t.uniforms.tDiffuseBlur=this._tDiffuseBlur,t.uniforms.textureMatrix=this._textureMatrix,t.uniforms.mirror=this._mirror,t.uniforms.mixBlur=this._mixBlur,t.uniforms.mixStrength=this._blurStrength,t.uniforms.minDepthThreshold=this._minDepthThreshold,t.uniforms.maxDepthThreshold=this._maxDepthThreshold,t.uniforms.depthScale=this._depthScale,t.uniforms.depthToBlurRatioBias=this._depthToBlurRatioBias,t.uniforms.distortion=this._distortion,t.uniforms.mixContrast=this._mixContrast,t.vertexShader=`
+        }`,blending:l.NoBlending,depthWrite:!1,depthTest:!1});le(this,"kernel");this.toneMapped=!1,this.setTexelSize(t.x,t.y),this.kernel=new Float32Array([0,1,2,2,3])}setTexelSize(t,n){this.uniforms.texelSize.value.set(t,n),this.uniforms.halfTexelSize.value.set(t,n).multiplyScalar(.5)}setResolution(t){this.uniforms.resolution.value.copy(t)}}class Fu{constructor({resolution:e,width:t=500,height:n=500,minDepthThreshold:r=0,maxDepthThreshold:i=1,depthScale:s=0,depthToBlurRatioBias:a=.25}){le(this,"renderTargetA");le(this,"renderTargetB");le(this,"convolutionMaterial");le(this,"scene");le(this,"camera");le(this,"screen");le(this,"renderToScreen",!1);this.renderTargetA=new l.WebGLRenderTarget(e,e,{minFilter:l.LinearFilter,magFilter:l.LinearFilter,stencilBuffer:!1,depthBuffer:!1,type:l.HalfFloatType}),this.renderTargetB=this.renderTargetA.clone(),this.convolutionMaterial=new Bu,this.convolutionMaterial.setTexelSize(1/t,1/n),this.convolutionMaterial.setResolution(new l.Vector2(t,n)),this.scene=new l.Scene,this.camera=new l.Camera,this.convolutionMaterial.uniforms.minDepthThreshold.value=r,this.convolutionMaterial.uniforms.maxDepthThreshold.value=i,this.convolutionMaterial.uniforms.depthScale.value=s,this.convolutionMaterial.uniforms.depthToBlurRatioBias.value=a,this.convolutionMaterial.defines.USE_DEPTH=s>0;const c=new Float32Array([-1,-1,0,3,-1,0,-1,3,0]),h=new Float32Array([0,0,2,0,0,2]),f=new l.BufferGeometry;f.setAttribute("position",new l.BufferAttribute(c,3)),f.setAttribute("uv",new l.BufferAttribute(h,2)),this.screen=new l.Mesh(f,this.convolutionMaterial),this.screen.frustumCulled=!1,this.scene.add(this.screen)}render(e,t,n){const r=this.scene,i=this.camera,s=this.renderTargetA,a=this.renderTargetB,c=this.convolutionMaterial,h=c.uniforms;h.depthBuffer.value=t.depthTexture;const f=c.kernel;let d=t,p,m,x;for(m=0,x=f.length-1;m<x;++m)p=m&1?a:s,h.kernel.value=f[m],h.inputBuffer.value=d.texture,e.setRenderTarget(p),e.render(r,i),d=p;h.kernel.value=f[m],h.inputBuffer.value=d.texture,e.setRenderTarget(this.renderToScreen?null:n),e.render(r,i)}}class Uu extends l.MeshStandardMaterial{constructor(t={}){super(t);le(this,"_tDepth",{value:null});le(this,"_distortionMap",{value:null});le(this,"_tDiffuse",{value:null});le(this,"_tDiffuseBlur",{value:null});le(this,"_textureMatrix",{value:null});le(this,"_hasBlur",{value:!1});le(this,"_mirror",{value:0});le(this,"_mixBlur",{value:0});le(this,"_blurStrength",{value:.5});le(this,"_minDepthThreshold",{value:.9});le(this,"_maxDepthThreshold",{value:1});le(this,"_depthScale",{value:0});le(this,"_depthToBlurRatioBias",{value:.25});le(this,"_distortion",{value:1});le(this,"_mixContrast",{value:1});this.setValues(t)}onBeforeCompile(t){var n;(n=t.defines)!=null&&n.USE_UV||(t.defines.USE_UV=""),t.uniforms.hasBlur=this._hasBlur,t.uniforms.tDiffuse=this._tDiffuse,t.uniforms.tDepth=this._tDepth,t.uniforms.distortionMap=this._distortionMap,t.uniforms.tDiffuseBlur=this._tDiffuseBlur,t.uniforms.textureMatrix=this._textureMatrix,t.uniforms.mirror=this._mirror,t.uniforms.mixBlur=this._mixBlur,t.uniforms.mixStrength=this._blurStrength,t.uniforms.minDepthThreshold=this._minDepthThreshold,t.uniforms.maxDepthThreshold=this._maxDepthThreshold,t.uniforms.depthScale=this._depthScale,t.uniforms.depthToBlurRatioBias=this._depthToBlurRatioBias,t.uniforms.distortion=this._distortion,t.uniforms.mixContrast=this._mixContrast,t.vertexShader=`
         uniform mat4 textureMatrix;
         varying vec4 my_vUv;
       ${t.vertexShader}`,t.vertexShader=t.vertexShader.replace("#include <project_vertex>",`#include <project_vertex>
@@ -559,7 +559,130 @@ list should be an Array.`),T.length===0)return new v(0);if(T.length===1)return T
       newMerge.b = (merge.b - 0.5) * mixContrast + 0.5;
 
       diffuseColor.rgb = diffuseColor.rgb * ((1.0 - min(1.0, mirror)) + newMerge.rgb * mixStrength);
-      `)}get tDiffuse(){return this._tDiffuse.value}set tDiffuse(t){this._tDiffuse.value=t}get tDepth(){return this._tDepth.value}set tDepth(t){this._tDepth.value=t}get distortionMap(){return this._distortionMap.value}set distortionMap(t){this._distortionMap.value=t}get tDiffuseBlur(){return this._tDiffuseBlur.value}set tDiffuseBlur(t){this._tDiffuseBlur.value=t}get textureMatrix(){return this._textureMatrix.value}set textureMatrix(t){this._textureMatrix.value=t}get hasBlur(){return this._hasBlur.value}set hasBlur(t){this._hasBlur.value=t}get mirror(){return this._mirror.value}set mirror(t){this._mirror.value=t}get mixBlur(){return this._mixBlur.value}set mixBlur(t){this._mixBlur.value=t}get mixStrength(){return this._blurStrength.value}set mixStrength(t){this._blurStrength.value=t}get minDepthThreshold(){return this._minDepthThreshold.value}set minDepthThreshold(t){this._minDepthThreshold.value=t}get maxDepthThreshold(){return this._maxDepthThreshold.value}set maxDepthThreshold(t){this._maxDepthThreshold.value=t}get depthScale(){return this._depthScale.value}set depthScale(t){this._depthScale.value=t}get depthToBlurRatioBias(){return this._depthToBlurRatioBias.value}set depthToBlurRatioBias(t){this._depthToBlurRatioBias.value=t}get distortion(){return this._distortion.value}set distortion(t){this._distortion.value=t}get mixContrast(){return this._mixContrast.value}set mixContrast(t){this._mixContrast.value=t}}const ku=["texture-matrix","mirror","t-diffuse","t-depth","t-diffuse-blur","has-blur","mix-strength","min-depth-threshold","max-depth-threshold","depth-scale","depth-to-blur-ratio-bias","distortion","distortionMap","mix-contrast","defines-USE_BLUR","defines-USE_DEPTH","defines-USE_DISTORTION"],Bu=f.defineComponent({__name:"index",props:{resolution:{default:256},mixBlur:{default:0},mixStrength:{default:1},blur:{default:()=>[0,0]},mirror:{default:0},minDepthThreshold:{default:.9},maxDepthThreshold:{default:1},depthScale:{default:0},depthToBlurRatioBias:{default:.25},distortionMap:{},distortion:{default:1},mixContrast:{default:1},reflectorOffset:{default:0}},setup(o){const e=o;function t(Q,K){let Z;return Q.traverse(X=>{X.isMesh&&X.material&&X.material.uuid===K&&(Z=X)}),Z}function n(Q){var Z,X;if(p.reflectorWorldPosition.setFromMatrixPosition(Q.matrixWorld),p.cameraWorldPosition.setFromMatrixPosition((Z=v.value)==null?void 0:Z.matrixWorld),p.rotationMatrix.extractRotation(Q.matrixWorld),p.normal.set(0,0,1),p.normal.applyMatrix4(p.rotationMatrix),p.reflectorWorldPosition.addScaledVector(p.normal,e.reflectorOffset),p.view.subVectors(p.reflectorWorldPosition,p.cameraWorldPosition),p.view.dot(p.normal)>0)return;p.view.reflect(p.normal).negate(),p.view.add(p.reflectorWorldPosition),p.rotationMatrix.extractRotation((X=v.value)==null?void 0:X.matrixWorld),p.lookAtPosition.set(0,0,-1),p.lookAtPosition.applyMatrix4(p.rotationMatrix),p.lookAtPosition.add(p.cameraWorldPosition),p.target.subVectors(p.reflectorWorldPosition,p.lookAtPosition),p.target.reflect(p.normal).negate(),p.target.add(p.reflectorWorldPosition),p.virtualCamera.position.copy(p.view),p.virtualCamera.up.set(0,1,0),p.virtualCamera.up.applyMatrix4(p.rotationMatrix),p.virtualCamera.up.reflect(p.normal),p.virtualCamera.lookAt(p.target),p.virtualCamera.far=(v==null?void 0:v.value).far,p.virtualCamera.updateMatrixWorld(),p.virtualCamera.projectionMatrix.copy((v==null?void 0:v.value).projectionMatrix),p.textureMatrix.set(.5,0,0,.5,0,.5,0,.5,0,0,.5,.5,0,0,0,1),p.textureMatrix.multiply(p.virtualCamera.projectionMatrix),p.textureMatrix.multiply(p.virtualCamera.matrixWorldInverse),p.textureMatrix.multiply(Q.matrixWorld),p.reflectorPlane.setFromNormalAndCoplanarPoint(p.normal,p.reflectorWorldPosition),p.reflectorPlane.applyMatrix4(p.virtualCamera.matrixWorldInverse),p.clipPlane.set(p.reflectorPlane.normal.x,p.reflectorPlane.normal.y,p.reflectorPlane.normal.z,p.reflectorPlane.constant);const K=p.virtualCamera.projectionMatrix;p.q.x=(Math.sign(p.clipPlane.x)+K.elements[8])/K.elements[0],p.q.y=(Math.sign(p.clipPlane.y)+K.elements[9])/K.elements[5],p.q.z=-1,p.q.w=(1+K.elements[10])/K.elements[14],p.clipPlane.multiplyScalar(2/p.clipPlane.dot(p.q)),K.elements[2]=p.clipPlane.x,K.elements[6]=p.clipPlane.y,K.elements[10]=p.clipPlane.z+1,K.elements[14]=p.clipPlane.w}const{resolution:s,minDepthThreshold:r,maxDepthThreshold:i,depthScale:a,depthToBlurRatioBias:l,blur:u,mirror:h,mixBlur:d,mixStrength:y,distortion:g,distortionMap:x,mixContrast:w}=f.toRefs(e),{camera:v,scene:P,renderer:D,extend:S}=ae.useTresContext();S({MeshReflectorMaterial:Fu});const _=f.shallowRef(),L=f.shallowRef(),b=f.shallowRef(),C=f.shallowRef(),m=f.computed(()=>typeof u.value=="number"?[u.value,u.value]:u.value),M=f.computed(()=>m.value[0]>0||m.value[1]>0),p={reflectorPlane:new c.Plane,normal:new c.Vector3,reflectorWorldPosition:new c.Vector3,cameraWorldPosition:new c.Vector3,rotationMatrix:new c.Matrix4,lookAtPosition:new c.Vector3(0,0,-1),clipPlane:new c.Vector4,view:new c.Vector3,target:new c.Vector3,q:new c.Vector4,virtualCamera:new c.PerspectiveCamera,textureMatrix:new c.Matrix4};f.watchEffect(()=>{var K;(K=_.value)==null||K.texture.dispose();const Q={minFilter:c.LinearFilter,magFilter:c.LinearFilter,type:c.HalfFloatType};_.value=new c.WebGLRenderTarget(s.value,s.value,{...Q,depthBuffer:!0,depthTexture:new c.DepthTexture(s.value,s.value,c.DepthFormat,c.UnsignedShortType)}),L.value=new c.WebGLRenderTarget(s.value,s.value,Q),b.value=new Ou({resolution:s.value,width:m.value[0],height:m.value[1],minDepthThreshold:r.value,maxDepthThreshold:i.value,depthScale:a.value,depthToBlurRatioBias:l.value}),C.value={mirror:h,textureMatrix:p.textureMatrix,mixBlur:d,tDiffuse:_.value.texture,tDepth:_.value.depthTexture,tDiffuseBlur:_.value.texture,hasBlur:M,mixStrength:y,minDepthThreshold:r,maxDepthThreshold:i,depthScale:a,depthToBlurRatioBias:l,distortion:g,distortionMap:x.value,mixContrast:w,"defines-USE_BLUR":M.value?"":void 0,"defines-USE_DEPTH":a.value>0?"":void 0,"defines-USE_DISTORTION":x.value?"":void 0}});const I=f.shallowRef(),{onLoop:F}=ae.useRenderLoop();F(()=>{var X;if(!I.value||!D.value||!_.value||!v.value)return;const Q=t(P.value,I.value.uuid);if(!Q)return;Q.visible=!1;const K=D.value.xr.enabled,Z=D.value.shadowMap.autoUpdate;n(Q),D.value.shadowMap.autoUpdate=!1,D.value.setRenderTarget(_.value),D.value.autoClear||D.value.clear(),D.value.render(P.value,p.virtualCamera),(X=b==null?void 0:b.value)==null||X.render(D.value,_.value,L.value),D.value.xr.enabled=K,D.value.shadowMap.autoUpdate=Z,Q.visible=!0,D.value.setRenderTarget(null)});const J=f.useAttrs(),G=f.computed(()=>{const Q={};return Object.assign(Q,e),Object.assign(Q,J.value),Q});return f.onBeforeUnmount(()=>{var Q,K;(Q=_==null?void 0:_.value)==null||Q.dispose(),(K=L==null?void 0:L.value)==null||K.dispose()}),(Q,K)=>{var Z,X,ne;return f.openBlock(),f.createElementBlock("TresMeshReflectorMaterial",f.mergeProps({key:`key${C.value["defines-USE_BLUR"]}${C.value["defines-USE_DEPTH"]}${C.value["defines-USE_DISTORTION"]}`,ref_key:"materialRef",ref:I},G.value,{"texture-matrix":p.textureMatrix,mirror:f.unref(h),"t-diffuse":(Z=_.value)==null?void 0:Z.texture,"t-depth":(X=_.value)==null?void 0:X.depthTexture,"t-diffuse-blur":(ne=L.value)==null?void 0:ne.texture,"has-blur":M.value,"mix-strength":f.unref(y),"min-depth-threshold":f.unref(r),"max-depth-threshold":f.unref(i),"depth-scale":f.unref(a),"depth-to-blur-ratio-bias":f.unref(l),distortion:f.unref(g),distortionMap:f.unref(x),"mix-contrast":f.unref(w),"defines-USE_BLUR":M.value?"":void 0,"defines-USE_DEPTH":f.unref(a)>0?"":void 0,"defines-USE_DISTORTION":f.unref(x)?"":void 0}),null,16,ku)}}}),Uu=["args"],Nu=["color"],zu=f.defineComponent({__name:"Box",props:{args:{default:()=>[1,1,1]},color:{default:"#ffffff"}},setup(o,{expose:e}){const t=o,{args:n,color:s}=f.toRefs(t),r=f.shallowRef();return e({value:r}),(i,a)=>(f.openBlock(),f.createElementBlock("TresMesh",f.mergeProps({ref_key:"boxRef",ref:r},i.$attrs),[f.createElementVNode("TresBoxGeometry",{args:f.unref(n)},null,8,Uu),f.renderSlot(i.$slots,"default",{},()=>[f.createElementVNode("TresMeshBasicMaterial",{color:f.unref(s)},null,8,Nu)])],16))}}),bi=new c.Box3,In=new c.Vector3;class Mi extends c.InstancedBufferGeometry{constructor(){super(),this.isLineSegmentsGeometry=!0,this.type="LineSegmentsGeometry";const e=[-1,2,0,1,2,0,-1,1,0,1,1,0,-1,0,0,1,0,0,-1,-1,0,1,-1,0],t=[-1,2,1,2,-1,1,1,1,-1,-1,1,-1,-1,-2,1,-2],n=[0,2,1,2,3,1,2,4,3,4,5,3,4,6,5,6,7,5];this.setIndex(n),this.setAttribute("position",new c.Float32BufferAttribute(e,3)),this.setAttribute("uv",new c.Float32BufferAttribute(t,2))}applyMatrix4(e){const t=this.attributes.instanceStart,n=this.attributes.instanceEnd;return t!==void 0&&(t.applyMatrix4(e),n.applyMatrix4(e),t.needsUpdate=!0),this.boundingBox!==null&&this.computeBoundingBox(),this.boundingSphere!==null&&this.computeBoundingSphere(),this}setPositions(e){let t;e instanceof Float32Array?t=e:Array.isArray(e)&&(t=new Float32Array(e));const n=new c.InstancedInterleavedBuffer(t,6,1);return this.setAttribute("instanceStart",new c.InterleavedBufferAttribute(n,3,0)),this.setAttribute("instanceEnd",new c.InterleavedBufferAttribute(n,3,3)),this.computeBoundingBox(),this.computeBoundingSphere(),this}setColors(e){let t;e instanceof Float32Array?t=e:Array.isArray(e)&&(t=new Float32Array(e));const n=new c.InstancedInterleavedBuffer(t,6,1);return this.setAttribute("instanceColorStart",new c.InterleavedBufferAttribute(n,3,0)),this.setAttribute("instanceColorEnd",new c.InterleavedBufferAttribute(n,3,3)),this}fromWireframeGeometry(e){return this.setPositions(e.attributes.position.array),this}fromEdgesGeometry(e){return this.setPositions(e.attributes.position.array),this}fromMesh(e){return this.fromWireframeGeometry(new c.WireframeGeometry(e.geometry)),this}fromLineSegments(e){const t=e.geometry;return this.setPositions(t.attributes.position.array),this}computeBoundingBox(){this.boundingBox===null&&(this.boundingBox=new c.Box3);const e=this.attributes.instanceStart,t=this.attributes.instanceEnd;e!==void 0&&t!==void 0&&(this.boundingBox.setFromBufferAttribute(e),bi.setFromBufferAttribute(t),this.boundingBox.union(bi))}computeBoundingSphere(){this.boundingSphere===null&&(this.boundingSphere=new c.Sphere),this.boundingBox===null&&this.computeBoundingBox();const e=this.attributes.instanceStart,t=this.attributes.instanceEnd;if(e!==void 0&&t!==void 0){const n=this.boundingSphere.center;this.boundingBox.getCenter(n);let s=0;for(let r=0,i=e.count;r<i;r++)In.fromBufferAttribute(e,r),s=Math.max(s,n.distanceToSquared(In)),In.fromBufferAttribute(t,r),s=Math.max(s,n.distanceToSquared(In));this.boundingSphere.radius=Math.sqrt(s),isNaN(this.boundingSphere.radius)&&console.error("THREE.LineSegmentsGeometry.computeBoundingSphere(): Computed radius is NaN. The instanced position data is likely to have NaN values.",this)}}toJSON(){}applyMatrix(e){return console.warn("THREE.LineSegmentsGeometry: applyMatrix() has been renamed to applyMatrix4()."),this.applyMatrix4(e)}}c.UniformsLib.line={worldUnits:{value:1},linewidth:{value:1},resolution:{value:new c.Vector2(1,1)},dashOffset:{value:0},dashScale:{value:1},dashSize:{value:1},gapSize:{value:1}},c.ShaderLib.line={uniforms:c.UniformsUtils.merge([c.UniformsLib.common,c.UniformsLib.fog,c.UniformsLib.line]),vertexShader:`
+      `)}get tDiffuse(){return this._tDiffuse.value}set tDiffuse(t){this._tDiffuse.value=t}get tDepth(){return this._tDepth.value}set tDepth(t){this._tDepth.value=t}get distortionMap(){return this._distortionMap.value}set distortionMap(t){this._distortionMap.value=t}get tDiffuseBlur(){return this._tDiffuseBlur.value}set tDiffuseBlur(t){this._tDiffuseBlur.value=t}get textureMatrix(){return this._textureMatrix.value}set textureMatrix(t){this._textureMatrix.value=t}get hasBlur(){return this._hasBlur.value}set hasBlur(t){this._hasBlur.value=t}get mirror(){return this._mirror.value}set mirror(t){this._mirror.value=t}get mixBlur(){return this._mixBlur.value}set mixBlur(t){this._mixBlur.value=t}get mixStrength(){return this._blurStrength.value}set mixStrength(t){this._blurStrength.value=t}get minDepthThreshold(){return this._minDepthThreshold.value}set minDepthThreshold(t){this._minDepthThreshold.value=t}get maxDepthThreshold(){return this._maxDepthThreshold.value}set maxDepthThreshold(t){this._maxDepthThreshold.value=t}get depthScale(){return this._depthScale.value}set depthScale(t){this._depthScale.value=t}get depthToBlurRatioBias(){return this._depthToBlurRatioBias.value}set depthToBlurRatioBias(t){this._depthToBlurRatioBias.value=t}get distortion(){return this._distortion.value}set distortion(t){this._distortion.value=t}get mixContrast(){return this._mixContrast.value}set mixContrast(t){this._mixContrast.value=t}}const Nu=["texture-matrix","mirror","t-diffuse","t-depth","t-diffuse-blur","has-blur","mix-strength","min-depth-threshold","max-depth-threshold","depth-scale","depth-to-blur-ratio-bias","distortion","distortionMap","mix-contrast","defines-USE_BLUR","defines-USE_DEPTH","defines-USE_DISTORTION"],zu=u.defineComponent({__name:"index",props:{resolution:{default:256},mixBlur:{default:0},mixStrength:{default:1},blur:{default:()=>[0,0]},mirror:{default:0},minDepthThreshold:{default:.9},maxDepthThreshold:{default:1},depthScale:{default:0},depthToBlurRatioBias:{default:.25},distortionMap:{},distortion:{default:1},mixContrast:{default:1},reflectorOffset:{default:0}},setup(o){const e=o;function t(Z,X){let K;return Z.traverse(Y=>{Y.isMesh&&Y.material&&Y.material.uuid===X&&(K=Y)}),K}function n(Z){var K,Y;if(g.reflectorWorldPosition.setFromMatrixPosition(Z.matrixWorld),g.cameraWorldPosition.setFromMatrixPosition((K=v.value)==null?void 0:K.matrixWorld),g.rotationMatrix.extractRotation(Z.matrixWorld),g.normal.set(0,0,1),g.normal.applyMatrix4(g.rotationMatrix),g.reflectorWorldPosition.addScaledVector(g.normal,e.reflectorOffset),g.view.subVectors(g.reflectorWorldPosition,g.cameraWorldPosition),g.view.dot(g.normal)>0)return;g.view.reflect(g.normal).negate(),g.view.add(g.reflectorWorldPosition),g.rotationMatrix.extractRotation((Y=v.value)==null?void 0:Y.matrixWorld),g.lookAtPosition.set(0,0,-1),g.lookAtPosition.applyMatrix4(g.rotationMatrix),g.lookAtPosition.add(g.cameraWorldPosition),g.target.subVectors(g.reflectorWorldPosition,g.lookAtPosition),g.target.reflect(g.normal).negate(),g.target.add(g.reflectorWorldPosition),g.virtualCamera.position.copy(g.view),g.virtualCamera.up.set(0,1,0),g.virtualCamera.up.applyMatrix4(g.rotationMatrix),g.virtualCamera.up.reflect(g.normal),g.virtualCamera.lookAt(g.target),g.virtualCamera.far=(v==null?void 0:v.value).far,g.virtualCamera.updateMatrixWorld(),g.virtualCamera.projectionMatrix.copy((v==null?void 0:v.value).projectionMatrix),g.textureMatrix.set(.5,0,0,.5,0,.5,0,.5,0,0,.5,.5,0,0,0,1),g.textureMatrix.multiply(g.virtualCamera.projectionMatrix),g.textureMatrix.multiply(g.virtualCamera.matrixWorldInverse),g.textureMatrix.multiply(Z.matrixWorld),g.reflectorPlane.setFromNormalAndCoplanarPoint(g.normal,g.reflectorWorldPosition),g.reflectorPlane.applyMatrix4(g.virtualCamera.matrixWorldInverse),g.clipPlane.set(g.reflectorPlane.normal.x,g.reflectorPlane.normal.y,g.reflectorPlane.normal.z,g.reflectorPlane.constant);const X=g.virtualCamera.projectionMatrix;g.q.x=(Math.sign(g.clipPlane.x)+X.elements[8])/X.elements[0],g.q.y=(Math.sign(g.clipPlane.y)+X.elements[9])/X.elements[5],g.q.z=-1,g.q.w=(1+X.elements[10])/X.elements[14],g.clipPlane.multiplyScalar(2/g.clipPlane.dot(g.q)),X.elements[2]=g.clipPlane.x,X.elements[6]=g.clipPlane.y,X.elements[10]=g.clipPlane.z+1,X.elements[14]=g.clipPlane.w}const{resolution:r,minDepthThreshold:i,maxDepthThreshold:s,depthScale:a,depthToBlurRatioBias:c,blur:h,mirror:f,mixBlur:d,mixStrength:p,distortion:m,distortionMap:x,mixContrast:b}=u.toRefs(e),{camera:v,scene:_,renderer:T,extend:w}=oe.useTresContext();w({MeshReflectorMaterial:Uu});const M=u.shallowRef(),D=u.shallowRef(),S=u.shallowRef(),C=u.shallowRef(),y=u.computed(()=>typeof h.value=="number"?[h.value,h.value]:h.value),A=u.computed(()=>y.value[0]>0||y.value[1]>0),g={reflectorPlane:new l.Plane,normal:new l.Vector3,reflectorWorldPosition:new l.Vector3,cameraWorldPosition:new l.Vector3,rotationMatrix:new l.Matrix4,lookAtPosition:new l.Vector3(0,0,-1),clipPlane:new l.Vector4,view:new l.Vector3,target:new l.Vector3,q:new l.Vector4,virtualCamera:new l.PerspectiveCamera,textureMatrix:new l.Matrix4};u.watchEffect(()=>{var X;(X=M.value)==null||X.texture.dispose();const Z={minFilter:l.LinearFilter,magFilter:l.LinearFilter,type:l.HalfFloatType};M.value=new l.WebGLRenderTarget(r.value,r.value,{...Z,depthBuffer:!0,depthTexture:new l.DepthTexture(r.value,r.value,l.DepthFormat,l.UnsignedShortType)}),D.value=new l.WebGLRenderTarget(r.value,r.value,Z),S.value=new Fu({resolution:r.value,width:y.value[0],height:y.value[1],minDepthThreshold:i.value,maxDepthThreshold:s.value,depthScale:a.value,depthToBlurRatioBias:c.value}),C.value={mirror:f,textureMatrix:g.textureMatrix,mixBlur:d,tDiffuse:M.value.texture,tDepth:M.value.depthTexture,tDiffuseBlur:M.value.texture,hasBlur:A,mixStrength:p,minDepthThreshold:i,maxDepthThreshold:s,depthScale:a,depthToBlurRatioBias:c,distortion:m,distortionMap:x.value,mixContrast:b,"defines-USE_BLUR":A.value?"":void 0,"defines-USE_DEPTH":a.value>0?"":void 0,"defines-USE_DISTORTION":x.value?"":void 0}});const I=u.shallowRef(),{onLoop:k}=oe.useRenderLoop();k(()=>{var Y;if(!I.value||!T.value||!M.value||!v.value)return;const Z=t(_.value,I.value.uuid);if(!Z)return;Z.visible=!1;const X=T.value.xr.enabled,K=T.value.shadowMap.autoUpdate;n(Z),T.value.shadowMap.autoUpdate=!1,T.value.setRenderTarget(M.value),T.value.autoClear||T.value.clear(),T.value.render(_.value,g.virtualCamera),(Y=S==null?void 0:S.value)==null||Y.render(T.value,M.value,D.value),T.value.xr.enabled=X,T.value.shadowMap.autoUpdate=K,Z.visible=!0,T.value.setRenderTarget(null)});const J=u.useAttrs(),G=u.computed(()=>{const Z={};return Object.assign(Z,e),Object.assign(Z,J.value),Z});return u.onBeforeUnmount(()=>{var Z,X;(Z=M==null?void 0:M.value)==null||Z.dispose(),(X=D==null?void 0:D.value)==null||X.dispose()}),(Z,X)=>{var K,Y,te;return u.openBlock(),u.createElementBlock("TresMeshReflectorMaterial",u.mergeProps({key:`key${C.value["defines-USE_BLUR"]}${C.value["defines-USE_DEPTH"]}${C.value["defines-USE_DISTORTION"]}`,ref_key:"materialRef",ref:I},G.value,{"texture-matrix":g.textureMatrix,mirror:u.unref(f),"t-diffuse":(K=M.value)==null?void 0:K.texture,"t-depth":(Y=M.value)==null?void 0:Y.depthTexture,"t-diffuse-blur":(te=D.value)==null?void 0:te.texture,"has-blur":A.value,"mix-strength":u.unref(p),"min-depth-threshold":u.unref(i),"max-depth-threshold":u.unref(s),"depth-scale":u.unref(a),"depth-to-blur-ratio-bias":u.unref(c),distortion:u.unref(m),distortionMap:u.unref(x),"mix-contrast":u.unref(b),"defines-USE_BLUR":A.value?"":void 0,"defines-USE_DEPTH":u.unref(a)>0?"":void 0,"defines-USE_DISTORTION":u.unref(x)?"":void 0}),null,16,Nu)}}});class Vu extends l.ShaderMaterial{constructor(e={}){super(),this.vertexShader=`
+      #define STANDARD
+      varying vec3 vViewPosition;
+      #ifdef USE_TRANSMISSION
+      varying vec3 vWorldPosition;
+      #endif
+    
+      varying vec2 vUv;
+      varying vec4 vPos;
+      varying vec3 vNormalW;
+      varying vec3 vPositionW;
+
+      #include <common>
+      #include <uv_pars_vertex>
+      #include <envmap_pars_vertex>
+      #include <color_pars_vertex>
+      #include <fog_pars_vertex>
+      #include <morphtarget_pars_vertex>
+      #include <skinning_pars_vertex>
+      #include <logdepthbuf_pars_vertex>
+      #include <clipping_planes_pars_vertex>
+
+      void main() {
+        
+        #include <uv_vertex>
+        #include <color_vertex>
+        #include <morphcolor_vertex>
+      
+        #if defined ( USE_ENVMAP ) || defined ( USE_SKINNING )
+      
+          #include <beginnormal_vertex>
+          #include <morphnormal_vertex>
+          #include <skinbase_vertex>
+          #include <skinnormal_vertex>
+          #include <defaultnormal_vertex>
+      
+        #endif
+      
+        #include <begin_vertex>
+        #include <morphtarget_vertex>
+        #include <skinning_vertex>
+        #include <project_vertex>
+        #include <logdepthbuf_vertex>
+        #include <clipping_planes_vertex>
+      
+        #include <worldpos_vertex>
+        #include <envmap_vertex>
+        #include <fog_vertex>
+
+        mat4 modelViewProjectionMatrix = projectionMatrix * modelViewMatrix;
+
+        vUv = uv;
+        vPos = projectionMatrix * modelViewMatrix * vec4( transformed, 1.0 );
+        vPositionW = vec3( vec4( transformed, 1.0 ) * modelMatrix);
+        vNormalW = normalize( vec3( vec4( normal, 0.0 ) * modelMatrix ) );
+        
+        gl_Position = modelViewProjectionMatrix * vec4( transformed, 1.0 );
+
+      }`,this.fragmentShader=` 
+      varying vec2 vUv;
+      varying vec3 vPositionW;
+      varying vec4 vPos;
+      varying vec3 vNormalW;
+      
+      uniform float time;
+      uniform float fresnelOpacity;
+      uniform float scanlineSize;
+      uniform float fresnelAmount;
+      uniform float signalSpeed;
+      uniform float hologramBrightness;
+      uniform float hologramOpacity;
+      uniform bool blinkFresnelOnly;
+      uniform bool enableBlinking;
+      uniform vec3 hologramColor;
+
+      float flicker( float amt, float time ) {return clamp( fract( cos( time ) * 43758.5453123 ), amt, 1.0 );}
+      float random(in float a, in float b) { return fract((cos(dot(vec2(a,b) ,vec2(12.9898,78.233))) * 43758.5453)); }
+
+      void main() {
+        vec2 vCoords = vPos.xy;
+        vCoords /= vPos.w;
+        vCoords = vCoords * 0.5 + 0.5;
+        vec2 myUV = fract( vCoords );
+
+        // Defines hologram main color
+        vec4 hologramColor = vec4(hologramColor, mix(hologramBrightness, vUv.y, 0.5));
+
+        // Add scanlines
+        float scanlines = 10.;
+        scanlines += 20. * sin(time *signalSpeed * 20.8 - myUV.y * 60. * scanlineSize);
+        scanlines *= smoothstep(1.3 * cos(time *signalSpeed + myUV.y * scanlineSize), 0.78, 0.9);
+        scanlines *= max(0.25, sin(time *signalSpeed) * 1.0);
+
+        // Scanlines offsets
+        float r = random(vUv.x, vUv.y);
+        float g = random(vUv.y * 20.2, 	vUv.y * .2);
+        float b = random(vUv.y * .9, 	vUv.y * .2);
+
+        // Scanline composition
+        hologramColor += vec4(r*scanlines, b*scanlines, r, 1.0) / 84.;
+        vec4 scanlineMix = mix(vec4(0.0), hologramColor, hologramColor.a);
+
+        // Calculates fresnel
+        vec3 viewDirectionW = normalize(cameraPosition - vPositionW);
+        float fresnelEffect = dot(viewDirectionW, vNormalW) * (1.6 - fresnelOpacity/2.);
+        fresnelEffect = clamp(fresnelAmount - fresnelEffect, 0., fresnelOpacity);
+
+        // Blinkin effect
+        //Suggested by Octano - https://x.com/OtanoDesign?s=20
+        float blinkValue = enableBlinking ? 0.6 - signalSpeed : 1.0;
+        float blink = flicker(blinkValue, time * signalSpeed * .02);
+
+        // Final shader composition
+        vec3 finalColor;
+
+        if(blinkFresnelOnly){
+          finalColor = scanlineMix.rgb + fresnelEffect * blink;
+        }else{
+          finalColor = scanlineMix.rgb * blink + fresnelEffect;
+        }
+
+        gl_FragColor = vec4( finalColor, hologramOpacity);
+
+      }`,this.uniforms={time:new l.Uniform(0),fresnelOpacity:new l.Uniform(e.fresnelOpacity!==void 0?e.fresnelOpacity:1),fresnelAmount:new l.Uniform(e.fresnelAmount!==void 0?e.fresnelAmount:.45),scanlineSize:new l.Uniform(e.scanlineSize!==void 0?e.scanlineSize:8),hologramBrightness:new l.Uniform(e.hologramBrightness!==void 0?e.hologramBrightness:1),signalSpeed:new l.Uniform(e.signalSpeed!==void 0?e.signalSpeed:1),hologramColor:new l.Uniform(e.hologramColor!==void 0?new l.Color(e.hologramColor):new l.Color("#00d5ff")),enableBlinking:new l.Uniform(e.enableBlinking!==void 0?e.enableBlinking:!0),blinkFresnelOnly:new l.Uniform(e.blinkFresnelOnly!==void 0?e.blinkFresnelOnly:!0),hologramOpacity:new l.Uniform(e.hologramOpacity!==void 0?e.hologramOpacity:1)},this.clock=new l.Clock,this.setValues(e),this.depthTest=e.depthTest!==void 0?e.depthTest:!1,this.blending=e.blendMode!==void 0?e.blendMode:l.AdditiveBlending,this.transparent=!0,this.side=e.side!==void 0?e.side:l.FrontSide}update(){this.uniforms.time.value=this.clock.getElapsedTime()}}const As=Vu,Ru=["uniforms-fresnelAmount-value","uniforms-enableBlinking-value","uniforms-fresnelOpacity-value","uniforms-hologramBrightness-value","uniforms-scanlineSize-value","uniforms-signalSpeed-value","uniforms-hologramColor-value","uniforms-hologramOpacity-value","uniforms-blinkFresnelOnly-value","enableAdditive","side"],Gu=u.defineComponent({__name:"index",props:{fresnelAmount:{default:.45},fresnelOpacity:{default:1},blinkFresnelOnly:{type:Boolean,default:!0},enableBlinking:{type:Boolean,default:!0},enableAdditive:{type:Boolean,default:!0},hologramBrightness:{default:.7},scanlineSize:{default:8},signalSpeed:{default:.45},hologramOpacity:{default:1},hologramColor:{default:"#00d5ff"},side:{default:l.FrontSide}},setup(o,{expose:e}){const t=o,n=u.shallowRef(),{extend:r}=oe.useTresContext();r({HolographicMaterial:As}),e({root:n,constructor:As});const{onLoop:i}=oe.useRenderLoop();return i(()=>{var s;(s=n.value)==null||s.update()}),(s,a)=>(u.openBlock(),u.createElementBlock("TresHolographicMaterial",{ref_key:"MeshHolographicMaterialClass",ref:n,"uniforms-fresnelAmount-value":t.fresnelAmount,"uniforms-enableBlinking-value":t.enableBlinking,"uniforms-fresnelOpacity-value":t.fresnelOpacity,"uniforms-hologramBrightness-value":t.hologramBrightness,"uniforms-scanlineSize-value":t.scanlineSize,"uniforms-signalSpeed-value":t.signalSpeed,"uniforms-hologramColor-value":t.hologramColor,"uniforms-hologramOpacity-value":t.hologramOpacity,"uniforms-blinkFresnelOnly-value":t.blinkFresnelOnly,enableAdditive:t.enableAdditive,side:t.side},null,8,Ru))}}),ju=["args"],Eu=["color"],Wu=u.defineComponent({__name:"Box",props:{args:{default:()=>[1,1,1]},color:{default:"#ffffff"}},setup(o,{expose:e}){const t=o,{args:n,color:r}=u.toRefs(t),i=u.shallowRef();return e({value:i}),(s,a)=>(u.openBlock(),u.createElementBlock("TresMesh",u.mergeProps({ref_key:"boxRef",ref:i},s.$attrs),[u.createElementVNode("TresBoxGeometry",{args:u.unref(n)},null,8,ju),u.renderSlot(s.$slots,"default",{},()=>[u.createElementVNode("TresMeshBasicMaterial",{color:u.unref(r)},null,8,Eu)])],16))}}),Cs=new l.Box3,kn=new l.Vector3;class Ps extends l.InstancedBufferGeometry{constructor(){super(),this.isLineSegmentsGeometry=!0,this.type="LineSegmentsGeometry";const e=[-1,2,0,1,2,0,-1,1,0,1,1,0,-1,0,0,1,0,0,-1,-1,0,1,-1,0],t=[-1,2,1,2,-1,1,1,1,-1,-1,1,-1,-1,-2,1,-2],n=[0,2,1,2,3,1,2,4,3,4,5,3,4,6,5,6,7,5];this.setIndex(n),this.setAttribute("position",new l.Float32BufferAttribute(e,3)),this.setAttribute("uv",new l.Float32BufferAttribute(t,2))}applyMatrix4(e){const t=this.attributes.instanceStart,n=this.attributes.instanceEnd;return t!==void 0&&(t.applyMatrix4(e),n.applyMatrix4(e),t.needsUpdate=!0),this.boundingBox!==null&&this.computeBoundingBox(),this.boundingSphere!==null&&this.computeBoundingSphere(),this}setPositions(e){let t;e instanceof Float32Array?t=e:Array.isArray(e)&&(t=new Float32Array(e));const n=new l.InstancedInterleavedBuffer(t,6,1);return this.setAttribute("instanceStart",new l.InterleavedBufferAttribute(n,3,0)),this.setAttribute("instanceEnd",new l.InterleavedBufferAttribute(n,3,3)),this.computeBoundingBox(),this.computeBoundingSphere(),this}setColors(e){let t;e instanceof Float32Array?t=e:Array.isArray(e)&&(t=new Float32Array(e));const n=new l.InstancedInterleavedBuffer(t,6,1);return this.setAttribute("instanceColorStart",new l.InterleavedBufferAttribute(n,3,0)),this.setAttribute("instanceColorEnd",new l.InterleavedBufferAttribute(n,3,3)),this}fromWireframeGeometry(e){return this.setPositions(e.attributes.position.array),this}fromEdgesGeometry(e){return this.setPositions(e.attributes.position.array),this}fromMesh(e){return this.fromWireframeGeometry(new l.WireframeGeometry(e.geometry)),this}fromLineSegments(e){const t=e.geometry;return this.setPositions(t.attributes.position.array),this}computeBoundingBox(){this.boundingBox===null&&(this.boundingBox=new l.Box3);const e=this.attributes.instanceStart,t=this.attributes.instanceEnd;e!==void 0&&t!==void 0&&(this.boundingBox.setFromBufferAttribute(e),Cs.setFromBufferAttribute(t),this.boundingBox.union(Cs))}computeBoundingSphere(){this.boundingSphere===null&&(this.boundingSphere=new l.Sphere),this.boundingBox===null&&this.computeBoundingBox();const e=this.attributes.instanceStart,t=this.attributes.instanceEnd;if(e!==void 0&&t!==void 0){const n=this.boundingSphere.center;this.boundingBox.getCenter(n);let r=0;for(let i=0,s=e.count;i<s;i++)kn.fromBufferAttribute(e,i),r=Math.max(r,n.distanceToSquared(kn)),kn.fromBufferAttribute(t,i),r=Math.max(r,n.distanceToSquared(kn));this.boundingSphere.radius=Math.sqrt(r),isNaN(this.boundingSphere.radius)&&console.error("THREE.LineSegmentsGeometry.computeBoundingSphere(): Computed radius is NaN. The instanced position data is likely to have NaN values.",this)}}toJSON(){}applyMatrix(e){return console.warn("THREE.LineSegmentsGeometry: applyMatrix() has been renamed to applyMatrix4()."),this.applyMatrix4(e)}}l.UniformsLib.line={worldUnits:{value:1},linewidth:{value:1},resolution:{value:new l.Vector2(1,1)},dashOffset:{value:0},dashScale:{value:1},dashSize:{value:1},gapSize:{value:1}},l.ShaderLib.line={uniforms:l.UniformsUtils.merge([l.UniformsLib.common,l.UniformsLib.fog,l.UniformsLib.line]),vertexShader:`
 		#include <common>
 		#include <color_pars_vertex>
 		#include <fog_pars_vertex>
@@ -929,9 +1052,9 @@ list should be an Array.`),T.length===0)return new v(0);if(T.length===1)return T
 			#include <premultiplied_alpha_fragment>
 
 		}
-		`};class Ps extends c.ShaderMaterial{constructor(e){super({type:"LineMaterial",uniforms:c.UniformsUtils.clone(c.ShaderLib.line.uniforms),vertexShader:c.ShaderLib.line.vertexShader,fragmentShader:c.ShaderLib.line.fragmentShader,clipping:!0}),this.isLineMaterial=!0,this.setValues(e)}get color(){return this.uniforms.diffuse.value}set color(e){this.uniforms.diffuse.value=e}get worldUnits(){return"WORLD_UNITS"in this.defines}set worldUnits(e){e===!0?this.defines.WORLD_UNITS="":delete this.defines.WORLD_UNITS}get linewidth(){return this.uniforms.linewidth.value}set linewidth(e){this.uniforms.linewidth&&(this.uniforms.linewidth.value=e)}get dashed(){return"USE_DASH"in this.defines}set dashed(e){e===!0!==this.dashed&&(this.needsUpdate=!0),e===!0?this.defines.USE_DASH="":delete this.defines.USE_DASH}get dashScale(){return this.uniforms.dashScale.value}set dashScale(e){this.uniforms.dashScale.value=e}get dashSize(){return this.uniforms.dashSize.value}set dashSize(e){this.uniforms.dashSize.value=e}get dashOffset(){return this.uniforms.dashOffset.value}set dashOffset(e){this.uniforms.dashOffset.value=e}get gapSize(){return this.uniforms.gapSize.value}set gapSize(e){this.uniforms.gapSize.value=e}get opacity(){return this.uniforms.opacity.value}set opacity(e){this.uniforms&&(this.uniforms.opacity.value=e)}get resolution(){return this.uniforms.resolution.value}set resolution(e){this.uniforms.resolution.value.copy(e)}get alphaToCoverage(){return"USE_ALPHA_TO_COVERAGE"in this.defines}set alphaToCoverage(e){this.defines&&(e===!0!==this.alphaToCoverage&&(this.needsUpdate=!0),e===!0?(this.defines.USE_ALPHA_TO_COVERAGE="",this.extensions.derivatives=!0):(delete this.defines.USE_ALPHA_TO_COVERAGE,this.extensions.derivatives=!1))}}const Si=new c.Vector3,Ai=new c.Vector3,Be=new c.Vector4,Ue=new c.Vector4,tt=new c.Vector4,Cs=new c.Vector3,Ts=new c.Matrix4,Ne=new c.Line3,Pi=new c.Vector3,Dn=new c.Box3,On=new c.Sphere,nt=new c.Vector4;let st,Ct;function Ci(o,e,t){return nt.set(0,0,-e,1).applyMatrix4(o.projectionMatrix),nt.multiplyScalar(1/nt.w),nt.x=Ct/t.width,nt.y=Ct/t.height,nt.applyMatrix4(o.projectionMatrixInverse),nt.multiplyScalar(1/nt.w),Math.abs(Math.max(nt.x,nt.y))}function Vu(o,e){const t=o.matrixWorld,n=o.geometry,s=n.attributes.instanceStart,r=n.attributes.instanceEnd,i=Math.min(n.instanceCount,s.count);for(let a=0,l=i;a<l;a++){Ne.start.fromBufferAttribute(s,a),Ne.end.fromBufferAttribute(r,a),Ne.applyMatrix4(t);const u=new c.Vector3,h=new c.Vector3;st.distanceSqToSegment(Ne.start,Ne.end,h,u),h.distanceTo(u)<Ct*.5&&e.push({point:h,pointOnLine:u,distance:st.origin.distanceTo(h),object:o,face:null,faceIndex:a,uv:null,uv1:null})}}function Ru(o,e,t){const n=e.projectionMatrix,r=o.material.resolution,i=o.matrixWorld,a=o.geometry,l=a.attributes.instanceStart,u=a.attributes.instanceEnd,h=Math.min(a.instanceCount,l.count),d=-e.near;st.at(1,tt),tt.w=1,tt.applyMatrix4(e.matrixWorldInverse),tt.applyMatrix4(n),tt.multiplyScalar(1/tt.w),tt.x*=r.x/2,tt.y*=r.y/2,tt.z=0,Cs.copy(tt),Ts.multiplyMatrices(e.matrixWorldInverse,i);for(let y=0,g=h;y<g;y++){if(Be.fromBufferAttribute(l,y),Ue.fromBufferAttribute(u,y),Be.w=1,Ue.w=1,Be.applyMatrix4(Ts),Ue.applyMatrix4(Ts),Be.z>d&&Ue.z>d)continue;if(Be.z>d){const S=Be.z-Ue.z,_=(Be.z-d)/S;Be.lerp(Ue,_)}else if(Ue.z>d){const S=Ue.z-Be.z,_=(Ue.z-d)/S;Ue.lerp(Be,_)}Be.applyMatrix4(n),Ue.applyMatrix4(n),Be.multiplyScalar(1/Be.w),Ue.multiplyScalar(1/Ue.w),Be.x*=r.x/2,Be.y*=r.y/2,Ue.x*=r.x/2,Ue.y*=r.y/2,Ne.start.copy(Be),Ne.start.z=0,Ne.end.copy(Ue),Ne.end.z=0;const w=Ne.closestPointToPointParameter(Cs,!0);Ne.at(w,Pi);const v=c.MathUtils.lerp(Be.z,Ue.z,w),P=v>=-1&&v<=1,D=Cs.distanceTo(Pi)<Ct*.5;if(P&&D){Ne.start.fromBufferAttribute(l,y),Ne.end.fromBufferAttribute(u,y),Ne.start.applyMatrix4(i),Ne.end.applyMatrix4(i);const S=new c.Vector3,_=new c.Vector3;st.distanceSqToSegment(Ne.start,Ne.end,_,S),t.push({point:_,pointOnLine:S,distance:st.origin.distanceTo(_),object:o,face:null,faceIndex:y,uv:null,uv1:null})}}}class Gu extends c.Mesh{constructor(e=new Mi,t=new Ps({color:Math.random()*16777215})){super(e,t),this.isLineSegments2=!0,this.type="LineSegments2"}computeLineDistances(){const e=this.geometry,t=e.attributes.instanceStart,n=e.attributes.instanceEnd,s=new Float32Array(2*t.count);for(let i=0,a=0,l=t.count;i<l;i++,a+=2)Si.fromBufferAttribute(t,i),Ai.fromBufferAttribute(n,i),s[a]=a===0?0:s[a-1],s[a+1]=s[a]+Si.distanceTo(Ai);const r=new c.InstancedInterleavedBuffer(s,2,1);return e.setAttribute("instanceDistanceStart",new c.InterleavedBufferAttribute(r,1,0)),e.setAttribute("instanceDistanceEnd",new c.InterleavedBufferAttribute(r,1,1)),this}raycast(e,t){const n=this.material.worldUnits,s=e.camera;s===null&&!n&&console.error('LineSegments2: "Raycaster.camera" needs to be set in order to raycast against LineSegments2 while worldUnits is set to false.');const r=e.params.Line2!==void 0&&e.params.Line2.threshold||0;st=e.ray;const i=this.matrixWorld,a=this.geometry,l=this.material;Ct=l.linewidth+r,a.boundingSphere===null&&a.computeBoundingSphere(),On.copy(a.boundingSphere).applyMatrix4(i);let u;if(n)u=Ct*.5;else{const d=Math.max(s.near,On.distanceToPoint(st.origin));u=Ci(s,d,l.resolution)}if(On.radius+=u,st.intersectsSphere(On)===!1)return;a.boundingBox===null&&a.computeBoundingBox(),Dn.copy(a.boundingBox).applyMatrix4(i);let h;if(n)h=Ct*.5;else{const d=Math.max(s.near,Dn.distanceToPoint(st.origin));h=Ci(s,d,l.resolution)}Dn.expandByScalar(h),st.intersectsBox(Dn)!==!1&&(n?Vu(this,t):Ru(this,s,t))}}class Ti extends Mi{constructor(){super(),this.isLineGeometry=!0,this.type="LineGeometry"}setPositions(e){const t=e.length-3,n=new Float32Array(2*t);for(let s=0;s<t;s+=3)n[2*s]=e[s],n[2*s+1]=e[s+1],n[2*s+2]=e[s+2],n[2*s+3]=e[s+3],n[2*s+4]=e[s+4],n[2*s+5]=e[s+5];return super.setPositions(n),this}setColors(e){const t=e.length-3,n=new Float32Array(2*t);for(let s=0;s<t;s+=3)n[2*s]=e[s],n[2*s+1]=e[s+1],n[2*s+2]=e[s+2],n[2*s+3]=e[s+3],n[2*s+4]=e[s+4],n[2*s+5]=e[s+5];return super.setColors(n),this}fromLine(e){const t=e.geometry;return this.setPositions(t.attributes.position.array),this}}class ju extends Gu{constructor(e=new Ti,t=new Ps({color:Math.random()*16777215})){super(e,t),this.isLine2=!0,this.type="Line2"}}const Eu=["object"],Li=f.defineComponent({__name:"Line2",props:{points:{},vertexColors:{default:null},color:{default:"white"},lineWidth:{default:1},worldUnits:{type:Boolean,default:!1},alphaToCoverage:{type:Boolean,default:!1},dashed:{type:Boolean,default:!1},dashSize:{default:1},gapSize:{default:1},dashScale:{default:1},dashOffset:{default:0}},setup(o){const e=o;function t(h,d){if(!h||h.length===0)return new Array(d).fill(ae.normalizeColor(e.color));if(h.length===1)return new Array(d).fill(ae.normalizeColor(h[0]));if(h.length===d)return h.map(ae.normalizeColor);const y=d-1,g=h.map(ae.normalizeColor);closed&&g.push(g[0].clone());const x=[g[0]],w=y/(g.length-1);for(let v=1;v<y;v++){const P=v%w/w,D=Math.floor(v/w);x.push(g[D].clone().lerp(g[D+1],P))}return x.push(g[g.length-1]),x}function n(h,d,y){const g=d.map(w=>w instanceof c.Vector3?[w.x,w.y,w.z]:w instanceof c.Vector2?[w.x,w.y,0]:Array.isArray(w)&&w.length===2?[w[0],w[1],0]:w).flat();h.setPositions(g.flat());const x=t(y,d.length).map(w=>w.toArray()).flat();h.setColors(x),a.computeLineDistances()}function s(h,d){h.color=ae.normalizeColor(d.color),h.linewidth=d.lineWidth,h.alphaToCoverage=d.alphaToCoverage,h.worldUnits=d.worldUnits,h.vertexColors=Array.isArray(d.vertexColors),h.dashed=d.dashed,h.dashScale=d.dashScale,h.dashSize=d.dashSize,h.dashOffset=d.dashOffset,h.gapSize=d.gapSize,h.needsUpdate=!0}const r=new Ps,i=new Ti,a=new ju(i,r),l=ae.useTresContext().sizes,u=f.computed(()=>Array.isArray(e.vertexColors));return s(r,e),n(i,e.points,e.vertexColors),a.computeLineDistances(),f.watch(()=>[e.color,e.lineWidth,e.alphaToCoverage,e.worldUnits,u,e.dashed,e.dashScale,e.dashSize,e.dashOffset],()=>s(r,e)),f.watch([e.points,e.vertexColors],()=>n(i,e.points,e.vertexColors)),f.watch(()=>e.vertexColors,()=>n(i,e.points,e.vertexColors)),f.watch(()=>e.points,()=>n(i,e.points,e.vertexColors)),f.watch([l.height,l.width],()=>r.resolution=new c.Vector2(l.width.value,l.height.value)),f.onUnmounted(()=>{i.dispose(),r.dispose()}),(h,d)=>(f.openBlock(),f.createElementBlock("primitive",{object:f.unref(a)},null,8,Eu))}}),Yu=f.defineComponent({__name:"CatmullRomCurve3",props:{segments:{default:20},closed:{type:Boolean,default:!1},curveType:{default:"centripetal"},tension:{default:.5},points:{},vertexColors:{},color:{},lineWidth:{},alphaToCoverage:{type:Boolean},dashed:{type:Boolean},dashSize:{},dashScale:{},dashOffset:{},gapSize:{},worldUnits:{type:Boolean}},setup(o){const e=o;function t(i,a,l,u){const h=i.map(d=>d instanceof c.Vector3?d:new c.Vector3(...d));return new c.CatmullRomCurve3(h,a,l,u)}function n(i,a){return i.getPoints(a)}const s=f.computed(()=>t(e.points,e.closed,e.curveType,e.tension)),r=f.computed(()=>n(s.value,e.segments));return(i,a)=>(f.openBlock(),f.createBlock(Li,{points:r.value,"vertex-colors":e.vertexColors,color:e.color,lineWidth:e.lineWidth,alphaToCoverage:e.alphaToCoverage,dashed:e.dashed,dashSize:e.dashSize,dashScale:e.dashScale,dashOffset:e.dashOffset,gapSize:e.gapSize,worldUnits:e.worldUnits},null,8,["points","vertex-colors","color","lineWidth","alphaToCoverage","dashed","dashSize","dashScale","dashOffset","gapSize","worldUnits"]))}}),Xu=["args"],Wu=["color"],Zu=f.defineComponent({__name:"Circle",props:{args:{default:()=>[1,32,0,Math.PI*2]},color:{default:"#ffffff"}},setup(o,{expose:e}){const t=o,{args:n,color:s}=f.toRefs(t),r=f.shallowRef();return e({value:r}),(i,a)=>(f.openBlock(),f.createElementBlock("TresMesh",f.mergeProps({ref_key:"circleRef",ref:r},i.$attrs),[f.createElementVNode("TresCircleGeometry",{args:f.unref(n)},null,8,Xu),f.renderSlot(i.$slots,"default",{},()=>[f.createElementVNode("TresMeshBasicMaterial",{color:f.unref(s)},null,8,Wu)])],16))}}),Ku=["args"],qu=["color"],Qu=f.defineComponent({__name:"Cone",props:{args:{default:()=>[1,1,12,12,!1,0,Math.PI*2]},color:{default:"#ffffff"}},setup(o,{expose:e}){const t=o,{args:n,color:s}=f.toRefs(t),r=f.shallowRef();return e({value:r}),(i,a)=>(f.openBlock(),f.createElementBlock("TresMesh",f.mergeProps({ref_key:"coneRef",ref:r},i.$attrs),[f.createElementVNode("TresConeGeometry",{args:f.unref(n)},null,8,Ku),f.renderSlot(i.$slots,"default",{},()=>[f.createElementVNode("TresMeshBasicMaterial",{color:f.unref(s)},null,8,qu)])],16))}}),Ju=["args"],Hu=["color"],$u=f.defineComponent({__name:"Dodecahedron",props:{args:{default:()=>[1,0]},color:{default:"#ffffff"}},setup(o,{expose:e}){const t=o,{args:n,color:s}=f.toRefs(t),r=f.shallowRef();return e({value:r}),(i,a)=>(f.openBlock(),f.createElementBlock("TresMesh",f.mergeProps({ref_key:"dodecahedronRef",ref:r},i.$attrs),[f.createElementVNode("TresDodecahedronGeometry",{args:f.unref(n)},null,8,Ju),f.renderSlot(i.$slots,"default",{},()=>[f.createElementVNode("TresMeshBasicMaterial",{color:f.unref(s)},null,8,Hu)])],16))}}),eh=["args"],th=["color"],nh=f.defineComponent({__name:"Icosahedron",props:{args:{default:()=>[1,0]},color:{default:"#ffffff"}},setup(o,{expose:e}){const t=o,{args:n,color:s}=f.toRefs(t),r=f.shallowRef();return e({value:r}),(i,a)=>(f.openBlock(),f.createElementBlock("TresMesh",f.mergeProps({ref_key:"icosahedronRef",ref:r},i.$attrs),[f.createElementVNode("TresIcosahedronGeometry",{args:f.unref(n)},null,8,eh),f.renderSlot(i.$slots,"default",{},()=>[f.createElementVNode("TresMeshBasicMaterial",{color:f.unref(s)},null,8,th)])],16))}}),sh=["args"],rh=["color"],ih=f.defineComponent({__name:"Octahedron",props:{args:{default:()=>[1,0]},color:{default:"#ffffff"}},setup(o,{expose:e}){const t=o,{args:n,color:s}=f.toRefs(t),r=f.shallowRef();return e({value:r}),(i,a)=>(f.openBlock(),f.createElementBlock("TresMesh",f.mergeProps({ref_key:"octahedronRef",ref:r},i.$attrs),[f.createElementVNode("TresOctahedronGeometry",{args:f.unref(n)},null,8,sh),f.renderSlot(i.$slots,"default",{},()=>[f.createElementVNode("TresMeshBasicMaterial",{color:f.unref(s)},null,8,rh)])],16))}}),oh=["rotation"],ah=["args"],lh=["color"],ch=f.defineComponent({__name:"Plane",props:{args:{default:()=>[1,1]},color:{default:"#ffffff"}},setup(o,{expose:e}){const t=o,{args:n,color:s}=f.toRefs(t),r=f.shallowRef();return e({value:r}),(i,a)=>(f.openBlock(),f.createElementBlock("TresMesh",f.mergeProps({ref_key:"planeRef",ref:r,rotation:[-Math.PI/2,0,0]},i.$attrs),[f.createElementVNode("TresPlaneGeometry",{args:f.unref(n)},null,8,ah),f.renderSlot(i.$slots,"default",{},()=>[f.createElementVNode("TresMeshBasicMaterial",{color:f.unref(s)},null,8,lh)])],16,oh))}}),uh=["args"],hh=["color"],fh=f.defineComponent({__name:"Ring",props:{args:{default:()=>[.5,1,32]},color:{default:"#ffffff"}},setup(o,{expose:e}){const t=o,{args:n,color:s}=f.toRefs(t),r=f.shallowRef();return e({value:r}),(i,a)=>(f.openBlock(),f.createElementBlock("TresMesh",f.mergeProps({ref_key:"ringRef",ref:r},i.$attrs),[f.createElementVNode("TresRingGeometry",{args:f.unref(n)},null,8,uh),f.renderSlot(i.$slots,"default",{},()=>[f.createElementVNode("TresMeshBasicMaterial",{color:f.unref(s)},null,8,hh)])],16))}}),dh=["args"],ph=["color"],mh=f.defineComponent({__name:"Sphere",props:{args:{default:()=>[2,32,16]},color:{default:"#ffffff"}},setup(o,{expose:e}){const t=o,{args:n,color:s}=f.toRefs(t),r=f.shallowRef();return e({value:r}),(i,a)=>(f.openBlock(),f.createElementBlock("TresMesh",f.mergeProps({ref_key:"sphereRef",ref:r},i.$attrs),[f.createElementVNode("TresSphereGeometry",{args:f.unref(n)},null,8,dh),f.renderSlot(i.$slots,"default",{},()=>[f.createElementVNode("TresMeshBasicMaterial",{color:f.unref(s)},null,8,ph)])],16))}}),gh=["geometry"],yh=["color"],_h=f.defineComponent({__name:"Superformula",props:{widthSegments:{default:32},heightSegments:{default:32},numArmsA:{default:4},expA:{default:()=>[40,1.3,.9]},numArmsB:{default:4},expB:{default:()=>[40,1.3,.9]},color:{default:"white"}},setup(o,{expose:e}){const t=o,{cos:n,sin:s,abs:r}=Math,i=f.shallowRef(),a=f.shallowRef(t.color);function l(y,g){const x=new c.BufferGeometry,w=y*g,v=new Float32Array(new Array(3*w).fill(0)),P=new Float32Array(new Array(3*w).fill(0)),D=[];for(let S=0;S<g-1;S++){for(let m=0;m<y-1;m++){const M=S*y+m,p=M+1,I=M+y,F=p+y;D.push(M,I,p),D.push(I,F,p)}const _=S*y+y-1,L=S*y,b=_+y,C=L+y;D.push(_,b,L),D.push(b,C,L)}return x.setIndex(D),x.setAttribute("position",new c.BufferAttribute(v,3)),x.setAttribute("normal",new c.BufferAttribute(P,3)),x}function u(y,g,x,w,v){return(r(n(g*y*.25))**w+r(s(g*y*.25))**v)**(-1/x)}function h(y,g,x,w,v,P,D,S,_,L,b){const C=2*Math.PI/L,m=-Math.PI,M=Math.PI/(b-1),p=-.5*Math.PI,I=y.getAttribute("position");let F=0,J=0,G=p;for(let Q=0;Q<b;Q++){J=m;for(let K=0;K<L;K++){const Z=u(J,g,x,w,v),X=u(G,P,D,S,_);I.setXYZ(F,Z*n(J)*X*n(G),X*s(G),Z*s(J)*X*n(G)),F++,J+=C}G+=M}I.needsUpdate=!0,y.computeVertexNormals()}f.watch(()=>t.color,()=>a.value=t.color),f.watch(()=>[t.widthSegments,t.heightSegments],()=>{i.value&&i.value.dispose(),i.value=l(t.widthSegments,t.heightSegments)},{immediate:!0}),f.watch(()=>[t.numArmsA,t.expA[0],t.expA[1],t.expA[2],t.numArmsB,t.expB[0],t.expB[1],t.expB[2]],()=>h(i.value,t.numArmsA,t.expA[0],t.expA[1],t.expA[2],t.numArmsB,t.expB[0],t.expB[1],t.expB[2],t.widthSegments,t.heightSegments),{immediate:!0}),f.onUnmounted(()=>{i.value&&i.value.dispose()});const d=f.shallowRef();return e({value:d}),(y,g)=>(f.openBlock(),f.createElementBlock("TresMesh",f.mergeProps({ref_key:"superformulaRef",ref:d},y.$attrs,{geometry:i.value}),[f.renderSlot(y.$slots,"default",{},()=>[f.createElementVNode("TresMeshBasicMaterial",{color:a.value},null,8,yh)])],16,gh))}}),vh=["rotation"],xh=["args"],wh=["color"],bh=f.defineComponent({__name:"Tetrahedron",props:{args:{default:()=>[1,0]},color:{default:"#ffffff"}},setup(o,{expose:e}){const t=o,{args:n,color:s}=f.toRefs(t),r=f.shallowRef();return e({value:r}),(i,a)=>(f.openBlock(),f.createElementBlock("TresMesh",f.mergeProps({ref_key:"tetrahedronRef",ref:r,rotation:[-Math.PI/2,0,0]},i.$attrs),[f.createElementVNode("TresTetrahedronGeometry",{args:f.unref(n)},null,8,xh),f.renderSlot(i.$slots,"default",{},()=>[f.createElementVNode("TresMeshBasicMaterial",{color:f.unref(s)},null,8,wh)])],16,vh))}}),Mh=["args"],Sh=["color"],Ah=f.defineComponent({__name:"Torus",props:{args:{default:()=>[1,1,16,80]},color:{default:"#ffffff"}},setup(o,{expose:e}){const t=o,{args:n,color:s}=f.toRefs(t),r=f.shallowRef();return e({value:r}),(i,a)=>(f.openBlock(),f.createElementBlock("TresMesh",f.mergeProps({ref_key:"torusRef",ref:r},i.$attrs),[f.createElementVNode("TresTorusGeometry",{args:f.unref(n)},null,8,Mh),f.renderSlot(i.$slots,"default",{},()=>[f.createElementVNode("TresMeshBasicMaterial",{color:f.unref(s)},null,8,Sh)])],16))}}),Ph=["args"],Ch=["color"],Th=f.defineComponent({__name:"TorusKnot",props:{args:{default:()=>[1,.4,64,8]},color:{default:"#ffffff"}},setup(o,{expose:e}){const t=o,{args:n,color:s}=f.toRefs(t),r=f.shallowRef();return e({value:r}),(i,a)=>(f.openBlock(),f.createElementBlock("TresMesh",f.mergeProps({ref_key:"torusKnotRef",ref:r},i.$attrs),[f.createElementVNode("TresTorusKnotGeometry",{args:f.unref(n)},null,8,Ph),f.renderSlot(i.$slots,"default",{},()=>[f.createElementVNode("TresMeshBasicMaterial",{color:f.unref(s)},null,8,Ch)])],16))}}),Lh=["args"],Ih=["color"],Dh=f.defineComponent({__name:"Tube",props:{args:{default:()=>[new c.QuadraticBezierCurve3(new c.Vector3(-1,0,0),new c.Vector3(0,1,0),new c.Vector3(1,0,0)),20,.2,8,!1]},color:{default:"#ffffff"}},setup(o,{expose:e}){const t=o,{args:n,color:s}=f.toRefs(t),r=f.shallowRef();return e({value:r}),(i,a)=>(f.openBlock(),f.createElementBlock("TresMesh",f.mergeProps({ref_key:"tubeRef",ref:r},i.$attrs),[f.createElementVNode("TresTubeGeometry",{args:f.unref(n)},null,8,Lh),f.renderSlot(i.$slots,"default",{},()=>[f.createElementVNode("TresMeshBasicMaterial",{color:f.unref(s)},null,8,Ih)])],16))}}),Oh=f.defineComponent({__name:"component",props:{background:{type:[Boolean,String],default:!1},blur:{default:0},files:{default:[]},path:{default:""},preset:{default:void 0}},async setup(o,{expose:e}){let t,n;const s=o,r=f.ref(null);return e(r),r.value=([t,n]=f.withAsyncContext(()=>Vr(s).texture),t=await t,n(),t),()=>{}}}),Fh=["receive-shadow","rotation"],kh=["args"],Bh=f.createElementVNode("TresMeshStandardMaterial",{color:8421504,side:2},null,-1),Uh=f.defineComponent({__name:"Backdrop",props:{floor:{default:.25},segments:{default:20},receiveShadow:{type:Boolean,default:!1}},setup(o){const e=o,t=a=>a===0?0:2**(10*a-10),{floor:n,segments:s,receiveShadow:r}=f.toRefs(e),i=f.ref(null);return f.watch(()=>[s.value,n.value,i.value],([a,l,u])=>{if(!u||a===null)return;let h=0;const d=a/a/2,y=u.attributes.position;for(let g=0;g<a+1;g++)for(let x=0;x<a+1;x++)y.setXYZ(h++,g/a-d+(g===0?-l:0),x/a-d,t(g/a));y.needsUpdate=!0,u.computeVertexNormals()}),(a,l)=>(f.openBlock(),f.createElementBlock("TresGroup",f.normalizeProps(f.guardReactiveProps(a.$attrs)),[f.createElementVNode("TresMesh",{"receive-shadow":f.unref(r),rotation:[-Math.PI/2,0,Math.PI/2]},[f.createElementVNode("TresPlaneGeometry",{ref_key:"planeRef",ref:i,args:[1,1,f.unref(s),f.unref(s)]},null,8,kh),f.renderSlot(a.$slots,"default",{},()=>[Bh])],8,Fh)],16))}}),Nh=["geometry"],zh=["map","opacity","depth-write"],Vh=["object"],Rh=["args"],Gh=["rotation","args"],jh=f.defineComponent({__name:"ContactShadows",props:{opacity:{default:1},width:{default:1},height:{default:1},blur:{default:1},far:{default:10},smooth:{type:Boolean,default:!0},resolution:{default:512},frames:{default:1/0},scale:{default:10},color:{default:"#000000"},depthWrite:{type:Boolean,default:!1},helper:{type:Boolean,default:!1}},setup(o,{expose:e}){const t=o,n=f.shallowRef(),s=f.shallowRef();e(n);let r,i,a,l,u;const{renderer:h,scene:d}=ae.useTresContext(),y=f.computed(()=>t.width*(Array.isArray(t.scale)?t.scale[0]:t.scale||1)),g=f.computed(()=>t.height*(Array.isArray(t.scale)?t.scale[1]:t.scale||1));f.watchEffect(()=>{r&&r.dispose(),i&&i.dispose(),a&&a.dispose(),l&&l.geometry.dispose(),r=new c.WebGLRenderTarget(t.resolution,t.resolution),i=new c.WebGLRenderTarget(t.resolution,t.resolution),i.texture.generateMipmaps=r.texture.generateMipmaps=!1,s.value=new c.OrthographicCamera(-y.value/2,y.value/2,g.value/2,-g.value/2,0,t.far),a=new c.PlaneGeometry(y.value,g.value).rotateX(Math.PI/2),l=new c.Mesh(a),l.visible=!1}),f.watchEffect(()=>{t.color&&(u&&u.dispose(),u=new c.MeshDepthMaterial,u.depthTest=u.depthWrite=!1,u.onBeforeCompile=L=>{L.uniforms={...L.uniforms,ucolor:{value:t.color?new c.Color(t.color):new c.Color}},L.fragmentShader=L.fragmentShader.replace("void main() {",`uniform vec3 ucolor;
+		`};class Lr extends l.ShaderMaterial{constructor(e){super({type:"LineMaterial",uniforms:l.UniformsUtils.clone(l.ShaderLib.line.uniforms),vertexShader:l.ShaderLib.line.vertexShader,fragmentShader:l.ShaderLib.line.fragmentShader,clipping:!0}),this.isLineMaterial=!0,this.setValues(e)}get color(){return this.uniforms.diffuse.value}set color(e){this.uniforms.diffuse.value=e}get worldUnits(){return"WORLD_UNITS"in this.defines}set worldUnits(e){e===!0?this.defines.WORLD_UNITS="":delete this.defines.WORLD_UNITS}get linewidth(){return this.uniforms.linewidth.value}set linewidth(e){this.uniforms.linewidth&&(this.uniforms.linewidth.value=e)}get dashed(){return"USE_DASH"in this.defines}set dashed(e){e===!0!==this.dashed&&(this.needsUpdate=!0),e===!0?this.defines.USE_DASH="":delete this.defines.USE_DASH}get dashScale(){return this.uniforms.dashScale.value}set dashScale(e){this.uniforms.dashScale.value=e}get dashSize(){return this.uniforms.dashSize.value}set dashSize(e){this.uniforms.dashSize.value=e}get dashOffset(){return this.uniforms.dashOffset.value}set dashOffset(e){this.uniforms.dashOffset.value=e}get gapSize(){return this.uniforms.gapSize.value}set gapSize(e){this.uniforms.gapSize.value=e}get opacity(){return this.uniforms.opacity.value}set opacity(e){this.uniforms&&(this.uniforms.opacity.value=e)}get resolution(){return this.uniforms.resolution.value}set resolution(e){this.uniforms.resolution.value.copy(e)}get alphaToCoverage(){return"USE_ALPHA_TO_COVERAGE"in this.defines}set alphaToCoverage(e){this.defines&&(e===!0!==this.alphaToCoverage&&(this.needsUpdate=!0),e===!0?(this.defines.USE_ALPHA_TO_COVERAGE="",this.extensions.derivatives=!0):(delete this.defines.USE_ALPHA_TO_COVERAGE,this.extensions.derivatives=!1))}}const Ts=new l.Vector3,Ls=new l.Vector3,Fe=new l.Vector4,Ue=new l.Vector4,nt=new l.Vector4,Dr=new l.Vector3,Ir=new l.Matrix4,Ne=new l.Line3,Ds=new l.Vector3,Bn=new l.Box3,Fn=new l.Sphere,rt=new l.Vector4;let it,Tt;function Is(o,e,t){return rt.set(0,0,-e,1).applyMatrix4(o.projectionMatrix),rt.multiplyScalar(1/rt.w),rt.x=Tt/t.width,rt.y=Tt/t.height,rt.applyMatrix4(o.projectionMatrixInverse),rt.multiplyScalar(1/rt.w),Math.abs(Math.max(rt.x,rt.y))}function Yu(o,e){const t=o.matrixWorld,n=o.geometry,r=n.attributes.instanceStart,i=n.attributes.instanceEnd,s=Math.min(n.instanceCount,r.count);for(let a=0,c=s;a<c;a++){Ne.start.fromBufferAttribute(r,a),Ne.end.fromBufferAttribute(i,a),Ne.applyMatrix4(t);const h=new l.Vector3,f=new l.Vector3;it.distanceSqToSegment(Ne.start,Ne.end,f,h),f.distanceTo(h)<Tt*.5&&e.push({point:f,pointOnLine:h,distance:it.origin.distanceTo(f),object:o,face:null,faceIndex:a,uv:null,uv1:null})}}function Xu(o,e,t){const n=e.projectionMatrix,i=o.material.resolution,s=o.matrixWorld,a=o.geometry,c=a.attributes.instanceStart,h=a.attributes.instanceEnd,f=Math.min(a.instanceCount,c.count),d=-e.near;it.at(1,nt),nt.w=1,nt.applyMatrix4(e.matrixWorldInverse),nt.applyMatrix4(n),nt.multiplyScalar(1/nt.w),nt.x*=i.x/2,nt.y*=i.y/2,nt.z=0,Dr.copy(nt),Ir.multiplyMatrices(e.matrixWorldInverse,s);for(let p=0,m=f;p<m;p++){if(Fe.fromBufferAttribute(c,p),Ue.fromBufferAttribute(h,p),Fe.w=1,Ue.w=1,Fe.applyMatrix4(Ir),Ue.applyMatrix4(Ir),Fe.z>d&&Ue.z>d)continue;if(Fe.z>d){const w=Fe.z-Ue.z,M=(Fe.z-d)/w;Fe.lerp(Ue,M)}else if(Ue.z>d){const w=Ue.z-Fe.z,M=(Ue.z-d)/w;Ue.lerp(Fe,M)}Fe.applyMatrix4(n),Ue.applyMatrix4(n),Fe.multiplyScalar(1/Fe.w),Ue.multiplyScalar(1/Ue.w),Fe.x*=i.x/2,Fe.y*=i.y/2,Ue.x*=i.x/2,Ue.y*=i.y/2,Ne.start.copy(Fe),Ne.start.z=0,Ne.end.copy(Ue),Ne.end.z=0;const b=Ne.closestPointToPointParameter(Dr,!0);Ne.at(b,Ds);const v=l.MathUtils.lerp(Fe.z,Ue.z,b),_=v>=-1&&v<=1,T=Dr.distanceTo(Ds)<Tt*.5;if(_&&T){Ne.start.fromBufferAttribute(c,p),Ne.end.fromBufferAttribute(h,p),Ne.start.applyMatrix4(s),Ne.end.applyMatrix4(s);const w=new l.Vector3,M=new l.Vector3;it.distanceSqToSegment(Ne.start,Ne.end,M,w),t.push({point:M,pointOnLine:w,distance:it.origin.distanceTo(M),object:o,face:null,faceIndex:p,uv:null,uv1:null})}}}class Zu extends l.Mesh{constructor(e=new Ps,t=new Lr({color:Math.random()*16777215})){super(e,t),this.isLineSegments2=!0,this.type="LineSegments2"}computeLineDistances(){const e=this.geometry,t=e.attributes.instanceStart,n=e.attributes.instanceEnd,r=new Float32Array(2*t.count);for(let s=0,a=0,c=t.count;s<c;s++,a+=2)Ts.fromBufferAttribute(t,s),Ls.fromBufferAttribute(n,s),r[a]=a===0?0:r[a-1],r[a+1]=r[a]+Ts.distanceTo(Ls);const i=new l.InstancedInterleavedBuffer(r,2,1);return e.setAttribute("instanceDistanceStart",new l.InterleavedBufferAttribute(i,1,0)),e.setAttribute("instanceDistanceEnd",new l.InterleavedBufferAttribute(i,1,1)),this}raycast(e,t){const n=this.material.worldUnits,r=e.camera;r===null&&!n&&console.error('LineSegments2: "Raycaster.camera" needs to be set in order to raycast against LineSegments2 while worldUnits is set to false.');const i=e.params.Line2!==void 0&&e.params.Line2.threshold||0;it=e.ray;const s=this.matrixWorld,a=this.geometry,c=this.material;Tt=c.linewidth+i,a.boundingSphere===null&&a.computeBoundingSphere(),Fn.copy(a.boundingSphere).applyMatrix4(s);let h;if(n)h=Tt*.5;else{const d=Math.max(r.near,Fn.distanceToPoint(it.origin));h=Is(r,d,c.resolution)}if(Fn.radius+=h,it.intersectsSphere(Fn)===!1)return;a.boundingBox===null&&a.computeBoundingBox(),Bn.copy(a.boundingBox).applyMatrix4(s);let f;if(n)f=Tt*.5;else{const d=Math.max(r.near,Bn.distanceToPoint(it.origin));f=Is(r,d,c.resolution)}Bn.expandByScalar(f),it.intersectsBox(Bn)!==!1&&(n?Yu(this,t):Xu(this,r,t))}}class Os extends Ps{constructor(){super(),this.isLineGeometry=!0,this.type="LineGeometry"}setPositions(e){const t=e.length-3,n=new Float32Array(2*t);for(let r=0;r<t;r+=3)n[2*r]=e[r],n[2*r+1]=e[r+1],n[2*r+2]=e[r+2],n[2*r+3]=e[r+3],n[2*r+4]=e[r+4],n[2*r+5]=e[r+5];return super.setPositions(n),this}setColors(e){const t=e.length-3,n=new Float32Array(2*t);for(let r=0;r<t;r+=3)n[2*r]=e[r],n[2*r+1]=e[r+1],n[2*r+2]=e[r+2],n[2*r+3]=e[r+3],n[2*r+4]=e[r+4],n[2*r+5]=e[r+5];return super.setColors(n),this}fromLine(e){const t=e.geometry;return this.setPositions(t.attributes.position.array),this}}class Ku extends Zu{constructor(e=new Os,t=new Lr({color:Math.random()*16777215})){super(e,t),this.isLine2=!0,this.type="Line2"}}const qu=["object"],ks=u.defineComponent({__name:"Line2",props:{points:{},vertexColors:{default:null},color:{default:"white"},lineWidth:{default:1},worldUnits:{type:Boolean,default:!1},alphaToCoverage:{type:Boolean,default:!1},dashed:{type:Boolean,default:!1},dashSize:{default:1},gapSize:{default:1},dashScale:{default:1},dashOffset:{default:0}},setup(o){const e=o;function t(f,d){if(!f||f.length===0)return new Array(d).fill(oe.normalizeColor(e.color));if(f.length===1)return new Array(d).fill(oe.normalizeColor(f[0]));if(f.length===d)return f.map(oe.normalizeColor);const p=d-1,m=f.map(oe.normalizeColor);closed&&m.push(m[0].clone());const x=[m[0]],b=p/(m.length-1);for(let v=1;v<p;v++){const _=v%b/b,T=Math.floor(v/b);x.push(m[T].clone().lerp(m[T+1],_))}return x.push(m[m.length-1]),x}function n(f,d,p){const m=d.map(b=>b instanceof l.Vector3?[b.x,b.y,b.z]:b instanceof l.Vector2?[b.x,b.y,0]:Array.isArray(b)&&b.length===2?[b[0],b[1],0]:b).flat();f.setPositions(m.flat());const x=t(p,d.length).map(b=>b.toArray()).flat();f.setColors(x),a.computeLineDistances()}function r(f,d){f.color=oe.normalizeColor(d.color),f.linewidth=d.lineWidth,f.alphaToCoverage=d.alphaToCoverage,f.worldUnits=d.worldUnits,f.vertexColors=Array.isArray(d.vertexColors),f.dashed=d.dashed,f.dashScale=d.dashScale,f.dashSize=d.dashSize,f.dashOffset=d.dashOffset,f.gapSize=d.gapSize,f.needsUpdate=!0}const i=new Lr,s=new Os,a=new Ku(s,i),c=oe.useTresContext().sizes,h=u.computed(()=>Array.isArray(e.vertexColors));return r(i,e),n(s,e.points,e.vertexColors),a.computeLineDistances(),u.watch(()=>[e.color,e.lineWidth,e.alphaToCoverage,e.worldUnits,h,e.dashed,e.dashScale,e.dashSize,e.dashOffset],()=>r(i,e)),u.watch([e.points,e.vertexColors],()=>n(s,e.points,e.vertexColors)),u.watch(()=>e.vertexColors,()=>n(s,e.points,e.vertexColors)),u.watch(()=>e.points,()=>n(s,e.points,e.vertexColors)),u.watch([c.height,c.width],()=>i.resolution=new l.Vector2(c.width.value,c.height.value)),u.onUnmounted(()=>{s.dispose(),i.dispose()}),(f,d)=>(u.openBlock(),u.createElementBlock("primitive",{object:u.unref(a)},null,8,qu))}}),Qu=u.defineComponent({__name:"CatmullRomCurve3",props:{segments:{default:20},closed:{type:Boolean,default:!1},curveType:{default:"centripetal"},tension:{default:.5},points:{},vertexColors:{},color:{},lineWidth:{},alphaToCoverage:{type:Boolean},dashed:{type:Boolean},dashSize:{},dashScale:{},dashOffset:{},gapSize:{},worldUnits:{type:Boolean}},setup(o){const e=o;function t(s,a,c,h){const f=s.map(d=>d instanceof l.Vector3?d:new l.Vector3(...d));return new l.CatmullRomCurve3(f,a,c,h)}function n(s,a){return s.getPoints(a)}const r=u.computed(()=>t(e.points,e.closed,e.curveType,e.tension)),i=u.computed(()=>n(r.value,e.segments));return(s,a)=>(u.openBlock(),u.createBlock(ks,{points:i.value,"vertex-colors":e.vertexColors,color:e.color,lineWidth:e.lineWidth,alphaToCoverage:e.alphaToCoverage,dashed:e.dashed,dashSize:e.dashSize,dashScale:e.dashScale,dashOffset:e.dashOffset,gapSize:e.gapSize,worldUnits:e.worldUnits},null,8,["points","vertex-colors","color","lineWidth","alphaToCoverage","dashed","dashSize","dashScale","dashOffset","gapSize","worldUnits"]))}}),Ju=["args"],Hu=["color"],$u=u.defineComponent({__name:"Circle",props:{args:{default:()=>[1,32,0,Math.PI*2]},color:{default:"#ffffff"}},setup(o,{expose:e}){const t=o,{args:n,color:r}=u.toRefs(t),i=u.shallowRef();return e({value:i}),(s,a)=>(u.openBlock(),u.createElementBlock("TresMesh",u.mergeProps({ref_key:"circleRef",ref:i},s.$attrs),[u.createElementVNode("TresCircleGeometry",{args:u.unref(n)},null,8,Ju),u.renderSlot(s.$slots,"default",{},()=>[u.createElementVNode("TresMeshBasicMaterial",{color:u.unref(r)},null,8,Hu)])],16))}}),eh=["args"],th=["color"],nh=u.defineComponent({__name:"Cone",props:{args:{default:()=>[1,1,12,12,!1,0,Math.PI*2]},color:{default:"#ffffff"}},setup(o,{expose:e}){const t=o,{args:n,color:r}=u.toRefs(t),i=u.shallowRef();return e({value:i}),(s,a)=>(u.openBlock(),u.createElementBlock("TresMesh",u.mergeProps({ref_key:"coneRef",ref:i},s.$attrs),[u.createElementVNode("TresConeGeometry",{args:u.unref(n)},null,8,eh),u.renderSlot(s.$slots,"default",{},()=>[u.createElementVNode("TresMeshBasicMaterial",{color:u.unref(r)},null,8,th)])],16))}}),rh=["args"],ih=["color"],sh=u.defineComponent({__name:"Dodecahedron",props:{args:{default:()=>[1,0]},color:{default:"#ffffff"}},setup(o,{expose:e}){const t=o,{args:n,color:r}=u.toRefs(t),i=u.shallowRef();return e({value:i}),(s,a)=>(u.openBlock(),u.createElementBlock("TresMesh",u.mergeProps({ref_key:"dodecahedronRef",ref:i},s.$attrs),[u.createElementVNode("TresDodecahedronGeometry",{args:u.unref(n)},null,8,rh),u.renderSlot(s.$slots,"default",{},()=>[u.createElementVNode("TresMeshBasicMaterial",{color:u.unref(r)},null,8,ih)])],16))}}),oh=["args"],ah=["color"],lh=u.defineComponent({__name:"Icosahedron",props:{args:{default:()=>[1,0]},color:{default:"#ffffff"}},setup(o,{expose:e}){const t=o,{args:n,color:r}=u.toRefs(t),i=u.shallowRef();return e({value:i}),(s,a)=>(u.openBlock(),u.createElementBlock("TresMesh",u.mergeProps({ref_key:"icosahedronRef",ref:i},s.$attrs),[u.createElementVNode("TresIcosahedronGeometry",{args:u.unref(n)},null,8,oh),u.renderSlot(s.$slots,"default",{},()=>[u.createElementVNode("TresMeshBasicMaterial",{color:u.unref(r)},null,8,ah)])],16))}}),ch=["args"],uh=["color"],hh=u.defineComponent({__name:"Octahedron",props:{args:{default:()=>[1,0]},color:{default:"#ffffff"}},setup(o,{expose:e}){const t=o,{args:n,color:r}=u.toRefs(t),i=u.shallowRef();return e({value:i}),(s,a)=>(u.openBlock(),u.createElementBlock("TresMesh",u.mergeProps({ref_key:"octahedronRef",ref:i},s.$attrs),[u.createElementVNode("TresOctahedronGeometry",{args:u.unref(n)},null,8,ch),u.renderSlot(s.$slots,"default",{},()=>[u.createElementVNode("TresMeshBasicMaterial",{color:u.unref(r)},null,8,uh)])],16))}}),fh=["rotation"],dh=["args"],ph=["color"],mh=u.defineComponent({__name:"Plane",props:{args:{default:()=>[1,1]},color:{default:"#ffffff"}},setup(o,{expose:e}){const t=o,{args:n,color:r}=u.toRefs(t),i=u.shallowRef();return e({value:i}),(s,a)=>(u.openBlock(),u.createElementBlock("TresMesh",u.mergeProps({ref_key:"planeRef",ref:i,rotation:[-Math.PI/2,0,0]},s.$attrs),[u.createElementVNode("TresPlaneGeometry",{args:u.unref(n)},null,8,dh),u.renderSlot(s.$slots,"default",{},()=>[u.createElementVNode("TresMeshBasicMaterial",{color:u.unref(r)},null,8,ph)])],16,fh))}}),gh=["args"],yh=["color"],vh=u.defineComponent({__name:"Ring",props:{args:{default:()=>[.5,1,32]},color:{default:"#ffffff"}},setup(o,{expose:e}){const t=o,{args:n,color:r}=u.toRefs(t),i=u.shallowRef();return e({value:i}),(s,a)=>(u.openBlock(),u.createElementBlock("TresMesh",u.mergeProps({ref_key:"ringRef",ref:i},s.$attrs),[u.createElementVNode("TresRingGeometry",{args:u.unref(n)},null,8,gh),u.renderSlot(s.$slots,"default",{},()=>[u.createElementVNode("TresMeshBasicMaterial",{color:u.unref(r)},null,8,yh)])],16))}}),_h=["args"],xh=["color"],wh=u.defineComponent({__name:"RoundedBox",props:{args:{default:()=>[1,1,1,2,.1]},color:{default:"#ffffff"}},setup(o,{expose:e}){const t=o,{args:n,color:r}=u.toRefs(t),{extend:i}=oe.useTresContext();i({RoundedBoxGeometry:Ca});const s=u.shallowRef();return e({value:s}),(a,c)=>(u.openBlock(),u.createElementBlock("TresMesh",{ref_key:"roundedBoxRef",ref:s},[u.createElementVNode("TresRoundedBoxGeometry",{args:u.unref(n)},null,8,_h),u.renderSlot(a.$slots,"default",{},()=>[u.createElementVNode("TresMeshBasicMaterial",{color:u.unref(r)},null,8,xh)])],512))}}),bh=["args"],Mh=["color"],Sh=u.defineComponent({__name:"Sphere",props:{args:{default:()=>[2,32,16]},color:{default:"#ffffff"}},setup(o,{expose:e}){const t=o,{args:n,color:r}=u.toRefs(t),i=u.shallowRef();return e({value:i}),(s,a)=>(u.openBlock(),u.createElementBlock("TresMesh",u.mergeProps({ref_key:"sphereRef",ref:i},s.$attrs),[u.createElementVNode("TresSphereGeometry",{args:u.unref(n)},null,8,bh),u.renderSlot(s.$slots,"default",{},()=>[u.createElementVNode("TresMeshBasicMaterial",{color:u.unref(r)},null,8,Mh)])],16))}}),Ah=["geometry"],Ch=["color"],Ph=u.defineComponent({__name:"Superformula",props:{widthSegments:{default:32},heightSegments:{default:32},numArmsA:{default:4},expA:{default:()=>[40,1.3,.9]},numArmsB:{default:4},expB:{default:()=>[40,1.3,.9]},color:{default:"white"}},setup(o,{expose:e}){const t=o,{cos:n,sin:r,abs:i}=Math,s=u.shallowRef(),a=u.shallowRef(t.color);function c(p,m){const x=new l.BufferGeometry,b=p*m,v=new Float32Array(new Array(3*b).fill(0)),_=new Float32Array(new Array(3*b).fill(0)),T=[];for(let w=0;w<m-1;w++){for(let y=0;y<p-1;y++){const A=w*p+y,g=A+1,I=A+p,k=g+p;T.push(A,I,g),T.push(I,k,g)}const M=w*p+p-1,D=w*p,S=M+p,C=D+p;T.push(M,S,D),T.push(S,C,D)}return x.setIndex(T),x.setAttribute("position",new l.BufferAttribute(v,3)),x.setAttribute("normal",new l.BufferAttribute(_,3)),x}function h(p,m,x,b,v){return(i(n(m*p*.25))**b+i(r(m*p*.25))**v)**(-1/x)}function f(p,m,x,b,v,_,T,w,M,D,S){const C=2*Math.PI/D,y=-Math.PI,A=Math.PI/(S-1),g=-.5*Math.PI,I=p.getAttribute("position");let k=0,J=0,G=g;for(let Z=0;Z<S;Z++){J=y;for(let X=0;X<D;X++){const K=h(J,m,x,b,v),Y=h(G,_,T,w,M);I.setXYZ(k,K*n(J)*Y*n(G),Y*r(G),K*r(J)*Y*n(G)),k++,J+=C}G+=A}I.needsUpdate=!0,p.computeVertexNormals()}u.watch(()=>t.color,()=>a.value=t.color),u.watch(()=>[t.widthSegments,t.heightSegments],()=>{s.value&&s.value.dispose(),s.value=c(t.widthSegments,t.heightSegments)},{immediate:!0}),u.watch(()=>[t.numArmsA,t.expA[0],t.expA[1],t.expA[2],t.numArmsB,t.expB[0],t.expB[1],t.expB[2]],()=>f(s.value,t.numArmsA,t.expA[0],t.expA[1],t.expA[2],t.numArmsB,t.expB[0],t.expB[1],t.expB[2],t.widthSegments,t.heightSegments),{immediate:!0}),u.onUnmounted(()=>{s.value&&s.value.dispose()});const d=u.shallowRef();return e({value:d}),(p,m)=>(u.openBlock(),u.createElementBlock("TresMesh",u.mergeProps({ref_key:"superformulaRef",ref:d},p.$attrs,{geometry:s.value}),[u.renderSlot(p.$slots,"default",{},()=>[u.createElementVNode("TresMeshBasicMaterial",{color:a.value},null,8,Ch)])],16,Ah))}}),Th=["rotation"],Lh=["args"],Dh=["color"],Ih=u.defineComponent({__name:"Tetrahedron",props:{args:{default:()=>[1,0]},color:{default:"#ffffff"}},setup(o,{expose:e}){const t=o,{args:n,color:r}=u.toRefs(t),i=u.shallowRef();return e({value:i}),(s,a)=>(u.openBlock(),u.createElementBlock("TresMesh",u.mergeProps({ref_key:"tetrahedronRef",ref:i,rotation:[-Math.PI/2,0,0]},s.$attrs),[u.createElementVNode("TresTetrahedronGeometry",{args:u.unref(n)},null,8,Lh),u.renderSlot(s.$slots,"default",{},()=>[u.createElementVNode("TresMeshBasicMaterial",{color:u.unref(r)},null,8,Dh)])],16,Th))}}),Oh=["args"],kh=["color"],Bh=u.defineComponent({__name:"Torus",props:{args:{default:()=>[1,1,16,80]},color:{default:"#ffffff"}},setup(o,{expose:e}){const t=o,{args:n,color:r}=u.toRefs(t),i=u.shallowRef();return e({value:i}),(s,a)=>(u.openBlock(),u.createElementBlock("TresMesh",u.mergeProps({ref_key:"torusRef",ref:i},s.$attrs),[u.createElementVNode("TresTorusGeometry",{args:u.unref(n)},null,8,Oh),u.renderSlot(s.$slots,"default",{},()=>[u.createElementVNode("TresMeshBasicMaterial",{color:u.unref(r)},null,8,kh)])],16))}}),Fh=["args"],Uh=["color"],Nh=u.defineComponent({__name:"TorusKnot",props:{args:{default:()=>[1,.4,64,8]},color:{default:"#ffffff"}},setup(o,{expose:e}){const t=o,{args:n,color:r}=u.toRefs(t),i=u.shallowRef();return e({value:i}),(s,a)=>(u.openBlock(),u.createElementBlock("TresMesh",u.mergeProps({ref_key:"torusKnotRef",ref:i},s.$attrs),[u.createElementVNode("TresTorusKnotGeometry",{args:u.unref(n)},null,8,Fh),u.renderSlot(s.$slots,"default",{},()=>[u.createElementVNode("TresMeshBasicMaterial",{color:u.unref(r)},null,8,Uh)])],16))}}),zh=["args"],Vh=["color"],Rh=u.defineComponent({__name:"Tube",props:{args:{default:()=>[new l.QuadraticBezierCurve3(new l.Vector3(-1,0,0),new l.Vector3(0,1,0),new l.Vector3(1,0,0)),20,.2,8,!1]},color:{default:"#ffffff"}},setup(o,{expose:e}){const t=o,{args:n,color:r}=u.toRefs(t),i=u.shallowRef();return e({value:i}),(s,a)=>(u.openBlock(),u.createElementBlock("TresMesh",u.mergeProps({ref_key:"tubeRef",ref:i},s.$attrs),[u.createElementVNode("TresTubeGeometry",{args:u.unref(n)},null,8,zh),u.renderSlot(s.$slots,"default",{},()=>[u.createElementVNode("TresMeshBasicMaterial",{color:u.unref(r)},null,8,Vh)])],16))}});class Gh extends l.Object3D{constructor(){super();le(this,"virtualScene",null);this.virtualScene=new l.Scene}add(...t){return this.virtualScene.add(...t),this}destructor(){this.virtualScene.traverse(t=>{t instanceof l.Mesh&&(t.geometry.dispose(),t.material.dispose(),t.material.map&&t.material.map.dispose(),this.virtualScene.remove(t))}),this.virtualScene=null}}const jh=Gh,Eh=u.defineComponent({__name:"component",props:{background:{type:[Boolean,String],default:!1},blur:{default:0},files:{default:[]},path:{default:""},preset:{default:void 0},resolution:{default:256},near:{default:1},far:{default:1e3},frames:{default:1/0}},async setup(o,{expose:e}){let t,n;const r=o,i=u.ref(null);e({texture:i});const{extend:s,renderer:a,scene:c}=oe.useTresContext();let h=null,f=u.ref(null),d=null;const p=u.ref(null);u.onUnmounted(()=>{var _,T;(_=p.value)==null||_.destructor(),(T=f.value)==null||T.dispose()});const{onBeforeLoop:m}=oe.useRenderLoop();let x=1;m(()=>{d&&p.value&&f.value&&(r.frames===1/0||x<r.frames)&&(d.update(a.value,u.toRaw(p.value.virtualScene)),x++)});const b=([t,n]=u.withAsyncContext(()=>Ei(r,f)),t=await t,n(),t).texture,v=_=>{_?(c.value.environment=_.texture,r.background&&(c.value.background=_.texture)):(c.value.environment=b.value,r.background&&(c.value.background=b.value))};return u.watch(b,_=>{f.value&&v(f.value)},{immediate:!0,deep:!0}),u.watch(u.useSlots().default,_=>{var T,w;if(_&&(h=_,Array.isArray(h)&&h.length>0&&typeof((T=h[0])==null?void 0:T.type)!="symbol")){s({EnvSence:jh}),f.value=new l.WebGLCubeRenderTarget(r.resolution),f.value.texture.type=l.HalfFloatType,d=new l.CubeCamera(r.near,r.far,f.value),v(f.value);return}(w=f.value)==null||w.dispose(),f.value=null,v()},{immediate:!0,deep:!0}),i.value=b,(_,T)=>u.unref(f)?(u.openBlock(),u.createElementBlock("TresEnvSence",{key:0,ref_key:"envSence",ref:p},[u.renderSlot(_.$slots,"default")],512)):u.createCommentVNode("",!0)}}),Wh={key:0,args:[0,1,64]},Yh={key:1,args:[.5,1,64]},Xh={key:2},Zh=["toneMapped","map","side","color"],Kh=u.defineComponent({__name:"index",props:{args:{default:null},from:{default:"rect"},toneMapped:{type:Boolean,default:!1},map:{default:null},intensity:{default:1},color:{default:new l.Color(16777215)}},setup(o){const e=o,t=u.ref();return u.watchEffect(()=>{t.value&&(t.value.color.multiplyScalar(e.intensity),t.value.needsUpdate=!0)}),(n,r)=>(u.openBlock(),u.createElementBlock("TresMesh",null,[e.from==="circle"?(u.openBlock(),u.createElementBlock("TresRingGeometry",Wh)):e.from==="ring"?(u.openBlock(),u.createElementBlock("TresRingGeometry",Yh)):e.from==="rect"?(u.openBlock(),u.createElementBlock("TresPlaneGeometry",Xh)):(u.openBlock(),u.createBlock(e.from,{key:3,args:e})),u.createElementVNode("TresMeshBasicMaterial",{ref_key:"material",ref:t,toneMapped:n.toneMapped,map:n.map,side:u.unref(l.DoubleSide),color:n.color},null,8,Zh)]))}}),qh=["receive-shadow","rotation"],Qh=["args"],Jh=u.createElementVNode("TresMeshStandardMaterial",{color:8421504,side:2},null,-1),Hh=u.defineComponent({__name:"Backdrop",props:{floor:{default:.25},segments:{default:20},receiveShadow:{type:Boolean,default:!1}},setup(o){const e=o,t=a=>a===0?0:2**(10*a-10),{floor:n,segments:r,receiveShadow:i}=u.toRefs(e),s=u.ref(null);return u.watch(()=>[r.value,n.value,s.value],([a,c,h])=>{if(!h||a===null)return;let f=0;const d=a/a/2,p=h.attributes.position;for(let m=0;m<a+1;m++)for(let x=0;x<a+1;x++)p.setXYZ(f++,m/a-d+(m===0?-c:0),x/a-d,t(m/a));p.needsUpdate=!0,h.computeVertexNormals()}),(a,c)=>(u.openBlock(),u.createElementBlock("TresGroup",u.normalizeProps(u.guardReactiveProps(a.$attrs)),[u.createElementVNode("TresMesh",{"receive-shadow":u.unref(i),rotation:[-Math.PI/2,0,Math.PI/2]},[u.createElementVNode("TresPlaneGeometry",{ref_key:"planeRef",ref:s,args:[1,1,u.unref(r),u.unref(r)]},null,8,Qh),u.renderSlot(a.$slots,"default",{},()=>[Jh])],8,qh)],16))}}),$h=["geometry"],ef=["map","opacity","depth-write"],tf=["object"],nf=["args"],rf=["rotation","args"],sf=u.defineComponent({__name:"ContactShadows",props:{opacity:{default:1},width:{default:1},height:{default:1},blur:{default:1},far:{default:10},smooth:{type:Boolean,default:!0},resolution:{default:512},frames:{default:1/0},scale:{default:10},color:{default:"#000000"},depthWrite:{type:Boolean,default:!1},helper:{type:Boolean,default:!1}},setup(o,{expose:e}){const t=o,n=u.shallowRef(),r=u.shallowRef();e(n);let i,s,a,c,h;const{renderer:f,scene:d}=oe.useTresContext(),p=u.computed(()=>t.width*(Array.isArray(t.scale)?t.scale[0]:t.scale||1)),m=u.computed(()=>t.height*(Array.isArray(t.scale)?t.scale[1]:t.scale||1));u.watchEffect(()=>{i&&i.dispose(),s&&s.dispose(),a&&a.dispose(),c&&c.geometry.dispose(),i=new l.WebGLRenderTarget(t.resolution,t.resolution),s=new l.WebGLRenderTarget(t.resolution,t.resolution),s.texture.generateMipmaps=i.texture.generateMipmaps=!1,r.value=new l.OrthographicCamera(-p.value/2,p.value/2,m.value/2,-m.value/2,0,t.far),a=new l.PlaneGeometry(p.value,m.value).rotateX(Math.PI/2),c=new l.Mesh(a),c.visible=!1}),u.watchEffect(()=>{t.color&&(h&&h.dispose(),h=new l.MeshDepthMaterial,h.depthTest=h.depthWrite=!1,h.onBeforeCompile=D=>{D.uniforms={...D.uniforms,ucolor:{value:t.color?new l.Color(t.color):new l.Color}},D.fragmentShader=D.fragmentShader.replace("void main() {",`uniform vec3 ucolor;
              void main() {
-            `),L.fragmentShader=L.fragmentShader.replace("vec4( vec3( 1.0 - fragCoordZ ), opacity );","vec4( ucolor * fragCoordZ * 2.0, ( 1.0 - fragCoordZ ) * 1.0 );")})});const x=new c.ShaderMaterial(ba),w=new c.ShaderMaterial(Ma);w.depthTest=x.depthTest=!1;function v(L){!h.value||!s.value||(l.visible=!0,l.material=x,x.uniforms.tDiffuse.value=r.texture,x.uniforms.h.value=L/256,h.value.setRenderTarget(i),h.value.render(l,s.value),l.material=w,w.uniforms.tDiffuse.value=i.texture,w.uniforms.v.value=L/256,h.value.setRenderTarget(r),h.value.render(l,s.value),l.visible=!1)}const{onLoop:P}=ae.useRenderLoop();let D=0,S,_;return P(()=>{!s.value||d.value===void 0||h.value===void 0||(t.frames===1/0||D<t.frames)&&(D++,S=d.value.background,_=d.value.overrideMaterial,n.value.visible=!1,d.value.background=null,d.value.overrideMaterial=u,h.value.setRenderTarget(r),h.value.render(d.value,s.value),v(t.blur),t.smooth&&v(t.blur*.4),h.value.setRenderTarget(null),n.value.visible=!0,d.value.background=S,d.value.overrideMaterial=_)}),(L,b)=>(f.openBlock(),f.createElementBlock("TresGroup",f.mergeProps({ref_key:"groupRef",ref:n},L.$attrs),[f.createElementVNode("TresMesh",{scale:[1,-1,1],geometry:f.unref(a)},[f.createElementVNode("TresMeshBasicMaterial",{map:f.unref(r).texture,opacity:L.opacity,"depth-write":L.depthWrite,transparent:!0},null,8,zh)],8,Nh),f.createElementVNode("primitive",{object:f.unref(l)},null,8,Vh),s.value&&L.helper?(f.openBlock(),f.createElementBlock("TresCameraHelper",{key:0,args:[s.value]},null,8,Rh)):f.createCommentVNode("",!0),f.createElementVNode("TresOrthographicCamera",{ref_key:"shadowCamera",ref:s,position:[0,0,0],rotation:[Math.PI/2,0,0],args:[-y.value/2,y.value/2,g.value/2,-g.value/2,0,L.far]},null,8,Gh)],16))}}),Eh=["size","color","alpha-map","map","opacity","alpha-test","depth-write","transparent","size-attenuation"],Yh=["position","velocity"],Xh=f.defineComponent({__name:"Precipitation",props:{size:{default:.1},area:{default:()=>[10,10,20]},color:{default:16777215},map:{},alphaMap:{},alphaTest:{default:.01},opacity:{default:.8},count:{default:5e3},speed:{default:.1},randomness:{default:.5},depthWrite:{type:Boolean,default:!1},transparent:{type:Boolean,default:!0},sizeAttenuation:{type:Boolean,default:!0}},setup(o){const e=o,{size:t,area:n,color:s,alphaMap:r,map:i,opacity:a,alphaTest:l,depthWrite:u,transparent:h,sizeAttenuation:d,count:y,speed:g,randomness:x}=f.toRefs(e),w=f.shallowRef();let v=[],P=[];const D=()=>{v=new Float32Array(y.value*3);for(let L=0;L<y.value;L++){const b=L*3;v[b]=(Math.random()-.5)*n.value[0],v[b+1]=(Math.random()-.5)*n.value[1],v[b+2]=(Math.random()-.5)*n.value[2]}},S=()=>{P=new Float32Array(y.value*2);for(let L=0;L<y.value*2;L+=2)P[L]=(Math.random()-.5)/5*g.value*x.value,P[L+1]=Math.random()/5*g.value+.01};S(),D(),f.watchEffect(()=>{S(),D()});const{onLoop:_}=ae.useRenderLoop();return _(()=>{var L,b;if((L=w.value)!=null&&L.attributes.position.array&&((b=w.value)!=null&&b.attributes.position.count)){const C=w.value.attributes.position.array;for(let m=0;m<w.value.attributes.position.count;m++){const M=P[m*2],p=P[m*2+1];C[m*3]+=M,C[m*3+1]-=p,(C[m*3]<=-n.value[0]/2||C[m*3]>=n.value[0]/2)&&(C[m*3]=C[m*3]*-1),(C[m*3+1]<=-n.value[1]/2||C[m*3+1]>=n.value[1]/2)&&(C[m*3+1]=C[m*3+1]*-1)}w.value.attributes.position.needsUpdate=!0}}),(L,b)=>(f.openBlock(),f.createElementBlock("TresPoints",null,[f.createElementVNode("TresPointsMaterial",{size:f.unref(t),color:f.unref(s),"alpha-map":f.unref(r),map:f.unref(i),opacity:f.unref(a),"alpha-test":f.unref(l),"depth-write":f.unref(u),transparent:f.unref(h),"size-attenuation":f.unref(d)},null,8,Eh),f.createElementVNode("TresBufferGeometry",{ref_key:"geometryRef",ref:w,position:[f.unref(v),3],velocity:[f.unref(P)]},null,8,Yh)]))}});class Fn extends c.Mesh{constructor(){const e=Fn.SkyShader,t=new c.ShaderMaterial({name:e.name,uniforms:c.UniformsUtils.clone(e.uniforms),vertexShader:e.vertexShader,fragmentShader:e.fragmentShader,side:c.BackSide,depthWrite:!1});super(new c.BoxGeometry(1,1,1),t),this.isSky=!0}}Fn.SkyShader={name:"SkyShader",uniforms:{turbidity:{value:2},rayleigh:{value:1},mieCoefficient:{value:.005},mieDirectionalG:{value:.8},sunPosition:{value:new c.Vector3},up:{value:new c.Vector3(0,1,0)}},vertexShader:`
+            `),D.fragmentShader=D.fragmentShader.replace("vec4( vec3( 1.0 - fragCoordZ ), opacity );","vec4( ucolor * fragCoordZ * 2.0, ( 1.0 - fragCoordZ ) * 1.0 );")})});const x=new l.ShaderMaterial(Pa),b=new l.ShaderMaterial(Ta);b.depthTest=x.depthTest=!1;function v(D){!f.value||!r.value||(c.visible=!0,c.material=x,x.uniforms.tDiffuse.value=i.texture,x.uniforms.h.value=D/256,f.value.setRenderTarget(s),f.value.render(c,r.value),c.material=b,b.uniforms.tDiffuse.value=s.texture,b.uniforms.v.value=D/256,f.value.setRenderTarget(i),f.value.render(c,r.value),c.visible=!1)}const{onLoop:_}=oe.useRenderLoop();let T=0,w,M;return _(()=>{!r.value||d.value===void 0||f.value===void 0||(t.frames===1/0||T<t.frames)&&(T++,w=d.value.background,M=d.value.overrideMaterial,n.value.visible=!1,d.value.background=null,d.value.overrideMaterial=h,f.value.setRenderTarget(i),f.value.render(d.value,r.value),v(t.blur),t.smooth&&v(t.blur*.4),f.value.setRenderTarget(null),n.value.visible=!0,d.value.background=w,d.value.overrideMaterial=M)}),(D,S)=>(u.openBlock(),u.createElementBlock("TresGroup",u.mergeProps({ref_key:"groupRef",ref:n},D.$attrs),[u.createElementVNode("TresMesh",{scale:[1,-1,1],geometry:u.unref(a)},[u.createElementVNode("TresMeshBasicMaterial",{map:u.unref(i).texture,opacity:D.opacity,"depth-write":D.depthWrite,transparent:!0},null,8,ef)],8,$h),u.createElementVNode("primitive",{object:u.unref(c)},null,8,tf),r.value&&D.helper?(u.openBlock(),u.createElementBlock("TresCameraHelper",{key:0,args:[r.value]},null,8,nf)):u.createCommentVNode("",!0),u.createElementVNode("TresOrthographicCamera",{ref_key:"shadowCamera",ref:r,position:[0,0,0],rotation:[Math.PI/2,0,0],args:[-p.value/2,p.value/2,m.value/2,-m.value/2,0,D.far]},null,8,rf)],16))}}),of=["size","color","alpha-map","map","opacity","alpha-test","depth-write","transparent","size-attenuation"],af=["position","velocity"],lf=u.defineComponent({__name:"Precipitation",props:{size:{default:.1},area:{default:()=>[10,10,20]},color:{default:16777215},map:{},alphaMap:{},alphaTest:{default:.01},opacity:{default:.8},count:{default:5e3},speed:{default:.1},randomness:{default:.5},depthWrite:{type:Boolean,default:!1},transparent:{type:Boolean,default:!0},sizeAttenuation:{type:Boolean,default:!0}},setup(o){const e=o,{size:t,area:n,color:r,alphaMap:i,map:s,opacity:a,alphaTest:c,depthWrite:h,transparent:f,sizeAttenuation:d,count:p,speed:m,randomness:x}=u.toRefs(e),b=u.shallowRef();let v=[],_=[];const T=()=>{v=new Float32Array(p.value*3);for(let D=0;D<p.value;D++){const S=D*3;v[S]=(Math.random()-.5)*n.value[0],v[S+1]=(Math.random()-.5)*n.value[1],v[S+2]=(Math.random()-.5)*n.value[2]}},w=()=>{_=new Float32Array(p.value*2);for(let D=0;D<p.value*2;D+=2)_[D]=(Math.random()-.5)/5*m.value*x.value,_[D+1]=Math.random()/5*m.value+.01};w(),T(),u.watchEffect(()=>{w(),T()});const{onLoop:M}=oe.useRenderLoop();return M(()=>{var D,S;if((D=b.value)!=null&&D.attributes.position.array&&((S=b.value)!=null&&S.attributes.position.count)){const C=b.value.attributes.position.array;for(let y=0;y<b.value.attributes.position.count;y++){const A=_[y*2],g=_[y*2+1];C[y*3]+=A,C[y*3+1]-=g,(C[y*3]<=-n.value[0]/2||C[y*3]>=n.value[0]/2)&&(C[y*3]=C[y*3]*-1),(C[y*3+1]<=-n.value[1]/2||C[y*3+1]>=n.value[1]/2)&&(C[y*3+1]=C[y*3+1]*-1)}b.value.attributes.position.needsUpdate=!0}}),(D,S)=>(u.openBlock(),u.createElementBlock("TresPoints",null,[u.createElementVNode("TresPointsMaterial",{size:u.unref(t),color:u.unref(r),"alpha-map":u.unref(i),map:u.unref(s),opacity:u.unref(a),"alpha-test":u.unref(c),"depth-write":u.unref(h),transparent:u.unref(f),"size-attenuation":u.unref(d)},null,8,of),u.createElementVNode("TresBufferGeometry",{ref_key:"geometryRef",ref:b,position:[u.unref(v),3],velocity:[u.unref(_)]},null,8,af)]))}});class Un extends l.Mesh{constructor(){const e=Un.SkyShader,t=new l.ShaderMaterial({name:e.name,uniforms:l.UniformsUtils.clone(e.uniforms),vertexShader:e.vertexShader,fragmentShader:e.fragmentShader,side:l.BackSide,depthWrite:!1});super(new l.BoxGeometry(1,1,1),t),this.isSky=!0}}Un.SkyShader={name:"SkyShader",uniforms:{turbidity:{value:2},rayleigh:{value:1},mieCoefficient:{value:.005},mieDirectionalG:{value:.8},sunPosition:{value:new l.Vector3},up:{value:new l.Vector3(0,1,0)}},vertexShader:`
 		uniform vec3 sunPosition;
 		uniform float rayleigh;
 		uniform float turbidity;
@@ -1084,7 +1207,7 @@ list should be an Array.`),T.length===0)return new v(0);if(T.length===1)return T
 			#include <tonemapping_fragment>
 			#include <colorspace_fragment>
 
-		}`};const Wh=["object","material-uniforms-turbidity-value","material-uniforms-rayleigh-value","material-uniforms-mieCoefficient-value","material-uniforms-mieDirectionalG-value","material-uniforms-sunPosition-value","scale"],Zh=f.defineComponent({__name:"Sky",props:{turbidity:{default:3.4},rayleigh:{default:3},mieCoefficient:{default:.005},mieDirectionalG:{default:.7},elevation:{default:.6},azimuth:{default:180},distance:{default:45e4}},setup(o){const e=o,t=new Fn,n=f.computed(()=>s(e.azimuth,e.elevation));function s(r,i){const a=c.MathUtils.degToRad(90-i),l=c.MathUtils.degToRad(r);return new c.Vector3().setFromSphericalCoords(1,a,l)}return(r,i)=>(f.openBlock(),f.createElementBlock("primitive",{object:f.unref(t),"material-uniforms-turbidity-value":e.turbidity,"material-uniforms-rayleigh-value":e.rayleigh,"material-uniforms-mieCoefficient-value":e.mieCoefficient,"material-uniforms-mieDirectionalG-value":e.mieDirectionalG,"material-uniforms-sunPosition-value":n.value,scale:e.distance},null,8,Wh))}}),Kh=["position"],qh=["position"],Qh=["scale"],Jh=["map","depth-test","color-space","color","opacity"],Hh=f.defineComponent({__name:"Smoke",props:{color:{default:"#ffffff"},opacity:{default:.5},speed:{default:.4},width:{default:10},depth:{default:1.5},segments:{default:20},texture:{default:"https://raw.githubusercontent.com/Tresjs/assets/main/textures/clouds/defaultCloud.png"},depthTest:{type:Boolean,default:!0}},async setup(o,{expose:e}){let t,n;const s=o,{width:r,depth:i,segments:a,texture:l,color:u,depthTest:h,opacity:d,speed:y}=f.toRefs(s),g=f.shallowRef(),x=f.shallowRef();e({value:g});const w=[...new Array(a)].map((b,C)=>({x:r.value/2-Math.random()*r.value,y:r.value/2-Math.random()*r.value,scale:.4+Math.sin((C+1)/a.value*Math.PI)*((.2+Math.random())*10),density:Math.max(.2,Math.random()),rotation:Math.max(.002,.005*Math.random())*y.value})),v=(b,C)=>b/6*C*d.value,{map:P}=([t,n]=f.withAsyncContext(()=>ae.useTexture({map:l.value})),t=await t,n(),t),{renderer:D,camera:S}=ae.useTresContext(),_=f.computed(()=>{var b;return(b=D.value)==null?void 0:b.outputColorSpace}),{onLoop:L}=ae.useRenderLoop();return L(()=>{var b,C;g.value&&S.value&&x.value&&((b=x.value)==null||b.children.forEach((m,M)=>{m.rotation.z+=w[M].rotation}),g.value.lookAt((C=S.value)==null?void 0:C.position))}),(b,C)=>(f.openBlock(),f.createElementBlock("TresGroup",f.mergeProps({ref_key:"smokeRef",ref:g},b.$attrs),[f.createElementVNode("TresGroup",{ref_key:"groupRef",ref:x,position:[0,0,f.unref(a)/2*f.unref(i)]},[(f.openBlock(!0),f.createElementBlock(f.Fragment,null,f.renderList(f.unref(w),({scale:m,x:M,y:p,density:I},F)=>(f.openBlock(),f.createElementBlock("TresMesh",{key:`${F}`,position:[M,p,-F*f.unref(i)]},[f.createElementVNode("TresPlaneGeometry",{scale:[m,m,m],rotation:[0,0,0]},null,8,Qh),f.createElementVNode("TresMeshStandardMaterial",{map:f.unref(P),"depth-test":f.unref(h),"color-space":_.value,color:f.unref(u),"depth-write":!1,transparent:"",opacity:v(m,I)},null,8,Jh)],8,qh))),128))],8,Kh)],16))}});function $h(o){return Is(o,{normalizeValue:e=>ae.normalizeColor(e),getDefaultValue:()=>new c.Color(0,0,0),isSingleValue:e=>!Array.isArray(e),isMultipleValues:e=>Array.isArray(e)&&(e.length===0||!Array.isArray(e[0])),isMultipleValuesWithStops:e=>Array.isArray(e)&&e.length>0&&Array.isArray(e[0]),isEmpty:e=>Array.isArray(e)&&e.length===0})}function Ls(o){return"isVector3"in o||Array.isArray(o)&&o.length>0&&o.every(e=>typeof e=="number")}function ef(o){return Is(o,{normalizeValue:e=>ae.normalizeVectorFlexibleParam(e),getDefaultValue:()=>[0,0,0],isSingleValue:e=>Ls(e),isMultipleValues:e=>Array.isArray(e)&&e.length>0&&Ls(e[0]),isMultipleValuesWithStops:e=>Array.isArray(e)&&e.length>0&&Array.isArray(e[0])&&e[0].length===2&&Ls(e[0][1]),isEmpty:e=>Array.isArray(e)&&e.length===0})}function tf(o){return Is(o,{normalizeValue:e=>e,getDefaultValue:()=>1,isSingleValue:e=>!Array.isArray(e)&&typeof e<"u",isMultipleValues:e=>Array.isArray(e)&&(e.length===0||!Array.isArray(e[0])),isMultipleValuesWithStops:e=>Array.isArray(e)&&e.length>0&&Array.isArray(e[0]),isEmpty:e=>Array.isArray(e)&&e.length===0})}function Is(o,e){const{normalizeValue:t,getDefaultValue:n,isEmpty:s}=e,r=l=>e.isSingleValue(l),i=l=>e.isMultipleValues(l),a=l=>e.isMultipleValuesWithStops(l);if(s(o))return[[0,n()]];if(r(o))return[[0,t(o)]];if(i(o)){const l=o.length>1?1/(o.length-1):1;return o.map((u,h)=>[l*h,t(u)])}else if(a(o))return o.map(([l,u],h)=>[l,t(u)]);return[[0,n()]]}class nf{constructor(e,t){le(this,"entries");le(this,"resolution");this.entries=e,this.resolution=t}useTexture(){return new of(this.entries,this.resolution).use()}}class Ds{constructor(e,t,n,s,r,i){le(this,"data");le(this,"ref");le(this,"name");le(this,"valueMin");le(this,"valueMax");le(this,"suffix");le(this,"renderToCanvasGradient");this.data=f.isRef(e)?e.value:e,this.ref=f.isRef(e)?e:null,this.name=t,this.valueMin=n,this.valueMax=s,this.suffix=r,this.renderToCanvasGradient=i}}class sf extends Ds{constructor(e,t="color",n=0,s=1,r="rgba",i=af){super(e,t,n,s,r,i)}}class Ii extends Ds{constructor(e,t="scalar",n=0,s=1,r="x",i=lf){super(e,t,n,s,r,i)}}class rf extends Ds{constructor(e,t="scalar3",n=0,s=1,r="xyz",i=cf){super(e,t,n,s,r,i)}}class of{constructor(e,t){le(this,"entries");le(this,"size");le(this,"dirty",f.shallowRef(0));le(this,"context");this.entries=e,this.size=Math.max(t,e.length);const n=document.createElement("canvas");n.height=this.size,n.width=this.size,this.context=n.getContext("2d")}use(){const e=this.build(),t=f.shallowRef(e);for(const n of this.entries)n.ref&&f.watch(n.ref,()=>{var s;n.data=(s=n.ref)==null?void 0:s.value,f.triggerRef(this.dirty)});return fl(this.dirty,()=>{this.build(e),t.value=e},{throttle:1e3/60}),{texture:t,dispose:()=>e.dispose(),yFor:this.entries.reduce((n,s,r)=>(n[s.name]=(r+.5)/this.size,n),{})}}build(e){this.entries.forEach((n,s)=>{const r=this.context.createLinearGradient(0,s,this.size,s);n.renderToCanvasGradient(r,n),this.context.fillStyle=r,this.context.fillRect(0,s,this.size,1)}),e&&(e.source.data=this.context.getImageData(0,0,this.size,this.size));const t=e??new c.DataTexture(this.context.getImageData(0,0,this.size,this.size).data,this.size,this.size,c.RGBAFormat,c.UnsignedByteType,c.UVMapping,c.ClampToEdgeWrapping,c.ClampToEdgeWrapping);return t.needsUpdate=!0,t}}function Di(o,e,t,n,s){return bc(gt(o,e,t),e,t,n,s)}function af(o,e){return $h(e.data).forEach(([t,n])=>o.addColorStop(t,`rgb(${n.r*255}, ${n.g*255}, ${n.b*255})`))}function lf(o,e){return tf(e.data).forEach(([t,n])=>{o.addColorStop(t,`rgb(${Di(n,e.valueMin,e.valueMax,0,255)}, 0, 0)`)})}function cf(o,e){return ef(e.data).forEach(([t,n])=>o.addColorStop(t,`rgb(${n.map(s=>Di(s,e.valueMin,e.valueMax,0,255))})`))}class uf{constructor(e=256){le(this,"entries");le(this,"resolution");this.resolution=e,this.entries=[]}withResolution(e){return this.resolution=e,this}get add(){return new ff(e=>this.onAdd(e))}build(){return new nf(this.entries,this.resolution)}onAdd(e){return this.entries.push(e),new hf(e,this)}}class hf{constructor(e,t){le(this,"entry");le(this,"parent");this.entry=e,this.parent=t}id(e){return this.entry.name=e,this}range(e,t){return this.entry.valueMin=e,this.entry.valueMax=t,this}suffix(e){return this.entry.suffix=e,this}canvasGradientRenderer(e){return this.entry.renderToCanvasGradient=e,this}get add(){return this.parent.add}build(){return this.parent.build()}}class ff{constructor(e){le(this,"onAdd");this.onAdd=e}GradientTresColor(e){return this.onAdd(new sf(e))}Gradient01(e){return this.onAdd(new Ii(e,"zeroOne",0,1))}GradientScalar(e,t,n){return this.onAdd(new Ii(e,"scalar",t,n))}GradientXyz(e,t,n){return this.onAdd(new rf(e,"position",t,n))}}let Os=null;function df(){return Os===null&&(Os=new c.DataTexture(new Uint8Array([0,0,0,0]),1,1)),Os}const pf=["object"],mf=f.defineComponent({__name:"component",props:{map:{default:"https://raw.githubusercontent.com/Tresjs/assets/e41a93c56ec7cb5ac2d241f309e23582a5fe1fc6/textures/sparkles/particle.png"},geometry:{default:void 0},directionalLight:{default:void 0},lifetimeSec:{default:.4},cooldownSec:{default:2},normalThreshold:{default:.7},noiseScale:{default:3},scaleNoise:{default:1},offsetNoise:{default:.1},lifetimeNoise:{default:0},size:{default:1},alpha:{default:1},offset:{default:1},surfaceDistance:{default:1},sequenceColor:{default:()=>[[.7,"#82dbc5"],[.8,"#fbb03b"]]},sequenceAlpha:{default:()=>[[0,0],[.1,1],[.5,1],[.9,0]]},sequenceOffset:{default:()=>[0,0,0]},sequenceNoise:{default:()=>[.1,.1,.1]},sequenceSize:{default:()=>[0,1]},sequenceSurfaceDistance:{default:()=>[.05,.08,.1]},mixColor:{default:.5},mixAlpha:{default:1},mixOffset:{default:1},mixSize:{default:0},mixSurfaceDistance:{default:1},mixNoise:{default:1},blending:{default:c.AdditiveBlending},transparent:{type:Boolean,default:!0},depthWrite:{type:Boolean,default:!1}},setup(o){const e=o,t=parseInt(c.REVISION.replace(/\D+/g,"")),n=f.toRefs(e),s=typeof e.map=="string"?df():e.map,{texture:r,yFor:i}=new uf(256).add.GradientTresColor(n.sequenceColor).id("sequenceColor").add.Gradient01(n.sequenceAlpha).id("sequenceAlpha").add.Gradient01(n.sequenceSurfaceDistance).id("sequenceSurfaceDistance").add.Gradient01(n.sequenceSize).id("sequenceSize").add.GradientXyz(n.sequenceOffset,-1,1).id("sequenceOffset").add.GradientXyz(n.sequenceNoise,0,1).id("sequenceNoise").build().useTexture(),a={blending:e.blending,transparent:e.transparent,depthWrite:e.depthWrite,uniforms:{uMap:new c.Uniform(s),uPixelRatio:new c.Uniform(1),uNormal:new c.Uniform(c.Object3D.DEFAULT_UP),uNormalThreshold:new c.Uniform(e.normalThreshold),uTime:new c.Uniform(0),uCooldownRatio:new c.Uniform(1),uSize:new c.Uniform(e.size),uAlpha:new c.Uniform(e.alpha),uOffset:new c.Uniform(e.offset),uSurfaceDistance:new c.Uniform(e.surfaceDistance),uNoiseScale:new c.Uniform(e.noiseScale),uScaleNoise:new c.Uniform(e.scaleNoise),uOffsetNoise:new c.Uniform(e.offsetNoise),uLifetimeNoise:new c.Uniform(e.lifetimeNoise),uMixColor:new c.Uniform(e.mixColor),uMixAlpha:new c.Uniform(e.mixAlpha),uMixOffset:new c.Uniform(e.mixOffset),uMixSize:new c.Uniform(e.mixSize),uMixSurfaceDistance:new c.Uniform(e.mixSurfaceDistance),uMixNoise:new c.Uniform(e.mixNoise),uInfoTexture:new c.Uniform(r.value)},vertexShader:`
+		}`};const cf=["object","material-uniforms-turbidity-value","material-uniforms-rayleigh-value","material-uniforms-mieCoefficient-value","material-uniforms-mieDirectionalG-value","material-uniforms-sunPosition-value","scale"],uf=u.defineComponent({__name:"Sky",props:{turbidity:{default:3.4},rayleigh:{default:3},mieCoefficient:{default:.005},mieDirectionalG:{default:.7},elevation:{default:.6},azimuth:{default:180},distance:{default:45e4}},setup(o,{expose:e}){const t=o,n=u.shallowRef(),r=new Un,i=u.computed(()=>s(t.azimuth,t.elevation));function s(a,c){const h=l.MathUtils.degToRad(90-c),f=l.MathUtils.degToRad(a);return new l.Vector3().setFromSphericalCoords(1,h,f)}return e({root:n,sunPosition:i.value}),(a,c)=>(u.openBlock(),u.createElementBlock("primitive",{ref_key:"skyRef",ref:n,object:u.unref(r),"material-uniforms-turbidity-value":t.turbidity,"material-uniforms-rayleigh-value":t.rayleigh,"material-uniforms-mieCoefficient-value":t.mieCoefficient,"material-uniforms-mieDirectionalG-value":t.mieDirectionalG,"material-uniforms-sunPosition-value":i.value,scale:t.distance},null,8,cf))}}),hf=["position"],ff=["position"],df=["scale"],pf=["map","depth-test","color-space","color","opacity"],mf=u.defineComponent({__name:"Smoke",props:{color:{default:"#ffffff"},opacity:{default:.5},speed:{default:.4},width:{default:10},depth:{default:1.5},segments:{default:20},texture:{default:"https://raw.githubusercontent.com/Tresjs/assets/main/textures/clouds/defaultCloud.png"},depthTest:{type:Boolean,default:!0}},async setup(o,{expose:e}){let t,n;const r=o,{width:i,depth:s,segments:a,texture:c,color:h,depthTest:f,opacity:d,speed:p}=u.toRefs(r),m=u.shallowRef(),x=u.shallowRef();e({value:m});const b=[...new Array(a)].map((S,C)=>({x:i.value/2-Math.random()*i.value,y:i.value/2-Math.random()*i.value,scale:.4+Math.sin((C+1)/a.value*Math.PI)*((.2+Math.random())*10),density:Math.max(.2,Math.random()),rotation:Math.max(.002,.005*Math.random())*p.value})),v=(S,C)=>S/6*C*d.value,{map:_}=([t,n]=u.withAsyncContext(()=>oe.useTexture({map:c.value})),t=await t,n(),t),{renderer:T,camera:w}=oe.useTresContext(),M=u.computed(()=>{var S;return(S=T.value)==null?void 0:S.outputColorSpace}),{onLoop:D}=oe.useRenderLoop();return D(()=>{var S,C;m.value&&w.value&&x.value&&((S=x.value)==null||S.children.forEach((y,A)=>{y.rotation.z+=b[A].rotation}),m.value.lookAt((C=w.value)==null?void 0:C.position))}),(S,C)=>(u.openBlock(),u.createElementBlock("TresGroup",u.mergeProps({ref_key:"smokeRef",ref:m},S.$attrs),[u.createElementVNode("TresGroup",{ref_key:"groupRef",ref:x,position:[0,0,u.unref(a)/2*u.unref(s)]},[(u.openBlock(!0),u.createElementBlock(u.Fragment,null,u.renderList(u.unref(b),({scale:y,x:A,y:g,density:I},k)=>(u.openBlock(),u.createElementBlock("TresMesh",{key:`${k}`,position:[A,g,-k*u.unref(s)]},[u.createElementVNode("TresPlaneGeometry",{scale:[y,y,y],rotation:[0,0,0]},null,8,df),u.createElementVNode("TresMeshStandardMaterial",{map:u.unref(_),"depth-test":u.unref(f),"color-space":M.value,color:u.unref(h),"depth-write":!1,transparent:"",opacity:v(y,I)},null,8,pf)],8,ff))),128))],8,hf)],16))}});function gf(o){return kr(o,{normalizeValue:e=>oe.normalizeColor(e),getDefaultValue:()=>new l.Color(0,0,0),isSingleValue:e=>!Array.isArray(e),isMultipleValues:e=>Array.isArray(e)&&(e.length===0||!Array.isArray(e[0])),isMultipleValuesWithStops:e=>Array.isArray(e)&&e.length>0&&Array.isArray(e[0]),isEmpty:e=>Array.isArray(e)&&e.length===0})}function Or(o){return"isVector3"in o||Array.isArray(o)&&o.length>0&&o.every(e=>typeof e=="number")}function yf(o){return kr(o,{normalizeValue:e=>oe.normalizeVectorFlexibleParam(e),getDefaultValue:()=>[0,0,0],isSingleValue:e=>Or(e),isMultipleValues:e=>Array.isArray(e)&&e.length>0&&Or(e[0]),isMultipleValuesWithStops:e=>Array.isArray(e)&&e.length>0&&Array.isArray(e[0])&&e[0].length===2&&Or(e[0][1]),isEmpty:e=>Array.isArray(e)&&e.length===0})}function vf(o){return kr(o,{normalizeValue:e=>e,getDefaultValue:()=>1,isSingleValue:e=>!Array.isArray(e)&&typeof e<"u",isMultipleValues:e=>Array.isArray(e)&&(e.length===0||!Array.isArray(e[0])),isMultipleValuesWithStops:e=>Array.isArray(e)&&e.length>0&&Array.isArray(e[0]),isEmpty:e=>Array.isArray(e)&&e.length===0})}function kr(o,e){const{normalizeValue:t,getDefaultValue:n,isEmpty:r}=e,i=c=>e.isSingleValue(c),s=c=>e.isMultipleValues(c),a=c=>e.isMultipleValuesWithStops(c);if(r(o))return[[0,n()]];if(i(o))return[[0,t(o)]];if(s(o)){const c=o.length>1?1/(o.length-1):1;return o.map((h,f)=>[c*f,t(h)])}else if(a(o))return o.map(([c,h],f)=>[c,t(h)]);return[[0,n()]]}class _f{constructor(e,t){le(this,"entries");le(this,"resolution");this.entries=e,this.resolution=t}useTexture(){return new bf(this.entries,this.resolution).use()}}class Br{constructor(e,t,n,r,i,s){le(this,"data");le(this,"ref");le(this,"name");le(this,"valueMin");le(this,"valueMax");le(this,"suffix");le(this,"renderToCanvasGradient");this.data=u.isRef(e)?e.value:e,this.ref=u.isRef(e)?e:null,this.name=t,this.valueMin=n,this.valueMax=r,this.suffix=i,this.renderToCanvasGradient=s}}class xf extends Br{constructor(e,t="color",n=0,r=1,i="rgba",s=Mf){super(e,t,n,r,i,s)}}class Bs extends Br{constructor(e,t="scalar",n=0,r=1,i="x",s=Sf){super(e,t,n,r,i,s)}}class wf extends Br{constructor(e,t="scalar3",n=0,r=1,i="xyz",s=Af){super(e,t,n,r,i,s)}}class bf{constructor(e,t){le(this,"entries");le(this,"size");le(this,"dirty",u.shallowRef(0));le(this,"context");this.entries=e,this.size=Math.max(t,e.length);const n=document.createElement("canvas");n.height=this.size,n.width=this.size,this.context=n.getContext("2d")}use(){const e=this.build(),t=u.shallowRef(e);for(const n of this.entries)n.ref&&u.watch(n.ref,()=>{var r;n.data=(r=n.ref)==null?void 0:r.value,u.triggerRef(this.dirty)});return yl(this.dirty,()=>{this.build(e),t.value=e},{throttle:1e3/60}),{texture:t,dispose:()=>e.dispose(),yFor:this.entries.reduce((n,r,i)=>(n[r.name]=(i+.5)/this.size,n),{})}}build(e){this.entries.forEach((n,r)=>{const i=this.context.createLinearGradient(0,r,this.size,r);n.renderToCanvasGradient(i,n),this.context.fillStyle=i,this.context.fillRect(0,r,this.size,1)}),e&&(e.source.data=this.context.getImageData(0,0,this.size,this.size));const t=e??new l.DataTexture(this.context.getImageData(0,0,this.size,this.size).data,this.size,this.size,l.RGBAFormat,l.UnsignedByteType,l.UVMapping,l.ClampToEdgeWrapping,l.ClampToEdgeWrapping);return t.needsUpdate=!0,t}}function Fs(o,e,t,n,r){return Ac(yt(o,e,t),e,t,n,r)}function Mf(o,e){return gf(e.data).forEach(([t,n])=>o.addColorStop(t,`rgb(${n.r*255}, ${n.g*255}, ${n.b*255})`))}function Sf(o,e){return vf(e.data).forEach(([t,n])=>{o.addColorStop(t,`rgb(${Fs(n,e.valueMin,e.valueMax,0,255)}, 0, 0)`)})}function Af(o,e){return yf(e.data).forEach(([t,n])=>o.addColorStop(t,`rgb(${n.map(r=>Fs(r,e.valueMin,e.valueMax,0,255))})`))}class Cf{constructor(e=256){le(this,"entries");le(this,"resolution");this.resolution=e,this.entries=[]}withResolution(e){return this.resolution=e,this}get add(){return new Tf(e=>this.onAdd(e))}build(){return new _f(this.entries,this.resolution)}onAdd(e){return this.entries.push(e),new Pf(e,this)}}class Pf{constructor(e,t){le(this,"entry");le(this,"parent");this.entry=e,this.parent=t}id(e){return this.entry.name=e,this}range(e,t){return this.entry.valueMin=e,this.entry.valueMax=t,this}suffix(e){return this.entry.suffix=e,this}canvasGradientRenderer(e){return this.entry.renderToCanvasGradient=e,this}get add(){return this.parent.add}build(){return this.parent.build()}}class Tf{constructor(e){le(this,"onAdd");this.onAdd=e}GradientTresColor(e){return this.onAdd(new xf(e))}Gradient01(e){return this.onAdd(new Bs(e,"zeroOne",0,1))}GradientScalar(e,t,n){return this.onAdd(new Bs(e,"scalar",t,n))}GradientXyz(e,t,n){return this.onAdd(new wf(e,"position",t,n))}}let Fr=null;function Lf(){return Fr===null&&(Fr=new l.DataTexture(new Uint8Array([0,0,0,0]),1,1)),Fr}const Df=["object"],If=u.defineComponent({__name:"component",props:{map:{default:"https://raw.githubusercontent.com/Tresjs/assets/e41a93c56ec7cb5ac2d241f309e23582a5fe1fc6/textures/sparkles/particle.png"},geometry:{default:void 0},directionalLight:{default:void 0},lifetimeSec:{default:.4},cooldownSec:{default:2},normalThreshold:{default:.7},noiseScale:{default:3},scaleNoise:{default:1},offsetNoise:{default:.1},lifetimeNoise:{default:0},size:{default:1},alpha:{default:1},offset:{default:1},surfaceDistance:{default:1},sequenceColor:{default:()=>[[.7,"#82dbc5"],[.8,"#fbb03b"]]},sequenceAlpha:{default:()=>[[0,0],[.1,1],[.5,1],[.9,0]]},sequenceOffset:{default:()=>[0,0,0]},sequenceNoise:{default:()=>[.1,.1,.1]},sequenceSize:{default:()=>[0,1]},sequenceSurfaceDistance:{default:()=>[.05,.08,.1]},mixColor:{default:.5},mixAlpha:{default:1},mixOffset:{default:1},mixSize:{default:0},mixSurfaceDistance:{default:1},mixNoise:{default:1},blending:{default:l.AdditiveBlending},transparent:{type:Boolean,default:!0},depthWrite:{type:Boolean,default:!1}},setup(o){const e=o,t=parseInt(l.REVISION.replace(/\D+/g,"")),n=u.toRefs(e),r=typeof e.map=="string"?Lf():e.map,{texture:i,yFor:s}=new Cf(256).add.GradientTresColor(n.sequenceColor).id("sequenceColor").add.Gradient01(n.sequenceAlpha).id("sequenceAlpha").add.Gradient01(n.sequenceSurfaceDistance).id("sequenceSurfaceDistance").add.Gradient01(n.sequenceSize).id("sequenceSize").add.GradientXyz(n.sequenceOffset,-1,1).id("sequenceOffset").add.GradientXyz(n.sequenceNoise,0,1).id("sequenceNoise").build().useTexture(),a={blending:e.blending,transparent:e.transparent,depthWrite:e.depthWrite,uniforms:{uMap:new l.Uniform(r),uPixelRatio:new l.Uniform(1),uNormal:new l.Uniform(l.Object3D.DEFAULT_UP),uNormalThreshold:new l.Uniform(e.normalThreshold),uTime:new l.Uniform(0),uCooldownRatio:new l.Uniform(1),uSize:new l.Uniform(e.size),uAlpha:new l.Uniform(e.alpha),uOffset:new l.Uniform(e.offset),uSurfaceDistance:new l.Uniform(e.surfaceDistance),uNoiseScale:new l.Uniform(e.noiseScale),uScaleNoise:new l.Uniform(e.scaleNoise),uOffsetNoise:new l.Uniform(e.offsetNoise),uLifetimeNoise:new l.Uniform(e.lifetimeNoise),uMixColor:new l.Uniform(e.mixColor),uMixAlpha:new l.Uniform(e.mixAlpha),uMixOffset:new l.Uniform(e.mixOffset),uMixSize:new l.Uniform(e.mixSize),uMixSurfaceDistance:new l.Uniform(e.mixSurfaceDistance),uMixNoise:new l.Uniform(e.mixNoise),uInfoTexture:new l.Uniform(i.value)},vertexShader:`
     uniform float uPixelRatio;
     uniform vec3 uNormal;
     uniform float uNormalThreshold;
@@ -1119,15 +1242,15 @@ list should be an Array.`),T.length===0)return new v(0);if(T.length===1)return T
       float lifetimeP = max(-0.0001, mix(-uCooldownRatio, 1. + cos(t) * lifetimeNoise, fract(t)));
       float surfaceDistance = texture2D(uInfoTexture, vec2(
         mix(normalP, lifetimeP, uMixSurfaceDistance),
-        ${i.sequenceSurfaceDistance})).x * uSurfaceDistance;
+        ${s.sequenceSurfaceDistance})).x * uSurfaceDistance;
 
       vec4 modelPosition = modelMatrix * (vec4(position, 1.0) + vec4(normal * surfaceDistance, 0.0));
       vec3 noise = texture2D(uInfoTexture, vec2(
         mix(normalP, lifetimeP, uMixNoise),
-        ${i.sequenceNoise})).xyz;
+        ${s.sequenceNoise})).xyz;
       vec3 offset = uOffset * (texture2D(uInfoTexture, vec2(
         mix(normalP, lifetimeP, uMixOffset),
-        ${i.sequenceOffset})).xyz * 2.0 - vec3(1.0, 1.0, 1.0));
+        ${s.sequenceOffset})).xyz * 2.0 - vec3(1.0, 1.0, 1.0));
       modelPosition.x += cos(t * uNoiseScale * 10.0) * 0.2 * uOffsetNoise * noise.x + offset.x;
       modelPosition.y += sin(t * uNoiseScale * 10.0) * 0.2 * uOffsetNoise * noise.y + offset.y;
       modelPosition.z += cos(t * uNoiseScale * 10.0) * 0.2 * uOffsetNoise * noise.z + offset.z;
@@ -1137,14 +1260,14 @@ list should be an Array.`),T.length===0)return new v(0);if(T.length===1)return T
       gl_Position = projectionPostion;
 
       gl_PointSize = 2.
-      * texture2D(uInfoTexture, vec2(mix(normalP, lifetimeP, uMixSize), ${i.sequenceSize})).x
+      * texture2D(uInfoTexture, vec2(mix(normalP, lifetimeP, uMixSize), ${s.sequenceSize})).x
       * mix(1., abs(sin(t * uNoiseScale + position.x * 13.9 + position.y * 73.1)), uScaleNoise)
       * uSize * (100.0 / -viewPosition.z) * uPixelRatio;
 
       if (gl_PointSize < 0.6 || lifetimeP < 0.0) { gl_Position = vec4(2, 2, 2, 1); }
 
-      vColor = texture2D(uInfoTexture, vec2(mix(normalP, lifetimeP, uMixColor), ${i.sequenceColor}))
-      * texture2D(uInfoTexture, vec2(mix(normalP, lifetimeP, uMixAlpha), ${i.sequenceAlpha})).x * uAlpha;
+      vColor = texture2D(uInfoTexture, vec2(mix(normalP, lifetimeP, uMixColor), ${s.sequenceColor}))
+      * texture2D(uInfoTexture, vec2(mix(normalP, lifetimeP, uMixAlpha), ${s.sequenceAlpha})).x * uAlpha;
     }`,fragmentShader:`
     varying vec4 vColor;
 
@@ -1155,7 +1278,103 @@ list should be an Array.`),T.length===0)return new v(0);if(T.length===1)return T
       gl_FragColor = vColor * texture2D(uMap, gl_PointCoord);
       #include <tonemapping_fragment>
       #include <${t>=154?"colorspace_fragment":"encodings_fragment"}>
-    }`},l=new c.ShaderMaterial(a),u=new c.Points(void 0,l),h=l.uniforms,d={immediate:!0};[[h.uPixelRatio,ae.useTresContext().sizes.aspectRatio],[h.uSize,n.size],[h.uNormalThreshold,n.normalThreshold],[h.uAlpha,n.alpha],[h.uOffset,n.offset],[h.uOffsetNoise,n.offsetNoise],[h.uMixColor,n.mixColor],[h.uMixAlpha,n.mixAlpha],[h.uMixOffset,n.mixOffset],[h.uMixSize,n.mixSize],[h.uMixSurfaceDistance,n.mixSurfaceDistance],[h.uMixNoise,n.mixNoise],[h.uInfoTexture,r]].forEach(([D,S])=>f.watch(S,()=>{D.value=S.value},d)),f.watch([n.noiseScale,n.lifetimeSec],()=>{h.uNoiseScale.value=n.noiseScale.value*n.lifetimeSec.value},d),f.watch([n.lifetimeSec,n.cooldownSec],()=>{h.uCooldownRatio.value=n.cooldownSec.value/n.lifetimeSec.value},d),f.watch(n.map,()=>{typeof n.map.value=="string"?ae.useTexture([n.map.value]).then(D=>l.uniforms.uMap.value=D):l.uniforms.uMap.value=n.map.value});const g=new c.Quaternion,x=new c.Vector3;ae.useRenderLoop().onLoop(({elapsed:D})=>{u.getWorldQuaternion(g),x.copy(e.directionalLight?e.directionalLight.position:c.Object3D.DEFAULT_UP).normalize(),x.applyQuaternion(g.invert()),l.uniforms.uNormal.value=x,l.uniforms.uTime.value=D/(e.cooldownSec+e.lifetimeSec)});function w(D){return D&&"isObject3D"in D}function v(D){return D&&"isBufferGeometry"in D}f.onMounted(()=>{e.geometry?v(e.geometry)?u.geometry.copy(e.geometry):w(e.geometry)&&"geometry"in e.geometry&&v(e.geometry.geometry)&&u.geometry.copy(e.geometry.geometry):w(u.parent)&&"geometry"in u.parent&&v(u.parent.geometry)?u.geometry.copy(u.parent.geometry):u.geometry=new c.IcosahedronGeometry(1,16),typeof e.map=="string"&&ae.useTexture([e.map]).then(D=>l.uniforms.uMap.value=D)}),f.onUnmounted(()=>{var D;(D=l.uniforms.uMap.value)==null||D.dispose(),r.value.dispose(),l.dispose()});const P=f.shallowRef();return(D,S)=>(f.openBlock(),f.createElementBlock("primitive",{ref_key:"sparkleRef",ref:P,object:f.unref(u)},null,8,pf))}}),gf=["position","a-scale"],yf=["size","size-attenuation","transparent","alpha-test","alpha-map"],_f=f.defineComponent({__name:"Stars",props:{size:{default:.1},sizeAttenuation:{type:Boolean,default:!0},transparent:{type:Boolean,default:!0},alphaTest:{default:.01},count:{default:5e3},depth:{default:50},radius:{default:100},alphaMap:{default:null}},setup(o,{expose:e}){const t=o,n=f.ref(),s=f.ref(),{radius:r,depth:i,count:a,size:l,sizeAttenuation:u,transparent:h,alphaMap:d,alphaTest:y}=f.toRefs(t),g=()=>{let w=r.value+i.value;const v=f.computed(()=>i.value/a.value),P=[],D=Array.from({length:a.value},()=>(.5+.5*Math.random())*4),S=_=>new c.Vector3().setFromSpherical(new c.Spherical(_,Math.acos(1-Math.random()*2),Math.random()*2*Math.PI)).toArray();for(let _=0;_<a.value;_++)w-=v.value*Math.random(),P.push(...S(w));n.value=new Float32Array(P),s.value=new Float32Array(D)};f.watchEffect(()=>{g()});const x=f.shallowRef();return e({value:x}),(w,v)=>(f.openBlock(),f.createElementBlock("TresPoints",{ref_key:"starsRef",ref:x},[f.createElementVNode("TresBufferGeometry",{position:[n.value,3],"a-scale":[s.value,1]},null,8,gf),f.createElementVNode("TresPointsMaterial",{size:f.unref(l),"size-attenuation":f.unref(u),transparent:f.unref(h),"alpha-test":f.unref(y),"alpha-map":f.unref(d)},null,8,yf)],512))}});let it;const vf=(o="body")=>{it||(it=new ji.Pane({container:document.querySelector(o)}),it.element.style.position="absolute",it.element.style.top="1rem",it.element.style.right="1rem",it.element.style.zIndex="9999");const{logWarning:e}=os();e("useTweakPane is deprecated as of Cientos v3.7.0 and will no longer be part of this package. Please migrate to @tresjs/leches package https://github.com/Tresjs/leches or v-tweakpane https://github.com/vinayakkulkarni/v-tweakpane instead.");function t(){it&&it.dispose()}return f.onMounted(()=>{const{resume:n}=ae.useRenderLoop();n()}),f.onUnmounted(()=>{t()}),{pane:it,disposeTweakPane:t}};var Oi={exports:{}};(function(o,e){(function(t,n){o.exports=n()})(Lc,function(){var t=function(){function n(g){return i.appendChild(g.dom),g}function s(g){for(var x=0;x<i.children.length;x++)i.children[x].style.display=x===g?"block":"none";r=g}var r=0,i=document.createElement("div");i.style.cssText="position:fixed;top:0;left:0;cursor:pointer;opacity:0.9;z-index:10000",i.addEventListener("click",function(g){g.preventDefault(),s(++r%i.children.length)},!1);var a=(performance||Date).now(),l=a,u=0,h=n(new t.Panel("FPS","#0ff","#002")),d=n(new t.Panel("MS","#0f0","#020"));if(self.performance&&self.performance.memory)var y=n(new t.Panel("MB","#f08","#201"));return s(0),{REVISION:16,dom:i,addPanel:n,showPanel:s,begin:function(){a=(performance||Date).now()},end:function(){u++;var g=(performance||Date).now();if(d.update(g-a,200),g>l+1e3&&(h.update(1e3*u/(g-l),100),l=g,u=0,y)){var x=performance.memory;y.update(x.usedJSHeapSize/1048576,x.jsHeapSizeLimit/1048576)}return g},update:function(){a=this.end()},domElement:i,setMode:s}};return t.Panel=function(n,s,r){var i=1/0,a=0,l=Math.round,u=l(window.devicePixelRatio||1),h=80*u,d=48*u,y=3*u,g=2*u,x=3*u,w=15*u,v=74*u,P=30*u,D=document.createElement("canvas");D.width=h,D.height=d,D.style.cssText="width:80px;height:48px";var S=D.getContext("2d");return S.font="bold "+9*u+"px Helvetica,Arial,sans-serif",S.textBaseline="top",S.fillStyle=r,S.fillRect(0,0,h,d),S.fillStyle=s,S.fillText(n,y,g),S.fillRect(x,w,v,P),S.fillStyle=r,S.globalAlpha=.9,S.fillRect(x,w,v,P),{dom:D,update:function(_,L){i=Math.min(i,_),a=Math.max(a,_),S.fillStyle=r,S.globalAlpha=1,S.fillRect(0,0,h,w),S.fillStyle=s,S.fillText(l(_)+" "+n+" ("+l(i)+"-"+l(a)+")",y,g),S.drawImage(D,x+u,w,v-u,P,x,w,v-u,P),S.fillRect(x+v-u,w,u,P),S.fillStyle=r,S.globalAlpha=.9,S.fillRect(x+v-u,w,u,l((1-_/L)*P))}}},t})})(Oi);var xf=Oi.exports;const wf=nn(xf),bf=f.defineComponent({name:"Stats",props:{showPanel:{type:Number,default:0}},setup(o,{expose:e}){const t=new wf;e({stats:t});const n=document.body;t.showPanel(o.showPanel||0),n==null||n.appendChild(t.dom);const{onBeforeLoop:s,onAfterLoop:r,resume:i}=ae.useRenderLoop();i(),s(()=>t.begin()),r(()=>t.end()),f.onUnmounted(()=>{n==null||n.removeChild(t.dom)})}});class Mf{constructor(e,t,n){this.name=e,this.fg=t,this.bg=n,this.PR=Math.round(window.devicePixelRatio||1),this.WIDTH=90*this.PR,this.HEIGHT=48*this.PR,this.TEXT_X=3*this.PR,this.TEXT_Y=2*this.PR,this.GRAPH_X=3*this.PR,this.GRAPH_Y=15*this.PR,this.GRAPH_WIDTH=84*this.PR,this.GRAPH_HEIGHT=30*this.PR,this.canvas=document.createElement("canvas"),this.canvas.width=90*this.PR,this.canvas.height=48*this.PR,this.canvas.style.width="90px",this.canvas.style.position="absolute",this.canvas.style.height="48px",this.canvas.style.cssText="width:90px;height:48px",this.context=this.canvas.getContext("2d"),this.context&&(this.context.font="bold "+9*this.PR+"px Helvetica,Arial,sans-serif",this.context.textBaseline="top",this.context.fillStyle=this.bg,this.context.fillRect(0,0,this.WIDTH,this.HEIGHT),this.context.fillStyle=this.fg,this.context.fillText(this.name,this.TEXT_X,this.TEXT_Y),this.context.fillRect(this.GRAPH_X,this.GRAPH_Y,this.GRAPH_WIDTH,this.GRAPH_HEIGHT),this.context.fillStyle=this.bg,this.context.globalAlpha=.9,this.context.fillRect(this.GRAPH_X,this.GRAPH_Y,this.GRAPH_WIDTH,this.GRAPH_HEIGHT))}update(e,t,n,s,r=0){let i=1/0,a=0;this.context&&(i=Math.min(i,e),a=Math.max(n,e),s=Math.max(s,t),this.context.fillStyle=this.bg,this.context.globalAlpha=1,this.context.fillRect(0,0,this.WIDTH,this.GRAPH_Y),this.context.fillStyle=this.fg,this.context.fillText(e.toFixed(r)+" "+this.name+" ("+i.toFixed(r)+"-"+parseFloat(a.toFixed(r))+")",this.TEXT_X,this.TEXT_Y),this.context.drawImage(this.canvas,this.GRAPH_X+this.PR,this.GRAPH_Y,this.GRAPH_WIDTH-this.PR,this.GRAPH_HEIGHT,this.GRAPH_X,this.GRAPH_Y,this.GRAPH_WIDTH-this.PR,this.GRAPH_HEIGHT),this.context.fillRect(this.GRAPH_X+this.GRAPH_WIDTH-this.PR,this.GRAPH_Y,this.PR,this.GRAPH_HEIGHT),this.context.fillStyle=this.bg,this.context.globalAlpha=.9,this.context.fillRect(this.GRAPH_X+this.GRAPH_WIDTH-this.PR,this.GRAPH_Y,this.PR,(1-t/s)*this.GRAPH_HEIGHT))}}const Fi=class Un{constructor({logsPerSecond:e=20,samplesLog:t=100,samplesGraph:n=10,precision:s=2,minimal:r=!1,horizontal:i=!0,mode:a=0}={}){this.totalCpuDuration=0,this.totalGpuDuration=0,this.totalFps=0,this.activeQuery=null,this.gpuQueries=[],this.renderCount=0,this.mode=a,this.horizontal=i,this.dom=document.createElement("div"),this.dom.style.cssText="position:fixed;top:0;left:0;opacity:0.9;z-index:10000;",r&&(this.dom.style.cssText+="cursor:pointer"),this.gl=null,this.query=null,this.isRunningCPUProfiling=!1,this.minimal=r,this.beginTime=(performance||Date).now(),this.prevTime=this.beginTime,this.prevCpuTime=this.beginTime,this.frames=0,this.renderCount=0,this.threeRendererPatched=!1,this.averageCpu={logs:[],graph:[]},this.averageGpu={logs:[],graph:[]},this.queryCreated=!1,this.fpsPanel=this.addPanel(new Un.Panel("FPS","#0ff","#002"),0),this.msPanel=this.addPanel(new Un.Panel("CPU","#0f0","#020"),1),this.gpuPanel=null,this.samplesLog=t,this.samplesGraph=n,this.precision=s,this.logsPerSecond=e,this.minimal?(this.dom.addEventListener("click",l=>{l.preventDefault(),this.showPanel(++this.mode%this.dom.children.length)},!1),this.mode=a,this.showPanel(this.mode)):window.addEventListener("resize",()=>{this.resizePanel(this.fpsPanel,0),this.resizePanel(this.msPanel,1),this.gpuPanel&&this.resizePanel(this.gpuPanel,2)})}patchThreeRenderer(e){const t=e.render,n=this;e.render=function(s,r){n.begin(),t.call(this,s,r),n.end()},this.threeRendererPatched=!0}resizePanel(e,t){e.canvas.style.position="absolute",this.minimal?e.canvas.style.display="none":(e.canvas.style.display="block",this.horizontal?(e.canvas.style.top="0px",e.canvas.style.left=t*e.WIDTH/e.PR+"px"):(e.canvas.style.left="0px",e.canvas.style.top=t*e.HEIGHT/e.PR+"px"))}addPanel(e,t){return e.canvas&&(this.dom.appendChild(e.canvas),this.resizePanel(e,t)),e}showPanel(e){for(let t=0;t<this.dom.children.length;t++){const n=this.dom.children[t];n.style.display=t===e?"block":"none"}this.mode=e}init(e){if(!e){console.error('Stats: The "canvas" parameter is undefined.');return}if(e.isWebGLRenderer&&!this.threeRendererPatched){const t=e;this.patchThreeRenderer(t),this.gl=t.getContext()}if(!this.gl&&e instanceof WebGL2RenderingContext)this.gl=e;else if(!this.gl&&e instanceof HTMLCanvasElement||e instanceof OffscreenCanvas){if(this.gl=e.getContext("webgl2"),!this.gl){console.error("Stats: Unable to obtain WebGL2 context.");return}}else if(!this.gl){console.error("Stats: Invalid input type. Expected WebGL2RenderingContext, HTMLCanvasElement, or OffscreenCanvas.");return}this.ext=this.gl.getExtension("EXT_disjoint_timer_query_webgl2"),this.ext&&(this.gpuPanel=this.addPanel(new Un.Panel("GPU","#ff0","#220"),2))}begin(){this.isRunningCPUProfiling||this.beginProfiling("cpu-started"),!(!this.gl||!this.ext)&&this.gl&&this.ext&&(this.activeQuery&&this.gl.endQuery(this.ext.TIME_ELAPSED_EXT),this.activeQuery=this.gl.createQuery(),this.activeQuery!==null&&this.gl.beginQuery(this.ext.TIME_ELAPSED_EXT,this.activeQuery))}end(){this.renderCount++,this.gl&&this.ext&&this.activeQuery&&(this.gl.endQuery(this.ext.TIME_ELAPSED_EXT),this.gpuQueries.push({query:this.activeQuery}),this.activeQuery=null)}processGpuQueries(){!this.gl||!this.ext||(this.totalGpuDuration=0,this.gpuQueries.forEach((e,t)=>{if(this.gl){const n=this.gl.getQueryParameter(e.query,this.gl.QUERY_RESULT_AVAILABLE),s=this.gl.getParameter(this.ext.GPU_DISJOINT_EXT);if(n&&!s){const i=this.gl.getQueryParameter(e.query,this.gl.QUERY_RESULT)*1e-6;this.totalGpuDuration+=i,this.gl.deleteQuery(e.query),this.gpuQueries.splice(t,1)}}}))}update(){this.processGpuQueries(),this.endProfiling("cpu-started","cpu-finished","cpu-duration"),this.addToAverage(this.totalCpuDuration,this.averageCpu),this.addToAverage(this.totalGpuDuration,this.averageGpu),this.renderCount=0,this.totalCpuDuration=0,this.totalGpuDuration=0,this.totalFps=0,this.beginTime=this.endInternal()}endInternal(){this.frames++;const e=(performance||Date).now();if(e>=this.prevCpuTime+1e3/this.logsPerSecond&&(this.updatePanel(this.msPanel,this.averageCpu),this.updatePanel(this.gpuPanel,this.averageGpu),this.prevCpuTime=e),e>=this.prevTime+1e3){const t=this.frames*1e3/(e-this.prevTime);this.fpsPanel.update(t,t,100,100,0),this.prevTime=e,this.frames=0}return e}addToAverage(e,t){t.logs.push(e),t.logs.length>this.samplesLog&&t.logs.shift(),t.graph.push(e),t.graph.length>this.samplesGraph&&t.graph.shift()}beginProfiling(e){window.performance&&(window.performance.mark(e),this.isRunningCPUProfiling=!0)}endProfiling(e,t,n){if(window.performance&&t&&this.isRunningCPUProfiling){window.performance.mark(t);const s=performance.measure(n,e,t);this.totalCpuDuration+=s.duration,this.isRunningCPUProfiling=!1}}updatePanel(e,t){if(t.logs.length>0){let n=0,s=.01;for(let a=0;a<t.logs.length;a++)n+=t.logs[a],t.logs[a]>s&&(s=t.logs[a]);let r=0,i=.01;for(let a=0;a<t.graph.length;a++)r+=t.graph[a],t.graph[a]>i&&(i=t.graph[a]);e&&e.update(n/Math.min(t.logs.length,this.samplesLog),r/Math.min(t.graph.length,this.samplesGraph),s,i,this.precision)}}get domElement(){return this.dom}get container(){return console.warn("Stats: Deprecated! this.container as been replaced to this.dom "),this.dom}};Fi.Panel=Mf;let Sf=Fi;const Af=f.defineComponent({name:"StatsGl",props:["logsPerSecond","samplesLog","samplesGraph","precision","horizontal","minimal","mode"],async setup(o,{expose:e}){const t=new Sf({logsPerSecond:o.logsPerSecond,samplesLog:o.samplesLog,samplesGraph:o.samplesGraph,precision:o.precision,horizontal:o.horizontal,minimal:o.minimal,mode:o.mode});e({statsGl:t});const n=document.body,s=t.dom||t.container;n==null||n.appendChild(s);const{renderer:r}=ae.useTresContext(),{onAfterLoop:i,resume:a}=ae.useRenderLoop();t.init(r.value),a(),i(()=>{t.update()}),f.onUnmounted(()=>{n==null||n.removeChild(s)})}}),Pf=f.defineComponent({name:"BakeShadows",setup(){const{renderer:o}=ae.useTresContext();f.watchEffect(()=>{o.value.shadowMap.autoUpdate=!1,o.value.shadowMap.needsUpdate=!0})}});var Cf=`#include <common>
+    }`},c=new l.ShaderMaterial(a),h=new l.Points(void 0,c),f=c.uniforms,d={immediate:!0};[[f.uPixelRatio,oe.useTresContext().sizes.aspectRatio],[f.uSize,n.size],[f.uNormalThreshold,n.normalThreshold],[f.uAlpha,n.alpha],[f.uOffset,n.offset],[f.uOffsetNoise,n.offsetNoise],[f.uMixColor,n.mixColor],[f.uMixAlpha,n.mixAlpha],[f.uMixOffset,n.mixOffset],[f.uMixSize,n.mixSize],[f.uMixSurfaceDistance,n.mixSurfaceDistance],[f.uMixNoise,n.mixNoise],[f.uInfoTexture,i]].forEach(([T,w])=>u.watch(w,()=>{T.value=w.value},d)),u.watch([n.noiseScale,n.lifetimeSec],()=>{f.uNoiseScale.value=n.noiseScale.value*n.lifetimeSec.value},d),u.watch([n.lifetimeSec,n.cooldownSec],()=>{f.uCooldownRatio.value=n.cooldownSec.value/n.lifetimeSec.value},d),u.watch(n.map,()=>{typeof n.map.value=="string"?oe.useTexture([n.map.value]).then(T=>c.uniforms.uMap.value=T):c.uniforms.uMap.value=n.map.value});const m=new l.Quaternion,x=new l.Vector3;oe.useRenderLoop().onLoop(({elapsed:T})=>{h.getWorldQuaternion(m),x.copy(e.directionalLight?e.directionalLight.position:l.Object3D.DEFAULT_UP).normalize(),x.applyQuaternion(m.invert()),c.uniforms.uNormal.value=x,c.uniforms.uTime.value=T/(e.cooldownSec+e.lifetimeSec)});function b(T){return T&&"isObject3D"in T}function v(T){return T&&"isBufferGeometry"in T}u.onMounted(()=>{e.geometry?v(e.geometry)?h.geometry.copy(e.geometry):b(e.geometry)&&"geometry"in e.geometry&&v(e.geometry.geometry)&&h.geometry.copy(e.geometry.geometry):b(h.parent)&&"geometry"in h.parent&&v(h.parent.geometry)?h.geometry.copy(h.parent.geometry):h.geometry=new l.IcosahedronGeometry(1,16),typeof e.map=="string"&&oe.useTexture([e.map]).then(T=>c.uniforms.uMap.value=T)}),u.onUnmounted(()=>{var T;(T=c.uniforms.uMap.value)==null||T.dispose(),i.value.dispose(),c.dispose()});const _=u.shallowRef();return(T,w)=>(u.openBlock(),u.createElementBlock("primitive",{ref_key:"sparkleRef",ref:_,object:u.unref(h)},null,8,Df))}}),Of=["position","a-scale"],kf=["size","size-attenuation","transparent","alpha-test","alpha-map"],Bf=u.defineComponent({__name:"Stars",props:{size:{default:.1},sizeAttenuation:{type:Boolean,default:!0},transparent:{type:Boolean,default:!0},alphaTest:{default:.01},count:{default:5e3},depth:{default:50},radius:{default:100},alphaMap:{default:null}},setup(o,{expose:e}){const t=o,n=u.ref(),r=u.ref(),{radius:i,depth:s,count:a,size:c,sizeAttenuation:h,transparent:f,alphaMap:d,alphaTest:p}=u.toRefs(t),m=()=>{let b=i.value+s.value;const v=u.computed(()=>s.value/a.value),_=[],T=Array.from({length:a.value},()=>(.5+.5*Math.random())*4),w=M=>new l.Vector3().setFromSpherical(new l.Spherical(M,Math.acos(1-Math.random()*2),Math.random()*2*Math.PI)).toArray();for(let M=0;M<a.value;M++)b-=v.value*Math.random(),_.push(...w(b));n.value=new Float32Array(_),r.value=new Float32Array(T)};u.watchEffect(()=>{m()});const x=u.shallowRef();return e({value:x}),(b,v)=>(u.openBlock(),u.createElementBlock("TresPoints",{ref_key:"starsRef",ref:x},[u.createElementVNode("TresBufferGeometry",{position:[n.value,3],"a-scale":[r.value,1]},null,8,Of),u.createElementVNode("TresPointsMaterial",{size:u.unref(c),"size-attenuation":u.unref(h),transparent:u.unref(f),"alpha-test":u.unref(p),"alpha-map":u.unref(d)},null,8,kf)],512))}});class Ff extends l.Mesh{constructor(e,t={}){super(e),this.isWater=!0;const n=this,r=t.textureWidth!==void 0?t.textureWidth:512,i=t.textureHeight!==void 0?t.textureHeight:512,s=t.clipBias!==void 0?t.clipBias:0,a=t.alpha!==void 0?t.alpha:1,c=t.time!==void 0?t.time:0,h=t.waterNormals!==void 0?t.waterNormals:null,f=t.sunDirection!==void 0?t.sunDirection:new l.Vector3(.70707,.70707,0),d=new l.Color(t.sunColor!==void 0?t.sunColor:16777215),p=new l.Color(t.waterColor!==void 0?t.waterColor:8355711),m=t.eye!==void 0?t.eye:new l.Vector3(0,0,0),x=t.distortionScale!==void 0?t.distortionScale:20,b=t.side!==void 0?t.side:l.FrontSide,v=t.fog!==void 0?t.fog:!1,_=new l.Plane,T=new l.Vector3,w=new l.Vector3,M=new l.Vector3,D=new l.Matrix4,S=new l.Vector3(0,0,-1),C=new l.Vector4,y=new l.Vector3,A=new l.Vector3,g=new l.Vector4,I=new l.Matrix4,k=new l.PerspectiveCamera,J=new l.WebGLRenderTarget(r,i),G={name:"MirrorShader",uniforms:l.UniformsUtils.merge([l.UniformsLib.fog,l.UniformsLib.lights,{normalSampler:{value:null},mirrorSampler:{value:null},alpha:{value:1},time:{value:0},size:{value:1},distortionScale:{value:20},textureMatrix:{value:new l.Matrix4},sunColor:{value:new l.Color(8355711)},sunDirection:{value:new l.Vector3(.70707,.70707,0)},eye:{value:new l.Vector3},waterColor:{value:new l.Color(5592405)}}]),vertexShader:`
+				uniform mat4 textureMatrix;
+				uniform float time;
+
+				varying vec4 mirrorCoord;
+				varying vec4 worldPosition;
+
+				#include <common>
+				#include <fog_pars_vertex>
+				#include <shadowmap_pars_vertex>
+				#include <logdepthbuf_pars_vertex>
+
+				void main() {
+					mirrorCoord = modelMatrix * vec4( position, 1.0 );
+					worldPosition = mirrorCoord.xyzw;
+					mirrorCoord = textureMatrix * mirrorCoord;
+					vec4 mvPosition =  modelViewMatrix * vec4( position, 1.0 );
+					gl_Position = projectionMatrix * mvPosition;
+
+				#include <beginnormal_vertex>
+				#include <defaultnormal_vertex>
+				#include <logdepthbuf_vertex>
+				#include <fog_vertex>
+				#include <shadowmap_vertex>
+			}`,fragmentShader:`
+				uniform sampler2D mirrorSampler;
+				uniform float alpha;
+				uniform float time;
+				uniform float size;
+				uniform float distortionScale;
+				uniform sampler2D normalSampler;
+				uniform vec3 sunColor;
+				uniform vec3 sunDirection;
+				uniform vec3 eye;
+				uniform vec3 waterColor;
+
+				varying vec4 mirrorCoord;
+				varying vec4 worldPosition;
+
+				vec4 getNoise( vec2 uv ) {
+					vec2 uv0 = ( uv / 103.0 ) + vec2(time / 17.0, time / 29.0);
+					vec2 uv1 = uv / 107.0-vec2( time / -19.0, time / 31.0 );
+					vec2 uv2 = uv / vec2( 8907.0, 9803.0 ) + vec2( time / 101.0, time / 97.0 );
+					vec2 uv3 = uv / vec2( 1091.0, 1027.0 ) - vec2( time / 109.0, time / -113.0 );
+					vec4 noise = texture2D( normalSampler, uv0 ) +
+						texture2D( normalSampler, uv1 ) +
+						texture2D( normalSampler, uv2 ) +
+						texture2D( normalSampler, uv3 );
+					return noise * 0.5 - 1.0;
+				}
+
+				void sunLight( const vec3 surfaceNormal, const vec3 eyeDirection, float shiny, float spec, float diffuse, inout vec3 diffuseColor, inout vec3 specularColor ) {
+					vec3 reflection = normalize( reflect( -sunDirection, surfaceNormal ) );
+					float direction = max( 0.0, dot( eyeDirection, reflection ) );
+					specularColor += pow( direction, shiny ) * sunColor * spec;
+					diffuseColor += max( dot( sunDirection, surfaceNormal ), 0.0 ) * sunColor * diffuse;
+				}
+
+				#include <common>
+				#include <packing>
+				#include <bsdfs>
+				#include <fog_pars_fragment>
+				#include <logdepthbuf_pars_fragment>
+				#include <lights_pars_begin>
+				#include <shadowmap_pars_fragment>
+				#include <shadowmask_pars_fragment>
+
+				void main() {
+
+					#include <logdepthbuf_fragment>
+					vec4 noise = getNoise( worldPosition.xz * size );
+					vec3 surfaceNormal = normalize( noise.xzy * vec3( 1.5, 1.0, 1.5 ) );
+
+					vec3 diffuseLight = vec3(0.0);
+					vec3 specularLight = vec3(0.0);
+
+					vec3 worldToEye = eye-worldPosition.xyz;
+					vec3 eyeDirection = normalize( worldToEye );
+					sunLight( surfaceNormal, eyeDirection, 100.0, 2.0, 0.5, diffuseLight, specularLight );
+
+					float distance = length(worldToEye);
+
+					vec2 distortion = surfaceNormal.xz * ( 0.001 + 1.0 / distance ) * distortionScale;
+					vec3 reflectionSample = vec3( texture2D( mirrorSampler, mirrorCoord.xy / mirrorCoord.w + distortion ) );
+
+					float theta = max( dot( eyeDirection, surfaceNormal ), 0.0 );
+					float rf0 = 0.3;
+					float reflectance = rf0 + ( 1.0 - rf0 ) * pow( ( 1.0 - theta ), 5.0 );
+					vec3 scatter = max( 0.0, dot( surfaceNormal, eyeDirection ) ) * waterColor;
+					vec3 albedo = mix( ( sunColor * diffuseLight * 0.3 + scatter ) * getShadowMask(), ( vec3( 0.1 ) + reflectionSample * 0.9 + reflectionSample * specularLight ), reflectance);
+					vec3 outgoingLight = albedo;
+					gl_FragColor = vec4( outgoingLight, alpha );
+
+					#include <tonemapping_fragment>
+					#include <colorspace_fragment>
+					#include <fog_fragment>	
+				}`},Z=new l.ShaderMaterial({name:G.name,uniforms:l.UniformsUtils.clone(G.uniforms),vertexShader:G.vertexShader,fragmentShader:G.fragmentShader,lights:!0,side:b,fog:v});Z.uniforms.mirrorSampler.value=J.texture,Z.uniforms.textureMatrix.value=I,Z.uniforms.alpha.value=a,Z.uniforms.time.value=c,Z.uniforms.normalSampler.value=h,Z.uniforms.sunColor.value=d,Z.uniforms.waterColor.value=p,Z.uniforms.sunDirection.value=f,Z.uniforms.distortionScale.value=x,Z.uniforms.eye.value=m,n.material=Z,n.onBeforeRender=function(X,K,Y){if(w.setFromMatrixPosition(n.matrixWorld),M.setFromMatrixPosition(Y.matrixWorld),D.extractRotation(n.matrixWorld),T.set(0,0,1),T.applyMatrix4(D),y.subVectors(w,M),y.dot(T)>0)return;y.reflect(T).negate(),y.add(w),D.extractRotation(Y.matrixWorld),S.set(0,0,-1),S.applyMatrix4(D),S.add(M),A.subVectors(w,S),A.reflect(T).negate(),A.add(w),k.position.copy(y),k.up.set(0,1,0),k.up.applyMatrix4(D),k.up.reflect(T),k.lookAt(A),k.far=Y.far,k.updateMatrixWorld(),k.projectionMatrix.copy(Y.projectionMatrix),I.set(.5,0,0,.5,0,.5,0,.5,0,0,.5,.5,0,0,0,1),I.multiply(k.projectionMatrix),I.multiply(k.matrixWorldInverse),_.setFromNormalAndCoplanarPoint(T,w),_.applyMatrix4(k.matrixWorldInverse),C.set(_.normal.x,_.normal.y,_.normal.z,_.constant);const te=k.projectionMatrix;g.x=(Math.sign(C.x)+te.elements[8])/te.elements[0],g.y=(Math.sign(C.y)+te.elements[9])/te.elements[5],g.z=-1,g.w=(1+te.elements[10])/te.elements[14],C.multiplyScalar(2/C.dot(g)),te.elements[2]=C.x,te.elements[6]=C.y,te.elements[10]=C.z+1-s,te.elements[14]=C.w,m.setFromMatrixPosition(Y.matrixWorld);const re=X.getRenderTarget(),ce=X.xr.enabled,j=X.shadowMap.autoUpdate;n.visible=!1,X.xr.enabled=!1,X.shadowMap.autoUpdate=!1,X.setRenderTarget(J),X.state.buffers.depth.setMask(!0),X.autoClear===!1&&X.clear(),X.render(K,k),n.visible=!0,X.xr.enabled=ce,X.shadowMap.autoUpdate=j,X.setRenderTarget(re);const z=Y.viewport;z!==void 0&&X.state.viewport(z)}}}const Uf=["rotation-x","args"],Nf=u.createElementVNode("TresPlaneGeometry",{args:[1e4,1e4]},null,-1),zf=u.defineComponent({__name:"Ocean",props:{textureWidth:{default:512},textureHeight:{default:512},waterNormals:{default:"https://raw.githubusercontent.com/Tresjs/assets/main/textures/water-normals/Water_1_M_Normal.jpg"},sunDirection:{default:()=>new l.Vector3},sunColor:{default:16777215},waterColor:{default:7695},distortionScale:{default:3.7},size:{default:1},clipBias:{default:0},alpha:{default:1},side:{default:l.FrontSide}},async setup(o,{expose:e}){let t,n;const r=o,{textureWidth:i,textureHeight:s,waterNormals:a,sunDirection:c,sunColor:h,waterColor:f,distortionScale:d,size:p,clipBias:m,alpha:x,side:b}=u.toRefs(r),{extend:v,scene:_}=oe.useTresContext();v({Water:Ff});const T=u.shallowRef(),w=u.shallowRef(),M=_.value.fog!==void 0;e({root:T}),_.value.traverse(C=>{C.hasOwnProperty("isSky")&&(w.value=C)}),u.onMounted(async()=>{if(await u.nextTick(),w.value){const C=w.value.material.uniforms.sunPosition.value;T.value.material.uniforms.sunDirection.value.copy(C)}});const{normalMap:D}=([t,n]=u.withAsyncContext(()=>oe.useTexture({normalMap:a.value})),t=await t,n(),t);D.wrapS=D.wrapT=l.RepeatWrapping;const{onLoop:S}=oe.useRenderLoop();return S(({delta:C})=>{T.value.material.uniforms.time.value+=C}),(C,y)=>(u.openBlock(),u.createElementBlock("TresWater",{ref_key:"waterRef",ref:T,"rotation-x":-Math.PI/2,args:[void 0,{textureWidth:u.unref(i),textureHeight:u.unref(s),waterNormals:u.unref(D),sunDirection:u.unref(c),sunColor:u.unref(h),waterColor:u.unref(f),distortionScale:u.unref(d),fog:M,size:u.unref(p),clipBias:u.unref(m),alpha:u.unref(x),side:u.unref(b)}]},[u.renderSlot(C.$slots,"default",{},()=>[Nf])],8,Uf))}});let ot;const Vf=(o="body")=>{ot||(ot=new Xs.Pane({container:document.querySelector(o)}),ot.element.style.position="absolute",ot.element.style.top="1rem",ot.element.style.right="1rem",ot.element.style.zIndex="9999");const{logWarning:e}=lr();e("useTweakPane is deprecated as of Cientos v3.7.0 and will no longer be part of this package. Please migrate to @tresjs/leches package https://github.com/Tresjs/leches or v-tweakpane https://github.com/vinayakkulkarni/v-tweakpane instead.");function t(){ot&&ot.dispose()}return u.onMounted(()=>{const{resume:n}=oe.useRenderLoop();n()}),u.onUnmounted(()=>{t()}),{pane:ot,disposeTweakPane:t}};var Us={exports:{}};(function(o,e){(function(t,n){o.exports=n()})(Oc,function(){var t=function(){function n(m){return s.appendChild(m.dom),m}function r(m){for(var x=0;x<s.children.length;x++)s.children[x].style.display=x===m?"block":"none";i=m}var i=0,s=document.createElement("div");s.style.cssText="position:fixed;top:0;left:0;cursor:pointer;opacity:0.9;z-index:10000",s.addEventListener("click",function(m){m.preventDefault(),r(++i%s.children.length)},!1);var a=(performance||Date).now(),c=a,h=0,f=n(new t.Panel("FPS","#0ff","#002")),d=n(new t.Panel("MS","#0f0","#020"));if(self.performance&&self.performance.memory)var p=n(new t.Panel("MB","#f08","#201"));return r(0),{REVISION:16,dom:s,addPanel:n,showPanel:r,begin:function(){a=(performance||Date).now()},end:function(){h++;var m=(performance||Date).now();if(d.update(m-a,200),m>c+1e3&&(f.update(1e3*h/(m-c),100),c=m,h=0,p)){var x=performance.memory;p.update(x.usedJSHeapSize/1048576,x.jsHeapSizeLimit/1048576)}return m},update:function(){a=this.end()},domElement:s,setMode:r}};return t.Panel=function(n,r,i){var s=1/0,a=0,c=Math.round,h=c(window.devicePixelRatio||1),f=80*h,d=48*h,p=3*h,m=2*h,x=3*h,b=15*h,v=74*h,_=30*h,T=document.createElement("canvas");T.width=f,T.height=d,T.style.cssText="width:80px;height:48px";var w=T.getContext("2d");return w.font="bold "+9*h+"px Helvetica,Arial,sans-serif",w.textBaseline="top",w.fillStyle=i,w.fillRect(0,0,f,d),w.fillStyle=r,w.fillText(n,p,m),w.fillRect(x,b,v,_),w.fillStyle=i,w.globalAlpha=.9,w.fillRect(x,b,v,_),{dom:T,update:function(M,D){s=Math.min(s,M),a=Math.max(a,M),w.fillStyle=i,w.globalAlpha=1,w.fillRect(0,0,f,b),w.fillStyle=r,w.fillText(c(M)+" "+n+" ("+c(s)+"-"+c(a)+")",p,m),w.drawImage(T,x+h,b,v-h,_,x,b,v-h,_),w.fillRect(x+v-h,b,h,_),w.fillStyle=i,w.globalAlpha=.9,w.fillRect(x+v-h,b,h,c((1-M/D)*_))}}},t})})(Us);var Rf=Us.exports;const Gf=on(Rf),jf=u.defineComponent({name:"Stats",props:{showPanel:{type:Number,default:0}},setup(o,{expose:e}){const t=new Gf;e({stats:t});const n=document.body;t.showPanel(o.showPanel||0),n==null||n.appendChild(t.dom);const{onBeforeLoop:r,onAfterLoop:i,resume:s}=oe.useRenderLoop();s(),r(()=>t.begin()),i(()=>t.end()),u.onUnmounted(()=>{n==null||n.removeChild(t.dom)})}});class Ef{constructor(e,t,n){this.name=e,this.fg=t,this.bg=n,this.PR=Math.round(window.devicePixelRatio||1),this.WIDTH=90*this.PR,this.HEIGHT=48*this.PR,this.TEXT_X=3*this.PR,this.TEXT_Y=2*this.PR,this.GRAPH_X=3*this.PR,this.GRAPH_Y=15*this.PR,this.GRAPH_WIDTH=84*this.PR,this.GRAPH_HEIGHT=30*this.PR,this.canvas=document.createElement("canvas"),this.canvas.width=90*this.PR,this.canvas.height=48*this.PR,this.canvas.style.width="90px",this.canvas.style.position="absolute",this.canvas.style.height="48px",this.canvas.style.cssText="width:90px;height:48px",this.context=this.canvas.getContext("2d"),this.context&&(this.context.font="bold "+9*this.PR+"px Helvetica,Arial,sans-serif",this.context.textBaseline="top",this.context.fillStyle=this.bg,this.context.fillRect(0,0,this.WIDTH,this.HEIGHT),this.context.fillStyle=this.fg,this.context.fillText(this.name,this.TEXT_X,this.TEXT_Y),this.context.fillRect(this.GRAPH_X,this.GRAPH_Y,this.GRAPH_WIDTH,this.GRAPH_HEIGHT),this.context.fillStyle=this.bg,this.context.globalAlpha=.9,this.context.fillRect(this.GRAPH_X,this.GRAPH_Y,this.GRAPH_WIDTH,this.GRAPH_HEIGHT))}update(e,t,n,r,i=0){let s=1/0,a=0;this.context&&(s=Math.min(s,e),a=Math.max(n,e),r=Math.max(r,t),this.context.fillStyle=this.bg,this.context.globalAlpha=1,this.context.fillRect(0,0,this.WIDTH,this.GRAPH_Y),this.context.fillStyle=this.fg,this.context.fillText(e.toFixed(i)+" "+this.name+" ("+s.toFixed(i)+"-"+parseFloat(a.toFixed(i))+")",this.TEXT_X,this.TEXT_Y),this.context.drawImage(this.canvas,this.GRAPH_X+this.PR,this.GRAPH_Y,this.GRAPH_WIDTH-this.PR,this.GRAPH_HEIGHT,this.GRAPH_X,this.GRAPH_Y,this.GRAPH_WIDTH-this.PR,this.GRAPH_HEIGHT),this.context.fillRect(this.GRAPH_X+this.GRAPH_WIDTH-this.PR,this.GRAPH_Y,this.PR,this.GRAPH_HEIGHT),this.context.fillStyle=this.bg,this.context.globalAlpha=.9,this.context.fillRect(this.GRAPH_X+this.GRAPH_WIDTH-this.PR,this.GRAPH_Y,this.PR,(1-t/r)*this.GRAPH_HEIGHT))}}const Ns=class Et{constructor({logsPerSecond:e=20,samplesLog:t=100,samplesGraph:n=10,precision:r=2,minimal:i=!1,horizontal:s=!0,mode:a=0}={}){this.totalCpuDuration=0,this.totalGpuDuration=0,this.totalGpuDurationCompute=0,this.totalFps=0,this.activeQuery=null,this.gpuQueries=[],this.renderCount=0,this.mode=a,this.horizontal=s,this.dom=document.createElement("div"),this.dom.style.cssText="position:fixed;top:0;left:0;opacity:0.9;z-index:10000;",i&&(this.dom.style.cssText+="cursor:pointer"),this.gl=null,this.query=null,this.isRunningCPUProfiling=!1,this.minimal=i,this.beginTime=(performance||Date).now(),this.prevTime=this.beginTime,this.prevCpuTime=this.beginTime,this.frames=0,this.renderCount=0,this.threeRendererPatched=!1,this.averageCpu={logs:[],graph:[]},this.averageGpu={logs:[],graph:[]},this.averageGpuCompute={logs:[],graph:[]},this.queryCreated=!1,this.fpsPanel=this.addPanel(new Et.Panel("FPS","#0ff","#002"),0),this.msPanel=this.addPanel(new Et.Panel("CPU","#0f0","#020"),1),this.gpuPanel=null,this.gpuPanelCompute=null,this.samplesLog=t,this.samplesGraph=n,this.precision=r,this.logsPerSecond=e,this.minimal?(this.dom.addEventListener("click",c=>{c.preventDefault(),this.showPanel(++this.mode%this.dom.children.length)},!1),this.mode=a,this.showPanel(this.mode)):window.addEventListener("resize",()=>{this.resizePanel(this.fpsPanel,0),this.resizePanel(this.msPanel,1),this.gpuPanel&&this.resizePanel(this.gpuPanel,2),this.gpuPanelCompute&&this.resizePanel(this.gpuPanelCompute,3)})}patchThreeRenderer(e){const t=e.render,n=this;e.render=function(r,i){n.begin(),t.call(this,r,i),n.end()},this.threeRendererPatched=!0}resizePanel(e,t){e.canvas.style.position="absolute",this.minimal?e.canvas.style.display="none":(e.canvas.style.display="block",this.horizontal?(e.canvas.style.top="0px",e.canvas.style.left=t*e.WIDTH/e.PR+"px"):(e.canvas.style.left="0px",e.canvas.style.top=t*e.HEIGHT/e.PR+"px"))}addPanel(e,t){return e.canvas&&(this.dom.appendChild(e.canvas),this.resizePanel(e,t)),e}showPanel(e){for(let t=0;t<this.dom.children.length;t++){const n=this.dom.children[t];n.style.display=t===e?"block":"none"}this.mode=e}async init(e){if(!e){console.error('Stats: The "canvas" parameter is undefined.');return}if(e.isWebGLRenderer&&!this.threeRendererPatched){const t=e;this.patchThreeRenderer(t),this.gl=t.getContext()}else!this.gl&&e instanceof WebGL2RenderingContext&&(this.gl=e);if(e.isWebGPURenderer){e.backend.trackTimestamp=!0,await e.hasFeatureAsync("timestamp-query")&&(this.gpuPanel=this.addPanel(new Et.Panel("GPU","#ff0","#220"),2),this.gpuPanelCompute=this.addPanel(new Et.Panel("CPT","#e1e1e1","#212121"),3),this.info=e.info);return}else if(!this.gl&&e instanceof HTMLCanvasElement||e instanceof OffscreenCanvas){if(this.gl=e.getContext("webgl2"),!this.gl){console.error("Stats: Unable to obtain WebGL2 context.");return}}else if(!this.gl){console.error("Stats: Invalid input type. Expected WebGL2RenderingContext, HTMLCanvasElement, or OffscreenCanvas.");return}this.ext=this.gl.getExtension("EXT_disjoint_timer_query_webgl2"),this.ext&&(this.gpuPanel=this.addPanel(new Et.Panel("GPU","#ff0","#220"),2))}begin(){this.isRunningCPUProfiling||this.beginProfiling("cpu-started"),!(!this.gl||!this.ext)&&this.gl&&this.ext&&(this.activeQuery&&this.gl.endQuery(this.ext.TIME_ELAPSED_EXT),this.activeQuery=this.gl.createQuery(),this.activeQuery!==null&&this.gl.beginQuery(this.ext.TIME_ELAPSED_EXT,this.activeQuery))}end(){this.renderCount++,this.gl&&this.ext&&this.activeQuery&&(this.gl.endQuery(this.ext.TIME_ELAPSED_EXT),this.gpuQueries.push({query:this.activeQuery}),this.activeQuery=null)}processGpuQueries(){!this.gl||!this.ext||(this.totalGpuDuration=0,this.gpuQueries.forEach((e,t)=>{if(this.gl){const n=this.gl.getQueryParameter(e.query,this.gl.QUERY_RESULT_AVAILABLE),r=this.gl.getParameter(this.ext.GPU_DISJOINT_EXT);if(n&&!r){const s=this.gl.getQueryParameter(e.query,this.gl.QUERY_RESULT)*1e-6;this.totalGpuDuration+=s,this.gl.deleteQuery(e.query),this.gpuQueries.splice(t,1)}}}))}update(){this.info===void 0?this.processGpuQueries():(this.totalGpuDuration=this.info.render.timestamp,this.totalGpuDurationCompute=this.info.compute.timestamp,this.addToAverage(this.totalGpuDurationCompute,this.averageGpuCompute)),this.endProfiling("cpu-started","cpu-finished","cpu-duration"),this.addToAverage(this.totalCpuDuration,this.averageCpu),this.addToAverage(this.totalGpuDuration,this.averageGpu),this.renderCount=0,this.totalCpuDuration===0&&this.beginProfiling("cpu-started"),this.totalCpuDuration=0,this.totalFps=0,this.beginTime=this.endInternal()}endInternal(){this.frames++;const e=(performance||Date).now();if(e>=this.prevCpuTime+1e3/this.logsPerSecond&&(this.updatePanel(this.msPanel,this.averageCpu),this.updatePanel(this.gpuPanel,this.averageGpu),this.gpuPanelCompute&&this.updatePanel(this.gpuPanelCompute,this.averageGpuCompute),this.prevCpuTime=e),e>=this.prevTime+1e3){const t=this.frames*1e3/(e-this.prevTime);this.fpsPanel.update(t,t,100,100,0),this.prevTime=e,this.frames=0}return e}addToAverage(e,t){t.logs.push(e),t.logs.length>this.samplesLog&&t.logs.shift(),t.graph.push(e),t.graph.length>this.samplesGraph&&t.graph.shift()}beginProfiling(e){window.performance&&(window.performance.mark(e),this.isRunningCPUProfiling=!0)}endProfiling(e,t,n){if(window.performance&&t&&this.isRunningCPUProfiling){window.performance.mark(t);const r=performance.measure(n,e,t);this.totalCpuDuration+=r.duration,this.isRunningCPUProfiling=!1}}updatePanel(e,t){if(t.logs.length>0){let n=0,r=.01;for(let a=0;a<t.logs.length;a++)n+=t.logs[a],t.logs[a]>r&&(r=t.logs[a]);let i=0,s=.01;for(let a=0;a<t.graph.length;a++)i+=t.graph[a],t.graph[a]>s&&(s=t.graph[a]);e&&e.update(n/Math.min(t.logs.length,this.samplesLog),i/Math.min(t.graph.length,this.samplesGraph),r,s,this.precision)}}get domElement(){return this.dom}get container(){return console.warn("Stats: Deprecated! this.container as been replaced to this.dom "),this.dom}};Ns.Panel=Ef;let Wf=Ns;const Yf=u.defineComponent({name:"StatsGl",props:["logsPerSecond","samplesLog","samplesGraph","precision","horizontal","minimal","mode"],async setup(o,{expose:e}){const t=new Wf({logsPerSecond:o.logsPerSecond,samplesLog:o.samplesLog,samplesGraph:o.samplesGraph,precision:o.precision,horizontal:o.horizontal,minimal:o.minimal,mode:o.mode});e({statsGl:t});const n=document.body,r=t.dom||t.container;n==null||n.appendChild(r);const{renderer:i}=oe.useTresContext(),{onAfterLoop:s,resume:a}=oe.useRenderLoop();t.init(i.value),a(),s(()=>{t.update()}),u.onUnmounted(()=>{n==null||n.removeChild(r)})}}),Xf=u.defineComponent({name:"BakeShadows",setup(){const{renderer:o}=oe.useTresContext();u.watchEffect(()=>{o.value.shadowMap.autoUpdate=!1,o.value.shadowMap.needsUpdate=!0})}});var Zf=`#include <common>
 
 void main() {
   vec2 center = vec2(0., 1.);
@@ -1180,6 +1399,6 @@ void main() {
   mvPosition.xy += rotatedPosition;
 
   gl_Position = projectionMatrix * mvPosition;
-}`,Tf=`void main() {
+}`,Kf=`void main() {
   gl_FragColor = vec4(0.0, 0.0, 0.0, 0.0);
-}`;const on=new c.Vector3(0,0,0),Fs=new c.Vector3(0,0,0),Lf=new c.Vector3(0,0,0);function ki(o,e,t){const n=on.setFromMatrixPosition(o.matrixWorld);n.project(e);const s=t.width/2,r=t.height/2;return[(Number.isNaN(n.x)?0:n.x)*s+s,-(n.y*r)+r]}function If(o,e){const t=on.setFromMatrixPosition(o.matrixWorld),n=Fs.setFromMatrixPosition(e.matrixWorld),s=t.sub(n),r=e.getWorldDirection(Lf);return s.angleTo(r)>Math.PI/2}function Df(o,e,t,n){const s=on.setFromMatrixPosition(o.matrixWorld),r=s.clone();r.project(e),t.setFromCamera(new c.Vector2(r.x,r.y),e);const i=t.intersectObjects(n,!0);if(i.length>0){const a=i[0].distance;return s.distanceTo(t.ray.origin)<a}return!0}function Of(o,e){if(e instanceof c.OrthographicCamera)return e.zoom;if(e instanceof c.PerspectiveCamera){const t=on.setFromMatrixPosition(o.matrixWorld),n=Fs.setFromMatrixPosition(e.matrixWorld),s=e.fov*Math.PI/180,r=t.distanceTo(n);return 1/(2*Math.tan(s/2)*r)}else return 1}function Ff(o,e,t){if(e instanceof c.PerspectiveCamera||e instanceof c.OrthographicCamera){const n=on.setFromMatrixPosition(o.matrixWorld),s=Fs.setFromMatrixPosition(e.matrixWorld),r=n.distanceTo(s),i=(t[1]-t[0])/(e.far-e.near),a=t[1]-i*e.far;return Math.round(i*r+a)}}const ks=o=>Math.abs(o)<1e-10?0:o;function Bi(o,e,t=""){let n="matrix3d(";for(let s=0;s!==16;s++)n+=ks(e[s]*o.elements[s])+(s!==15?",":")");return t+n}const kf=(o=>e=>Bi(e,o))([1,-1,1,1,1,-1,1,1,1,-1,1,1,1,-1,1,1]),Bf=(o=>(e,t)=>Bi(e,o(t),"translate(-50%,-50%)"))(o=>[1/o,1/o,1/o,1,-1/o,-1/o,-1/o,-1,1/o,1/o,1/o,1,1,1,1,1]),Uf=["geometry","material"],Nf=f.defineComponent({__name:"HTML",props:{geometry:{default:new c.PlaneGeometry},material:{},as:{default:"div"},transform:{type:Boolean,default:!1},portal:{},wrapperClass:{},eps:{default:1e-4},distanceFactor:{},fullscreen:{type:Boolean},center:{type:Boolean},pointerEvents:{default:"auto"},sprite:{type:Boolean,default:!1},zIndexRange:{default:()=>[16777271,0]},occlude:{type:[Array,Boolean,String]}},emits:["onOcclude"],setup(o,{emit:e}){const t=o,n=e,s=f.useAttrs(),r=f.useSlots(),i=f.ref(),a=f.ref(),{geometry:l,material:u,as:h,transform:d,portal:y,wrapperClass:g,eps:x,distanceFactor:w,fullscreen:v,center:P,pointerEvents:D,sprite:S,occlude:_,zIndexRange:L}=f.toRefs(t),{renderer:b,scene:C,camera:m,raycaster:M,sizes:p}=ae.useTresContext(),I=f.computed(()=>document.createElement(h.value)),F=f.ref([0,0]),J=f.ref(0),G=f.ref(),Q=f.computed(()=>d.value?{position:"absolute",top:0,left:0,width:`${p.width.value}px`,height:`${p.height.value}px`,transformStyle:"preserve-3d",pointerEvents:"none",zIndex:2,willChange:"transform"}:{position:"absolute",transform:P.value?"translate3d(-50%,-50%,0)":"none",...v.value&&{top:-p.height.value/2,left:-p.width.value/2,width:`${p.width.value}px`,height:`${p.height.value}px`},zIndex:2,...s.style,willChange:"transform"}),K=f.computed(()=>({position:"absolute",pointerEvents:D.value})),Z=f.ref(null),X=f.ref(!1),ne=f.computed(()=>(_==null?void 0:_.value)&&(_==null?void 0:_.value)!=="blending"||Array.isArray(_==null?void 0:_.value)&&(_==null?void 0:_.value.length)&&f.isRef(_.value[0]));f.watch(()=>_,A=>{A&&A==="blending"?(I.value.style.zIndex=`${Math.floor(L.value[0]/2)}`,I.value.style.position="absolute",I.value.style.pointerEvents="none"):(I.value.style.zIndex=null,I.value.style.position=null,I.value.style.pointerEvents=null)}),f.watch(()=>{var A;return[i.value,b.value,p.width.value,p.height.value,(A=r.default)==null?void 0:A.call(r)]},([A,V])=>{var ee,N,R,T,O,k;if(A&&V){const E=(y==null?void 0:y.value)||V.domElement;if((ee=C.value)==null||ee.updateMatrixWorld(),d.value)I.value.style.cssText="position:absolute;top:0;left:0;pointer-events:none;overflow:hidden;";else{const q=ki(A,m.value,{width:p.width.value,height:p.height.value});I.value.style.cssText=`position:absolute;top:0;left:0;transform:translate3d(${q[0]}px,${q[1]}px,0);transform-origin:0 0;`}E&&!I.value.parentNode&&((N=E.parentNode)==null||N.appendChild(I.value)),d.value?G.value=f.createVNode("div",{id:"outer",style:Q.value},[f.createVNode("div",{id:"inner",style:K.value},[f.createVNode("div",{key:(R=a.value)==null?void 0:R.uuid,id:C==null?void 0:C.value.uuid,class:s.class,style:s.style},(T=r.default)==null?void 0:T.call(r))])]):G.value=f.createVNode("div",{key:(O=a.value)==null?void 0:O.uuid,id:C==null?void 0:C.value.uuid,style:Q.value},(k=r.default)==null?void 0:k.call(r)),f.render(G.value,I.value)}}),f.watchEffect(()=>{g!=null&&g.value&&(I.value.className=g.value)});const se=f.ref(!0),{onLoop:ue}=ae.useRenderLoop();ue(()=>{var A,V,ee,N,R,T,O;if(i.value&&m.value&&b.value){(A=m.value)==null||A.updateMatrixWorld(),i.value.updateWorldMatrix(!0,!1);const k=d.value?F.value:ki(i.value,m.value,{width:p.width.value||0,height:p.height.value||0});if(d.value||Math.abs(J.value-m.value.zoom)>x.value||Math.abs(F.value[0]-k[0])>x.value||Math.abs(F.value[1]-k[1])>x.value){const E=If(i.value,m.value);let q=!1;ne.value&&(Array.isArray(_==null?void 0:_.value)?q=_==null?void 0:_.value:(_==null?void 0:_.value)!=="blending"&&(q=[C.value]));const W=se.value;if(q){const B=Df(i.value,m.value,M.value,q);se.value=B&&!E}else se.value=!E;W!==se.value&&(n("onOcclude",!se.value),I.value.style.display=se.value?"block":"none");const te=Math.floor(L.value[0]/2),U=_!=null&&_.value?ne.value?[L.value[0],te]:[te-1,0]:L.value;if(I.value.style.zIndex=`${Ff(i.value,m.value,U)}`,I.value.style.willChange="transform",d.value){const[B,oe]=[p.width.value/2,p.height.value/2],ce=m.value.projectionMatrix.elements[5]*oe,{isOrthographicCamera:ge,top:_e,left:xe,bottom:Oe,right:at}=m.value,an=kf(m.value.matrixWorldInverse),Rt=ge?`scale(${ce})translate(${ks(-(at+xe)/2)}px,${ks((_e+Oe)/2)}px)`:`translateZ(${ce}px)`;let Ke=i.value.matrixWorld;S.value&&(Ke=m.value.matrixWorldInverse.clone().transpose().copyPosition(Ke).scale(i.value.scale),Ke.elements[3]=Ke.elements[7]=Ke.elements[11]=0,Ke.elements[15]=1),I.value.style.width=`${p.width.value}px`,I.value.style.height=`${p.height.value}px`,I.value.style.perspective=ge?"":`${ce}px`,(V=G.value)!=null&&V.el&&((ee=G.value)!=null&&ee.children)&&(G.value.el.style.willChange="transform",G.value.el.style.transform=`${Rt}${an}translate(${B}px,${oe}px)`,G.value.children[0].willChange="transform",G.value.children[0].el.style.transform=Bf(Ke,1/(((w==null?void 0:w.value)||10)/400)))}else{const B=(w==null?void 0:w.value)===void 0?1:Of(i.value,m.value)*(w==null?void 0:w.value);I.value.style.transform=`translate3d(${k[0]}px,${k[1]}px,0) scale(${B})`}}F.value=k,J.value=m.value.zoom}if(!ne.value&&a.value&&!X.value)if(d.value){if((N=G.value)!=null&&N.el&&((R=G.value)!=null&&R.children)){const k=(T=G.value)==null?void 0:T.children[0];if(k!=null&&k.clientWidth&&(k!=null&&k.clientHeight)){const{isOrthographicCamera:E}=m.value;if(E||l)s.scale&&(Array.isArray(s.scale)?s.scale instanceof c.Vector3?a.value.scale.copy(s.scale.clone().divideScalar(1)):a.value.scale.set(1/s.scale[0],1/s.scale[1],1/s.scale[2]):a.value.scale.setScalar(1/s.scale));else{const q=((w==null?void 0:w.value)||10)/400,W=k.clientWidth*q,te=k.clientHeight*q;a.value.scale.set(W,te,1)}X.value=!0}}}else{const k=I.value.children[0];if(k!=null&&k.clientWidth&&(k!=null&&k.clientHeight)){const q=k.clientWidth*1,W=k.clientHeight*1;a.value.scale.set(q,W,1),X.value=!0}Z.value.lookAt((O=m.value)==null?void 0:O.position)}});const j=f.computed(()=>({vertexShader:d.value?void 0:Cf,fragmentShader:Tf})),z=f.computed(()=>{const A=j.value;return u.value||new c.ShaderMaterial({vertexShader:A.vertexShader,fragmentShader:A.fragmentShader,side:c.DoubleSide})});return f.onUnmounted(()=>{z.value&&z.value.dispose(),I.value.remove()}),(A,V)=>(f.openBlock(),f.createElementBlock("TresGroup",{ref_key:"groupRef",ref:i},[f.unref(_)&&!ne.value?(f.openBlock(),f.createElementBlock("TresMesh",{key:0,ref_key:"meshRef",ref:a,geometry:f.unref(l),material:z.value},null,8,Uf)):f.createCommentVNode("",!0)],512))}}),{logError:zf}=ae.useLogger();async function Vf(o,e){const t=new Vn,n=(e==null?void 0:e.fileName)||"scene";t.parse(o,s=>{if(s instanceof ArrayBuffer)Gf(s,`${n}.glb`);else{const r=JSON.stringify(s,null,2);Rf(r,`${n}.gltf`)}},s=>{zf("An error happened while exporting the GLTF",s)},e)}function Rf(o,e){Ui(new Blob([o],{type:"text/plain"}),e)}function Gf(o,e){Ui(new Blob([o],{type:"application/octet-stream"}),e)}function Ui(o,e){const t=document.createElement("a");t.style.display="none",document.body.appendChild(t),t.href=URL.createObjectURL(o),t.download=e,t.click(),t.remove()}const jf={mounted:(o,e)=>{if(e.arg){console.log(`v-log:${e.arg}`,o[e.arg]);return}console.log("v-log",o)}},{logWarning:Ni}=ae.useLogger(),Ef={mounted:o=>{if(!o.isLight){Ni(`${o.type} is not a light`);return}kn=Yf[o.type],o.parent.add(new kn(o))},updated:o=>{Vt=o.parent.children.find(e=>e instanceof kn),!(Vt instanceof wr)&&Vt.update()},unmounted:o=>{if(!o.isLight){Ni(`${o.type} is not a light`);return}Vt=o.parent.children.find(e=>e instanceof kn),Vt.dispose(),o.parent.remove(Vt)}};let kn,Vt;const Yf={DirectionalLight:c.DirectionalLightHelper,PointLight:c.PointLightHelper,SpotLight:c.SpotLightHelper,HemisphereLight:c.HemisphereLightHelper,RectAreaLight:wr};function Xf(o,e){const t={};for(const n of e)Object.prototype.hasOwnProperty.call(o,n)&&(t[n]=o[n]);return t}function Wf(o,e){const t=`set${e[0].toUpperCase()}${e.slice(1)}`;return o[t]!==void 0}function Bs(o){var t,n;let e=o.value;return o.value&&((n=(t=o.value)==null?void 0:t.value)!=null&&n.isMesh)&&(e=o.value.value.position),Array.isArray(o.value)&&(e=new c.Vector3(...e)),e}const{logWarning:Zf}=ae.useLogger(),Kf={updated:(o,e)=>{const t=Bs(e);if(!t){Zf(`v-always-look-at: problem with binding value: ${e.value}`);return}const{onLoop:n}=ae.useRenderLoop();n(()=>{o.lookAt(t)})}},{logWarning:qf}=ae.useLogger(),Qf={updated:(o,e)=>{var s;const t=Bs(e);if(!t){qf(`v-distance-to: problem with binding value: ${e.value}`);return}ot&&(ot.dispose(),o.parent.remove(ot));const n=t.clone().sub(o.position);n.normalize(),ot=new c.ArrowHelper(n,o.position,o.position.distanceTo(t)/1.5,16776960),o.parent.add(ot),console.table([["Distance:",o.position.distanceTo(t)],[`origin: ${o.name||o.type}`,`x:${o.position.x}, y:${o.position.y}, z:${(s=o.position)==null?void 0:s.z}`],[`Destiny: ${o.name||o.type}`,`x:${t.x}, y:${t.y}, z:${t==null?void 0:t.z}`]])},unmounted:o=>{ot==null||ot.dispose(),o.parent.remove(ot)}};let ot=null;re.Backdrop=Uh,re.BakeShadows=Pf,re.Box=zu,re.CameraControls=yc,re.CatmullRomCurve3=Yu,re.Circle=Zu,re.Cone=Qu,re.ContactShadows=jh,re.CustomShaderMaterial=Lu,re.Dodecahedron=$u,re.Environment=Oh,re.FBXModel=Kl,re.Fbo=Gl,re.GLTFModel=Wl,re.GlobalAudio=Ml,re.Html=Nf,re.Icosahedron=nh,re.KeyboardControls=rc,re.Lensflare=Rl,re.Levioso=$a,re.Line2=Li,re.MapControls=uc,re.MeshGlassMaterial=Tc,re.MeshReflectionMaterial=Bu,re.MeshWobbleMaterial=xc,re.MouseParallax=bl,re.Octahedron=ih,re.OrbitControls=ec,re.Plane=ch,re.PointerLockControls=lc,re.Precipitation=Xh,re.Reflector=nl,re.Ring=fh,re.SVG=Ql,re.Sampler=jl,re.ScrollControls=hc,re.Sky=Zh,re.Smoke=Hh,re.Sparkles=mf,re.Sphere=mh,re.Stars=_f,re.Stats=bf,re.StatsGl=Af,re.Superformula=_h,re.Tetrahedron=bh,re.Text3D=Ja,re.Torus=Ah,re.TorusKnot=Th,re.TransformControls=oc,re.Tube=Dh,re.extractBindingPosition=Bs,re.hasSetter=Wf,re.pick=Xf,re.useAnimations=Ha,re.useEnvironment=Vr,re.useFBO=Nr,re.useFBX=Gr,re.useGLTF=Rr,re.useGLTFExporter=Vf,re.useProgress=Jl,re.useSurfaceSampler=zr,re.useTweakPane=vf,re.useVideoTexture=Hl,re.vAlwaysLookAt=Kf,re.vDistanceTo=Qf,re.vLightHelper=Ef,re.vLog=jf,Object.defineProperty(re,Symbol.toStringTag,{value:"Module"})});
+}`;const cn=new l.Vector3(0,0,0),Ur=new l.Vector3(0,0,0),qf=new l.Vector3(0,0,0);function zs(o,e,t){const n=cn.setFromMatrixPosition(o.matrixWorld);n.project(e);const r=t.width/2,i=t.height/2;return[(Number.isNaN(n.x)?0:n.x)*r+r,-(n.y*i)+i]}function Qf(o,e){const t=cn.setFromMatrixPosition(o.matrixWorld),n=Ur.setFromMatrixPosition(e.matrixWorld),r=t.sub(n),i=e.getWorldDirection(qf);return r.angleTo(i)>Math.PI/2}function Jf(o,e,t,n){const r=cn.setFromMatrixPosition(o.matrixWorld),i=r.clone();i.project(e),t.setFromCamera(new l.Vector2(i.x,i.y),e);const s=t.intersectObjects(n,!0);if(s.length>0){const a=s[0].distance;return r.distanceTo(t.ray.origin)<a}return!0}function Hf(o,e){if(e instanceof l.OrthographicCamera)return e.zoom;if(e instanceof l.PerspectiveCamera){const t=cn.setFromMatrixPosition(o.matrixWorld),n=Ur.setFromMatrixPosition(e.matrixWorld),r=e.fov*Math.PI/180,i=t.distanceTo(n);return 1/(2*Math.tan(r/2)*i)}else return 1}function $f(o,e,t){if(e instanceof l.PerspectiveCamera||e instanceof l.OrthographicCamera){const n=cn.setFromMatrixPosition(o.matrixWorld),r=Ur.setFromMatrixPosition(e.matrixWorld),i=n.distanceTo(r),s=(t[1]-t[0])/(e.far-e.near),a=t[1]-s*e.far;return Math.round(s*i+a)}}const Nr=o=>Math.abs(o)<1e-10?0:o;function Vs(o,e,t=""){let n="matrix3d(";for(let r=0;r!==16;r++)n+=Nr(e[r]*o.elements[r])+(r!==15?",":")");return t+n}const ed=(o=>e=>Vs(e,o))([1,-1,1,1,1,-1,1,1,1,-1,1,1,1,-1,1,1]),td=(o=>(e,t)=>Vs(e,o(t),"translate(-50%,-50%)"))(o=>[1/o,1/o,1/o,1,-1/o,-1/o,-1/o,-1,1/o,1/o,1/o,1,1,1,1,1]),nd=["geometry","material"],rd=u.defineComponent({__name:"HTML",props:{geometry:{default:new l.PlaneGeometry},material:{},as:{default:"div"},transform:{type:Boolean,default:!1},portal:{},wrapperClass:{},eps:{default:1e-4},distanceFactor:{},fullscreen:{type:Boolean},center:{type:Boolean},pointerEvents:{default:"auto"},sprite:{type:Boolean,default:!1},zIndexRange:{default:()=>[16777271,0]},occlude:{type:[Array,Boolean,String]}},emits:["onOcclude"],setup(o,{emit:e}){const t=o,n=e,r=u.useAttrs(),i=u.useSlots(),s=u.ref(),a=u.ref(),{geometry:c,material:h,as:f,transform:d,portal:p,wrapperClass:m,eps:x,distanceFactor:b,fullscreen:v,center:_,pointerEvents:T,sprite:w,occlude:M,zIndexRange:D}=u.toRefs(t),{renderer:S,scene:C,camera:y,raycaster:A,sizes:g}=oe.useTresContext(),I=u.computed(()=>document.createElement(f.value)),k=u.ref([0,0]),J=u.ref(0),G=u.ref(),Z=u.computed(()=>d.value?{position:"absolute",top:0,left:0,width:`${g.width.value}px`,height:`${g.height.value}px`,transformStyle:"preserve-3d",pointerEvents:"none",zIndex:2,willChange:"transform"}:{position:"absolute",transform:_.value?"translate3d(-50%,-50%,0)":"none",...v.value&&{top:-g.height.value/2,left:-g.width.value/2,width:`${g.width.value}px`,height:`${g.height.value}px`},zIndex:2,...r.style,willChange:"transform"}),X=u.computed(()=>({position:"absolute",pointerEvents:T.value})),K=u.ref(null),Y=u.ref(!1),te=u.computed(()=>(M==null?void 0:M.value)&&(M==null?void 0:M.value)!=="blending"||Array.isArray(M==null?void 0:M.value)&&(M==null?void 0:M.value.length)&&u.isRef(M.value[0]));u.watch(()=>M,P=>{P&&P==="blending"?(I.value.style.zIndex=`${Math.floor(D.value[0]/2)}`,I.value.style.position="absolute",I.value.style.pointerEvents="none"):(I.value.style.zIndex=null,I.value.style.position=null,I.value.style.pointerEvents=null)}),u.watch(()=>{var P;return[s.value,S.value,g.width.value,g.height.value,(P=i.default)==null?void 0:P.call(i)]},([P,V])=>{var ee,N,R,L,O,B;if(P&&V){const E=(p==null?void 0:p.value)||V.domElement;if((ee=C.value)==null||ee.updateMatrixWorld(),d.value)I.value.style.cssText="position:absolute;top:0;left:0;pointer-events:none;overflow:hidden;";else{const Q=zs(P,y.value,{width:g.width.value,height:g.height.value});I.value.style.cssText=`position:absolute;top:0;left:0;transform:translate3d(${Q[0]}px,${Q[1]}px,0);transform-origin:0 0;`}E&&!I.value.parentNode&&((N=E.parentNode)==null||N.appendChild(I.value)),d.value?G.value=u.createVNode("div",{id:"outer",style:Z.value},[u.createVNode("div",{id:"inner",style:X.value},[u.createVNode("div",{key:(R=a.value)==null?void 0:R.uuid,id:C==null?void 0:C.value.uuid,class:r.class,style:r.style},(L=i.default)==null?void 0:L.call(i))])]):G.value=u.createVNode("div",{key:(O=a.value)==null?void 0:O.uuid,id:C==null?void 0:C.value.uuid,style:Z.value},(B=i.default)==null?void 0:B.call(i)),u.render(G.value,I.value)}}),u.watchEffect(()=>{m!=null&&m.value&&(I.value.className=m.value)});const re=u.ref(!0),{onLoop:ce}=oe.useRenderLoop();ce(()=>{var P,V,ee,N,R,L,O;if(s.value&&y.value&&S.value){(P=y.value)==null||P.updateMatrixWorld(),s.value.updateWorldMatrix(!0,!1);const B=d.value?k.value:zs(s.value,y.value,{width:g.width.value||0,height:g.height.value||0});if(d.value||Math.abs(J.value-y.value.zoom)>x.value||Math.abs(k.value[0]-B[0])>x.value||Math.abs(k.value[1]-B[1])>x.value){const E=Qf(s.value,y.value);let Q=!1;te.value&&(Array.isArray(M==null?void 0:M.value)?Q=M==null?void 0:M.value:(M==null?void 0:M.value)!=="blending"&&(Q=[C.value]));const q=re.value;if(Q){const F=Jf(s.value,y.value,A.value,Q);re.value=F&&!E}else re.value=!E;q!==re.value&&(n("onOcclude",!re.value),I.value.style.display=re.value?"block":"none");const ne=Math.floor(D.value[0]/2),U=M!=null&&M.value?te.value?[D.value[0],ne]:[ne-1,0]:D.value;if(I.value.style.zIndex=`${$f(s.value,y.value,U)}`,I.value.style.willChange="transform",d.value){const[F,ae]=[g.width.value/2,g.height.value/2],ue=y.value.projectionMatrix.elements[5]*ae,{isOrthographicCamera:me,top:ye,left:_e,bottom:Oe,right:lt}=y.value,un=ed(y.value.matrixWorldInverse),Gt=me?`scale(${ue})translate(${Nr(-(lt+_e)/2)}px,${Nr((ye+Oe)/2)}px)`:`translateZ(${ue}px)`;let qe=s.value.matrixWorld;w.value&&(qe=y.value.matrixWorldInverse.clone().transpose().copyPosition(qe).scale(s.value.scale),qe.elements[3]=qe.elements[7]=qe.elements[11]=0,qe.elements[15]=1),I.value.style.width=`${g.width.value}px`,I.value.style.height=`${g.height.value}px`,I.value.style.perspective=me?"":`${ue}px`,(V=G.value)!=null&&V.el&&((ee=G.value)!=null&&ee.children)&&(G.value.el.style.willChange="transform",G.value.el.style.transform=`${Gt}${un}translate(${F}px,${ae}px)`,G.value.children[0].willChange="transform",G.value.children[0].el.style.transform=td(qe,1/(((b==null?void 0:b.value)||10)/400)))}else{const F=(b==null?void 0:b.value)===void 0?1:Hf(s.value,y.value)*(b==null?void 0:b.value);I.value.style.transform=`translate3d(${B[0]}px,${B[1]}px,0) scale(${F})`}}k.value=B,J.value=y.value.zoom}if(!te.value&&a.value&&!Y.value)if(d.value){if((N=G.value)!=null&&N.el&&((R=G.value)!=null&&R.children)){const B=(L=G.value)==null?void 0:L.children[0];if(B!=null&&B.clientWidth&&(B!=null&&B.clientHeight)){const{isOrthographicCamera:E}=y.value;if(E||c)r.scale&&(Array.isArray(r.scale)?r.scale instanceof l.Vector3?a.value.scale.copy(r.scale.clone().divideScalar(1)):a.value.scale.set(1/r.scale[0],1/r.scale[1],1/r.scale[2]):a.value.scale.setScalar(1/r.scale));else{const Q=((b==null?void 0:b.value)||10)/400,q=B.clientWidth*Q,ne=B.clientHeight*Q;a.value.scale.set(q,ne,1)}Y.value=!0}}}else{const B=I.value.children[0];if(B!=null&&B.clientWidth&&(B!=null&&B.clientHeight)){const Q=B.clientWidth*1,q=B.clientHeight*1;a.value.scale.set(Q,q,1),Y.value=!0}K.value.lookAt((O=y.value)==null?void 0:O.position)}});const j=u.computed(()=>({vertexShader:d.value?void 0:Zf,fragmentShader:Kf})),z=u.computed(()=>{const P=j.value;return h.value||new l.ShaderMaterial({vertexShader:P.vertexShader,fragmentShader:P.fragmentShader,side:l.DoubleSide})});return u.onUnmounted(()=>{z.value&&z.value.dispose(),I.value.remove()}),(P,V)=>(u.openBlock(),u.createElementBlock("TresGroup",{ref_key:"groupRef",ref:s},[u.unref(M)&&!te.value?(u.openBlock(),u.createElementBlock("TresMesh",{key:0,ref_key:"meshRef",ref:a,geometry:u.unref(c),material:z.value},null,8,nd)):u.createCommentVNode("",!0)],512))}}),{logError:id}=oe.useLogger();async function sd(o,e){const t=new Gn,n=(e==null?void 0:e.fileName)||"scene";t.parse(o,r=>{if(r instanceof ArrayBuffer)ad(r,`${n}.glb`);else{const i=JSON.stringify(r,null,2);od(i,`${n}.gltf`)}},r=>{id("An error happened while exporting the GLTF",r)},e)}function od(o,e){Rs(new Blob([o],{type:"text/plain"}),e)}function ad(o,e){Rs(new Blob([o],{type:"application/octet-stream"}),e)}function Rs(o,e){const t=document.createElement("a");t.style.display="none",document.body.appendChild(t),t.href=URL.createObjectURL(o),t.download=e,t.click(),t.remove()}const ld={mounted:(o,e)=>{if(e.arg){console.log(`v-log:${e.arg}`,o[e.arg]);return}console.log("v-log",o)}},{logWarning:Gs}=oe.useLogger(),cd={mounted:o=>{if(!o.isLight){Gs(`${o.type} is not a light`);return}Nn=ud[o.type],o.parent.add(new Nn(o))},updated:o=>{Rt=o.parent.children.find(e=>e instanceof Nn),!(Rt instanceof Si)&&Rt.update()},unmounted:o=>{if(!o.isLight){Gs(`${o.type} is not a light`);return}Rt=o.parent.children.find(e=>e instanceof Nn),Rt.dispose(),o.parent.remove(Rt)}};let Nn,Rt;const ud={DirectionalLight:l.DirectionalLightHelper,PointLight:l.PointLightHelper,SpotLight:l.SpotLightHelper,HemisphereLight:l.HemisphereLightHelper,RectAreaLight:Si};function hd(o,e){const t={};for(const n of e)Object.prototype.hasOwnProperty.call(o,n)&&(t[n]=o[n]);return t}function fd(o,e){const t=`set${e[0].toUpperCase()}${e.slice(1)}`;return o[t]!==void 0}function zr(o){var t,n;let e=o.value;return o.value&&((n=(t=o.value)==null?void 0:t.value)!=null&&n.isMesh)&&(e=o.value.value.position),Array.isArray(o.value)&&(e=new l.Vector3(...e)),e}const{logWarning:dd}=oe.useLogger(),pd={updated:(o,e)=>{const t=zr(e);if(!t){dd(`v-always-look-at: problem with binding value: ${e.value}`);return}const{onLoop:n}=oe.useRenderLoop();n(()=>{o.lookAt(t)})}},{logWarning:md}=oe.useLogger(),gd={updated:(o,e)=>{var r;const t=zr(e);if(!t){md(`v-distance-to: problem with binding value: ${e.value}`);return}at&&(at.dispose(),o.parent.remove(at));const n=t.clone().sub(o.position);n.normalize(),at=new l.ArrowHelper(n,o.position,o.position.distanceTo(t)/1.5,16776960),o.parent.add(at),console.table([["Distance:",o.position.distanceTo(t)],[`origin: ${o.name||o.type}`,`x:${o.position.x}, y:${o.position.y}, z:${(r=o.position)==null?void 0:r.z}`],[`Destiny: ${o.name||o.type}`,`x:${t.x}, y:${t.y}, z:${t==null?void 0:t.z}`]])},unmounted:o=>{at==null||at.dispose(),o.parent.remove(at)}};let at=null;ie.Backdrop=Hh,ie.BakeShadows=Xf,ie.Box=Wu,ie.CameraControls=xc,ie.CatmullRomCurve3=Qu,ie.Circle=$u,ie.Cone=nh,ie.ContactShadows=sf,ie.CustomShaderMaterial=Ou,ie.Dodecahedron=sh,ie.Environment=Eh,ie.FBXModel=Hl,ie.Fbo=Yl,ie.GLTFModel=Ql,ie.GlobalAudio=Pl,ie.HolographicMaterial=Gu,ie.Html=rd,ie.Icosahedron=lh,ie.KeyboardControls=lc,ie.Lensflare=Wl,ie.Levioso=il,ie.Lightformer=Kh,ie.Line2=ks,ie.MapControls=pc,ie.MeshGlassMaterial=Ic,ie.MeshReflectionMaterial=zu,ie.MeshWobbleMaterial=Mc,ie.MouseParallax=Cl,ie.Ocean=zf,ie.Octahedron=hh,ie.OrbitControls=ic,ie.Plane=mh,ie.PointerLockControls=fc,ie.Precipitation=lf,ie.Reflector=al,ie.Ring=vh,ie.RoundedBox=wh,ie.SVG=ec,ie.Sampler=Xl,ie.ScrollControls=mc,ie.Sky=uf,ie.Smoke=mf,ie.Sparkles=If,ie.Sphere=Sh,ie.Stars=Bf,ie.Stats=jf,ie.StatsGl=Yf,ie.Superformula=Ph,ie.Tetrahedron=Ih,ie.Text3D=nl,ie.Torus=Bh,ie.TorusKnot=Nh,ie.TransformControls=uc,ie.Tube=Rh,ie.extractBindingPosition=zr,ie.hasSetter=fd,ie.pick=hd,ie.useAnimations=rl,ie.useEnvironment=Ei,ie.useFBO=Gi,ie.useFBX=Yi,ie.useGLTF=Wi,ie.useGLTFExporter=sd,ie.useProgress=tc,ie.useSurfaceSampler=ji,ie.useTweakPane=Vf,ie.useVideoTexture=nc,ie.vAlwaysLookAt=pd,ie.vDistanceTo=gd,ie.vLightHelper=cd,ie.vLog=ld,Object.defineProperty(ie,Symbol.toStringTag,{value:"Module"})});
